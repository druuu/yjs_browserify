(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":1,"ieee754":3}],3:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],4:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],5:[function(require,module,exports){
(function (process,global,Buffer){

/**
 * y-webrtc3 - 
 * @version v2.4.0
 * @license MIT
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ywebrtc = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */

	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

	var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];

	var parseuri = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');

	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }

	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;

	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }

	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }

	    return uri;
	};

	var parseuri$1 = /*#__PURE__*/Object.freeze({
		default: parseuri,
		__moduleExports: parseuri
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	var possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	var ms = function ms(val, options) {
	  options = options || {};
	  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

	var ms$1 = /*#__PURE__*/Object.freeze({
		default: ms,
		__moduleExports: ms
	});

	var require$$0 = ( ms$1 && ms ) || ms$1;

	var debug = createCommonjsModule(function (module, exports) {
	  /**
	   * This is the common logic for both the Node.js and web browser
	   * implementations of `debug()`.
	   *
	   * Expose `debug()` as the module.
	   */

	  exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	  exports.coerce = coerce;
	  exports.disable = disable;
	  exports.enable = enable;
	  exports.enabled = enabled;
	  exports.humanize = require$$0;

	  /**
	   * Active `debug` instances.
	   */
	  exports.instances = [];

	  /**
	   * The currently active debug mode names, and names to skip.
	   */

	  exports.names = [];
	  exports.skips = [];

	  /**
	   * Map of special "%n" handling functions, for the debug "format" argument.
	   *
	   * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	   */

	  exports.formatters = {};

	  /**
	   * Select a color.
	   * @param {String} namespace
	   * @return {Number}
	   * @api private
	   */

	  function selectColor(namespace) {
	    var hash = 0,
	        i;

	    for (i in namespace) {
	      hash = (hash << 5) - hash + namespace.charCodeAt(i);
	      hash |= 0; // Convert to 32bit integer
	    }

	    return exports.colors[Math.abs(hash) % exports.colors.length];
	  }

	  /**
	   * Create a debugger with the given `namespace`.
	   *
	   * @param {String} namespace
	   * @return {Function}
	   * @api public
	   */

	  function createDebug(namespace) {

	    var prevTime;

	    function debug() {
	      // disabled?
	      if (!debug.enabled) return;

	      var self = debug;

	      // set `diff` timestamp
	      var curr = +new Date();
	      var ms = curr - (prevTime || curr);
	      self.diff = ms;
	      self.prev = prevTime;
	      self.curr = curr;
	      prevTime = curr;

	      // turn the `arguments` into a proper Array
	      var args = new Array(arguments.length);
	      for (var i = 0; i < args.length; i++) {
	        args[i] = arguments[i];
	      }

	      args[0] = exports.coerce(args[0]);

	      if ('string' !== typeof args[0]) {
	        // anything else let's inspect with %O
	        args.unshift('%O');
	      }

	      // apply any `formatters` transformations
	      var index = 0;
	      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	        // if we encounter an escaped % then don't increase the array index
	        if (match === '%%') return match;
	        index++;
	        var formatter = exports.formatters[format];
	        if ('function' === typeof formatter) {
	          var val = args[index];
	          match = formatter.call(self, val);

	          // now we need to remove `args[index]` since it's inlined in the `format`
	          args.splice(index, 1);
	          index--;
	        }
	        return match;
	      });

	      // apply env-specific formatting (colors, etc.)
	      exports.formatArgs.call(self, args);

	      var logFn = debug.log || exports.log || console.log.bind(console);
	      logFn.apply(self, args);
	    }

	    debug.namespace = namespace;
	    debug.enabled = exports.enabled(namespace);
	    debug.useColors = exports.useColors();
	    debug.color = selectColor(namespace);
	    debug.destroy = destroy;

	    // env-specific initialization logic for debug instances
	    if ('function' === typeof exports.init) {
	      exports.init(debug);
	    }

	    exports.instances.push(debug);

	    return debug;
	  }

	  function destroy() {
	    var index = exports.instances.indexOf(this);
	    if (index !== -1) {
	      exports.instances.splice(index, 1);
	      return true;
	    } else {
	      return false;
	    }
	  }

	  /**
	   * Enables a debug mode by namespaces. This can include modes
	   * separated by a colon and wildcards.
	   *
	   * @param {String} namespaces
	   * @api public
	   */

	  function enable(namespaces) {
	    exports.save(namespaces);

	    exports.names = [];
	    exports.skips = [];

	    var i;
	    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	    var len = split.length;

	    for (i = 0; i < len; i++) {
	      if (!split[i]) continue; // ignore empty strings
	      namespaces = split[i].replace(/\*/g, '.*?');
	      if (namespaces[0] === '-') {
	        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	      } else {
	        exports.names.push(new RegExp('^' + namespaces + '$'));
	      }
	    }

	    for (i = 0; i < exports.instances.length; i++) {
	      var instance = exports.instances[i];
	      instance.enabled = exports.enabled(instance.namespace);
	    }
	  }

	  /**
	   * Disable debug output.
	   *
	   * @api public
	   */

	  function disable() {
	    exports.enable('');
	  }

	  /**
	   * Returns true if the given mode name is enabled, false otherwise.
	   *
	   * @param {String} name
	   * @return {Boolean}
	   * @api public
	   */

	  function enabled(name) {
	    if (name[name.length - 1] === '*') {
	      return true;
	    }
	    var i, len;
	    for (i = 0, len = exports.skips.length; i < len; i++) {
	      if (exports.skips[i].test(name)) {
	        return false;
	      }
	    }
	    for (i = 0, len = exports.names.length; i < len; i++) {
	      if (exports.names[i].test(name)) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * Coerce `val`.
	   *
	   * @param {Mixed} val
	   * @return {Mixed}
	   * @api private
	   */

	  function coerce(val) {
	    if (val instanceof Error) return val.stack || val.message;
	    return val;
	  }
	});
	var debug_1 = debug.coerce;
	var debug_2 = debug.disable;
	var debug_3 = debug.enable;
	var debug_4 = debug.enabled;
	var debug_5 = debug.humanize;
	var debug_6 = debug.instances;
	var debug_7 = debug.names;
	var debug_8 = debug.skips;
	var debug_9 = debug.formatters;

	var debug$1 = /*#__PURE__*/Object.freeze({
		default: debug,
		__moduleExports: debug,
		coerce: debug_1,
		disable: debug_2,
		enable: debug_3,
		enabled: debug_4,
		humanize: debug_5,
		instances: debug_6,
		names: debug_7,
		skips: debug_8,
		formatters: debug_9
	});

	var require$$0$1 = ( debug$1 && debug ) || debug$1;

	var browser = createCommonjsModule(function (module, exports) {
	  /**
	   * This is the web browser implementation of `debug()`.
	   *
	   * Expose `debug()` as the module.
	   */

	  exports = module.exports = require$$0$1;
	  exports.log = log;
	  exports.formatArgs = formatArgs;
	  exports.save = save;
	  exports.load = load;
	  exports.useColors = useColors;
	  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

	  /**
	   * Colors.
	   */

	  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

	  /**
	   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	   * and the Firebug extension (any Firefox version) are known
	   * to support "%c" CSS customizations.
	   *
	   * TODO: add a `localStorage` variable to explicitly enable/disable colors
	   */

	  function useColors() {
	    // NB: In an Electron preload script, document will be defined but not fully
	    // initialized. Since we know we're in Chrome, we'll just detect this case
	    // explicitly
	    if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	      return true;
	    }

	    // Internet Explorer and Edge do not support colors.
	    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	      return false;
	    }

	    // is webkit? http://stackoverflow.com/a/16459606/376773
	    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
	    // double check webkit in userAgent just in case we are in a worker
	    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	  }

	  /**
	   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	   */

	  exports.formatters.j = function (v) {
	    try {
	      return JSON.stringify(v);
	    } catch (err) {
	      return '[UnexpectedJSONParseError]: ' + err.message;
	    }
	  };

	  /**
	   * Colorize log arguments if enabled.
	   *
	   * @api public
	   */

	  function formatArgs(args) {
	    var useColors = this.useColors;

	    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

	    if (!useColors) return;

	    var c = 'color: ' + this.color;
	    args.splice(1, 0, c, 'color: inherit');

	    // the final "%c" is somewhat tricky, because there could be other
	    // arguments passed either before or after the %c, so we need to
	    // figure out the correct index to insert the CSS into
	    var index = 0;
	    var lastC = 0;
	    args[0].replace(/%[a-zA-Z%]/g, function (match) {
	      if ('%%' === match) return;
	      index++;
	      if ('%c' === match) {
	        // we only are interested in the *last* %c
	        // (the user may have provided their own)
	        lastC = index;
	      }
	    });

	    args.splice(lastC, 0, c);
	  }

	  /**
	   * Invokes `console.log()` when available.
	   * No-op when `console.log` is not a "function".
	   *
	   * @api public
	   */

	  function log() {
	    // this hackery is required for IE8/9, where
	    // the `console.log` function doesn't have 'apply'
	    return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	  }

	  /**
	   * Save `namespaces`.
	   *
	   * @param {String} namespaces
	   * @api private
	   */

	  function save(namespaces) {
	    try {
	      if (null == namespaces) {
	        exports.storage.removeItem('debug');
	      } else {
	        exports.storage.debug = namespaces;
	      }
	    } catch (e) {}
	  }

	  /**
	   * Load `namespaces`.
	   *
	   * @return {String} returns the previously persisted debug modes
	   * @api private
	   */

	  function load() {
	    var r;
	    try {
	      r = exports.storage.debug;
	    } catch (e) {}

	    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	    if (!r && typeof process !== 'undefined' && 'env' in process) {
	      r = process.env.DEBUG;
	    }

	    return r;
	  }

	  /**
	   * Enable namespaces listed in `localStorage.debug` initially.
	   */

	  exports.enable(load());

	  /**
	   * Localstorage attempts to return the localstorage.
	   *
	   * This is necessary because safari throws
	   * when a user disables cookies/localstorage
	   * and you attempt to access it.
	   *
	   * @return {LocalStorage}
	   * @api private
	   */

	  function localstorage() {
	    try {
	      return window.localStorage;
	    } catch (e) {}
	  }
	});
	var browser_1 = browser.log;
	var browser_2 = browser.formatArgs;
	var browser_3 = browser.save;
	var browser_4 = browser.load;
	var browser_5 = browser.useColors;
	var browser_6 = browser.storage;
	var browser_7 = browser.colors;

	var browser$1 = /*#__PURE__*/Object.freeze({
		default: browser,
		__moduleExports: browser,
		log: browser_1,
		formatArgs: browser_2,
		save: browser_3,
		load: browser_4,
		useColors: browser_5,
		storage: browser_6,
		colors: browser_7
	});

	var parseuri$2 = ( parseuri$1 && parseuri ) || parseuri$1;

	var require$$0$2 = ( browser$1 && browser ) || browser$1;

	/**
	 * Module dependencies.
	 */

	var debug$2 = require$$0$2('socket.io-client:url');

	/**
	 * Module exports.
	 */

	var url_1 = url;

	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */

	function url(uri, loc) {
	  var obj = uri;

	  // default to window.location
	  loc = loc || commonjsGlobal.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;

	  // relative path support
	  if ('string' === typeof uri) {
	    if ('/' === uri.charAt(0)) {
	      if ('/' === uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }

	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug$2('protocol-less url %s', uri);
	      if ('undefined' !== typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }

	    // parse
	    debug$2('parse %s', uri);
	    obj = parseuri$2(uri);
	  }

	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    } else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }

	  obj.path = obj.path || '/';

	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);

	  return obj;
	}

	var url$1 = /*#__PURE__*/Object.freeze({
		default: url_1,
		__moduleExports: url_1
	});

	var componentEmitter = createCommonjsModule(function (module) {
	  /**
	   * Expose `Emitter`.
	   */

	  {
	    module.exports = Emitter;
	  }

	  /**
	   * Initialize a new `Emitter`.
	   *
	   * @api public
	   */

	  function Emitter(obj) {
	    if (obj) return mixin(obj);
	  }
	  /**
	   * Mixin the emitter properties.
	   *
	   * @param {Object} obj
	   * @return {Object}
	   * @api private
	   */

	  function mixin(obj) {
	    for (var key in Emitter.prototype) {
	      obj[key] = Emitter.prototype[key];
	    }
	    return obj;
	  }

	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   * @return {Emitter}
	   * @api public
	   */

	  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
	    this._callbacks = this._callbacks || {};
	    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
	    return this;
	  };

	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   * @return {Emitter}
	   * @api public
	   */

	  Emitter.prototype.once = function (event, fn) {
	    function on() {
	      this.off(event, on);
	      fn.apply(this, arguments);
	    }

	    on.fn = fn;
	    this.on(event, on);
	    return this;
	  };

	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   * @return {Emitter}
	   * @api public
	   */

	  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
	    this._callbacks = this._callbacks || {};

	    // all
	    if (0 == arguments.length) {
	      this._callbacks = {};
	      return this;
	    }

	    // specific event
	    var callbacks = this._callbacks['$' + event];
	    if (!callbacks) return this;

	    // remove all handlers
	    if (1 == arguments.length) {
	      delete this._callbacks['$' + event];
	      return this;
	    }

	    // remove specific handler
	    var cb;
	    for (var i = 0; i < callbacks.length; i++) {
	      cb = callbacks[i];
	      if (cb === fn || cb.fn === fn) {
	        callbacks.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };

	  /**
	   * Emit `event` with the given args.
	   *
	   * @param {String} event
	   * @param {Mixed} ...
	   * @return {Emitter}
	   */

	  Emitter.prototype.emit = function (event) {
	    this._callbacks = this._callbacks || {};
	    var args = [].slice.call(arguments, 1),
	        callbacks = this._callbacks['$' + event];

	    if (callbacks) {
	      callbacks = callbacks.slice(0);
	      for (var i = 0, len = callbacks.length; i < len; ++i) {
	        callbacks[i].apply(this, args);
	      }
	    }

	    return this;
	  };

	  /**
	   * Return array of callbacks for `event`.
	   *
	   * @param {String} event
	   * @return {Array}
	   * @api public
	   */

	  Emitter.prototype.listeners = function (event) {
	    this._callbacks = this._callbacks || {};
	    return this._callbacks['$' + event] || [];
	  };

	  /**
	   * Check if this emitter has `event` handlers.
	   *
	   * @param {String} event
	   * @return {Boolean}
	   * @api public
	   */

	  Emitter.prototype.hasListeners = function (event) {
	    return !!this.listeners(event).length;
	  };
	});

	var componentEmitter$1 = /*#__PURE__*/Object.freeze({
		default: componentEmitter,
		__moduleExports: componentEmitter
	});

	var toString = {}.toString;

	var isarray = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

	var isarray$1 = /*#__PURE__*/Object.freeze({
		default: isarray,
		__moduleExports: isarray
	});

	var isBuffer = isBuf;

	var withNativeBuffer = typeof commonjsGlobal.Buffer === 'function' && typeof commonjsGlobal.Buffer.isBuffer === 'function';
	var withNativeArrayBuffer = typeof commonjsGlobal.ArrayBuffer === 'function';

	var isView = function () {
	  if (withNativeArrayBuffer && typeof commonjsGlobal.ArrayBuffer.isView === 'function') {
	    return commonjsGlobal.ArrayBuffer.isView;
	  } else {
	    return function (obj) {
	      return obj.buffer instanceof commonjsGlobal.ArrayBuffer;
	    };
	  }
	}();

	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */

	function isBuf(obj) {
	  return withNativeBuffer && commonjsGlobal.Buffer.isBuffer(obj) || withNativeArrayBuffer && (obj instanceof commonjsGlobal.ArrayBuffer || isView(obj));
	}

	var isBuffer$1 = /*#__PURE__*/Object.freeze({
		default: isBuffer,
		__moduleExports: isBuffer
	});

	var isArray = ( isarray$1 && isarray ) || isarray$1;

	var isBuf$1 = ( isBuffer$1 && isBuffer ) || isBuffer$1;

	/*global Blob,File*/

	/**
	 * Module requirements
	 */

	var toString$1 = Object.prototype.toString;
	var withNativeBlob = typeof commonjsGlobal.Blob === 'function' || toString$1.call(commonjsGlobal.Blob) === '[object BlobConstructor]';
	var withNativeFile = typeof commonjsGlobal.File === 'function' || toString$1.call(commonjsGlobal.File) === '[object FileConstructor]';

	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */

	var deconstructPacket = function deconstructPacket(packet) {
	  var buffers = [];
	  var packetData = packet.data;
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData, buffers);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return { packet: pack, buffers: buffers };
	};

	function _deconstructPacket(data, buffers) {
	  if (!data) return data;

	  if (isBuf$1(data)) {
	    var placeholder = { _placeholder: true, num: buffers.length };
	    buffers.push(data);
	    return placeholder;
	  } else if (isArray(data)) {
	    var newData = new Array(data.length);
	    for (var i = 0; i < data.length; i++) {
	      newData[i] = _deconstructPacket(data[i], buffers);
	    }
	    return newData;
	  } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && !(data instanceof Date)) {
	    var newData = {};
	    for (var key in data) {
	      newData[key] = _deconstructPacket(data[key], buffers);
	    }
	    return newData;
	  }
	  return data;
	}

	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */

	var reconstructPacket = function reconstructPacket(packet, buffers) {
	  packet.data = _reconstructPacket(packet.data, buffers);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};

	function _reconstructPacket(data, buffers) {
	  if (!data) return data;

	  if (data && data._placeholder) {
	    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
	  } else if (isArray(data)) {
	    for (var i = 0; i < data.length; i++) {
	      data[i] = _reconstructPacket(data[i], buffers);
	    }
	  } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
	    for (var key in data) {
	      data[key] = _reconstructPacket(data[key], buffers);
	    }
	  }

	  return data;
	}

	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */

	var removeBlobs = function removeBlobs(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;

	    // convert any blob
	    if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
	      pendingBlobs++;

	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function () {
	        // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        } else {
	          bloblessData = this.result;
	        }

	        // if nothing pending its callback time
	        if (! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };

	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) {
	      // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !isBuf$1(obj)) {
	      // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }

	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};

	var binary = {
	  deconstructPacket: deconstructPacket,
	  reconstructPacket: reconstructPacket,
	  removeBlobs: removeBlobs
	};

	var binary$1 = /*#__PURE__*/Object.freeze({
		default: binary,
		__moduleExports: binary,
		deconstructPacket: deconstructPacket,
		reconstructPacket: reconstructPacket,
		removeBlobs: removeBlobs
	});

	var Emitter = ( componentEmitter$1 && componentEmitter ) || componentEmitter$1;

	var binary$2 = ( binary$1 && binary ) || binary$1;

	var socket_ioParser = createCommonjsModule(function (module, exports) {
	  /**
	   * Module dependencies.
	   */

	  var debug = require$$0$2('socket.io-parser');

	  /**
	   * Protocol version.
	   *
	   * @api public
	   */

	  exports.protocol = 4;

	  /**
	   * Packet types.
	   *
	   * @api public
	   */

	  exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];

	  /**
	   * Packet type `connect`.
	   *
	   * @api public
	   */

	  exports.CONNECT = 0;

	  /**
	   * Packet type `disconnect`.
	   *
	   * @api public
	   */

	  exports.DISCONNECT = 1;

	  /**
	   * Packet type `event`.
	   *
	   * @api public
	   */

	  exports.EVENT = 2;

	  /**
	   * Packet type `ack`.
	   *
	   * @api public
	   */

	  exports.ACK = 3;

	  /**
	   * Packet type `error`.
	   *
	   * @api public
	   */

	  exports.ERROR = 4;

	  /**
	   * Packet type 'binary event'
	   *
	   * @api public
	   */

	  exports.BINARY_EVENT = 5;

	  /**
	   * Packet type `binary ack`. For acks with binary arguments.
	   *
	   * @api public
	   */

	  exports.BINARY_ACK = 6;

	  /**
	   * Encoder constructor.
	   *
	   * @api public
	   */

	  exports.Encoder = Encoder;

	  /**
	   * Decoder constructor.
	   *
	   * @api public
	   */

	  exports.Decoder = Decoder;

	  /**
	   * A socket.io Encoder instance
	   *
	   * @api public
	   */

	  function Encoder() {}

	  var ERROR_PACKET = exports.ERROR + '"encode error"';

	  /**
	   * Encode a packet as a single string if non-binary, or as a
	   * buffer sequence, depending on packet type.
	   *
	   * @param {Object} obj - packet object
	   * @param {Function} callback - function to handle encodings (likely engine.write)
	   * @return Calls callback with Array of encodings
	   * @api public
	   */

	  Encoder.prototype.encode = function (obj, callback) {
	    debug('encoding packet %j', obj);

	    if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
	      encodeAsBinary(obj, callback);
	    } else {
	      var encoding = encodeAsString(obj);
	      callback([encoding]);
	    }
	  };

	  /**
	   * Encode packet as string.
	   *
	   * @param {Object} packet
	   * @return {String} encoded
	   * @api private
	   */

	  function encodeAsString(obj) {

	    // first is type
	    var str = '' + obj.type;

	    // attachments if we have them
	    if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
	      str += obj.attachments + '-';
	    }

	    // if we have a namespace other than `/`
	    // we append it followed by a comma `,`
	    if (obj.nsp && '/' !== obj.nsp) {
	      str += obj.nsp + ',';
	    }

	    // immediately followed by the id
	    if (null != obj.id) {
	      str += obj.id;
	    }

	    // json data
	    if (null != obj.data) {
	      var payload = tryStringify(obj.data);
	      if (payload !== false) {
	        str += payload;
	      } else {
	        return ERROR_PACKET;
	      }
	    }

	    debug('encoded %j as %s', obj, str);
	    return str;
	  }

	  function tryStringify(str) {
	    try {
	      return JSON.stringify(str);
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Encode packet as 'buffer sequence' by removing blobs, and
	   * deconstructing packet into object with placeholders and
	   * a list of buffers.
	   *
	   * @param {Object} packet
	   * @return {Buffer} encoded
	   * @api private
	   */

	  function encodeAsBinary(obj, callback) {

	    function writeEncoding(bloblessData) {
	      var deconstruction = binary$2.deconstructPacket(bloblessData);
	      var pack = encodeAsString(deconstruction.packet);
	      var buffers = deconstruction.buffers;

	      buffers.unshift(pack); // add packet info to beginning of data list
	      callback(buffers); // write all the buffers
	    }

	    binary$2.removeBlobs(obj, writeEncoding);
	  }

	  /**
	   * A socket.io Decoder instance
	   *
	   * @return {Object} decoder
	   * @api public
	   */

	  function Decoder() {
	    this.reconstructor = null;
	  }

	  /**
	   * Mix in `Emitter` with Decoder.
	   */

	  Emitter(Decoder.prototype);

	  /**
	   * Decodes an ecoded packet string into packet JSON.
	   *
	   * @param {String} obj - encoded packet
	   * @return {Object} packet
	   * @api public
	   */

	  Decoder.prototype.add = function (obj) {
	    var packet;
	    if (typeof obj === 'string') {
	      packet = decodeString(obj);
	      if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) {
	        // binary packet's json
	        this.reconstructor = new BinaryReconstructor(packet);

	        // no attachments, labeled binary but no binary data to follow
	        if (this.reconstructor.reconPack.attachments === 0) {
	          this.emit('decoded', packet);
	        }
	      } else {
	        // non-binary full packet
	        this.emit('decoded', packet);
	      }
	    } else if (isBuf$1(obj) || obj.base64) {
	      // raw binary data
	      if (!this.reconstructor) {
	        throw new Error('got binary data when not reconstructing a packet');
	      } else {
	        packet = this.reconstructor.takeBinaryData(obj);
	        if (packet) {
	          // received final buffer
	          this.reconstructor = null;
	          this.emit('decoded', packet);
	        }
	      }
	    } else {
	      throw new Error('Unknown type: ' + obj);
	    }
	  };

	  /**
	   * Decode a packet String (JSON data)
	   *
	   * @param {String} str
	   * @return {Object} packet
	   * @api private
	   */

	  function decodeString(str) {
	    var i = 0;
	    // look up type
	    var p = {
	      type: Number(str.charAt(0))
	    };

	    if (null == exports.types[p.type]) {
	      return error('unknown packet type ' + p.type);
	    }

	    // look up attachments if type binary
	    if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
	      var buf = '';
	      while (str.charAt(++i) !== '-') {
	        buf += str.charAt(i);
	        if (i == str.length) break;
	      }
	      if (buf != Number(buf) || str.charAt(i) !== '-') {
	        throw new Error('Illegal attachments');
	      }
	      p.attachments = Number(buf);
	    }

	    // look up namespace (if any)
	    if ('/' === str.charAt(i + 1)) {
	      p.nsp = '';
	      while (++i) {
	        var c = str.charAt(i);
	        if (',' === c) break;
	        p.nsp += c;
	        if (i === str.length) break;
	      }
	    } else {
	      p.nsp = '/';
	    }

	    // look up id
	    var next = str.charAt(i + 1);
	    if ('' !== next && Number(next) == next) {
	      p.id = '';
	      while (++i) {
	        var c = str.charAt(i);
	        if (null == c || Number(c) != c) {
	          --i;
	          break;
	        }
	        p.id += str.charAt(i);
	        if (i === str.length) break;
	      }
	      p.id = Number(p.id);
	    }

	    // look up json data
	    if (str.charAt(++i)) {
	      var payload = tryParse(str.substr(i));
	      var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
	      if (isPayloadValid) {
	        p.data = payload;
	      } else {
	        return error('invalid payload');
	      }
	    }

	    debug('decoded %s as %j', str, p);
	    return p;
	  }

	  function tryParse(str) {
	    try {
	      return JSON.parse(str);
	    } catch (e) {
	      return false;
	    }
	  }

	  /**
	   * Deallocates a parser's resources
	   *
	   * @api public
	   */

	  Decoder.prototype.destroy = function () {
	    if (this.reconstructor) {
	      this.reconstructor.finishedReconstruction();
	    }
	  };

	  /**
	   * A manager of a binary event's 'buffer sequence'. Should
	   * be constructed whenever a packet of type BINARY_EVENT is
	   * decoded.
	   *
	   * @param {Object} packet
	   * @return {BinaryReconstructor} initialized reconstructor
	   * @api private
	   */

	  function BinaryReconstructor(packet) {
	    this.reconPack = packet;
	    this.buffers = [];
	  }

	  /**
	   * Method to be called when binary data received from connection
	   * after a BINARY_EVENT packet.
	   *
	   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	   * @return {null | Object} returns null if more binary data is expected or
	   *   a reconstructed packet object if all buffers have been received.
	   * @api private
	   */

	  BinaryReconstructor.prototype.takeBinaryData = function (binData) {
	    this.buffers.push(binData);
	    if (this.buffers.length === this.reconPack.attachments) {
	      // done with buffer list
	      var packet = binary$2.reconstructPacket(this.reconPack, this.buffers);
	      this.finishedReconstruction();
	      return packet;
	    }
	    return null;
	  };

	  /**
	   * Cleans up binary packet reconstruction variables.
	   *
	   * @api private
	   */

	  BinaryReconstructor.prototype.finishedReconstruction = function () {
	    this.reconPack = null;
	    this.buffers = [];
	  };

	  function error(msg) {
	    return {
	      type: exports.ERROR,
	      data: 'parser error: ' + msg
	    };
	  }
	});
	var socket_ioParser_1 = socket_ioParser.protocol;
	var socket_ioParser_2 = socket_ioParser.types;
	var socket_ioParser_3 = socket_ioParser.CONNECT;
	var socket_ioParser_4 = socket_ioParser.DISCONNECT;
	var socket_ioParser_5 = socket_ioParser.EVENT;
	var socket_ioParser_6 = socket_ioParser.ACK;
	var socket_ioParser_7 = socket_ioParser.ERROR;
	var socket_ioParser_8 = socket_ioParser.BINARY_EVENT;
	var socket_ioParser_9 = socket_ioParser.BINARY_ACK;
	var socket_ioParser_10 = socket_ioParser.Encoder;
	var socket_ioParser_11 = socket_ioParser.Decoder;

	var socket_ioParser$1 = /*#__PURE__*/Object.freeze({
		default: socket_ioParser,
		__moduleExports: socket_ioParser,
		protocol: socket_ioParser_1,
		types: socket_ioParser_2,
		CONNECT: socket_ioParser_3,
		DISCONNECT: socket_ioParser_4,
		EVENT: socket_ioParser_5,
		ACK: socket_ioParser_6,
		ERROR: socket_ioParser_7,
		BINARY_EVENT: socket_ioParser_8,
		BINARY_ACK: socket_ioParser_9,
		Encoder: socket_ioParser_10,
		Decoder: socket_ioParser_11
	});

	var hasCors = createCommonjsModule(function (module) {
	  /**
	   * Module exports.
	   *
	   * Logic borrowed from Modernizr:
	   *
	   *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	   */

	  try {
	    module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
	  } catch (err) {
	    // if XMLHttp support is disabled in IE then it will throw
	    // when trying to create
	    module.exports = false;
	  }
	});

	var hasCors$1 = /*#__PURE__*/Object.freeze({
		default: hasCors,
		__moduleExports: hasCors
	});

	var hasCORS = ( hasCors$1 && hasCors ) || hasCors$1;

	// browser shim for xmlhttprequest module


	var xmlhttprequest = function xmlhttprequest(opts) {
	  var xdomain = opts.xdomain;

	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;

	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;

	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) {}

	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) {}

	  if (!xdomain) {
	    try {
	      return new commonjsGlobal[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
	    } catch (e) {}
	  }
	};

	var xmlhttprequest$1 = /*#__PURE__*/Object.freeze({
		default: xmlhttprequest,
		__moduleExports: xmlhttprequest
	});

	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */

	var keys = Object.keys || function keys(obj) {
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;

	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};

	var keys$1 = /*#__PURE__*/Object.freeze({
		default: keys,
		__moduleExports: keys
	});

	/* global Blob File */

	/*
	 * Module requirements.
	 */

	var toString$2 = Object.prototype.toString;
	var withNativeBlob$1 = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString$2.call(Blob) === '[object BlobConstructor]';
	var withNativeFile$1 = typeof File === 'function' || typeof File !== 'undefined' && toString$2.call(File) === '[object FileConstructor]';

	/**
	 * Module exports.
	 */

	var hasBinary2 = hasBinary;

	/**
	 * Checks for binary data.
	 *
	 * Supports Buffer, ArrayBuffer, Blob and File.
	 *
	 * @param {Object} anything
	 * @api public
	 */

	function hasBinary(obj) {
	  if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
	    return false;
	  }

	  if (isArray(obj)) {
	    for (var i = 0, l = obj.length; i < l; i++) {
	      if (hasBinary(obj[i])) {
	        return true;
	      }
	    }
	    return false;
	  }

	  if (typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj) || typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer || withNativeBlob$1 && obj instanceof Blob || withNativeFile$1 && obj instanceof File) {
	    return true;
	  }

	  // see: https://github.com/Automattic/has-binary/pull/4
	  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
	    return hasBinary(obj.toJSON(), true);
	  }

	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
	      return true;
	    }
	  }

	  return false;
	}

	var hasBinary2$1 = /*#__PURE__*/Object.freeze({
		default: hasBinary2,
		__moduleExports: hasBinary2
	});

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */

	var arraybuffer_slice = function arraybuffer_slice(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;

	  if (arraybuffer.slice) {
	    return arraybuffer.slice(start, end);
	  }

	  if (start < 0) {
	    start += bytes;
	  }
	  if (end < 0) {
	    end += bytes;
	  }
	  if (end > bytes) {
	    end = bytes;
	  }

	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }

	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};

	var arraybuffer_slice$1 = /*#__PURE__*/Object.freeze({
		default: arraybuffer_slice,
		__moduleExports: arraybuffer_slice
	});

	var after_1 = after;

	function after(count, callback, err_cb) {
	    var bail = false;
	    err_cb = err_cb || noop;
	    proxy.count = count;

	    return count === 0 ? callback() : proxy;

	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times');
	        }
	        --proxy.count;

	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true;
	            callback(err);
	            // future error callbacks will go to error handler
	            callback = err_cb;
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result);
	        }
	    }
	}

	function noop() {}

	var after$1 = /*#__PURE__*/Object.freeze({
		default: after_1,
		__moduleExports: after_1
	});

	var utf8 = createCommonjsModule(function (module, exports) {
	(function (root) {

			// Detect free variables `exports`
			var freeExports = exports;

			// Detect free variable `module`
			var freeModule = module && module.exports == freeExports && module;

			// Detect free variable `global`, from Node.js or Browserified code,
			// and use it as `root`
			var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal;
			if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
				root = freeGlobal;
			}

			/*--------------------------------------------------------------------------*/

			var stringFromCharCode = String.fromCharCode;

			// Taken from https://mths.be/punycode
			function ucs2decode(string) {
				var output = [];
				var counter = 0;
				var length = string.length;
				var value;
				var extra;
				while (counter < length) {
					value = string.charCodeAt(counter++);
					if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
						// high surrogate, and there is a next character
						extra = string.charCodeAt(counter++);
						if ((extra & 0xFC00) == 0xDC00) {
							// low surrogate
							output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
						} else {
							// unmatched surrogate; only append this code unit, in case the next
							// code unit is the high surrogate of a surrogate pair
							output.push(value);
							counter--;
						}
					} else {
						output.push(value);
					}
				}
				return output;
			}

			// Taken from https://mths.be/punycode
			function ucs2encode(array) {
				var length = array.length;
				var index = -1;
				var value;
				var output = '';
				while (++index < length) {
					value = array[index];
					if (value > 0xFFFF) {
						value -= 0x10000;
						output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
						value = 0xDC00 | value & 0x3FF;
					}
					output += stringFromCharCode(value);
				}
				return output;
			}

			function checkScalarValue(codePoint, strict) {
				if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
					if (strict) {
						throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
					}
					return false;
				}
				return true;
			}
			/*--------------------------------------------------------------------------*/

			function createByte(codePoint, shift) {
				return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
			}

			function encodeCodePoint(codePoint, strict) {
				if ((codePoint & 0xFFFFFF80) == 0) {
					// 1-byte sequence
					return stringFromCharCode(codePoint);
				}
				var symbol = '';
				if ((codePoint & 0xFFFFF800) == 0) {
					// 2-byte sequence
					symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
				} else if ((codePoint & 0xFFFF0000) == 0) {
					// 3-byte sequence
					if (!checkScalarValue(codePoint, strict)) {
						codePoint = 0xFFFD;
					}
					symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
					symbol += createByte(codePoint, 6);
				} else if ((codePoint & 0xFFE00000) == 0) {
					// 4-byte sequence
					symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
					symbol += createByte(codePoint, 12);
					symbol += createByte(codePoint, 6);
				}
				symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
				return symbol;
			}

			function utf8encode(string, opts) {
				opts = opts || {};
				var strict = false !== opts.strict;

				var codePoints = ucs2decode(string);
				var length = codePoints.length;
				var index = -1;
				var codePoint;
				var byteString = '';
				while (++index < length) {
					codePoint = codePoints[index];
					byteString += encodeCodePoint(codePoint, strict);
				}
				return byteString;
			}

			/*--------------------------------------------------------------------------*/

			function readContinuationByte() {
				if (byteIndex >= byteCount) {
					throw Error('Invalid byte index');
				}

				var continuationByte = byteArray[byteIndex] & 0xFF;
				byteIndex++;

				if ((continuationByte & 0xC0) == 0x80) {
					return continuationByte & 0x3F;
				}

				// If we end up here, it’s not a continuation byte
				throw Error('Invalid continuation byte');
			}

			function decodeSymbol(strict) {
				var byte1;
				var byte2;
				var byte3;
				var byte4;
				var codePoint;

				if (byteIndex > byteCount) {
					throw Error('Invalid byte index');
				}

				if (byteIndex == byteCount) {
					return false;
				}

				// Read first byte
				byte1 = byteArray[byteIndex] & 0xFF;
				byteIndex++;

				// 1-byte sequence (no continuation bytes)
				if ((byte1 & 0x80) == 0) {
					return byte1;
				}

				// 2-byte sequence
				if ((byte1 & 0xE0) == 0xC0) {
					byte2 = readContinuationByte();
					codePoint = (byte1 & 0x1F) << 6 | byte2;
					if (codePoint >= 0x80) {
						return codePoint;
					} else {
						throw Error('Invalid continuation byte');
					}
				}

				// 3-byte sequence (may include unpaired surrogates)
				if ((byte1 & 0xF0) == 0xE0) {
					byte2 = readContinuationByte();
					byte3 = readContinuationByte();
					codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
					if (codePoint >= 0x0800) {
						return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
					} else {
						throw Error('Invalid continuation byte');
					}
				}

				// 4-byte sequence
				if ((byte1 & 0xF8) == 0xF0) {
					byte2 = readContinuationByte();
					byte3 = readContinuationByte();
					byte4 = readContinuationByte();
					codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
					if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
						return codePoint;
					}
				}

				throw Error('Invalid UTF-8 detected');
			}

			var byteArray;
			var byteCount;
			var byteIndex;
			function utf8decode(byteString, opts) {
				opts = opts || {};
				var strict = false !== opts.strict;

				byteArray = ucs2decode(byteString);
				byteCount = byteArray.length;
				byteIndex = 0;
				var codePoints = [];
				var tmp;
				while ((tmp = decodeSymbol(strict)) !== false) {
					codePoints.push(tmp);
				}
				return ucs2encode(codePoints);
			}

			/*--------------------------------------------------------------------------*/

			var utf8 = {
				'version': '2.1.2',
				'encode': utf8encode,
				'decode': utf8decode
			};

			// Some AMD build optimizers, like r.js, check for specific condition patterns
			// like the following:
			if (typeof undefined == 'function' && _typeof(undefined.amd) == 'object' && undefined.amd) {
				undefined(function () {
					return utf8;
				});
			} else if (freeExports && !freeExports.nodeType) {
				if (freeModule) {
					// in Node.js or RingoJS v0.8.0+
					freeModule.exports = utf8;
				} else {
					// in Narwhal or RingoJS v0.7.0-
					var object = {};
					var hasOwnProperty = object.hasOwnProperty;
					for (var key in utf8) {
						hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
					}
				}
			} else {
				// in Rhino or a web browser
				root.utf8 = utf8;
			}
		})(commonjsGlobal);
	});

	var utf8$1 = /*#__PURE__*/Object.freeze({
		default: utf8,
		__moduleExports: utf8
	});

	var base64Arraybuffer = createCommonjsModule(function (module, exports) {
	  /*
	   * base64-arraybuffer
	   * https://github.com/niklasvh/base64-arraybuffer
	   *
	   * Copyright (c) 2012 Niklas von Hertzen
	   * Licensed under the MIT license.
	   */
	  (function () {

	    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	    // Use a lookup table to find the index.
	    var lookup = new Uint8Array(256);
	    for (var i = 0; i < chars.length; i++) {
	      lookup[chars.charCodeAt(i)] = i;
	    }

	    exports.encode = function (arraybuffer) {
	      var bytes = new Uint8Array(arraybuffer),
	          i,
	          len = bytes.length,
	          base64 = "";

	      for (i = 0; i < len; i += 3) {
	        base64 += chars[bytes[i] >> 2];
	        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
	        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
	        base64 += chars[bytes[i + 2] & 63];
	      }

	      if (len % 3 === 2) {
	        base64 = base64.substring(0, base64.length - 1) + "=";
	      } else if (len % 3 === 1) {
	        base64 = base64.substring(0, base64.length - 2) + "==";
	      }

	      return base64;
	    };

	    exports.decode = function (base64) {
	      var bufferLength = base64.length * 0.75,
	          len = base64.length,
	          i,
	          p = 0,
	          encoded1,
	          encoded2,
	          encoded3,
	          encoded4;

	      if (base64[base64.length - 1] === "=") {
	        bufferLength--;
	        if (base64[base64.length - 2] === "=") {
	          bufferLength--;
	        }
	      }

	      var arraybuffer = new ArrayBuffer(bufferLength),
	          bytes = new Uint8Array(arraybuffer);

	      for (i = 0; i < len; i += 4) {
	        encoded1 = lookup[base64.charCodeAt(i)];
	        encoded2 = lookup[base64.charCodeAt(i + 1)];
	        encoded3 = lookup[base64.charCodeAt(i + 2)];
	        encoded4 = lookup[base64.charCodeAt(i + 3)];

	        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
	        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
	        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
	      }

	      return arraybuffer;
	    };
	  })();
	});
	var base64Arraybuffer_1 = base64Arraybuffer.encode;
	var base64Arraybuffer_2 = base64Arraybuffer.decode;

	var base64Arraybuffer$1 = /*#__PURE__*/Object.freeze({
		default: base64Arraybuffer,
		__moduleExports: base64Arraybuffer,
		encode: base64Arraybuffer_1,
		decode: base64Arraybuffer_2
	});

	/**
	 * Create a blob builder even when vendor prefixes exist
	 */

	var BlobBuilder = commonjsGlobal.BlobBuilder || commonjsGlobal.WebKitBlobBuilder || commonjsGlobal.MSBlobBuilder || commonjsGlobal.MozBlobBuilder;

	/**
	 * Check if Blob constructor is supported
	 */

	var blobSupported = function () {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch (e) {
	    return false;
	  }
	}();

	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */

	var blobSupportsArrayBufferView = blobSupported && function () {
	  try {
	    var b = new Blob([new Uint8Array([1, 2])]);
	    return b.size === 2;
	  } catch (e) {
	    return false;
	  }
	}();

	/**
	 * Check if BlobBuilder is supported
	 */

	var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;

	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */

	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;

	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }

	      ary[i] = buf;
	    }
	  }
	}

	function BlobBuilderConstructor(ary, options) {
	  options = options || {};

	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);

	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }

	  return options.type ? bb.getBlob(options.type) : bb.getBlob();
	}
	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	}
	var blob = function () {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? commonjsGlobal.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	}();

	var blob$1 = /*#__PURE__*/Object.freeze({
		default: blob,
		__moduleExports: blob
	});

	var keys$2 = ( keys$1 && keys ) || keys$1;

	var hasBinary$1 = ( hasBinary2$1 && hasBinary2 ) || hasBinary2$1;

	var sliceBuffer = ( arraybuffer_slice$1 && arraybuffer_slice ) || arraybuffer_slice$1;

	var after$2 = ( after$1 && after_1 ) || after$1;

	var utf8$2 = ( utf8$1 && utf8 ) || utf8$1;

	var require$$0$3 = ( base64Arraybuffer$1 && base64Arraybuffer ) || base64Arraybuffer$1;

	var Blob$1 = ( blob$1 && blob ) || blob$1;

	var browser$2 = createCommonjsModule(function (module, exports) {
	  /**
	   * Module dependencies.
	   */

	  var base64encoder;
	  if (commonjsGlobal && commonjsGlobal.ArrayBuffer) {
	    base64encoder = require$$0$3;
	  }

	  /**
	   * Check if we are running an android browser. That requires us to use
	   * ArrayBuffer with polling transports...
	   *
	   * http://ghinda.net/jpeg-blob-ajax-android/
	   */

	  var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

	  /**
	   * Check if we are running in PhantomJS.
	   * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	   * https://github.com/ariya/phantomjs/issues/11395
	   * @type boolean
	   */
	  var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

	  /**
	   * When true, avoids using Blobs to encode payloads.
	   * @type boolean
	   */
	  var dontSendBlobs = isAndroid || isPhantomJS;

	  /**
	   * Current protocol version.
	   */

	  exports.protocol = 3;

	  /**
	   * Packet types.
	   */

	  var packets = exports.packets = {
	    open: 0 // non-ws
	    , close: 1 // non-ws
	    , ping: 2,
	    pong: 3,
	    message: 4,
	    upgrade: 5,
	    noop: 6
	  };

	  var packetslist = keys$2(packets);

	  /**
	   * Premade error packet.
	   */

	  var err = { type: 'error', data: 'parser error' };

	  /**
	   * Create a blob api even for blob builder when vendor prefixes exist
	   */

	  /**
	   * Encodes a packet.
	   *
	   *     <packet type id> [ <data> ]
	   *
	   * Example:
	   *
	   *     5hello world
	   *     3
	   *     4
	   *
	   * Binary is encoded in an identical principle
	   *
	   * @api private
	   */

	  exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	    if (typeof supportsBinary === 'function') {
	      callback = supportsBinary;
	      supportsBinary = false;
	    }

	    if (typeof utf8encode === 'function') {
	      callback = utf8encode;
	      utf8encode = null;
	    }

	    var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;

	    if (commonjsGlobal.ArrayBuffer && data instanceof ArrayBuffer) {
	      return encodeArrayBuffer(packet, supportsBinary, callback);
	    } else if (Blob$1 && data instanceof commonjsGlobal.Blob) {
	      return encodeBlob(packet, supportsBinary, callback);
	    }

	    // might be an object with { base64: true, data: dataAsBase64String }
	    if (data && data.base64) {
	      return encodeBase64Object(packet, callback);
	    }

	    // Sending data as a utf-8 string
	    var encoded = packets[packet.type];

	    // data fragment is optional
	    if (undefined !== packet.data) {
	      encoded += utf8encode ? utf8$2.encode(String(packet.data), { strict: false }) : String(packet.data);
	    }

	    return callback('' + encoded);
	  };

	  function encodeBase64Object(packet, callback) {
	    // packet data is an object { base64: true, data: dataAsBase64String }
	    var message = 'b' + exports.packets[packet.type] + packet.data.data;
	    return callback(message);
	  }

	  /**
	   * Encode packet helpers for binary types
	   */

	  function encodeArrayBuffer(packet, supportsBinary, callback) {
	    if (!supportsBinary) {
	      return exports.encodeBase64Packet(packet, callback);
	    }

	    var data = packet.data;
	    var contentArray = new Uint8Array(data);
	    var resultBuffer = new Uint8Array(1 + data.byteLength);

	    resultBuffer[0] = packets[packet.type];
	    for (var i = 0; i < contentArray.length; i++) {
	      resultBuffer[i + 1] = contentArray[i];
	    }

	    return callback(resultBuffer.buffer);
	  }

	  function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	    if (!supportsBinary) {
	      return exports.encodeBase64Packet(packet, callback);
	    }

	    var fr = new FileReader();
	    fr.onload = function () {
	      packet.data = fr.result;
	      exports.encodePacket(packet, supportsBinary, true, callback);
	    };
	    return fr.readAsArrayBuffer(packet.data);
	  }

	  function encodeBlob(packet, supportsBinary, callback) {
	    if (!supportsBinary) {
	      return exports.encodeBase64Packet(packet, callback);
	    }

	    if (dontSendBlobs) {
	      return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	    }

	    var length = new Uint8Array(1);
	    length[0] = packets[packet.type];
	    var blob = new Blob$1([length.buffer, packet.data]);

	    return callback(blob);
	  }

	  /**
	   * Encodes a packet with binary data in a base64 string
	   *
	   * @param {Object} packet, has `type` and `data`
	   * @return {String} base64 encoded message
	   */

	  exports.encodeBase64Packet = function (packet, callback) {
	    var message = 'b' + exports.packets[packet.type];
	    if (Blob$1 && packet.data instanceof commonjsGlobal.Blob) {
	      var fr = new FileReader();
	      fr.onload = function () {
	        var b64 = fr.result.split(',')[1];
	        callback(message + b64);
	      };
	      return fr.readAsDataURL(packet.data);
	    }

	    var b64data;
	    try {
	      b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	    } catch (e) {
	      // iPhone Safari doesn't let you apply with typed arrays
	      var typed = new Uint8Array(packet.data);
	      var basic = new Array(typed.length);
	      for (var i = 0; i < typed.length; i++) {
	        basic[i] = typed[i];
	      }
	      b64data = String.fromCharCode.apply(null, basic);
	    }
	    message += commonjsGlobal.btoa(b64data);
	    return callback(message);
	  };

	  /**
	   * Decodes a packet. Changes format to Blob if requested.
	   *
	   * @return {Object} with `type` and `data` (if any)
	   * @api private
	   */

	  exports.decodePacket = function (data, binaryType, utf8decode) {
	    if (data === undefined) {
	      return err;
	    }
	    // String data
	    if (typeof data === 'string') {
	      if (data.charAt(0) === 'b') {
	        return exports.decodeBase64Packet(data.substr(1), binaryType);
	      }

	      if (utf8decode) {
	        data = tryDecode(data);
	        if (data === false) {
	          return err;
	        }
	      }
	      var type = data.charAt(0);

	      if (Number(type) != type || !packetslist[type]) {
	        return err;
	      }

	      if (data.length > 1) {
	        return { type: packetslist[type], data: data.substring(1) };
	      } else {
	        return { type: packetslist[type] };
	      }
	    }

	    var asArray = new Uint8Array(data);
	    var type = asArray[0];
	    var rest = sliceBuffer(data, 1);
	    if (Blob$1 && binaryType === 'blob') {
	      rest = new Blob$1([rest]);
	    }
	    return { type: packetslist[type], data: rest };
	  };

	  function tryDecode(data) {
	    try {
	      data = utf8$2.decode(data, { strict: false });
	    } catch (e) {
	      return false;
	    }
	    return data;
	  }

	  /**
	   * Decodes a packet encoded in a base64 string
	   *
	   * @param {String} base64 encoded message
	   * @return {Object} with `type` and `data` (if any)
	   */

	  exports.decodeBase64Packet = function (msg, binaryType) {
	    var type = packetslist[msg.charAt(0)];
	    if (!base64encoder) {
	      return { type: type, data: { base64: true, data: msg.substr(1) } };
	    }

	    var data = base64encoder.decode(msg.substr(1));

	    if (binaryType === 'blob' && Blob$1) {
	      data = new Blob$1([data]);
	    }

	    return { type: type, data: data };
	  };

	  /**
	   * Encodes multiple messages (payload).
	   *
	   *     <length>:data
	   *
	   * Example:
	   *
	   *     11:hello world2:hi
	   *
	   * If any contents are binary, they will be encoded as base64 strings. Base64
	   * encoded strings are marked with a b before the length specifier
	   *
	   * @param {Array} packets
	   * @api private
	   */

	  exports.encodePayload = function (packets, supportsBinary, callback) {
	    if (typeof supportsBinary === 'function') {
	      callback = supportsBinary;
	      supportsBinary = null;
	    }

	    var isBinary = hasBinary$1(packets);

	    if (supportsBinary && isBinary) {
	      if (Blob$1 && !dontSendBlobs) {
	        return exports.encodePayloadAsBlob(packets, callback);
	      }

	      return exports.encodePayloadAsArrayBuffer(packets, callback);
	    }

	    if (!packets.length) {
	      return callback('0:');
	    }

	    function setLengthHeader(message) {
	      return message.length + ':' + message;
	    }

	    function encodeOne(packet, doneCallback) {
	      exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function (message) {
	        doneCallback(null, setLengthHeader(message));
	      });
	    }

	    map(packets, encodeOne, function (err, results) {
	      return callback(results.join(''));
	    });
	  };

	  /**
	   * Async array map using after
	   */

	  function map(ary, each, done) {
	    var result = new Array(ary.length);
	    var next = after$2(ary.length, done);

	    var eachWithIndex = function eachWithIndex(i, el, cb) {
	      each(el, function (error, msg) {
	        result[i] = msg;
	        cb(error, result);
	      });
	    };

	    for (var i = 0; i < ary.length; i++) {
	      eachWithIndex(i, ary[i], next);
	    }
	  }

	  /*
	   * Decodes data when a payload is maybe expected. Possible binary contents are
	   * decoded from their base64 representation
	   *
	   * @param {String} data, callback method
	   * @api public
	   */

	  exports.decodePayload = function (data, binaryType, callback) {
	    if (typeof data !== 'string') {
	      return exports.decodePayloadAsBinary(data, binaryType, callback);
	    }

	    if (typeof binaryType === 'function') {
	      callback = binaryType;
	      binaryType = null;
	    }

	    var packet;
	    if (data === '') {
	      // parser error - ignoring payload
	      return callback(err, 0, 1);
	    }

	    var length = '',
	        n,
	        msg;

	    for (var i = 0, l = data.length; i < l; i++) {
	      var chr = data.charAt(i);

	      if (chr !== ':') {
	        length += chr;
	        continue;
	      }

	      if (length === '' || length != (n = Number(length))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }

	      msg = data.substr(i + 1, n);

	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }

	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, false);

	        if (err.type === packet.type && err.data === packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }

	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }

	      // advance cursor
	      i += n;
	      length = '';
	    }

	    if (length !== '') {
	      // parser error - ignoring payload
	      return callback(err, 0, 1);
	    }
	  };

	  /**
	   * Encodes multiple messages (payload) as binary.
	   *
	   * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	   * 255><data>
	   *
	   * Example:
	   * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	   *
	   * @param {Array} packets
	   * @return {ArrayBuffer} encoded payload
	   * @api private
	   */

	  exports.encodePayloadAsArrayBuffer = function (packets, callback) {
	    if (!packets.length) {
	      return callback(new ArrayBuffer(0));
	    }

	    function encodeOne(packet, doneCallback) {
	      exports.encodePacket(packet, true, true, function (data) {
	        return doneCallback(null, data);
	      });
	    }

	    map(packets, encodeOne, function (err, encodedPackets) {
	      var totalLength = encodedPackets.reduce(function (acc, p) {
	        var len;
	        if (typeof p === 'string') {
	          len = p.length;
	        } else {
	          len = p.byteLength;
	        }
	        return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	      }, 0);

	      var resultArray = new Uint8Array(totalLength);

	      var bufferIndex = 0;
	      encodedPackets.forEach(function (p) {
	        var isString = typeof p === 'string';
	        var ab = p;
	        if (isString) {
	          var view = new Uint8Array(p.length);
	          for (var i = 0; i < p.length; i++) {
	            view[i] = p.charCodeAt(i);
	          }
	          ab = view.buffer;
	        }

	        if (isString) {
	          // not true binary
	          resultArray[bufferIndex++] = 0;
	        } else {
	          // true binary
	          resultArray[bufferIndex++] = 1;
	        }

	        var lenStr = ab.byteLength.toString();
	        for (var i = 0; i < lenStr.length; i++) {
	          resultArray[bufferIndex++] = parseInt(lenStr[i]);
	        }
	        resultArray[bufferIndex++] = 255;

	        var view = new Uint8Array(ab);
	        for (var i = 0; i < view.length; i++) {
	          resultArray[bufferIndex++] = view[i];
	        }
	      });

	      return callback(resultArray.buffer);
	    });
	  };

	  /**
	   * Encode as Blob
	   */

	  exports.encodePayloadAsBlob = function (packets, callback) {
	    function encodeOne(packet, doneCallback) {
	      exports.encodePacket(packet, true, true, function (encoded) {
	        var binaryIdentifier = new Uint8Array(1);
	        binaryIdentifier[0] = 1;
	        if (typeof encoded === 'string') {
	          var view = new Uint8Array(encoded.length);
	          for (var i = 0; i < encoded.length; i++) {
	            view[i] = encoded.charCodeAt(i);
	          }
	          encoded = view.buffer;
	          binaryIdentifier[0] = 0;
	        }

	        var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;

	        var lenStr = len.toString();
	        var lengthAry = new Uint8Array(lenStr.length + 1);
	        for (var i = 0; i < lenStr.length; i++) {
	          lengthAry[i] = parseInt(lenStr[i]);
	        }
	        lengthAry[lenStr.length] = 255;

	        if (Blob$1) {
	          var blob = new Blob$1([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	          doneCallback(null, blob);
	        }
	      });
	    }

	    map(packets, encodeOne, function (err, results) {
	      return callback(new Blob$1(results));
	    });
	  };

	  /*
	   * Decodes data when a payload is maybe expected. Strings are decoded by
	   * interpreting each byte as a key code for entries marked to start with 0. See
	   * description of encodePayloadAsBinary
	   *
	   * @param {ArrayBuffer} data, callback method
	   * @api public
	   */

	  exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	    if (typeof binaryType === 'function') {
	      callback = binaryType;
	      binaryType = null;
	    }

	    var bufferTail = data;
	    var buffers = [];

	    while (bufferTail.byteLength > 0) {
	      var tailArray = new Uint8Array(bufferTail);
	      var isString = tailArray[0] === 0;
	      var msgLength = '';

	      for (var i = 1;; i++) {
	        if (tailArray[i] === 255) break;

	        // 310 = char length of Number.MAX_VALUE
	        if (msgLength.length > 310) {
	          return callback(err, 0, 1);
	        }

	        msgLength += tailArray[i];
	      }

	      bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	      msgLength = parseInt(msgLength);

	      var msg = sliceBuffer(bufferTail, 0, msgLength);
	      if (isString) {
	        try {
	          msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	        } catch (e) {
	          // iPhone Safari doesn't let you apply to typed arrays
	          var typed = new Uint8Array(msg);
	          msg = '';
	          for (var i = 0; i < typed.length; i++) {
	            msg += String.fromCharCode(typed[i]);
	          }
	        }
	      }

	      buffers.push(msg);
	      bufferTail = sliceBuffer(bufferTail, msgLength);
	    }

	    var total = buffers.length;
	    buffers.forEach(function (buffer, i) {
	      callback(exports.decodePacket(buffer, binaryType, true), i, total);
	    });
	  };
	});
	var browser_1$1 = browser$2.protocol;
	var browser_2$1 = browser$2.packets;
	var browser_3$1 = browser$2.encodePacket;
	var browser_4$1 = browser$2.encodeBase64Packet;
	var browser_5$1 = browser$2.decodePacket;
	var browser_6$1 = browser$2.decodeBase64Packet;
	var browser_7$1 = browser$2.encodePayload;
	var browser_8 = browser$2.decodePayload;
	var browser_9 = browser$2.encodePayloadAsArrayBuffer;
	var browser_10 = browser$2.encodePayloadAsBlob;
	var browser_11 = browser$2.decodePayloadAsBinary;

	var browser$3 = /*#__PURE__*/Object.freeze({
		default: browser$2,
		__moduleExports: browser$2,
		protocol: browser_1$1,
		packets: browser_2$1,
		encodePacket: browser_3$1,
		encodeBase64Packet: browser_4$1,
		decodePacket: browser_5$1,
		decodeBase64Packet: browser_6$1,
		encodePayload: browser_7$1,
		decodePayload: browser_8,
		encodePayloadAsArrayBuffer: browser_9,
		encodePayloadAsBlob: browser_10,
		decodePayloadAsBinary: browser_11
	});

	var parser = ( browser$3 && browser$2 ) || browser$3;

	/**
	 * Module dependencies.
	 */

	/**
	 * Module exports.
	 */

	var transport = Transport;

	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */

	function Transport(opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	  this.forceNode = opts.forceNode;

	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	  this.localAddress = opts.localAddress;
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Transport.prototype);

	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */

	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};

	/**
	 * Opens the transport.
	 *
	 * @api public
	 */

	Transport.prototype.open = function () {
	  if ('closed' === this.readyState || '' === this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }

	  return this;
	};

	/**
	 * Closes the transport.
	 *
	 * @api private
	 */

	Transport.prototype.close = function () {
	  if ('opening' === this.readyState || 'open' === this.readyState) {
	    this.doClose();
	    this.onClose();
	  }

	  return this;
	};

	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */

	Transport.prototype.send = function (packets) {
	  if ('open' === this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};

	/**
	 * Called upon open
	 *
	 * @api private
	 */

	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};

	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */

	Transport.prototype.onData = function (data) {
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};

	/**
	 * Called with a decoded packet.
	 */

	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon close.
	 *
	 * @api private
	 */

	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};

	var transport$1 = /*#__PURE__*/Object.freeze({
		default: transport,
		__moduleExports: transport
	});

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */

	var encode = function encode(obj) {
	  var str = '';

	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }

	  return str;
	};

	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */

	var decode = function decode(qs) {
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};

	var parseqs = {
	  encode: encode,
	  decode: decode
	};

	var parseqs$1 = /*#__PURE__*/Object.freeze({
		default: parseqs,
		__moduleExports: parseqs,
		encode: encode,
		decode: decode
	});

	var componentInherit = function componentInherit(a, b) {
	  var fn = function fn() {};
	  fn.prototype = b.prototype;
	  a.prototype = new fn();
	  a.prototype.constructor = a;
	};

	var componentInherit$1 = /*#__PURE__*/Object.freeze({
		default: componentInherit,
		__moduleExports: componentInherit
	});

	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
	    length = 64,
	    map = {},
	    seed = 0,
	    i = 0,
	    prev;

	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode$1(num) {
	  var encoded = '';

	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);

	  return encoded;
	}

	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode$1(str) {
	  var decoded = 0;

	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }

	  return decoded;
	}

	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode$1(+new Date());

	  if (now !== prev) return seed = 0, prev = now;
	  return now + '.' + encode$1(seed++);
	}

	//
	// Map each character to its index.
	//
	for (; i < length; i++) {
	  map[alphabet[i]] = i;
	} //
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode$1;
	yeast.decode = decode$1;
	var yeast_1 = yeast;

	var yeast$1 = /*#__PURE__*/Object.freeze({
		default: yeast_1,
		__moduleExports: yeast_1
	});

	var Transport$1 = ( transport$1 && transport ) || transport$1;

	var parseqs$2 = ( parseqs$1 && parseqs ) || parseqs$1;

	var inherit = ( componentInherit$1 && componentInherit ) || componentInherit$1;

	var yeast$2 = ( yeast$1 && yeast_1 ) || yeast$1;

	var require$$1 = ( xmlhttprequest$1 && xmlhttprequest ) || xmlhttprequest$1;

	/**
	 * Module dependencies.
	 */

	var debug$3 = require$$0$2('engine.io-client:polling');

	/**
	 * Module exports.
	 */

	var polling = Polling;

	/**
	 * Is XHR2 supported?
	 */

	var hasXHR2 = function () {
	  var XMLHttpRequest = require$$1;
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	}();

	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */

	function Polling(opts) {
	  var forceBase64 = opts && opts.forceBase64;
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport$1.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(Polling, Transport$1);

	/**
	 * Transport name.
	 */

	Polling.prototype.name = 'polling';

	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */

	Polling.prototype.doOpen = function () {
	  this.poll();
	};

	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */

	Polling.prototype.pause = function (onPause) {
	  var self = this;

	  this.readyState = 'pausing';

	  function pause() {
	    debug$3('paused');
	    self.readyState = 'paused';
	    onPause();
	  }

	  if (this.polling || !this.writable) {
	    var total = 0;

	    if (this.polling) {
	      debug$3('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function () {
	        debug$3('pre-pause polling complete');
	        --total || pause();
	      });
	    }

	    if (!this.writable) {
	      debug$3('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function () {
	        debug$3('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};

	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */

	Polling.prototype.poll = function () {
	  debug$3('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};

	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */

	Polling.prototype.onData = function (data) {
	  var self = this;
	  debug$3('polling got data %s', data);
	  var callback = function callback(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' === self.readyState) {
	      self.onOpen();
	    }

	    // if its a close packet, we close the ongoing requests
	    if ('close' === packet.type) {
	      self.onClose();
	      return false;
	    }

	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };

	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);

	  // if an event did not trigger closing
	  if ('closed' !== this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');

	    if ('open' === this.readyState) {
	      this.poll();
	    } else {
	      debug$3('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};

	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */

	Polling.prototype.doClose = function () {
	  var self = this;

	  function close() {
	    debug$3('writing close packet');
	    self.write([{ type: 'close' }]);
	  }

	  if ('open' === this.readyState) {
	    debug$3('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug$3('transport not open - deferring close');
	    this.once('open', close);
	  }
	};

	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */

	Polling.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;
	  var callbackfn = function callbackfn() {
	    self.writable = true;
	    self.emit('drain');
	  };

	  parser.encodePayload(packets, this.supportsBinary, function (data) {
	    self.doWrite(data, callbackfn);
	  });
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	Polling.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';

	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast$2();
	  }

	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }

	  query = parseqs$2.encode(query);

	  // avoid port if default for schema
	  if (this.port && ('https' === schema && Number(this.port) !== 443 || 'http' === schema && Number(this.port) !== 80)) {
	    port = ':' + this.port;
	  }

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};

	var polling$1 = /*#__PURE__*/Object.freeze({
		default: polling,
		__moduleExports: polling
	});

	var Polling$1 = ( polling$1 && polling ) || polling$1;

	/**
	 * Module requirements.
	 */

	var debug$4 = require$$0$2('engine.io-client:polling-xhr');

	/**
	 * Module exports.
	 */

	var pollingXhr = XHR;
	var Request_1 = Request;

	/**
	 * Empty function
	 */

	function empty() {}

	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function XHR(opts) {
	  Polling$1.call(this, opts);
	  this.requestTimeout = opts.requestTimeout;
	  this.extraHeaders = opts.extraHeaders;

	  if (commonjsGlobal.location) {
	    var isSSL = 'https:' === location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    this.xd = opts.hostname !== commonjsGlobal.location.hostname || port !== opts.port;
	    this.xs = opts.secure !== isSSL;
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(XHR, Polling$1);

	/**
	 * XHR supports binary
	 */

	XHR.prototype.supportsBinary = true;

	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */

	XHR.prototype.request = function (opts) {
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  opts.requestTimeout = this.requestTimeout;

	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;

	  return new Request(opts);
	};

	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */

	XHR.prototype.doWrite = function (data, fn) {
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function (err) {
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	XHR.prototype.doPoll = function () {
	  debug$4('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function (data) {
	    self.onData(data);
	  });
	  req.on('error', function (err) {
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};

	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */

	function Request(opts) {
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined !== opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	  this.requestTimeout = opts.requestTimeout;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;

	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;

	  this.create();
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Request.prototype);

	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */

	Request.prototype.create = function () {
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  var xhr = this.xhr = new require$$1(opts);
	  var self = this;

	  try {
	    debug$4('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}

	    if ('POST' === this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }

	    try {
	      xhr.setRequestHeader('Accept', '*/*');
	    } catch (e) {}

	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }

	    if (this.requestTimeout) {
	      xhr.timeout = this.requestTimeout;
	    }

	    if (this.hasXDR()) {
	      xhr.onload = function () {
	        self.onLoad();
	      };
	      xhr.onerror = function () {
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function () {
	        if (xhr.readyState === 2) {
	          try {
	            var contentType = xhr.getResponseHeader('Content-Type');
	            if (self.supportsBinary && contentType === 'application/octet-stream') {
	              xhr.responseType = 'arraybuffer';
	            }
	          } catch (e) {}
	        }
	        if (4 !== xhr.readyState) return;
	        if (200 === xhr.status || 1223 === xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function () {
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }

	    debug$4('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function () {
	      self.onError(e);
	    }, 0);
	    return;
	  }

	  if (commonjsGlobal.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};

	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */

	Request.prototype.onSuccess = function () {
	  this.emit('success');
	  this.cleanup();
	};

	/**
	 * Called if we have data.
	 *
	 * @api private
	 */

	Request.prototype.onData = function (data) {
	  this.emit('data', data);
	  this.onSuccess();
	};

	/**
	 * Called upon error.
	 *
	 * @api private
	 */

	Request.prototype.onError = function (err) {
	  this.emit('error', err);
	  this.cleanup(true);
	};

	/**
	 * Cleans up house.
	 *
	 * @api private
	 */

	Request.prototype.cleanup = function (fromError) {
	  if ('undefined' === typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }

	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch (e) {}
	  }

	  if (commonjsGlobal.document) {
	    delete Request.requests[this.index];
	  }

	  this.xhr = null;
	};

	/**
	 * Called upon load.
	 *
	 * @api private
	 */

	Request.prototype.onLoad = function () {
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type');
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response || this.xhr.responseText;
	    } else {
	      data = this.xhr.responseText;
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};

	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */

	Request.prototype.hasXDR = function () {
	  return 'undefined' !== typeof commonjsGlobal.XDomainRequest && !this.xs && this.enablesXDR;
	};

	/**
	 * Aborts the request.
	 *
	 * @api public
	 */

	Request.prototype.abort = function () {
	  this.cleanup();
	};

	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */

	Request.requestsCount = 0;
	Request.requests = {};

	if (commonjsGlobal.document) {
	  if (commonjsGlobal.attachEvent) {
	    commonjsGlobal.attachEvent('onunload', unloadHandler);
	  } else if (commonjsGlobal.addEventListener) {
	    commonjsGlobal.addEventListener('beforeunload', unloadHandler, false);
	  }
	}

	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}
	pollingXhr.Request = Request_1;

	var pollingXhr$1 = /*#__PURE__*/Object.freeze({
		default: pollingXhr,
		__moduleExports: pollingXhr,
		Request: Request_1
	});

	/**
	 * Module requirements.
	 */

	/**
	 * Module exports.
	 */

	var pollingJsonp = JSONPPolling;

	/**
	 * Cached regular expressions.
	 */

	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;

	/**
	 * Global JSONP callbacks.
	 */

	var callbacks;

	/**
	 * Noop.
	 */

	function empty$1() {}

	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */

	function JSONPPolling(opts) {
	  Polling$1.call(this, opts);

	  this.query = this.query || {};

	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!commonjsGlobal.___eio) commonjsGlobal.___eio = [];
	    callbacks = commonjsGlobal.___eio;
	  }

	  // callback identifier
	  this.index = callbacks.length;

	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });

	  // append to query string
	  this.query.j = this.index;

	  // prevent spurious errors from being emitted when the window is unloaded
	  if (commonjsGlobal.document && commonjsGlobal.addEventListener) {
	    commonjsGlobal.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty$1;
	    }, false);
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(JSONPPolling, Polling$1);

	/*
	 * JSONP only supports binary as base64 encoded strings
	 */

	JSONPPolling.prototype.supportsBinary = false;

	/**
	 * Closes the socket.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }

	  Polling$1.prototype.doClose.call(this);
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');

	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function (e) {
	    self.onError('jsonp poll error', e);
	  };

	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  } else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;

	  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};

	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */

	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;

	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;

	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);

	    this.form = form;
	    this.area = area;
	  }

	  this.form.action = this.uri();

	  function complete() {
	    initIframe();
	    fn();
	  }

	  function initIframe() {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }

	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }

	    iframe.id = self.iframeId;

	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }

	  initIframe();

	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');

	  try {
	    this.form.submit();
	  } catch (e) {}

	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function () {
	      if (self.iframe.readyState === 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};

	var pollingJsonp$1 = /*#__PURE__*/Object.freeze({
		default: pollingJsonp,
		__moduleExports: pollingJsonp
	});

	var empty$2 = {};

	var empty$3 = /*#__PURE__*/Object.freeze({
		default: empty$2
	});

	var require$$1$1 = ( empty$3 && empty$2 ) || empty$3;

	/**
	 * Module dependencies.
	 */

	var debug$5 = require$$0$2('engine.io-client:websocket');
	var BrowserWebSocket = commonjsGlobal.WebSocket || commonjsGlobal.MozWebSocket;
	var NodeWebSocket;
	if (typeof window === 'undefined') {
	  try {
	    NodeWebSocket = require$$1$1;
	  } catch (e) {}
	}

	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */

	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  WebSocket = NodeWebSocket;
	}

	/**
	 * Module exports.
	 */

	var websocket = WS;

	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */

	function WS(opts) {
	  var forceBase64 = opts && opts.forceBase64;
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
	  this.protocols = opts.protocols;
	  if (!this.usingBrowserWebSocket) {
	    WebSocket = NodeWebSocket;
	  }
	  Transport$1.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(WS, Transport$1);

	/**
	 * Transport name.
	 *
	 * @api public
	 */

	WS.prototype.name = 'websocket';

	/*
	 * WebSockets support binary
	 */

	WS.prototype.supportsBinary = true;

	/**
	 * Opens socket.
	 *
	 * @api private
	 */

	WS.prototype.doOpen = function () {
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }

	  var uri = this.uri();
	  var protocols = this.protocols;
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }
	  if (this.localAddress) {
	    opts.localAddress = this.localAddress;
	  }

	  try {
	    this.ws = this.usingBrowserWebSocket ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
	  } catch (err) {
	    return this.emit('error', err);
	  }

	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }

	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'nodebuffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }

	  this.addEventListeners();
	};

	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */

	WS.prototype.addEventListeners = function () {
	  var self = this;

	  this.ws.onopen = function () {
	    self.onOpen();
	  };
	  this.ws.onclose = function () {
	    self.onClose();
	  };
	  this.ws.onmessage = function (ev) {
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function (e) {
	    self.onError('websocket error', e);
	  };
	};

	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */

	WS.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;

	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function (packet) {
	      parser.encodePacket(packet, self.supportsBinary, function (data) {
	        if (!self.usingBrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }

	          if (self.perMessageDeflate) {
	            var len = 'string' === typeof data ? commonjsGlobal.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }

	        // Sometimes the websocket has already been closed but the browser didn't
	        // have a chance of informing us about it yet, in that case send will
	        // throw an error
	        try {
	          if (self.usingBrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e) {
	          debug$5('websocket closed before onclose event');
	        }

	        --total || done();
	      });
	    })(packets[i]);
	  }

	  function done() {
	    self.emit('flush');

	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function () {
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};

	/**
	 * Called upon close
	 *
	 * @api private
	 */

	WS.prototype.onClose = function () {
	  Transport$1.prototype.onClose.call(this);
	};

	/**
	 * Closes socket.
	 *
	 * @api private
	 */

	WS.prototype.doClose = function () {
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	WS.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';

	  // avoid port if default for schema
	  if (this.port && ('wss' === schema && Number(this.port) !== 443 || 'ws' === schema && Number(this.port) !== 80)) {
	    port = ':' + this.port;
	  }

	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast$2();
	  }

	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }

	  query = parseqs$2.encode(query);

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};

	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */

	WS.prototype.check = function () {
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};

	var websocket$1 = /*#__PURE__*/Object.freeze({
		default: websocket,
		__moduleExports: websocket
	});

	var XHR$1 = ( pollingXhr$1 && pollingXhr ) || pollingXhr$1;

	var JSONP = ( pollingJsonp$1 && pollingJsonp ) || pollingJsonp$1;

	var websocket$2 = ( websocket$1 && websocket ) || websocket$1;

	/**
	 * Module dependencies
	 */

	/**
	 * Export transports.
	 */

	var polling_1 = polling$2;
	var websocket_1 = websocket$2;

	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */

	function polling$2(opts) {
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;

	  if (commonjsGlobal.location) {
	    var isSSL = 'https:' === location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    xd = opts.hostname !== location.hostname || port !== opts.port;
	    xs = opts.secure !== isSSL;
	  }

	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new require$$1(opts);

	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR$1(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}

	var transports = {
	  polling: polling_1,
	  websocket: websocket_1
	};

	var transports$1 = /*#__PURE__*/Object.freeze({
		default: transports,
		__moduleExports: transports,
		polling: polling_1,
		websocket: websocket_1
	});

	var indexOf = [].indexOf;

	var indexof = function indexof(arr, obj) {
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

	var indexof$1 = /*#__PURE__*/Object.freeze({
		default: indexof,
		__moduleExports: indexof
	});

	var transports$2 = ( transports$1 && transports ) || transports$1;

	var index = ( indexof$1 && indexof ) || indexof$1;

	/**
	 * Module dependencies.
	 */

	var debug$6 = require$$0$2('engine.io-client:socket');

	/**
	 * Module exports.
	 */

	var socket = Socket;

	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */

	function Socket(uri, opts) {
	  if (!(this instanceof Socket)) return new Socket(uri, opts);

	  opts = opts || {};

	  if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
	    opts = uri;
	    uri = null;
	  }

	  if (uri) {
	    uri = parseuri$2(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri$2(opts.host).host;
	  }

	  this.secure = null != opts.secure ? opts.secure : commonjsGlobal.location && 'https:' === location.protocol;

	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }

	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname || (commonjsGlobal.location ? location.hostname : 'localhost');
	  this.port = opts.port || (commonjsGlobal.location && location.port ? location.port : this.secure ? 443 : 80);
	  this.query = opts.query || {};
	  if ('string' === typeof this.query) this.query = parseqs$2.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.transportOptions = opts.transportOptions || {};
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.prevBufferLen = 0;
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;

	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }

	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
	  this.forceNode = !!opts.forceNode;

	  // other options for Node.js client
	  var freeGlobal = _typeof(commonjsGlobal) === 'object' && commonjsGlobal;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }

	    if (opts.localAddress) {
	      this.localAddress = opts.localAddress;
	    }
	  }

	  // set on handshake
	  this.id = null;
	  this.upgrades = null;
	  this.pingInterval = null;
	  this.pingTimeout = null;

	  // set on heartbeat
	  this.pingIntervalTimer = null;
	  this.pingTimeoutTimer = null;

	  this.open();
	}

	Socket.priorWebsocketSuccess = false;

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	Socket.protocol = parser.protocol; // this is an int

	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */

	Socket.Socket = Socket;
	Socket.Transport = Transport$1;
	Socket.transports = transports$2;
	Socket.parser = parser;

	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */

	Socket.prototype.createTransport = function (name) {
	  debug$6('creating transport "%s"', name);
	  var query = clone(this.query);

	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;

	  // transport name
	  query.transport = name;

	  // per-transport options
	  var options = this.transportOptions[name] || {};

	  // session id if we already have one
	  if (this.id) query.sid = this.id;

	  var transport = new transports$2[name]({
	    query: query,
	    socket: this,
	    agent: options.agent || this.agent,
	    hostname: options.hostname || this.hostname,
	    port: options.port || this.port,
	    secure: options.secure || this.secure,
	    path: options.path || this.path,
	    forceJSONP: options.forceJSONP || this.forceJSONP,
	    jsonp: options.jsonp || this.jsonp,
	    forceBase64: options.forceBase64 || this.forceBase64,
	    enablesXDR: options.enablesXDR || this.enablesXDR,
	    timestampRequests: options.timestampRequests || this.timestampRequests,
	    timestampParam: options.timestampParam || this.timestampParam,
	    policyPort: options.policyPort || this.policyPort,
	    pfx: options.pfx || this.pfx,
	    key: options.key || this.key,
	    passphrase: options.passphrase || this.passphrase,
	    cert: options.cert || this.cert,
	    ca: options.ca || this.ca,
	    ciphers: options.ciphers || this.ciphers,
	    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
	    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
	    extraHeaders: options.extraHeaders || this.extraHeaders,
	    forceNode: options.forceNode || this.forceNode,
	    localAddress: options.localAddress || this.localAddress,
	    requestTimeout: options.requestTimeout || this.requestTimeout,
	    protocols: options.protocols || void 0
	  });

	  return transport;
	};

	function clone(obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}

	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function () {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';

	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }

	  transport.open();
	  this.setTransport(transport);
	};

	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */

	Socket.prototype.setTransport = function (transport) {
	  debug$6('setting transport %s', transport.name);
	  var self = this;

	  if (this.transport) {
	    debug$6('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }

	  // set up transport
	  this.transport = transport;

	  // set up transport listeners
	  transport.on('drain', function () {
	    self.onDrain();
	  }).on('packet', function (packet) {
	    self.onPacket(packet);
	  }).on('error', function (e) {
	    self.onError(e);
	  }).on('close', function () {
	    self.onClose('transport close');
	  });
	};

	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */

	Socket.prototype.probe = function (name) {
	  debug$6('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 });
	  var failed = false;
	  var self = this;

	  Socket.priorWebsocketSuccess = false;

	  function onTransportOpen() {
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;

	    debug$6('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' === msg.type && 'probe' === msg.data) {
	        debug$6('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

	        debug$6('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' === self.readyState) return;
	          debug$6('changing transport and sending upgrade packet');

	          cleanup();

	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug$6('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }

	  function freezeTransport() {
	    if (failed) return;

	    // Any callback called by transport should be ignored since now
	    failed = true;

	    cleanup();

	    transport.close();
	    transport = null;
	  }

	  // Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;

	    freezeTransport();

	    debug$6('probe transport "%s" failed because of error: %s', name, err);

	    self.emit('upgradeError', error);
	  }

	  function onTransportClose() {
	    onerror('transport closed');
	  }

	  // When the socket is closed while we're probing
	  function onclose() {
	    onerror('socket closed');
	  }

	  // When the socket is upgraded while we're probing
	  function onupgrade(to) {
	    if (transport && to.name !== transport.name) {
	      debug$6('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }

	  // Remove all listeners on the transport and on self
	  function cleanup() {
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }

	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);

	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);

	  transport.open();
	};

	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */

	Socket.prototype.onOpen = function () {
	  debug$6('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
	  this.emit('open');
	  this.flush();

	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
	    debug$6('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};

	/**
	 * Handles a packet.
	 *
	 * @api private
	 */

	Socket.prototype.onPacket = function (packet) {
	  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
	    debug$6('socket receive: type "%s", data "%s"', packet.type, packet.data);

	    this.emit('packet', packet);

	    // Socket is live - any packet counts
	    this.emit('heartbeat');

	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(JSON.parse(packet.data));
	        break;

	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;

	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;

	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug$6('packet received with socket readyState "%s"', this.readyState);
	  }
	};

	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */

	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if ('closed' === this.readyState) return;
	  this.setPing();

	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};

	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */

	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' === self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || self.pingInterval + self.pingTimeout);
	};

	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */

	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug$6('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};

	/**
	* Sends a ping packet.
	*
	* @api private
	*/

	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function () {
	    self.emit('ping');
	  });
	};

	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */

	Socket.prototype.onDrain = function () {
	  this.writeBuffer.splice(0, this.prevBufferLen);

	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;

	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};

	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */

	Socket.prototype.flush = function () {
	  if ('closed' !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
	    debug$6('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};

	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */

	Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */

	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if ('function' === typeof data) {
	    fn = data;
	    data = undefined;
	  }

	  if ('function' === typeof options) {
	    fn = options;
	    options = null;
	  }

	  if ('closing' === this.readyState || 'closed' === this.readyState) {
	    return;
	  }

	  options = options || {};
	  options.compress = false !== options.compress;

	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};

	/**
	 * Closes the connection.
	 *
	 * @api private
	 */

	Socket.prototype.close = function () {
	  if ('opening' === this.readyState || 'open' === this.readyState) {
	    this.readyState = 'closing';

	    var self = this;

	    if (this.writeBuffer.length) {
	      this.once('drain', function () {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }

	  function close() {
	    self.onClose('forced close');
	    debug$6('socket closing - telling transport to close');
	    self.transport.close();
	  }

	  function cleanupAndClose() {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }

	  function waitForUpgrade() {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }

	  return this;
	};

	/**
	 * Called upon transport error
	 *
	 * @api private
	 */

	Socket.prototype.onError = function (err) {
	  debug$6('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};

	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */

	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
	    debug$6('socket close with reason: "%s"', reason);
	    var self = this;

	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);

	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');

	    // ensure transport won't stay open
	    this.transport.close();

	    // ignore further transport communication
	    this.transport.removeAllListeners();

	    // set ready state
	    this.readyState = 'closed';

	    // clear session id
	    this.id = null;

	    // emit close event
	    this.emit('close', reason, desc);

	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};

	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */

	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i < j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};

	var socket$1 = /*#__PURE__*/Object.freeze({
		default: socket,
		__moduleExports: socket
	});

	var require$$0$4 = ( socket$1 && socket ) || socket$1;

	var lib = require$$0$4;

	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	var parser$1 = parser;
	lib.parser = parser$1;

	var lib$1 = /*#__PURE__*/Object.freeze({
		default: lib,
		__moduleExports: lib,
		parser: parser$1
	});

	var toArray_1 = toArray$1;

	function toArray$1(list, index) {
	    var array = [];

	    index = index || 0;

	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i];
	    }

	    return array;
	}

	var toArray$2 = /*#__PURE__*/Object.freeze({
		default: toArray_1,
		__moduleExports: toArray_1
	});

	/**
	 * Module exports.
	 */

	var on_1 = on;

	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */

	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function destroy() {
	      obj.removeListener(ev, fn);
	    }
	  };
	}

	var on$1 = /*#__PURE__*/Object.freeze({
		default: on_1,
		__moduleExports: on_1
	});

	/**
	 * Slice reference.
	 */

	var slice = [].slice;

	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */

	var componentBind = function componentBind(obj, fn) {
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function () {
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  };
	};

	var componentBind$1 = /*#__PURE__*/Object.freeze({
		default: componentBind,
		__moduleExports: componentBind
	});

	var parser$2 = ( socket_ioParser$1 && socket_ioParser ) || socket_ioParser$1;

	var toArray$3 = ( toArray$2 && toArray_1 ) || toArray$2;

	var on$2 = ( on$1 && on_1 ) || on$1;

	var bind = ( componentBind$1 && componentBind ) || componentBind$1;

	var socket$2 = createCommonjsModule(function (module, exports) {
	  /**
	   * Module dependencies.
	   */

	  var debug = require$$0$2('socket.io-client:socket');

	  /**
	   * Module exports.
	   */

	  module.exports = exports = Socket;

	  /**
	   * Internal events (blacklisted).
	   * These events can't be emitted by the user.
	   *
	   * @api private
	   */

	  var events = {
	    connect: 1,
	    connect_error: 1,
	    connect_timeout: 1,
	    connecting: 1,
	    disconnect: 1,
	    error: 1,
	    reconnect: 1,
	    reconnect_attempt: 1,
	    reconnect_failed: 1,
	    reconnect_error: 1,
	    reconnecting: 1,
	    ping: 1,
	    pong: 1
	  };

	  /**
	   * Shortcut to `Emitter#emit`.
	   */

	  var emit = Emitter.prototype.emit;

	  /**
	   * `Socket` constructor.
	   *
	   * @api public
	   */

	  function Socket(io, nsp, opts) {
	    this.io = io;
	    this.nsp = nsp;
	    this.json = this; // compat
	    this.ids = 0;
	    this.acks = {};
	    this.receiveBuffer = [];
	    this.sendBuffer = [];
	    this.connected = false;
	    this.disconnected = true;
	    this.flags = {};
	    if (opts && opts.query) {
	      this.query = opts.query;
	    }
	    if (this.io.autoConnect) this.open();
	  }

	  /**
	   * Mix in `Emitter`.
	   */

	  Emitter(Socket.prototype);

	  /**
	   * Subscribe to open, close and packet events
	   *
	   * @api private
	   */

	  Socket.prototype.subEvents = function () {
	    if (this.subs) return;

	    var io = this.io;
	    this.subs = [on$2(io, 'open', bind(this, 'onopen')), on$2(io, 'packet', bind(this, 'onpacket')), on$2(io, 'close', bind(this, 'onclose'))];
	  };

	  /**
	   * "Opens" the socket.
	   *
	   * @api public
	   */

	  Socket.prototype.open = Socket.prototype.connect = function () {
	    if (this.connected) return this;

	    this.subEvents();
	    this.io.open(); // ensure open
	    if ('open' === this.io.readyState) this.onopen();
	    this.emit('connecting');
	    return this;
	  };

	  /**
	   * Sends a `message` event.
	   *
	   * @return {Socket} self
	   * @api public
	   */

	  Socket.prototype.send = function () {
	    var args = toArray$3(arguments);
	    args.unshift('message');
	    this.emit.apply(this, args);
	    return this;
	  };

	  /**
	   * Override `emit`.
	   * If the event is in `events`, it's emitted normally.
	   *
	   * @param {String} event name
	   * @return {Socket} self
	   * @api public
	   */

	  Socket.prototype.emit = function (ev) {
	    if (events.hasOwnProperty(ev)) {
	      emit.apply(this, arguments);
	      return this;
	    }

	    var args = toArray$3(arguments);
	    var packet = {
	      type: (this.flags.binary !== undefined ? this.flags.binary : hasBinary$1(args)) ? parser$2.BINARY_EVENT : parser$2.EVENT,
	      data: args
	    };

	    packet.options = {};
	    packet.options.compress = !this.flags || false !== this.flags.compress;

	    // event ack callback
	    if ('function' === typeof args[args.length - 1]) {
	      debug('emitting packet with ack id %d', this.ids);
	      this.acks[this.ids] = args.pop();
	      packet.id = this.ids++;
	    }

	    if (this.connected) {
	      this.packet(packet);
	    } else {
	      this.sendBuffer.push(packet);
	    }

	    this.flags = {};

	    return this;
	  };

	  /**
	   * Sends a packet.
	   *
	   * @param {Object} packet
	   * @api private
	   */

	  Socket.prototype.packet = function (packet) {
	    packet.nsp = this.nsp;
	    this.io.packet(packet);
	  };

	  /**
	   * Called upon engine `open`.
	   *
	   * @api private
	   */

	  Socket.prototype.onopen = function () {
	    debug('transport is open - connecting');

	    // write connect packet if necessary
	    if ('/' !== this.nsp) {
	      if (this.query) {
	        var query = _typeof(this.query) === 'object' ? parseqs$2.encode(this.query) : this.query;
	        debug('sending connect packet with query %s', query);
	        this.packet({ type: parser$2.CONNECT, query: query });
	      } else {
	        this.packet({ type: parser$2.CONNECT });
	      }
	    }
	  };

	  /**
	   * Called upon engine `close`.
	   *
	   * @param {String} reason
	   * @api private
	   */

	  Socket.prototype.onclose = function (reason) {
	    debug('close (%s)', reason);
	    this.connected = false;
	    this.disconnected = true;
	    delete this.id;
	    this.emit('disconnect', reason);
	  };

	  /**
	   * Called with socket packet.
	   *
	   * @param {Object} packet
	   * @api private
	   */

	  Socket.prototype.onpacket = function (packet) {
	    var sameNamespace = packet.nsp === this.nsp;
	    var rootNamespaceError = packet.type === parser$2.ERROR && packet.nsp === '/';

	    if (!sameNamespace && !rootNamespaceError) return;

	    switch (packet.type) {
	      case parser$2.CONNECT:
	        this.onconnect();
	        break;

	      case parser$2.EVENT:
	        this.onevent(packet);
	        break;

	      case parser$2.BINARY_EVENT:
	        this.onevent(packet);
	        break;

	      case parser$2.ACK:
	        this.onack(packet);
	        break;

	      case parser$2.BINARY_ACK:
	        this.onack(packet);
	        break;

	      case parser$2.DISCONNECT:
	        this.ondisconnect();
	        break;

	      case parser$2.ERROR:
	        this.emit('error', packet.data);
	        break;
	    }
	  };

	  /**
	   * Called upon a server event.
	   *
	   * @param {Object} packet
	   * @api private
	   */

	  Socket.prototype.onevent = function (packet) {
	    var args = packet.data || [];
	    debug('emitting event %j', args);

	    if (null != packet.id) {
	      debug('attaching ack callback to event');
	      args.push(this.ack(packet.id));
	    }

	    if (this.connected) {
	      emit.apply(this, args);
	    } else {
	      this.receiveBuffer.push(args);
	    }
	  };

	  /**
	   * Produces an ack callback to emit with an event.
	   *
	   * @api private
	   */

	  Socket.prototype.ack = function (id) {
	    var self = this;
	    var sent = false;
	    return function () {
	      // prevent double callbacks
	      if (sent) return;
	      sent = true;
	      var args = toArray$3(arguments);
	      debug('sending ack %j', args);

	      self.packet({
	        type: hasBinary$1(args) ? parser$2.BINARY_ACK : parser$2.ACK,
	        id: id,
	        data: args
	      });
	    };
	  };

	  /**
	   * Called upon a server acknowlegement.
	   *
	   * @param {Object} packet
	   * @api private
	   */

	  Socket.prototype.onack = function (packet) {
	    var ack = this.acks[packet.id];
	    if ('function' === typeof ack) {
	      debug('calling ack %s with %j', packet.id, packet.data);
	      ack.apply(this, packet.data);
	      delete this.acks[packet.id];
	    } else {
	      debug('bad ack %s', packet.id);
	    }
	  };

	  /**
	   * Called upon server connect.
	   *
	   * @api private
	   */

	  Socket.prototype.onconnect = function () {
	    this.connected = true;
	    this.disconnected = false;
	    this.emit('connect');
	    this.emitBuffered();
	  };

	  /**
	   * Emit buffered events (received and emitted).
	   *
	   * @api private
	   */

	  Socket.prototype.emitBuffered = function () {
	    var i;
	    for (i = 0; i < this.receiveBuffer.length; i++) {
	      emit.apply(this, this.receiveBuffer[i]);
	    }
	    this.receiveBuffer = [];

	    for (i = 0; i < this.sendBuffer.length; i++) {
	      this.packet(this.sendBuffer[i]);
	    }
	    this.sendBuffer = [];
	  };

	  /**
	   * Called upon server disconnect.
	   *
	   * @api private
	   */

	  Socket.prototype.ondisconnect = function () {
	    debug('server disconnect (%s)', this.nsp);
	    this.destroy();
	    this.onclose('io server disconnect');
	  };

	  /**
	   * Called upon forced client/server side disconnections,
	   * this method ensures the manager stops tracking us and
	   * that reconnections don't get triggered for this.
	   *
	   * @api private.
	   */

	  Socket.prototype.destroy = function () {
	    if (this.subs) {
	      // clean subscriptions to avoid reconnections
	      for (var i = 0; i < this.subs.length; i++) {
	        this.subs[i].destroy();
	      }
	      this.subs = null;
	    }

	    this.io.destroy(this);
	  };

	  /**
	   * Disconnects the socket manually.
	   *
	   * @return {Socket} self
	   * @api public
	   */

	  Socket.prototype.close = Socket.prototype.disconnect = function () {
	    if (this.connected) {
	      debug('performing disconnect (%s)', this.nsp);
	      this.packet({ type: parser$2.DISCONNECT });
	    }

	    // remove socket from pool
	    this.destroy();

	    if (this.connected) {
	      // fire events
	      this.onclose('io client disconnect');
	    }
	    return this;
	  };

	  /**
	   * Sets the compress flag.
	   *
	   * @param {Boolean} if `true`, compresses the sending data
	   * @return {Socket} self
	   * @api public
	   */

	  Socket.prototype.compress = function (compress) {
	    this.flags.compress = compress;
	    return this;
	  };

	  /**
	   * Sets the binary flag
	   *
	   * @param {Boolean} whether the emitted data contains binary
	   * @return {Socket} self
	   * @api public
	   */

	  Socket.prototype.binary = function (binary) {
	    this.flags.binary = binary;
	    return this;
	  };
	});

	var socket$3 = /*#__PURE__*/Object.freeze({
		default: socket$2,
		__moduleExports: socket$2
	});

	/**
	 * Expose `Backoff`.
	 */

	var backo2 = Backoff;

	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}

	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */

	Backoff.prototype.duration = function () {
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand = Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};

	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */

	Backoff.prototype.reset = function () {
	  this.attempts = 0;
	};

	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMin = function (min) {
	  this.ms = min;
	};

	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMax = function (max) {
	  this.max = max;
	};

	/**
	 * Set the jitter
	 *
	 * @api public
	 */

	Backoff.prototype.setJitter = function (jitter) {
	  this.jitter = jitter;
	};

	var backo2$1 = /*#__PURE__*/Object.freeze({
		default: backo2,
		__moduleExports: backo2
	});

	var eio = ( lib$1 && lib ) || lib$1;

	var Socket$1 = ( socket$3 && socket$2 ) || socket$3;

	var Backoff$1 = ( backo2$1 && backo2 ) || backo2$1;

	/**
	 * Module dependencies.
	 */

	var debug$7 = require$$0$2('socket.io-client:manager');

	/**
	 * IE6+ hasOwnProperty
	 */

	var has = Object.prototype.hasOwnProperty;

	/**
	 * Module exports
	 */

	var manager = Manager;

	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */

	function Manager(uri, opts) {
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};

	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff$1({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  var _parser = opts.parser || parser$2;
	  this.encoder = new _parser.Encoder();
	  this.decoder = new _parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}

	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */

	Manager.prototype.emitAll = function () {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};

	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */

	Manager.prototype.updateSocketIds = function () {
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.generateId(nsp);
	    }
	  }
	};

	/**
	 * generate `socket.id` for the given `nsp`
	 *
	 * @param {String} nsp
	 * @return {String}
	 * @api private
	 */

	Manager.prototype.generateId = function (nsp) {
	  return (nsp === '/' ? '' : nsp + '#') + this.engine.id;
	};

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Manager.prototype);

	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnection = function (v) {
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};

	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionAttempts = function (v) {
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};

	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelay = function (v) {
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};

	Manager.prototype.randomizationFactor = function (v) {
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};

	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelayMax = function (v) {
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};

	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.timeout = function (v) {
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};

	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */

	Manager.prototype.maybeReconnectOnOpen = function () {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};

	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */

	Manager.prototype.open = Manager.prototype.connect = function (fn, opts) {
	  debug$7('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;

	  debug$7('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;

	  // emit `open`
	  var openSub = on$2(socket, 'open', function () {
	    self.onopen();
	    fn && fn();
	  });

	  // emit `connect_error`
	  var errorSub = on$2(socket, 'error', function (data) {
	    debug$7('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });

	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug$7('connect attempt will timeout after %d', timeout);

	    // set timer
	    var timer = setTimeout(function () {
	      debug$7('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);

	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }

	  this.subs.push(openSub);
	  this.subs.push(errorSub);

	  return this;
	};

	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */

	Manager.prototype.onopen = function () {
	  debug$7('open');

	  // clear old subs
	  this.cleanup();

	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');

	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on$2(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on$2(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on$2(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on$2(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on$2(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on$2(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};

	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */

	Manager.prototype.onping = function () {
	  this.lastPing = new Date();
	  this.emitAll('ping');
	};

	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */

	Manager.prototype.onpong = function () {
	  this.emitAll('pong', new Date() - this.lastPing);
	};

	/**
	 * Called with data.
	 *
	 * @api private
	 */

	Manager.prototype.ondata = function (data) {
	  this.decoder.add(data);
	};

	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */

	Manager.prototype.ondecoded = function (packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */

	Manager.prototype.onerror = function (err) {
	  debug$7('error', err);
	  this.emitAll('error', err);
	};

	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */

	Manager.prototype.socket = function (nsp, opts) {
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket$1(this, nsp, opts);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function () {
	      socket.id = self.generateId(nsp);
	    });

	    if (this.autoConnect) {
	      // manually call here since connecting event is fired before listening
	      onConnecting();
	    }
	  }

	  function onConnecting() {
	    if (!~index(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }

	  return socket;
	};

	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */

	Manager.prototype.destroy = function (socket) {
	  var index$$1 = index(this.connecting, socket);
	  if (~index$$1) this.connecting.splice(index$$1, 1);
	  if (this.connecting.length) return;

	  this.close();
	};

	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Manager.prototype.packet = function (packet) {
	  debug$7('writing packet %j', packet);
	  var self = this;
	  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function (encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else {
	    // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};

	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */

	Manager.prototype.processPacketQueue = function () {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};

	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */

	Manager.prototype.cleanup = function () {
	  debug$7('cleanup');

	  var subsLength = this.subs.length;
	  for (var i = 0; i < subsLength; i++) {
	    var sub = this.subs.shift();
	    sub.destroy();
	  }

	  this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;

	  this.decoder.destroy();
	};

	/**
	 * Close the current socket.
	 *
	 * @api private
	 */

	Manager.prototype.close = Manager.prototype.disconnect = function () {
	  debug$7('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' === this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};

	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */

	Manager.prototype.onclose = function (reason) {
	  debug$7('onclose');

	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);

	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};

	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */

	Manager.prototype.reconnect = function () {
	  if (this.reconnecting || this.skipReconnect) return this;

	  var self = this;

	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug$7('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug$7('will wait %dms before reconnect attempt', delay);

	    this.reconnecting = true;
	    var timer = setTimeout(function () {
	      if (self.skipReconnect) return;

	      debug$7('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);

	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;

	      self.open(function (err) {
	        if (err) {
	          debug$7('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug$7('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);

	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }
	};

	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */

	Manager.prototype.onreconnect = function () {
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};

	var manager$1 = /*#__PURE__*/Object.freeze({
		default: manager,
		__moduleExports: manager
	});

	var url$2 = ( url$1 && url_1 ) || url$1;

	var Manager$1 = ( manager$1 && manager ) || manager$1;

	var lib$2 = createCommonjsModule(function (module, exports) {
	  /**
	   * Module dependencies.
	   */

	  var debug = require$$0$2('socket.io-client');

	  /**
	   * Module exports.
	   */

	  module.exports = exports = lookup;

	  /**
	   * Managers cache.
	   */

	  var cache = exports.managers = {};

	  /**
	   * Looks up an existing `Manager` for multiplexing.
	   * If the user summons:
	   *
	   *   `io('http://localhost/a');`
	   *   `io('http://localhost/b');`
	   *
	   * We reuse the existing instance based on same scheme/port/host,
	   * and we initialize sockets for each namespace.
	   *
	   * @api public
	   */

	  function lookup(uri, opts) {
	    if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') {
	      opts = uri;
	      uri = undefined;
	    }

	    opts = opts || {};

	    var parsed = url$2(uri);
	    var source = parsed.source;
	    var id = parsed.id;
	    var path = parsed.path;
	    var sameNamespace = cache[id] && path in cache[id].nsps;
	    var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;

	    var io;

	    if (newConnection) {
	      debug('ignoring socket cache for %s', source);
	      io = Manager$1(source, opts);
	    } else {
	      if (!cache[id]) {
	        debug('new io instance for %s', source);
	        cache[id] = Manager$1(source, opts);
	      }
	      io = cache[id];
	    }
	    if (parsed.query && !opts.query) {
	      opts.query = parsed.query;
	    }
	    return io.socket(parsed.path, opts);
	  }

	  /**
	   * Protocol version.
	   *
	   * @api public
	   */

	  exports.protocol = parser$2.protocol;

	  /**
	   * `connect`.
	   *
	   * @param {String} uri
	   * @api public
	   */

	  exports.connect = lookup;

	  /**
	   * Expose constructors for standalone build.
	   *
	   * @api public
	   */

	  exports.Manager = Manager$1;
	  exports.Socket = Socket$1;
	});
	var lib_1 = lib$2.managers;
	var lib_2 = lib$2.protocol;
	var lib_3 = lib$2.connect;
	var lib_4 = lib$2.Manager;
	var lib_5 = lib$2.Socket;

	function extend(Y) {
	    var Connector = function (_Y$AbstractConnector) {
	        inherits(Connector, _Y$AbstractConnector);

	        function Connector(y, options) {
	            classCallCheck(this, Connector);

	            if (options === undefined) {
	                throw new Error('Options must not be undefined!');
	            }
	            options.preferUntransformed = true;
	            options.generateUserId = options.generateUserId || false;
	            if (options.initSync !== false) {
	                options.initSync = true;
	            }

	            var _this = possibleConstructorReturn(this, (Connector.__proto__ || Object.getPrototypeOf(Connector)).call(this, y, options));

	            _this._sentSync = false;
	            _this.options = options;
	            options.url = options.url || 'https://yjs.dbis.rwth-aachen.de:5072';
	            var socket = options.socket || lib$2(options.url, options.options);
	            _this.socket = socket;
	            var self = _this;

	            /****************** start minimal webrtc **********************/
	            var signaling_socket = socket;
	            var DEFAULT_CHANNEL = options.room;
	            var ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }, { urls: "turn:try.refactored.ai:3478", username: "test99", credential: "test" }];
	            var dcs = {};
	            _this.dcs = dcs;
	            _this.sdcs = dcs;
	            var peers = {};
	            var peer_media_elements = {};
	            var sockets;
	            _this.sockets = sockets;

	            function receiveData(ywebrtc, peer_id) {
	                var buf, count;
	                return function onmessage(event) {
	                    if (typeof event.data === 'string') {
	                        buf = new Uint8Array(parseInt(event.data));
	                        count = 0;
	                        return;
	                    }
	                    var data = new Uint8Array(event.data);
	                    buf.set(data, count);
	                    count += data.byteLength;
	                    if (count === buf.byteLength) {
	                        ywebrtc.receiveMessage(peer_id, buf);
	                    }
	                };
	            }

	            function init(ywebrtc) {
	                signaling_socket.on('connect', function () {
	                    join_chat_channel(DEFAULT_CHANNEL, { 'whatever-you-want-here': 'stuff' });
	                });

	                signaling_socket.on('sockets', function (sockets) {
	                    ywebrtc.sockets = sockets;
	                });

	                signaling_socket.on('disconnect', function () {
	                    /* Tear down all of our peer connections and remove all the
	                     * media divs when we disconnect */
	                    for (peer_id in peer_media_elements) {
	                        peer_media_elements[peer_id].remove();
	                    }
	                    for (peer_id in peers) {
	                        peers[peer_id].close();
	                    }

	                    peers = {};
	                    peer_media_elements = {};
	                });

	                function join_chat_channel(channel, userdata) {
	                    signaling_socket.emit('join', { "channel": channel, "userdata": userdata });
	                    ywebrtc.userID = signaling_socket.id;
	                }

	                signaling_socket.on('addPeer', function (config) {
	                    var peer_id = config.peer_id;

	                    if (peer_id in peers) {
	                        /* This could happen if the user joins multiple channels where the other peer is also in. */
	                        return;
	                    }

	                    var peer_connection = new RTCPeerConnection({ "iceServers": ICE_SERVERS });
	                    peers[peer_id] = peer_connection;

	                    var dataChannel = peer_connection.createDataChannel('data');
	                    var syncDataChannel = peer_connection.createDataChannel('sync_data');

	                    dataChannel.binaryType = 'arraybuffer';
	                    syncDataChannel.binaryType = 'arraybuffer';

	                    ywebrtc.dcs[peer_id] = dataChannel;
	                    ywebrtc.sdcs[peer_id] = syncDataChannel;

	                    ywebrtc.userJoined(peer_id, 'master');

	                    dataChannel.onmessage = receiveData(ywebrtc, peer_id);
	                    syncDataChannel.onmessage = function (e) {
	                        ywebrtc.receivebuffer(peer_id, e.data);
	                    };

	                    peer_connection.onicecandidate = function (event) {
	                        if (event.candidate) {
	                            signaling_socket.emit('relayICECandidate', {
	                                'peer_id': peer_id,
	                                'ice_candidate': {
	                                    'sdpMLineIndex': event.candidate.sdpMLineIndex,
	                                    'candidate': event.candidate.candidate
	                                }
	                            });
	                        }
	                    };

	                    if (config.should_create_offer) {
	                        peer_connection.createOffer(function (local_description) {
	                            peer_connection.setLocalDescription(local_description, function () {
	                                signaling_socket.emit('relaySessionDescription', { 'peer_id': peer_id, 'session_description': local_description });
	                            }, function () {
	                                Alert("Offer setLocalDescription failed!");
	                            });
	                        }, function (error) {
	                            console.log("Error sending offer: ", error);
	                        });
	                    }
	                });

	                /** 
	                 * Peers exchange session descriptions which contains information
	                 * about their audio / video settings and that sort of stuff. First
	                 * the 'offerer' sends a description to the 'answerer' (with type
	                 * "offer"), then the answerer sends one back (with type "answer").  
	                 */
	                signaling_socket.on('sessionDescription', function (config) {
	                    var peer_id = config.peer_id;
	                    var peer = peers[peer_id];

	                    peer.ondatachannel = function (event) {
	                        var dataChannel = event.channel;
	                        dataChannel.binaryType = 'arraybuffer';
	                        if (dataChannel.label == 'sync_data') {
	                            dataChannel.onmessage = receiveData(ywebrtc, peer_id);
	                        } else {
	                            dataChannel.onmessage = function (e) {
	                                ywebrtc.receivebuffer(peer_id, e.data);
	                            };
	                        }
	                    };

	                    var remote_description = config.session_description;

	                    var desc = new RTCSessionDescription(remote_description);
	                    var stuff = peer.setRemoteDescription(desc, function () {
	                        if (remote_description.type == "offer") {
	                            peer.createAnswer(function (local_description) {
	                                peer.setLocalDescription(local_description, function () {
	                                    signaling_socket.emit('relaySessionDescription', { 'peer_id': peer_id, 'session_description': local_description });
	                                }, function () {
	                                    Alert("Answer setLocalDescription failed!");
	                                });
	                            }, function (error) {
	                                console.log("Error creating answer: ", error);
	                            });
	                        }
	                    }, function (error) {
	                        console.log("setRemoteDescription error: ", error);
	                    });
	                });

	                signaling_socket.on('iceCandidate', function (config) {
	                    var peer = peers[config.peer_id];
	                    var ice_candidate = config.ice_candidate;
	                    peer.addIceCandidate(new RTCIceCandidate(ice_candidate));
	                });

	                signaling_socket.on('removePeer', function (config) {
	                    var peer_id = config.peer_id;
	                    ywebrtc.userLeft(peer_id);
	                    if (peer_id in peer_media_elements) {
	                        peer_media_elements[peer_id].remove();
	                    }
	                    if (peer_id in peers) {
	                        peers[peer_id].close();
	                    }

	                    delete peers[peer_id];
	                    delete peer_media_elements[config.peer_id];
	                });
	            }
	            init(self);
	            /************************ end minimal_webrtc ****************************/
	            return _this;
	        }

	        createClass(Connector, [{
	            key: 'disconnect',
	            value: function disconnect() {}
	        }, {
	            key: 'destroy',
	            value: function destroy() {}
	        }, {
	            key: 'reconnect',
	            value: function reconnect() {}
	        }, {
	            key: 'send',
	            value: function send(uid, message) {
	                console.log('$$$$$$$$$$$$$$$$ syncing...... $$$$$$$$$$$$$$$$$');
	                function send2(dataChannel, data2) {
	                    if (dataChannel.readyState === 'open') {
	                        var CHUNK_LEN = 64000;
	                        var len = data2.byteLength;
	                        var n = len / CHUNK_LEN | 0;
	                        dataChannel.send(len);
	                        // split the photo and send in chunks of about 64KB
	                        for (var i = 0; i < n; i++) {
	                            var start = i * CHUNK_LEN,
	                                end = (i + 1) * CHUNK_LEN;
	                            dataChannel.send(data2.subarray(start, end));
	                        }
	                        // send the reminder, if any
	                        if (len % CHUNK_LEN) {
	                            dataChannel.send(data2.subarray(n * CHUNK_LEN));
	                        }
	                    } else {
	                        setTimeout(send2, 500, dataChannel, data2);
	                    }
	                }
	                send2(this.sdcs[uid], new Uint8Array(message));
	            }
	        }, {
	            key: 'broadcast',
	            value: function broadcast(message) {
	                for (var peer_id in this.dcs) {
	                    var send2 = function send2(dataChannel, data2) {
	                        if (dataChannel.readyState === 'open') {
	                            var CHUNK_LEN = 64000;
	                            var len = data2.byteLength;
	                            var n = len / CHUNK_LEN | 0;
	                            dataChannel.send(len);
	                            // split the photo and send in chunks of about 64KB
	                            for (var i = 0; i < n; i++) {
	                                var start = i * CHUNK_LEN,
	                                    end = (i + 1) * CHUNK_LEN;
	                                dataChannel.send(data2.subarray(start, end));
	                            }
	                            // send the reminder, if any
	                            if (len % CHUNK_LEN) {
	                                dataChannel.send(data2.subarray(n * CHUNK_LEN));
	                            }
	                        } else {
	                            console.log('Errrrrrrrrrrrrrrrrrrrrrrrrrrrrrr', peer_id);
	                        }
	                    };

	                    send2(this.dcs[peer_id], new Uint8Array(message));
	                }
	            }
	        }, {
	            key: 'isDisconnected',
	            value: function isDisconnected() {
	                return this.socket.disconnected;
	            }
	        }]);
	        return Connector;
	    }(Y.AbstractConnector);

	    Connector.io = lib$2;
	    Y['webrtc'] = Connector;
	}

	if (typeof Y !== 'undefined') {
	    extend(Y); // eslint-disable-line
	}

	return extend;

})));


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":4,"buffer":2}],6:[function(require,module,exports){
(function (process,Buffer){

/**
 * yjs - A framework for real-time p2p shared editing on any data
 * @version v13.0.0-62
 * @license MIT
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Y = factory());
}(this, (function () { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  function rotate(tree, parent, newParent, n) {
    if (parent === null) {
      tree.root = newParent;
      newParent._parent = null;
    } else if (parent.left === n) {
      parent.left = newParent;
    } else if (parent.right === n) {
      parent.right = newParent;
    } else {
      throw new Error('The elements are wrongly connected!');
    }
  }

  var N = function () {
    // A created node is always red!
    function N(val) {
      classCallCheck(this, N);

      this.val = val;
      this.color = true;
      this._left = null;
      this._right = null;
      this._parent = null;
    }

    createClass(N, [{
      key: 'isRed',
      value: function isRed() {
        return this.color;
      }
    }, {
      key: 'isBlack',
      value: function isBlack() {
        return !this.color;
      }
    }, {
      key: 'redden',
      value: function redden() {
        this.color = true;return this;
      }
    }, {
      key: 'blacken',
      value: function blacken() {
        this.color = false;return this;
      }
    }, {
      key: 'rotateLeft',
      value: function rotateLeft(tree) {
        var parent = this.parent;
        var newParent = this.right;
        var newRight = this.right.left;
        newParent.left = this;
        this.right = newRight;
        rotate(tree, parent, newParent, this);
      }
    }, {
      key: 'next',
      value: function next() {
        if (this.right !== null) {
          // search the most left node in the right tree
          var o = this.right;
          while (o.left !== null) {
            o = o.left;
          }
          return o;
        } else {
          var p = this;
          while (p.parent !== null && p !== p.parent.left) {
            p = p.parent;
          }
          return p.parent;
        }
      }
    }, {
      key: 'prev',
      value: function prev() {
        if (this.left !== null) {
          // search the most right node in the left tree
          var o = this.left;
          while (o.right !== null) {
            o = o.right;
          }
          return o;
        } else {
          var p = this;
          while (p.parent !== null && p !== p.parent.right) {
            p = p.parent;
          }
          return p.parent;
        }
      }
    }, {
      key: 'rotateRight',
      value: function rotateRight(tree) {
        var parent = this.parent;
        var newParent = this.left;
        var newLeft = this.left.right;
        newParent.right = this;
        this.left = newLeft;
        rotate(tree, parent, newParent, this);
      }
    }, {
      key: 'getUncle',
      value: function getUncle() {
        // we can assume that grandparent exists when this is called!
        if (this.parent === this.parent.parent.left) {
          return this.parent.parent.right;
        } else {
          return this.parent.parent.left;
        }
      }
    }, {
      key: 'grandparent',
      get: function get$$1() {
        return this.parent.parent;
      }
    }, {
      key: 'parent',
      get: function get$$1() {
        return this._parent;
      }
    }, {
      key: 'sibling',
      get: function get$$1() {
        return this === this.parent.left ? this.parent.right : this.parent.left;
      }
    }, {
      key: 'left',
      get: function get$$1() {
        return this._left;
      },
      set: function set$$1(n) {
        if (n !== null) {
          n._parent = this;
        }
        this._left = n;
      }
    }, {
      key: 'right',
      get: function get$$1() {
        return this._right;
      },
      set: function set$$1(n) {
        if (n !== null) {
          n._parent = this;
        }
        this._right = n;
      }
    }]);
    return N;
  }();

  /*
   * This is a Red Black Tree implementation
   */


  var Tree = function () {
    function Tree() {
      classCallCheck(this, Tree);

      this.root = null;
      this.length = 0;
    }

    createClass(Tree, [{
      key: 'findNext',
      value: function findNext(id) {
        var nextID = id.clone();
        nextID.clock += 1;
        return this.findWithLowerBound(nextID);
      }
    }, {
      key: 'findPrev',
      value: function findPrev(id) {
        var prevID = id.clone();
        prevID.clock -= 1;
        return this.findWithUpperBound(prevID);
      }
    }, {
      key: 'findNodeWithLowerBound',
      value: function findNodeWithLowerBound(from) {
        var o = this.root;
        if (o === null) {
          return null;
        } else {
          while (true) {
            if (from === null || from.lessThan(o.val._id) && o.left !== null) {
              // o is included in the bound
              // try to find an element that is closer to the bound
              o = o.left;
            } else if (from !== null && o.val._id.lessThan(from)) {
              // o is not within the bound, maybe one of the right elements is..
              if (o.right !== null) {
                o = o.right;
              } else {
                // there is no right element. Search for the next bigger element,
                // this should be within the bounds
                return o.next();
              }
            } else {
              return o;
            }
          }
        }
      }
    }, {
      key: 'findNodeWithUpperBound',
      value: function findNodeWithUpperBound(to) {
        if (to === void 0) {
          throw new Error('You must define from!');
        }
        var o = this.root;
        if (o === null) {
          return null;
        } else {
          while (true) {
            if ((to === null || o.val._id.lessThan(to)) && o.right !== null) {
              // o is included in the bound
              // try to find an element that is closer to the bound
              o = o.right;
            } else if (to !== null && to.lessThan(o.val._id)) {
              // o is not within the bound, maybe one of the left elements is..
              if (o.left !== null) {
                o = o.left;
              } else {
                // there is no left element. Search for the prev smaller element,
                // this should be within the bounds
                return o.prev();
              }
            } else {
              return o;
            }
          }
        }
      }
    }, {
      key: 'findSmallestNode',
      value: function findSmallestNode() {
        var o = this.root;
        while (o != null && o.left != null) {
          o = o.left;
        }
        return o;
      }
    }, {
      key: 'findWithLowerBound',
      value: function findWithLowerBound(from) {
        var n = this.findNodeWithLowerBound(from);
        return n == null ? null : n.val;
      }
    }, {
      key: 'findWithUpperBound',
      value: function findWithUpperBound(to) {
        var n = this.findNodeWithUpperBound(to);
        return n == null ? null : n.val;
      }
    }, {
      key: 'iterate',
      value: function iterate(from, to, f) {
        var o;
        if (from === null) {
          o = this.findSmallestNode();
        } else {
          o = this.findNodeWithLowerBound(from);
        }
        while (o !== null && (to === null || // eslint-disable-line no-unmodified-loop-condition
        o.val._id.lessThan(to) || o.val._id.equals(to))) {
          f(o.val);
          o = o.next();
        }
      }
    }, {
      key: 'find',
      value: function find(id) {
        var n = this.findNode(id);
        if (n !== null) {
          return n.val;
        } else {
          return null;
        }
      }
    }, {
      key: 'findNode',
      value: function findNode(id) {
        var o = this.root;
        if (o === null) {
          return null;
        } else {
          while (true) {
            if (o === null) {
              return null;
            }
            if (id.lessThan(o.val._id)) {
              o = o.left;
            } else if (o.val._id.lessThan(id)) {
              o = o.right;
            } else {
              return o;
            }
          }
        }
      }
    }, {
      key: 'delete',
      value: function _delete(id) {
        var d = this.findNode(id);
        if (d == null) {
          // throw new Error('Element does not exist!')
          return;
        }
        this.length--;
        if (d.left !== null && d.right !== null) {
          // switch d with the greates element in the left subtree.
          // o should have at most one child.
          var o = d.left;
          // find
          while (o.right !== null) {
            o = o.right;
          }
          // switch
          d.val = o.val;
          d = o;
        }
        // d has at most one child
        // let n be the node that replaces d
        var isFakeChild;
        var child = d.left || d.right;
        if (child === null) {
          isFakeChild = true;
          child = new N(null);
          child.blacken();
          d.right = child;
        } else {
          isFakeChild = false;
        }

        if (d.parent === null) {
          if (!isFakeChild) {
            this.root = child;
            child.blacken();
            child._parent = null;
          } else {
            this.root = null;
          }
          return;
        } else if (d.parent.left === d) {
          d.parent.left = child;
        } else if (d.parent.right === d) {
          d.parent.right = child;
        } else {
          throw new Error('Impossible!');
        }
        if (d.isBlack()) {
          if (child.isRed()) {
            child.blacken();
          } else {
            this._fixDelete(child);
          }
        }
        this.root.blacken();
        if (isFakeChild) {
          if (child.parent.left === child) {
            child.parent.left = null;
          } else if (child.parent.right === child) {
            child.parent.right = null;
          } else {
            throw new Error('Impossible #3');
          }
        }
      }
    }, {
      key: '_fixDelete',
      value: function _fixDelete(n) {
        function isBlack(node) {
          return node !== null ? node.isBlack() : true;
        }
        function isRed(node) {
          return node !== null ? node.isRed() : false;
        }
        if (n.parent === null) {
          // this can only be called after the first iteration of fixDelete.
          return;
        }
        // d was already replaced by the child
        // d is not the root
        // d and child are black
        var sibling = n.sibling;
        if (isRed(sibling)) {
          // make sibling the grandfather
          n.parent.redden();
          sibling.blacken();
          if (n === n.parent.left) {
            n.parent.rotateLeft(this);
          } else if (n === n.parent.right) {
            n.parent.rotateRight(this);
          } else {
            throw new Error('Impossible #2');
          }
          sibling = n.sibling;
        }
        // parent, sibling, and children of n are black
        if (n.parent.isBlack() && sibling.isBlack() && isBlack(sibling.left) && isBlack(sibling.right)) {
          sibling.redden();
          this._fixDelete(n.parent);
        } else if (n.parent.isRed() && sibling.isBlack() && isBlack(sibling.left) && isBlack(sibling.right)) {
          sibling.redden();
          n.parent.blacken();
        } else {
          if (n === n.parent.left && sibling.isBlack() && isRed(sibling.left) && isBlack(sibling.right)) {
            sibling.redden();
            sibling.left.blacken();
            sibling.rotateRight(this);
            sibling = n.sibling;
          } else if (n === n.parent.right && sibling.isBlack() && isRed(sibling.right) && isBlack(sibling.left)) {
            sibling.redden();
            sibling.right.blacken();
            sibling.rotateLeft(this);
            sibling = n.sibling;
          }
          sibling.color = n.parent.color;
          n.parent.blacken();
          if (n === n.parent.left) {
            sibling.right.blacken();
            n.parent.rotateLeft(this);
          } else {
            sibling.left.blacken();
            n.parent.rotateRight(this);
          }
        }
      }
    }, {
      key: 'put',
      value: function put(v) {
        var node = new N(v);
        if (this.root !== null) {
          var p = this.root; // p abbrev. parent
          while (true) {
            if (node.val._id.lessThan(p.val._id)) {
              if (p.left === null) {
                p.left = node;
                break;
              } else {
                p = p.left;
              }
            } else if (p.val._id.lessThan(node.val._id)) {
              if (p.right === null) {
                p.right = node;
                break;
              } else {
                p = p.right;
              }
            } else {
              p.val = node.val;
              return p;
            }
          }
          this._fixInsert(node);
        } else {
          this.root = node;
        }
        this.length++;
        this.root.blacken();
        return node;
      }
    }, {
      key: '_fixInsert',
      value: function _fixInsert(n) {
        if (n.parent === null) {
          n.blacken();
          return;
        } else if (n.parent.isBlack()) {
          return;
        }
        var uncle = n.getUncle();
        if (uncle !== null && uncle.isRed()) {
          // Note: parent: red, uncle: red
          n.parent.blacken();
          uncle.blacken();
          n.grandparent.redden();
          this._fixInsert(n.grandparent);
        } else {
          // Note: parent: red, uncle: black or null
          // Now we transform the tree in such a way that
          // either of these holds:
          //   1) grandparent.left.isRed
          //     and grandparent.left.left.isRed
          //   2) grandparent.right.isRed
          //     and grandparent.right.right.isRed
          if (n === n.parent.right && n.parent === n.grandparent.left) {
            n.parent.rotateLeft(this);
            // Since we rotated and want to use the previous
            // cases, we need to set n in such a way that
            // n.parent.isRed again
            n = n.left;
          } else if (n === n.parent.left && n.parent === n.grandparent.right) {
            n.parent.rotateRight(this);
            // see above
            n = n.right;
          }
          // Case 1) or 2) hold from here on.
          // Now traverse grandparent, make parent a black node
          // on the highest level which holds two red nodes.
          n.parent.blacken();
          n.grandparent.redden();
          if (n === n.parent.left) {
            // Case 1
            n.grandparent.rotateRight(this);
          } else {
            // Case 2
            n.grandparent.rotateLeft(this);
          }
        }
      }
    }]);
    return Tree;
  }();

  var ID = function () {
    function ID(user, clock) {
      classCallCheck(this, ID);

      this.user = user; // TODO: rename to client
      this.clock = clock;
    }

    createClass(ID, [{
      key: "clone",
      value: function clone() {
        return new ID(this.user, this.clock);
      }
    }, {
      key: "equals",
      value: function equals(id) {
        return id !== null && id.user === this.user && id.clock === this.clock;
      }
    }, {
      key: "lessThan",
      value: function lessThan(id) {
        if (id.constructor === ID) {
          return this.user < id.user || this.user === id.user && this.clock < id.clock;
        } else {
          return false;
        }
      }
    }]);
    return ID;
  }();

  var DSNode = function () {
    function DSNode(id, len, gc) {
      classCallCheck(this, DSNode);

      this._id = id;
      this.len = len;
      this.gc = gc;
    }

    createClass(DSNode, [{
      key: 'clone',
      value: function clone() {
        return new DSNode(this._id, this.len, this.gc);
      }
    }]);
    return DSNode;
  }();

  var DeleteStore = function (_Tree) {
    inherits(DeleteStore, _Tree);

    function DeleteStore() {
      classCallCheck(this, DeleteStore);
      return possibleConstructorReturn(this, (DeleteStore.__proto__ || Object.getPrototypeOf(DeleteStore)).apply(this, arguments));
    }

    createClass(DeleteStore, [{
      key: 'logTable',
      value: function logTable() {
        var deletes = [];
        this.iterate(null, null, function (n) {
          deletes.push({
            user: n._id.user,
            clock: n._id.clock,
            len: n.len,
            gc: n.gc
          });
        });
        console.table(deletes);
      }
    }, {
      key: 'isDeleted',
      value: function isDeleted(id) {
        var n = this.findWithUpperBound(id);
        return n !== null && n._id.user === id.user && id.clock < n._id.clock + n.len;
      }
    }, {
      key: 'mark',
      value: function mark(id, length, gc) {
        if (length === 0) return;
        // Step 1. Unmark range
        var leftD = this.findWithUpperBound(new ID(id.user, id.clock - 1));
        // Resize left DSNode if necessary
        if (leftD !== null && leftD._id.user === id.user) {
          if (leftD._id.clock < id.clock && id.clock < leftD._id.clock + leftD.len) {
            // node is overlapping. need to resize
            if (id.clock + length < leftD._id.clock + leftD.len) {
              // overlaps new mark range and some more
              // create another DSNode to the right of new mark
              this.put(new DSNode(new ID(id.user, id.clock + length), leftD._id.clock + leftD.len - id.clock - length, leftD.gc));
            }
            // resize left DSNode
            leftD.len = id.clock - leftD._id.clock;
          } // Otherwise there is no overlapping
        }
        // Resize right DSNode if necessary
        var upper = new ID(id.user, id.clock + length - 1);
        var rightD = this.findWithUpperBound(upper);
        if (rightD !== null && rightD._id.user === id.user) {
          if (rightD._id.clock < id.clock + length && id.clock <= rightD._id.clock && id.clock + length < rightD._id.clock + rightD.len) {
            // we only consider the case where we resize the node
            var d = id.clock + length - rightD._id.clock;
            rightD._id = new ID(rightD._id.user, rightD._id.clock + d);
            rightD.len -= d;
          }
        }
        // Now we only have to delete all inner marks
        var deleteNodeIds = [];
        this.iterate(id, upper, function (m) {
          deleteNodeIds.push(m._id);
        });
        for (var i = deleteNodeIds.length - 1; i >= 0; i--) {
          this.delete(deleteNodeIds[i]);
        }
        var newMark = new DSNode(id, length, gc);
        // Step 2. Check if we can extend left or right
        if (leftD !== null && leftD._id.user === id.user && leftD._id.clock + leftD.len === id.clock && leftD.gc === gc) {
          // We can extend left
          leftD.len += length;
          newMark = leftD;
        }
        var rightNext = this.find(new ID(id.user, id.clock + length));
        if (rightNext !== null && rightNext._id.user === id.user && id.clock + length === rightNext._id.clock && gc === rightNext.gc) {
          // We can merge newMark and rightNext
          newMark.len += rightNext.len;
          this.delete(rightNext._id);
        }
        if (leftD !== newMark) {
          // only put if we didn't extend left
          this.put(newMark);
        }
      }
      // TODO: exchange markDeleted for mark()

    }, {
      key: 'markDeleted',
      value: function markDeleted(id, length) {
        this.mark(id, length, false);
      }
    }]);
    return DeleteStore;
  }(Tree);

  /**
   * A BinaryDecoder handles the decoding of an ArrayBuffer.
   */

  var BinaryDecoder = function () {
    /**
     * @param {Uint8Array|Buffer} buffer The binary data that this instance
     *                                   decodes.
     */
    function BinaryDecoder(buffer) {
      classCallCheck(this, BinaryDecoder);

      if (buffer instanceof ArrayBuffer) {
        this.uint8arr = new Uint8Array(buffer);
      } else if (buffer instanceof Uint8Array || typeof Buffer !== 'undefined' && buffer instanceof Buffer) {
        this.uint8arr = buffer;
      } else {
        throw new Error('Expected an ArrayBuffer or Uint8Array!');
      }
      this.pos = 0;
    }

    /**
     * Clone this decoder instance.
     * Optionally set a new position parameter.
     */


    createClass(BinaryDecoder, [{
      key: 'clone',
      value: function clone() {
        var newPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pos;

        var decoder = new BinaryDecoder(this.uint8arr);
        decoder.pos = newPos;
        return decoder;
      }

      /**
       * Number of bytes.
       */

    }, {
      key: 'skip8',


      /**
       * Skip one byte, jump to the next position.
       */
      value: function skip8() {
        this.pos++;
      }

      /**
       * Read one byte as unsigned integer.
       */

    }, {
      key: 'readUint8',
      value: function readUint8() {
        return this.uint8arr[this.pos++];
      }

      /**
       * Read 4 bytes as unsigned integer.
       *
       * @return {number} An unsigned integer.
       */

    }, {
      key: 'readUint32',
      value: function readUint32() {
        var uint = this.uint8arr[this.pos] + (this.uint8arr[this.pos + 1] << 8) + (this.uint8arr[this.pos + 2] << 16) + (this.uint8arr[this.pos + 3] << 24);
        this.pos += 4;
        return uint;
      }

      /**
       * Look ahead without incrementing position.
       * to the next byte and read it as unsigned integer.
       *
       * @return {number} An unsigned integer.
       */

    }, {
      key: 'peekUint8',
      value: function peekUint8() {
        return this.uint8arr[this.pos];
      }

      /**
       * Read unsigned integer (32bit) with variable length.
       * 1/8th of the storage is used as encoding overhead.
       *  * numbers < 2^7 is stored in one byte.
       *  * numbers < 2^14 is stored in two bytes.
       *
       * @return {number} An unsigned integer.
       */

    }, {
      key: 'readVarUint',
      value: function readVarUint() {
        var num = 0;
        var len = 0;
        while (true) {
          var r = this.uint8arr[this.pos++];
          num = num | (r & 127) << len;
          len += 7;
          if (r < 1 << 7) {
            return num >>> 0; // return unsigned number!
          }
          if (len > 35) {
            throw new Error('Integer out of range!');
          }
        }
      }

      /**
       * Read string of variable length
       * * varUint is used to store the length of the string
       *
       * @return {String} The read String.
       */

    }, {
      key: 'readVarString',
      value: function readVarString() {
        var len = this.readVarUint();
        var bytes = new Array(len);
        for (var i = 0; i < len; i++) {
          bytes[i] = this.uint8arr[this.pos++];
        }
        var encodedString = bytes.map(function (b) {
          return String.fromCodePoint(b);
        }).join('');
        return decodeURIComponent(escape(encodedString));
      }

      /**
       * Look ahead and read varString without incrementing position
       */

    }, {
      key: 'peekVarString',
      value: function peekVarString() {
        var pos = this.pos;
        var s = this.readVarString();
        this.pos = pos;
        return s;
      }

      /**
       * Read ID.
       * * If first varUint read is 0xFFFFFF a RootID is returned.
       * * Otherwise an ID is returned.
       *
       * @return ID
       */

    }, {
      key: 'readID',
      value: function readID() {
        var user = this.readVarUint();
        if (user === RootFakeUserID) {
          // read property name and type id
          var rid = new RootID(this.readVarString(), null);
          rid.type = this.readVarUint();
          return rid;
        }
        return new ID(user, this.readVarUint());
      }
    }, {
      key: 'length',
      get: function get$$1() {
        return this.uint8arr.length;
      }
    }]);
    return BinaryDecoder;
  }();

  // TODO should have the same base class as Item

  var GC = function () {
    function GC() {
      classCallCheck(this, GC);

      this._id = null;
      this._length = 0;
    }

    createClass(GC, [{
      key: '_integrate',
      value: function _integrate(y) {
        var id = this._id;
        var userState = y.ss.getState(id.user);
        if (id.clock === userState) {
          y.ss.setState(id.user, id.clock + this._length);
        }
        y.ds.mark(this._id, this._length, true);
        var n = y.os.put(this);
        var prev = n.prev().val;
        if (prev !== null && prev.constructor === GC && prev._id.user === n.val._id.user && prev._id.clock + prev._length === n.val._id.clock) {
          // TODO: do merging for all items!
          prev._length += n.val._length;
          y.os.delete(n.val._id);
          n = prev;
        }
        if (n.val) {
          n = n.val;
        }
        var next = y.os.findNext(n._id);
        if (next !== null && next.constructor === GC && next._id.user === n._id.user && next._id.clock === n._id.clock + n._length) {
          n._length += next._length;
          y.os.delete(next._id);
        }
        if (id.user !== RootFakeUserID) {
          if (y.connector !== null && (y.connector._forwardAppliedStructs || id.user === y.userID)) {
            y.connector.broadcastStruct(this);
          }
          if (y.persistence !== null) {
            y.persistence.saveStruct(y, this);
          }
        }
      }

      /**
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       *
       * @param {BinaryEncoder} encoder The encoder to write data to.
       * @private
       */

    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        encoder.writeUint8(getStructReference(this.constructor));
        encoder.writeID(this._id);
        encoder.writeVarUint(this._length);
      }

      /**
       * Read the next Item in a Decoder and fill this Item with the read data.
       *
       * This is called when data is received from a remote peer.
       *
       * @param {Y} y The Yjs instance that this Item belongs to.
       * @param {BinaryDecoder} decoder The decoder object to read data from.
       * @private
       */

    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var id = decoder.readID();
        this._id = id;
        this._length = decoder.readVarUint();
        var missing = [];
        if (y.ss.getState(id.user) < id.clock) {
          missing.push(new ID(id.user, id.clock - 1));
        }
        return missing;
      }
    }, {
      key: '_splitAt',
      value: function _splitAt() {
        return this;
      }
    }, {
      key: '_clonePartial',
      value: function _clonePartial(diff) {
        var gc = new GC();
        gc._id = new ID(this._id.user, this._id.clock + diff);
        gc._length = this._length - diff;
        return gc;
      }
    }, {
      key: '_deleted',
      get: function get$$1() {
        return true;
      }
    }]);
    return GC;
  }();

  var MissingEntry = function MissingEntry(decoder, missing, struct) {
    classCallCheck(this, MissingEntry);

    this.decoder = decoder;
    this.missing = missing.length;
    this.struct = struct;
  };

  /**
   * @private
   * Integrate remote struct
   * When a remote struct is integrated, other structs might be ready to ready to
   * integrate.
   */


  function _integrateRemoteStructHelper(y, struct) {
    var id = struct._id;
    if (id === undefined) {
      struct._integrate(y);
    } else {
      if (y.ss.getState(id.user) > id.clock) {
        return;
      }
      if (!y.gcEnabled || struct.constructor === GC || struct._parent.constructor !== GC && struct._parent._deleted === false) {
        // Is either a GC or Item with an undeleted parent
        // save to integrate
        struct._integrate(y);
      } else {
        // Is an Item. parent was deleted.
        struct._gc(y);
      }
      var msu = y._missingStructs.get(id.user);
      if (msu != null) {
        var clock = id.clock;
        var finalClock = clock + struct._length;
        for (; clock < finalClock; clock++) {
          var missingStructs = msu.get(clock);
          if (missingStructs !== undefined) {
            missingStructs.forEach(function (missingDef) {
              missingDef.missing--;
              if (missingDef.missing === 0) {
                var decoder = missingDef.decoder;
                var oldPos = decoder.pos;
                var missing = missingDef.struct._fromBinary(y, decoder);
                decoder.pos = oldPos;
                if (missing.length === 0) {
                  y._readyToIntegrate.push(missingDef.struct);
                }
              }
            });
            msu.delete(clock);
          }
        }
      }
    }
  }

  function stringifyStructs(y, decoder, strBuilder) {
    var len = decoder.readUint32();
    for (var i = 0; i < len; i++) {
      var reference = decoder.readVarUint();
      var Constr = getStruct(reference);
      var struct = new Constr();
      var missing = struct._fromBinary(y, decoder);
      var logMessage = '  ' + struct._logString();
      if (missing.length > 0) {
        logMessage += ' .. missing: ' + missing.map(logID).join(', ');
      }
      strBuilder.push(logMessage);
    }
  }

  function integrateRemoteStructs(y, decoder) {
    var len = decoder.readUint32();
    for (var i = 0; i < len; i++) {
      var reference = decoder.readVarUint();
      var Constr = getStruct(reference);
      var struct = new Constr();
      var decoderPos = decoder.pos;
      var missing = struct._fromBinary(y, decoder);
      if (missing.length === 0) {
        while (struct != null) {
          _integrateRemoteStructHelper(y, struct);
          struct = y._readyToIntegrate.shift();
        }
      } else {
        var _decoder = new BinaryDecoder(decoder.uint8arr);
        _decoder.pos = decoderPos;
        var missingEntry = new MissingEntry(_decoder, missing, struct);
        var missingStructs = y._missingStructs;
        for (var _i = missing.length - 1; _i >= 0; _i--) {
          var m = missing[_i];
          if (!missingStructs.has(m.user)) {
            missingStructs.set(m.user, new Map());
          }
          var msu = missingStructs.get(m.user);
          if (!msu.has(m.clock)) {
            msu.set(m.clock, []);
          }
          var mArray = msu = msu.get(m.clock);
          mArray.push(missingEntry);
        }
      }
    }
  }

  var bits7 = 127;
  var bits8 = 255;

  /**
   * A BinaryEncoder handles the encoding to an ArrayBuffer.
   */

  var BinaryEncoder = function () {
    function BinaryEncoder() {
      classCallCheck(this, BinaryEncoder);

      // TODO: implement chained Uint8Array buffers instead of Array buffer
      // TODO: Rewrite all methods as functions!
      this.data = [];
    }

    /**
     * The current length of the encoded data.
     */


    createClass(BinaryEncoder, [{
      key: 'createBuffer',


      /**
       * Create an ArrayBuffer.
       *
       * @return {Uint8Array} A Uint8Array that represents the written data.
       */
      value: function createBuffer() {
        return Uint8Array.from(this.data).buffer;
      }

      /**
       * Write one byte as an unsigned integer.
       *
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'writeUint8',
      value: function writeUint8(num) {
        this.data.push(num & bits8);
      }

      /**
       * Write one byte as an unsigned Integer at a specific location.
       *
       * @param {number} pos The location where the data will be written.
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'setUint8',
      value: function setUint8(pos, num) {
        this.data[pos] = num & bits8;
      }

      /**
       * Write two bytes as an unsigned integer.
       *
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'writeUint16',
      value: function writeUint16(num) {
        this.data.push(num & bits8, num >>> 8 & bits8);
      }
      /**
       * Write two bytes as an unsigned integer at a specific location.
       *
       * @param {number} pos The location where the data will be written.
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'setUint16',
      value: function setUint16(pos, num) {
        this.data[pos] = num & bits8;
        this.data[pos + 1] = num >>> 8 & bits8;
      }

      /**
       * Write two bytes as an unsigned integer
       *
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'writeUint32',
      value: function writeUint32(num) {
        for (var i = 0; i < 4; i++) {
          this.data.push(num & bits8);
          num >>>= 8;
        }
      }

      /**
       * Write two bytes as an unsigned integer at a specific location.
       *
       * @param {number} pos The location where the data will be written.
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'setUint32',
      value: function setUint32(pos, num) {
        for (var i = 0; i < 4; i++) {
          this.data[pos + i] = num & bits8;
          num >>>= 8;
        }
      }

      /**
       * Write a variable length unsigned integer.
       *
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'writeVarUint',
      value: function writeVarUint(num) {
        while (num >= 128) {
          this.data.push(128 | bits7 & num);
          num >>>= 7;
        }
        this.data.push(bits7 & num);
      }

      /**
       * Write a variable length string.
       *
       * @param {String} str The string that is to be encoded.
       */

    }, {
      key: 'writeVarString',
      value: function writeVarString(str) {
        var encodedString = unescape(encodeURIComponent(str));
        var bytes = encodedString.split('').map(function (c) {
          return c.codePointAt();
        });
        var len = bytes.length;
        this.writeVarUint(len);
        for (var i = 0; i < len; i++) {
          this.data.push(bytes[i]);
        }
      }

      /**
       * Write an ID at the current position.
       *
       * @param {ID} id The ID that is to be written.
       */

    }, {
      key: 'writeID',
      value: function writeID(id) {
        var user = id.user;
        this.writeVarUint(user);
        if (user !== RootFakeUserID) {
          this.writeVarUint(id.clock);
        } else {
          this.writeVarString(id.name);
          this.writeVarUint(id.type);
        }
      }
    }, {
      key: 'length',
      get: function get$$1() {
        return this.data.length;
      }

      /**
       * The current write pointer (the same as {@link length}).
       */

    }, {
      key: 'pos',
      get: function get$$1() {
        return this.data.length;
      }
    }]);
    return BinaryEncoder;
  }();

  function readStateSet(decoder) {
    var ss = new Map();
    var ssLength = decoder.readUint32();
    for (var i = 0; i < ssLength; i++) {
      var user = decoder.readVarUint();
      var clock = decoder.readVarUint();
      ss.set(user, clock);
    }
    return ss;
  }

  function writeStateSet(y, encoder) {
    var lenPosition = encoder.pos;
    var len = 0;
    encoder.writeUint32(0);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = y.ss.state[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = slicedToArray(_step.value, 2),
            user = _step$value[0],
            clock = _step$value[1];

        encoder.writeVarUint(user);
        encoder.writeVarUint(clock);
        len++;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    encoder.setUint32(lenPosition, len);
  }

  function writeDeleteSet(y, encoder) {
    var currentUser = null;
    var currentLength = void 0;
    var lastLenPos = void 0;

    var numberOfUsers = 0;
    var laterDSLenPus = encoder.pos;
    encoder.writeUint32(0);

    y.ds.iterate(null, null, function (n) {
      var user = n._id.user;
      var clock = n._id.clock;
      var len = n.len;
      var gc = n.gc;
      if (currentUser !== user) {
        numberOfUsers++;
        // a new user was found
        if (currentUser !== null) {
          // happens on first iteration
          encoder.setUint32(lastLenPos, currentLength);
        }
        currentUser = user;
        encoder.writeVarUint(user);
        // pseudo-fill pos
        lastLenPos = encoder.pos;
        encoder.writeUint32(0);
        currentLength = 0;
      }
      encoder.writeVarUint(clock);
      encoder.writeVarUint(len);
      encoder.writeUint8(gc ? 1 : 0);
      currentLength++;
    });
    if (currentUser !== null) {
      // happens on first iteration
      encoder.setUint32(lastLenPos, currentLength);
    }
    encoder.setUint32(laterDSLenPus, numberOfUsers);
  }

  function readDeleteSet(y, decoder) {
    var dsLength = decoder.readUint32();

    var _loop = function _loop(i) {
      var user = decoder.readVarUint();
      var dv = [];
      var dvLength = decoder.readUint32();
      for (var j = 0; j < dvLength; j++) {
        var from = decoder.readVarUint();
        var len = decoder.readVarUint();
        var gc = decoder.readUint8() === 1;
        dv.push([from, len, gc]);
      }
      if (dvLength > 0) {
        var pos = 0;
        var d = dv[pos];
        var deletions = [];
        y.ds.iterate(new ID(user, 0), new ID(user, Number.MAX_VALUE), function (n) {
          // cases:
          // 1. d deletes something to the right of n
          //  => go to next n (break)
          // 2. d deletes something to the left of n
          //  => create deletions
          //  => reset d accordingly
          //  *)=> if d doesn't delete anything anymore, go to next d (continue)
          // 3. not 2) and d deletes something that also n deletes
          //  => reset d so that it doesn't contain n's deletion
          //  *)=> if d does not delete anything anymore, go to next d (continue)
          while (d != null) {
            var diff = 0; // describe the diff of length in 1) and 2)
            if (n._id.clock + n.len <= d[0]) {
              // 1)
              break;
            } else if (d[0] < n._id.clock) {
              // 2)
              // delete maximum the len of d
              // else delete as much as possible
              diff = Math.min(n._id.clock - d[0], d[1]);
              // deleteItemRange(y, user, d[0], diff, true)
              deletions.push([user, d[0], diff]);
            } else {
              // 3)
              diff = n._id.clock + n.len - d[0]; // never null (see 1)
              if (d[2] && !n.gc) {
                // d marks as gc'd but n does not
                // then delete either way
                // deleteItemRange(y, user, d[0], Math.min(diff, d[1]), true)
                deletions.push([user, d[0], Math.min(diff, d[1])]);
              }
            }
            if (d[1] <= diff) {
              // d doesn't delete anything anymore
              d = dv[++pos];
            } else {
              d[0] = d[0] + diff; // reset pos
              d[1] = d[1] - diff; // reset length
            }
          }
        });
        // TODO: It would be more performant to apply the deletes in the above loop
        // Adapt the Tree implementation to support delete while iterating
        for (var _i = deletions.length - 1; _i >= 0; _i--) {
          var del = deletions[_i];
          deleteItemRange(y, del[0], del[1], del[2], true);
        }
        // for the rest.. just apply it
        for (; pos < dv.length; pos++) {
          d = dv[pos];
          deleteItemRange(y, user, d[0], d[1], true);
          // deletions.push([user, d[0], d[1], d[2]])
        }
      }
    };

    for (var i = 0; i < dsLength; i++) {
      _loop(i);
    }
  }

  function stringifySyncStep1(y, decoder, strBuilder) {
    var auth = decoder.readVarString();
    var protocolVersion = decoder.readVarUint();
    strBuilder.push('  - auth: "' + auth + '"');
    strBuilder.push('  - protocolVersion: ' + protocolVersion);
    // write SS
    var ssBuilder = [];
    var len = decoder.readUint32();
    for (var i = 0; i < len; i++) {
      var user = decoder.readVarUint();
      var clock = decoder.readVarUint();
      ssBuilder.push('(' + user + ':' + clock + ')');
    }
    strBuilder.push('  == SS: ' + ssBuilder.join(','));
  }

  function sendSyncStep1(connector, syncUser) {
    var encoder = new BinaryEncoder();
    encoder.writeVarString(connector.y.room);
    encoder.writeVarString('sync step 1');
    encoder.writeVarString(connector.authInfo || '');
    encoder.writeVarUint(connector.protocolVersion);
    writeStateSet(connector.y, encoder);
    connector.send(syncUser, encoder.createBuffer());
  }

  /**
   * @private
   * Write all Items that are not not included in ss to
   * the encoder object.
   */
  function writeStructs(y, encoder, ss) {
    var lenPos = encoder.pos;
    encoder.writeUint32(0);
    var len = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = y.ss.state.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var user = _step.value;

        var clock = ss.get(user) || 0;
        if (user !== RootFakeUserID) {
          var minBound = new ID(user, clock);
          var overlappingLeft = y.os.findPrev(minBound);
          var rightID = overlappingLeft === null ? null : overlappingLeft._id;
          if (rightID !== null && rightID.user === user && rightID.clock + overlappingLeft._length > clock) {
            var struct = overlappingLeft._clonePartial(clock - rightID.clock);
            struct._toBinary(encoder);
            len++;
          }
          y.os.iterate(minBound, new ID(user, Number.MAX_VALUE), function (struct) {
            struct._toBinary(encoder);
            len++;
          });
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    encoder.setUint32(lenPos, len);
  }

  function readSyncStep1(decoder, encoder, y, senderConn, sender) {
    var protocolVersion = decoder.readVarUint();
    // check protocol version
    if (protocolVersion !== y.connector.protocolVersion) {
      console.warn('You tried to sync with a Yjs instance that has a different protocol version\n      (You: ' + protocolVersion + ', Client: ' + protocolVersion + ').\n      ');
      y.destroy();
    }
    // write sync step 2
    encoder.writeVarString('sync step 2');
    encoder.writeVarString(y.connector.authInfo || '');
    var ss = readStateSet(decoder);
    writeStructs(y, encoder, ss);
    writeDeleteSet(y, encoder);
    y.connector.send(senderConn.uid, encoder.createBuffer());
    senderConn.receivedSyncStep2 = true;
    if (y.connector.role === 'slave') {
      sendSyncStep1(y.connector, sender);
    }
  }

  function stringifySyncStep2(y, decoder, strBuilder) {
    strBuilder.push('     - auth: ' + decoder.readVarString());
    strBuilder.push('  == OS:');
    stringifyStructs(y, decoder, strBuilder);
    // write DS to string
    strBuilder.push('  == DS:');
    var len = decoder.readUint32();
    for (var i = 0; i < len; i++) {
      var user = decoder.readVarUint();
      strBuilder.push('    User: ' + user + ': ');
      var len2 = decoder.readUint32();
      for (var j = 0; j < len2; j++) {
        var from = decoder.readVarUint();
        var to = decoder.readVarUint();
        var gc = decoder.readUint8() === 1;
        strBuilder.push('[' + from + ', ' + to + ', ' + gc + ']');
      }
    }
  }

  function readSyncStep2(decoder, encoder, y, senderConn, sender) {
    integrateRemoteStructs(y, decoder);
    readDeleteSet(y, decoder);
    y.connector._setSyncedWith(sender);
  }

  function messageToString(_ref) {
    var _ref2 = slicedToArray(_ref, 2),
        y = _ref2[0],
        buffer = _ref2[1];

    var decoder = new BinaryDecoder(buffer);
    decoder.readVarString(); // read roomname
    var type = decoder.readVarString();
    var strBuilder = [];
    strBuilder.push('\n === ' + type + ' ===');
    if (type === 'update') {
      stringifyStructs(y, decoder, strBuilder);
    } else if (type === 'sync step 1') {
      stringifySyncStep1(y, decoder, strBuilder);
    } else if (type === 'sync step 2') {
      stringifySyncStep2(y, decoder, strBuilder);
    } else {
      strBuilder.push('-- Unknown message type - probably an encoding issue!!!');
    }
    return strBuilder.join('\n');
  }

  function messageToRoomname(buffer) {
    var decoder = new BinaryDecoder(buffer);
    decoder.readVarString(); // roomname
    return decoder.readVarString(); // messageType
  }

  function logID(id) {
    if (id !== null && id._id != null) {
      id = id._id;
    }
    if (id === null) {
      return '()';
    } else if (id instanceof ID) {
      return '(' + id.user + ',' + id.clock + ')';
    } else if (id instanceof RootID) {
      return '(' + id.name + ',' + id.type + ')';
    } else if (id.constructor === Y) {
      return 'y';
    } else {
      throw new Error('This is not a valid ID!');
    }
  }

  /**
   * Helper utility to convert an item to a readable format.
   *
   * @param {String} name The name of the item class (YText, ItemString, ..).
   * @param {Item} item The item instance.
   * @param {String} [append] Additional information to append to the returned
   *                          string.
   * @return {String} A readable string that represents the item object.
   *
   * @private
   */
  function logItemHelper(name, item, append) {
    var left = item._left !== null ? item._left._lastId : null;
    var origin = item._origin !== null ? item._origin._lastId : null;
    return name + '(id:' + logID(item._id) + ',left:' + logID(left) + ',origin:' + logID(origin) + ',right:' + logID(item._right) + ',parent:' + logID(item._parent) + ',parentSub:' + item._parentSub + (append !== undefined ? ' - ' + append : '') + ')';
  }

  /**
   * @private
   * Delete all items in an ID-range
   * TODO: implement getItemCleanStartNode for better performance (only one lookup)
   */
  function deleteItemRange(y, user, clock, range, gcChildren) {
    var createDelete = y.connector !== null && y.connector._forwardAppliedStructs;
    var item = y.os.getItemCleanStart(new ID(user, clock));
    if (item !== null) {
      if (!item._deleted) {
        item._splitAt(y, range);
        item._delete(y, createDelete, true);
      }
      var itemLen = item._length;
      range -= itemLen;
      clock += itemLen;
      if (range > 0) {
        var node = y.os.findNode(new ID(user, clock));
        while (node !== null && node.val !== null && range > 0 && node.val._id.equals(new ID(user, clock))) {
          var nodeVal = node.val;
          if (!nodeVal._deleted) {
            nodeVal._splitAt(y, range);
            nodeVal._delete(y, createDelete, gcChildren);
          }
          var nodeLen = nodeVal._length;
          range -= nodeLen;
          clock += nodeLen;
          node = node.next();
        }
      }
    }
  }

  /**
   * @private
   * A Delete change is not a real Item, but it provides the same interface as an
   * Item. The only difference is that it will not be saved in the ItemStore
   * (OperationStore), but instead it is safed in the DeleteStore.
   */

  var Delete = function () {
    function Delete() {
      classCallCheck(this, Delete);

      this._target = null;
      this._length = null;
    }

    /**
     * @private
     * Read the next Item in a Decoder and fill this Item with the read data.
     *
     * This is called when data is received from a remote peer.
     *
     * @param {Y} y The Yjs instance that this Item belongs to.
     * @param {BinaryDecoder} decoder The decoder object to read data from.
     */


    createClass(Delete, [{
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        // TODO: set target, and add it to missing if not found
        // There is an edge case in p2p networks!
        var targetID = decoder.readID();
        this._targetID = targetID;
        this._length = decoder.readVarUint();
        if (y.os.getItem(targetID) === null) {
          return [targetID];
        } else {
          return [];
        }
      }

      /**
       * @private
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       *
       * @param {BinaryEncoder} encoder The encoder to write data to.
       */

    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        encoder.writeUint8(getStructReference(this.constructor));
        encoder.writeID(this._targetID);
        encoder.writeVarUint(this._length);
      }

      /**
       * @private
       * Integrates this Item into the shared structure.
       *
       * This method actually applies the change to the Yjs instance. In the case of
       * Delete it marks the delete target as deleted.
       *
       * * If created remotely (a remote user deleted something),
       *   this Delete is applied to all structs in id-range.
       * * If created lokally (e.g. when y-array deletes a range of elements),
       *   this struct is broadcasted only (it is already executed)
       */

    }, {
      key: '_integrate',
      value: function _integrate(y) {
        var locallyCreated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (!locallyCreated) {
          // from remote
          var id = this._targetID;
          deleteItemRange(y, id.user, id.clock, this._length, false);
        } else if (y.connector !== null) {
          // from local
          y.connector.broadcastStruct(this);
        }
        if (y.persistence !== null) {
          y.persistence.saveStruct(y, this);
        }
      }

      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return 'Delete - target: ' + logID(this._targetID) + ', len: ' + this._length;
      }
    }]);
    return Delete;
  }();

  /**
   * A transaction is created for every change on the Yjs model. It is possible
   * to bundle changes on the Yjs model in a single transaction to
   * minimize the number on messages sent and the number of observer calls.
   * If possible the user of this library should bundle as many changes as
   * possible. Here is an example to illustrate the advantages of bundling:
   *
   * @example
   * const map = y.define('map', YMap)
   * // Log content when change is triggered
   * map.observe(function () {
   *   console.log('change triggered')
   * })
   * // Each change on the map type triggers a log message:
   * map.set('a', 0) // => "change triggered"
   * map.set('b', 0) // => "change triggered"
   * // When put in a transaction, it will trigger the log after the transaction:
   * y.transact(function () {
   *   map.set('a', 1)
   *   map.set('b', 1)
   * }) // => "change triggered"
   *
   */
  var Transaction = function Transaction(y) {
    classCallCheck(this, Transaction);

    /**
     * @type {Y} The Yjs instance.
     */
    this.y = y;
    /**
     * All new types that are added during a transaction.
     * @type {Set<Item>}
     */
    this.newTypes = new Set();
    /**
     * All types that were directly modified (property added or child
     * inserted/deleted). New types are not included in this Set.
     * Maps from type to parentSubs (`item._parentSub = null` for YArray)
     * @type {Set<YType,String>}
     */
    this.changedTypes = new Map();
    // TODO: rename deletedTypes
    /**
     * Set of all deleted Types and Structs.
     * @type {Set<Item>}
     */
    this.deletedStructs = new Set();
    /**
     * Saves the old state set of the Yjs instance. If a state was modified,
     * the original value is saved here.
     * @type {Map<Number,Number>}
     */
    this.beforeState = new Map();
    /**
     * Stores the events for the types that observe also child elements.
     * It is mainly used by `observeDeep`.
     * @type {Map<YType,Array<YEvent>>}
     */
    this.changedParentTypes = new Map();
  };
  function transactionTypeChanged(y, type, sub) {
    if (type !== y && !type._deleted && !y._transaction.newTypes.has(type)) {
      var changedTypes = y._transaction.changedTypes;
      var subs = changedTypes.get(type);
      if (subs === undefined) {
        // create if it doesn't exist yet
        subs = new Set();
        changedTypes.set(type, subs);
      }
      subs.add(sub);
    }
  }

  /**
   * @private
   * Helper utility to split an Item (see {@link Item#_splitAt})
   * - copies all properties from a to b
   * - connects a to b
   * - assigns the correct _id
   * - saves b to os
   */
  function splitHelper(y, a, b, diff) {
    var aID = a._id;
    b._id = new ID(aID.user, aID.clock + diff);
    b._origin = a;
    b._left = a;
    b._right = a._right;
    if (b._right !== null) {
      b._right._left = b;
    }
    b._right_origin = a._right_origin;
    // do not set a._right_origin, as this will lead to problems when syncing
    a._right = b;
    b._parent = a._parent;
    b._parentSub = a._parentSub;
    b._deleted = a._deleted;
    // now search all relevant items to the right and update origin
    // if origin is not it foundOrigins, we don't have to search any longer
    var foundOrigins = new Set();
    foundOrigins.add(a);
    var o = b._right;
    while (o !== null && foundOrigins.has(o._origin)) {
      if (o._origin === a) {
        o._origin = b;
      }
      foundOrigins.add(o);
      o = o._right;
    }
    y.os.put(b);
    if (y._transaction.newTypes.has(a)) {
      y._transaction.newTypes.add(b);
    } else if (y._transaction.deletedStructs.has(a)) {
      y._transaction.deletedStructs.add(b);
    }
  }

  /**
   * Abstract class that represents any content.
   */

  var Item = function () {
    function Item() {
      classCallCheck(this, Item);

      /**
       * The uniqe identifier of this type.
       * @type {ID}
       */
      this._id = null;
      /**
       * The item that was originally to the left of this item.
       * @type {Item}
       */
      this._origin = null;
      /**
       * The item that is currently to the left of this item.
       * @type {Item}
       */
      this._left = null;
      /**
       * The item that is currently to the right of this item.
       * @type {Item}
       */
      this._right = null;
      /**
       * The item that was originally to the right of this item.
       * @type {Item}
       */
      this._right_origin = null;
      /**
       * The parent type.
       * @type {Y|YType}
       */
      this._parent = null;
      /**
       * If the parent refers to this item with some kind of key (e.g. YMap, the
       * key is specified here. The key is then used to refer to the list in which
       * to insert this item. If `parentSub = null` type._start is the list in
       * which to insert to. Otherwise it is `parent._start`.
       * @type {String}
       */
      this._parentSub = null;
      /**
       * Whether this item was deleted or not.
       * @type {Boolean}
       */
      this._deleted = false;
      /**
       * If this type's effect is reundone this type refers to the type that undid
       * this operation.
       * @type {Item}
       */
      this._redone = null;
    }

    /**
     * Creates an Item with the same effect as this Item (without position effect)
     *
     * @private
     */


    createClass(Item, [{
      key: '_copy',
      value: function _copy() {
        return new this.constructor();
      }

      /**
       * Redoes the effect of this operation.
       *
       * @param {Y} y The Yjs instance.
       *
       * @private
       */

    }, {
      key: '_redo',
      value: function _redo(y, redoitems) {
        if (this._redone !== null) {
          return this._redone;
        }
        var struct = this._copy();
        var left = this._left;
        var right = this;
        var parent = this._parent;
        // make sure that parent is redone
        if (parent._deleted === true && parent._redone === null) {
          // try to undo parent if it will be undone anyway
          if (!redoitems.has(parent) || !parent._redo(y, redoitems)) {
            return false;
          }
        }
        if (parent._redone !== null) {
          parent = parent._redone;
          // find next cloned items
          while (left !== null) {
            if (left._redone !== null && left._redone._parent === parent) {
              left = left._redone;
              break;
            }
            left = left._left;
          }
          while (right !== null) {
            if (right._redone !== null && right._redone._parent === parent) {
              right = right._redone;
            }
            right = right._right;
          }
        }
        struct._origin = left;
        struct._left = left;
        struct._right = right;
        struct._right_origin = right;
        struct._parent = parent;
        struct._parentSub = this._parentSub;
        struct._integrate(y);
        this._redone = struct;
        return true;
      }

      /**
       * Computes the last content address of this Item.
       *
       * @private
       */

    }, {
      key: '_splitAt',


      /**
       * Splits this Item so that another Items can be inserted in-between.
       * This must be overwritten if _length > 1
       * Returns right part after split
       * * diff === 0 => this
       * * diff === length => this._right
       * * otherwise => split _content and return right part of split
       * (see {@link ItemJSON}/{@link ItemString} for implementation)
       *
       * @private
       */
      value: function _splitAt(y, diff) {
        if (diff === 0) {
          return this;
        }
        return this._right;
      }

      /**
       * Mark this Item as deleted.
       *
       * @param {Y} y The Yjs instance
       * @param {boolean} createDelete Whether to propagate a message that this
       *                               Type was deleted.
       *
       * @private
       */

    }, {
      key: '_delete',
      value: function _delete(y) {
        var createDelete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (!this._deleted) {
          this._deleted = true;
          y.ds.mark(this._id, this._length, false);
          var del = new Delete();
          del._targetID = this._id;
          del._length = this._length;
          if (createDelete) {
            // broadcast and persists Delete
            del._integrate(y, true);
          } else if (y.persistence !== null) {
            // only persist Delete
            y.persistence.saveStruct(y, del);
          }
          transactionTypeChanged(y, this._parent, this._parentSub);
          y._transaction.deletedStructs.add(this);
        }
      }
    }, {
      key: '_gcChildren',
      value: function _gcChildren(y) {}
    }, {
      key: '_gc',
      value: function _gc(y) {
        var gc = new GC();
        gc._id = this._id;
        gc._length = this._length;
        y.os.delete(this._id);
        gc._integrate(y);
      }

      /**
       * This is called right before this Item receives any children.
       * It can be overwritten to apply pending changes before applying remote changes
       *
       * @private
       */

    }, {
      key: '_beforeChange',
      value: function _beforeChange() {}
      // nop


      /**
       * Integrates this Item into the shared structure.
       *
       * This method actually applies the change to the Yjs instance. In case of
       * Item it connects _left and _right to this Item and calls the
       * {@link Item#beforeChange} method.
       *
       * * Integrate the struct so that other types/structs can see it
       * * Add this struct to y.os
       * * Check if this is struct deleted
       *
       * @private
       */

    }, {
      key: '_integrate',
      value: function _integrate(y) {
        y._transaction.newTypes.add(this);
        var parent = this._parent;
        var selfID = this._id;
        var user = selfID === null ? y.userID : selfID.user;
        var userState = y.ss.getState(user);
        if (selfID === null) {
          this._id = y.ss.getNextID(this._length);
        } else if (selfID.user === RootFakeUserID) ; else if (selfID.clock < userState) {
          // already applied..
          return [];
        } else if (selfID.clock === userState) {
          y.ss.setState(selfID.user, userState + this._length);
        } else {
          // missing content from user
          throw new Error('Can not apply yet!');
        }
        if (!parent._deleted && !y._transaction.changedTypes.has(parent) && !y._transaction.newTypes.has(parent)) {
          // this is the first time parent is updated
          // or this types is new
          this._parent._beforeChange();
        }

        /*
        # $this has to find a unique position between origin and the next known character
        # case 1: $origin equals $o.origin: the $creator parameter decides if left or right
        #         let $OL= [o1,o2,o3,o4], whereby $this is to be inserted between o1 and o4
        #         o2,o3 and o4 origin is 1 (the position of o2)
        #         there is the case that $this.creator < o2.creator, but o3.creator < $this.creator
        #         then o2 knows o3. Since on another client $OL could be [o1,o3,o4] the problem is complex
        #         therefore $this would be always to the right of o3
        # case 2: $origin < $o.origin
        #         if current $this insert_position > $o origin: $this ins
        #         else $insert_position will not change
        #         (maybe we encounter case 1 later, then this will be to the right of $o)
        # case 3: $origin > $o.origin
        #         $this insert_position is to the left of $o (forever!)
        */
        // handle conflicts
        var o = void 0;
        // set o to the first conflicting item
        if (this._left !== null) {
          o = this._left._right;
        } else if (this._parentSub !== null) {
          o = this._parent._map.get(this._parentSub) || null;
        } else {
          o = this._parent._start;
        }
        var conflictingItems = new Set();
        var itemsBeforeOrigin = new Set();
        // Let c in conflictingItems, b in itemsBeforeOrigin
        // ***{origin}bbbb{this}{c,b}{c,b}{o}***
        // Note that conflictingItems is a subset of itemsBeforeOrigin
        while (o !== null && o !== this._right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (this._origin === o._origin) {
            // case 1
            if (o._id.user < this._id.user) {
              this._left = o;
              conflictingItems.clear();
            }
          } else if (itemsBeforeOrigin.has(o._origin)) {
            // case 2
            if (!conflictingItems.has(o._origin)) {
              this._left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          // TODO: try to use right_origin instead.
          // Then you could basically omit conflictingItems!
          // Note: you probably can't use right_origin in every case.. only when setting _left
          o = o._right;
        }
        // reconnect left/right + update parent map/start if necessary
        var parentSub = this._parentSub;
        if (this._left === null) {
          var right = void 0;
          if (parentSub !== null) {
            var pmap = parent._map;
            right = pmap.get(parentSub) || null;
            pmap.set(parentSub, this);
          } else {
            right = parent._start;
            parent._start = this;
          }
          this._right = right;
          if (right !== null) {
            right._left = this;
          }
        } else {
          var left = this._left;
          var _right = left._right;
          this._right = _right;
          left._right = this;
          if (_right !== null) {
            _right._left = this;
          }
        }
        if (parent._deleted) {
          this._delete(y, false);
        }
        y.os.put(this);
        transactionTypeChanged(y, parent, parentSub);
        if (this._id.user !== RootFakeUserID) {
          if (y.connector !== null && (y.connector._forwardAppliedStructs || this._id.user === y.userID)) {
            y.connector.broadcastStruct(this);
          }
          if (y.persistence !== null) {
            y.persistence.saveStruct(y, this);
          }
        }
      }

      /**
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       *
       * @param {BinaryEncoder} encoder The encoder to write data to.
       *
       * @private
       */

    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        encoder.writeUint8(getStructReference(this.constructor));
        var info = 0;
        if (this._origin !== null) {
          info += 1; // origin is defined
        }
        // TODO: remove
        /* no longer send _left
        if (this._left !== this._origin) {
          info += 0b10 // do not copy origin to left
        }
        */
        if (this._right_origin !== null) {
          info += 4;
        }
        if (this._parentSub !== null) {
          info += 8;
        }
        encoder.writeUint8(info);
        encoder.writeID(this._id);
        if (info & 1) {
          encoder.writeID(this._origin._lastId);
        }
        // TODO: remove
        /* see above
        if (info & 0b10) {
          encoder.writeID(this._left._lastId)
        }
        */
        if (info & 4) {
          encoder.writeID(this._right_origin._id);
        }
        if ((info & 5) === 0) {
          // neither origin nor right is defined
          encoder.writeID(this._parent._id);
        }
        if (info & 8) {
          encoder.writeVarString(JSON.stringify(this._parentSub));
        }
      }

      /**
       * Read the next Item in a Decoder and fill this Item with the read data.
       *
       * This is called when data is received from a remote peer.
       *
       * @param {Y} y The Yjs instance that this Item belongs to.
       * @param {BinaryDecoder} decoder The decoder object to read data from.
       *
       * @private
       */

    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = [];
        var info = decoder.readUint8();
        var id = decoder.readID();
        this._id = id;
        // read origin
        if (info & 1) {
          // origin != null
          var originID = decoder.readID();
          // we have to query for left again because it might have been split/merged..
          var origin = y.os.getItemCleanEnd(originID);
          if (origin === null) {
            missing.push(originID);
          } else {
            this._origin = origin;
            this._left = this._origin;
          }
        }
        // read right
        if (info & 4) {
          // right != null
          var rightID = decoder.readID();
          // we have to query for right again because it might have been split/merged..
          var right = y.os.getItemCleanStart(rightID);
          if (right === null) {
            missing.push(rightID);
          } else {
            this._right = right;
            this._right_origin = right;
          }
        }
        // read parent
        if ((info & 5) === 0) {
          // neither origin nor right is defined
          var parentID = decoder.readID();
          // parent does not change, so we don't have to search for it again
          if (this._parent === null) {
            var parent = void 0;
            if (parentID.constructor === RootID) {
              parent = y.os.get(parentID);
            } else {
              parent = y.os.getItem(parentID);
            }
            if (parent === null) {
              missing.push(parentID);
            } else {
              this._parent = parent;
            }
          }
        } else if (this._parent === null) {
          if (this._origin !== null) {
            if (this._origin.constructor === GC) {
              // if origin is a gc, set parent also gc'd
              this._parent = this._origin;
            } else {
              this._parent = this._origin._parent;
            }
          } else if (this._right_origin !== null) {
            // if origin is a gc, set parent also gc'd
            if (this._right_origin.constructor === GC) {
              this._parent = this._right_origin;
            } else {
              this._parent = this._right_origin._parent;
            }
          }
        }
        if (info & 8) {
          // TODO: maybe put this in read parent condition (you can also read parentsub from left/right)
          this._parentSub = JSON.parse(decoder.readVarString());
        }
        if (y.ss.getState(id.user) < id.clock) {
          missing.push(new ID(id.user, id.clock - 1));
        }
        return missing;
      }
    }, {
      key: '_lastId',
      get: function get$$1() {
        return new ID(this._id.user, this._id.clock + this._length - 1);
      }

      /**
       * Computes the length of this Item.
       *
       * @private
       */

    }, {
      key: '_length',
      get: function get$$1() {
        return 1;
      }

      /**
       * Should return false if this Item is some kind of meta information
       * (e.g. format information).
       *
       * * Whether this Item should be addressable via `yarray.get(i)`
       * * Whether this Item should be counted when computing yarray.length
       *
       * @private
       */

    }, {
      key: '_countable',
      get: function get$$1() {
        return true;
      }
    }]);
    return Item;
  }();

  /**
   * General event handler implementation.
   */
  var EventHandler = function () {
    function EventHandler() {
      classCallCheck(this, EventHandler);

      this.eventListeners = [];
    }

    /**
     * To prevent memory leaks, call this method when the eventListeners won't be
     * used anymore.
     */


    createClass(EventHandler, [{
      key: "destroy",
      value: function destroy() {
        this.eventListeners = null;
      }

      /**
       * Adds an event listener that is called when
       * {@link EventHandler#callEventListeners} is called.
       *
       * @param {Function} f The event handler.
       */

    }, {
      key: "addEventListener",
      value: function addEventListener(f) {
        this.eventListeners.push(f);
      }

      /**
       * Removes an event listener.
       *
       * @param {Function} f The event handler that was added with
       *                     {@link EventHandler#addEventListener}
       */

    }, {
      key: "removeEventListener",
      value: function removeEventListener(f) {
        this.eventListeners = this.eventListeners.filter(function (g) {
          return f !== g;
        });
      }

      /**
       * Removes all event listeners.
       */

    }, {
      key: "removeAllEventListeners",
      value: function removeAllEventListeners() {
        this.eventListeners = [];
      }

      /**
       * Call all event listeners that were added via
       * {@link EventHandler#addEventListener}.
       *
       * @param {Transaction} transaction The transaction object // TODO: do we need this?
       * @param {YEvent} event An event object that describes the change on a type.
       */

    }, {
      key: "callEventListeners",
      value: function callEventListeners(transaction, event) {
        for (var i = 0; i < this.eventListeners.length; i++) {
          try {
            var f = this.eventListeners[i];
            f(event);
          } catch (e) {
            /*
              Your observer threw an error. This error was caught so that Yjs
              can ensure data consistency! In order to debug this error you
              have to check "Pause On Caught Exceptions" in developer tools.
            */
            console.error(e);
          }
        }
      }
    }]);
    return EventHandler;
  }();

  // restructure children as if they were inserted one after another
  function integrateChildren(y, start) {
    var right = void 0;
    do {
      right = start._right;
      start._right = null;
      start._right_origin = null;
      start._origin = start._left;
      start._integrate(y);
      start = right;
    } while (right !== null);
  }

  function gcChildren(y, item) {
    while (item !== null) {
      item._delete(y, false, true);
      item._gc(y);
      item = item._right;
    }
  }

  /**
   * Abstract Yjs Type class
   */

  var Type = function (_Item) {
    inherits(Type, _Item);

    function Type() {
      classCallCheck(this, Type);

      var _this = possibleConstructorReturn(this, (Type.__proto__ || Object.getPrototypeOf(Type)).call(this));

      _this._map = new Map();
      _this._start = null;
      _this._y = null;
      _this._eventHandler = new EventHandler();
      _this._deepEventHandler = new EventHandler();
      return _this;
    }

    /**
     * Compute the path from this type to the specified target.
     *
     * @example
     * It should be accessible via `this.get(result[0]).get(result[1])..`
     * const path = type.getPathTo(child)
     * // assuming `type instanceof YArray`
     * console.log(path) // might look like => [2, 'key1']
     * child === type.get(path[0]).get(path[1])
     *
     * @param {YType} type Type target
     * @return {Array<string>} Path to the target
     */


    createClass(Type, [{
      key: 'getPathTo',
      value: function getPathTo(type) {
        if (type === this) {
          return [];
        }
        var path = [];
        var y = this._y;
        while (type !== this && type !== y) {
          var parent = type._parent;
          if (type._parentSub !== null) {
            path.unshift(type._parentSub);
          } else {
            // parent is array-ish
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = parent[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = slicedToArray(_step.value, 2),
                    i = _step$value[0],
                    child = _step$value[1];

                if (child === type) {
                  path.unshift(i);
                  break;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
          type = parent;
        }
        if (type !== this) {
          throw new Error('The type is not a child of this node');
        }
        return path;
      }

      /**
       * @private
       * Call event listeners with an event. This will also add an event to all
       * parents (for `.observeDeep` handlers).
       */

    }, {
      key: '_callEventHandler',
      value: function _callEventHandler(transaction, event) {
        var changedParentTypes = transaction.changedParentTypes;
        this._eventHandler.callEventListeners(transaction, event);
        var type = this;
        while (type !== this._y) {
          var events = changedParentTypes.get(type);
          if (events === undefined) {
            events = [];
            changedParentTypes.set(type, events);
          }
          events.push(event);
          type = type._parent;
        }
      }

      /**
       * @private
       * Helper method to transact if the y instance is available.
       *
       * TODO: Currently event handlers are not thrown when a type is not registered
       *       with a Yjs instance.
       */

    }, {
      key: '_transact',
      value: function _transact(f) {
        var y = this._y;
        if (y !== null) {
          y.transact(f);
        } else {
          f(y);
        }
      }

      /**
       * Observe all events that are created on this type.
       *
       * @param {Function} f Observer function
       */

    }, {
      key: 'observe',
      value: function observe(f) {
        this._eventHandler.addEventListener(f);
      }

      /**
       * Observe all events that are created by this type and its children.
       *
       * @param {Function} f Observer function
       */

    }, {
      key: 'observeDeep',
      value: function observeDeep(f) {
        this._deepEventHandler.addEventListener(f);
      }

      /**
       * Unregister an observer function.
       *
       * @param {Function} f Observer function
       */

    }, {
      key: 'unobserve',
      value: function unobserve(f) {
        this._eventHandler.removeEventListener(f);
      }

      /**
       * Unregister an observer function.
       *
       * @param {Function} f Observer function
       */

    }, {
      key: 'unobserveDeep',
      value: function unobserveDeep(f) {
        this._deepEventHandler.removeEventListener(f);
      }

      /**
       * @private
       * Integrate this type into the Yjs instance.
       *
       * * Save this struct in the os
       * * This type is sent to other client
       * * Observer functions are fired
       *
       * @param {Y} y The Yjs instance
       */

    }, {
      key: '_integrate',
      value: function _integrate(y) {
        get(Type.prototype.__proto__ || Object.getPrototypeOf(Type.prototype), '_integrate', this).call(this, y);
        this._y = y;
        // when integrating children we must make sure to
        // integrate start
        var start = this._start;
        if (start !== null) {
          this._start = null;
          integrateChildren(y, start);
        }
        // integrate map children
        var map = this._map;
        this._map = new Map();
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = map.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var t = _step2.value;

            // TODO make sure that right elements are deleted!
            integrateChildren(y, t);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }, {
      key: '_gcChildren',
      value: function _gcChildren(y) {
        gcChildren(y, this._start);
        this._start = null;
        this._map.forEach(function (item) {
          gcChildren(y, item);
        });
        this._map = new Map();
      }
    }, {
      key: '_gc',
      value: function _gc(y) {
        this._gcChildren(y);
        get(Type.prototype.__proto__ || Object.getPrototypeOf(Type.prototype), '_gc', this).call(this, y);
      }

      /**
       * @private
       * Mark this Item as deleted.
       *
       * @param {Y} y The Yjs instance
       * @param {boolean} createDelete Whether to propagate a message that this
       *                               Type was deleted.
       * @param {boolean} [gcChildren=y._hasUndoManager===false] Whether to garbage
       *                                         collect the children of this type.
       */

    }, {
      key: '_delete',
      value: function _delete(y, createDelete, gcChildren) {
        if (gcChildren === undefined || !y.gcEnabled) {
          gcChildren = y._hasUndoManager === false && y.gcEnabled;
        }
        get(Type.prototype.__proto__ || Object.getPrototypeOf(Type.prototype), '_delete', this).call(this, y, createDelete, gcChildren);
        y._transaction.changedTypes.delete(this);
        // delete map types
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this._map.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var value = _step3.value;

            if (value instanceof Item && !value._deleted) {
              value._delete(y, false, gcChildren);
            }
          }
          // delete array types
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        var t = this._start;
        while (t !== null) {
          if (!t._deleted) {
            t._delete(y, false, gcChildren);
          }
          t = t._right;
        }
        if (gcChildren) {
          this._gcChildren(y);
        }
      }
    }]);
    return Type;
  }(Item);

  var ItemJSON = function (_Item) {
    inherits(ItemJSON, _Item);

    function ItemJSON() {
      classCallCheck(this, ItemJSON);

      var _this = possibleConstructorReturn(this, (ItemJSON.__proto__ || Object.getPrototypeOf(ItemJSON)).call(this));

      _this._content = null;
      return _this;
    }

    createClass(ItemJSON, [{
      key: '_copy',
      value: function _copy() {
        var struct = get(ItemJSON.prototype.__proto__ || Object.getPrototypeOf(ItemJSON.prototype), '_copy', this).call(this);
        struct._content = this._content;
        return struct;
      }
    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(ItemJSON.prototype.__proto__ || Object.getPrototypeOf(ItemJSON.prototype), '_fromBinary', this).call(this, y, decoder);
        var len = decoder.readVarUint();
        this._content = new Array(len);
        for (var i = 0; i < len; i++) {
          var ctnt = decoder.readVarString();
          var parsed = void 0;
          if (ctnt === 'undefined') {
            parsed = undefined;
          } else {
            parsed = JSON.parse(ctnt);
          }
          this._content[i] = parsed;
        }
        return missing;
      }
    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(ItemJSON.prototype.__proto__ || Object.getPrototypeOf(ItemJSON.prototype), '_toBinary', this).call(this, encoder);
        var len = this._content.length;
        encoder.writeVarUint(len);
        for (var i = 0; i < len; i++) {
          var encoded = void 0;
          var content = this._content[i];
          if (content === undefined) {
            encoded = 'undefined';
          } else {
            encoded = JSON.stringify(content);
          }
          encoder.writeVarString(encoded);
        }
      }
      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('ItemJSON', this, 'content:' + JSON.stringify(this._content));
      }
    }, {
      key: '_splitAt',
      value: function _splitAt(y, diff) {
        if (diff === 0) {
          return this;
        } else if (diff >= this._length) {
          return this._right;
        }
        var item = new ItemJSON();
        item._content = this._content.splice(diff);
        splitHelper(y, this, item, diff);
        return item;
      }
    }, {
      key: '_length',
      get: function get$$1() {
        return this._content.length;
      }
    }]);
    return ItemJSON;
  }(Item);

  var ItemString = function (_Item) {
    inherits(ItemString, _Item);

    function ItemString() {
      classCallCheck(this, ItemString);

      var _this = possibleConstructorReturn(this, (ItemString.__proto__ || Object.getPrototypeOf(ItemString)).call(this));

      _this._content = null;
      return _this;
    }

    createClass(ItemString, [{
      key: '_copy',
      value: function _copy() {
        var struct = get(ItemString.prototype.__proto__ || Object.getPrototypeOf(ItemString.prototype), '_copy', this).call(this);
        struct._content = this._content;
        return struct;
      }
    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(ItemString.prototype.__proto__ || Object.getPrototypeOf(ItemString.prototype), '_fromBinary', this).call(this, y, decoder);
        this._content = decoder.readVarString();
        return missing;
      }
    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(ItemString.prototype.__proto__ || Object.getPrototypeOf(ItemString.prototype), '_toBinary', this).call(this, encoder);
        encoder.writeVarString(this._content);
      }
      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('ItemString', this, 'content:"' + this._content + '"');
      }
    }, {
      key: '_splitAt',
      value: function _splitAt(y, diff) {
        if (diff === 0) {
          return this;
        } else if (diff >= this._length) {
          return this._right;
        }
        var item = new ItemString();
        item._content = this._content.slice(diff);
        this._content = this._content.slice(0, diff);
        splitHelper(y, this, item, diff);
        return item;
      }
    }, {
      key: '_length',
      get: function get$$1() {
        return this._content.length;
      }
    }]);
    return ItemString;
  }(Item);

  /**
   * YEvent describes the changes on a YType.
   */
  var YEvent = function () {
    /**
     * @param {YType} target The changed type.
     */
    function YEvent(target) {
      classCallCheck(this, YEvent);

      /**
       * The type on which this event was created on.
       * @type {YType}
       */
      this.target = target;
      /**
       * The current target on which the observe callback is called.
       * @type {YType}
       */
      this.currentTarget = target;
    }

    /**
     * Computes the path from `y` to the changed type.
     *
     * The following property holds:
     * @example
     *   let type = y
     *   event.path.forEach(function (dir) {
     *     type = type.get(dir)
     *   })
     *   type === event.target // => true
     */


    createClass(YEvent, [{
      key: "path",
      get: function get$$1() {
        return this.currentTarget.getPathTo(this.target);
      }
    }]);
    return YEvent;
  }();

  /**
   * Event that describes the changes on a YArray
   *
   * @param {YArray} yarray The changed type
   * @param {Boolean} remote Whether the changed was caused by a remote peer
   * @param {Transaction} transaction The transaction object
   */
  var YArrayEvent = function (_YEvent) {
    inherits(YArrayEvent, _YEvent);

    function YArrayEvent(yarray, remote, transaction) {
      classCallCheck(this, YArrayEvent);

      var _this = possibleConstructorReturn(this, (YArrayEvent.__proto__ || Object.getPrototypeOf(YArrayEvent)).call(this, yarray));

      _this.remote = remote;
      _this._transaction = transaction;
      _this._addedElements = null;
      _this._removedElements = null;
      return _this;
    }

    /**
     * Child elements that were added in this transaction.
     *
     * @return {Set}
     */


    createClass(YArrayEvent, [{
      key: 'addedElements',
      get: function get$$1() {
        if (this._addedElements === null) {
          var target = this.target;
          var transaction = this._transaction;
          var addedElements = new Set();
          transaction.newTypes.forEach(function (type) {
            if (type._parent === target && !transaction.deletedStructs.has(type)) {
              addedElements.add(type);
            }
          });
          this._addedElements = addedElements;
        }
        return this._addedElements;
      }

      /**
       * Child elements that were removed in this transaction.
       *
       * @return {Set}
       */

    }, {
      key: 'removedElements',
      get: function get$$1() {
        if (this._removedElements === null) {
          var target = this.target;
          var transaction = this._transaction;
          var removedElements = new Set();
          transaction.deletedStructs.forEach(function (struct) {
            if (struct._parent === target && !transaction.newTypes.has(struct)) {
              removedElements.add(struct);
            }
          });
          this._removedElements = removedElements;
        }
        return this._removedElements;
      }
    }]);
    return YArrayEvent;
  }(YEvent);

  /**
   * A shared Array implementation.
   */

  var YArray = function (_Type) {
    inherits(YArray, _Type);

    function YArray() {
      classCallCheck(this, YArray);
      return possibleConstructorReturn(this, (YArray.__proto__ || Object.getPrototypeOf(YArray)).apply(this, arguments));
    }

    createClass(YArray, [{
      key: '_callObserver',

      /**
       * @private
       * Creates YArray Event and calls observers.
       */
      value: function _callObserver(transaction, parentSubs, remote) {
        this._callEventHandler(transaction, new YArrayEvent(this, remote, transaction));
      }

      /**
       * Returns the i-th element from a YArray.
       *
       * @param {Integer} index The index of the element to return from the YArray
       */

    }, {
      key: 'get',
      value: function get$$1(index) {
        var n = this._start;
        while (n !== null) {
          if (!n._deleted && n._countable) {
            if (index < n._length) {
              if (n.constructor === ItemJSON || n.constructor === ItemString) {
                return n._content[index];
              } else {
                return n;
              }
            }
            index -= n._length;
          }
          n = n._right;
        }
      }

      /**
       * Transforms this YArray to a JavaScript Array.
       *
       * @return {Array}
       */

    }, {
      key: 'toArray',
      value: function toArray$$1() {
        return this.map(function (c) {
          return c;
        });
      }

      /**
       * Transforms this Shared Type to a JSON object.
       *
       * @return {Array}
       */

    }, {
      key: 'toJSON',
      value: function toJSON() {
        return this.map(function (c) {
          if (c instanceof Type) {
            if (c.toJSON !== null) {
              return c.toJSON();
            } else {
              return c.toString();
            }
          }
          return c;
        });
      }

      /**
       * Returns an Array with the result of calling a provided function on every
       * element of this YArray.
       *
       * @param {Function} f Function that produces an element of the new Array
       * @return {Array} A new array with each element being the result of the
       *                 callback function
       */

    }, {
      key: 'map',
      value: function map(f) {
        var _this3 = this;

        var res = [];
        this.forEach(function (c, i) {
          res.push(f(c, i, _this3));
        });
        return res;
      }

      /**
       * Executes a provided function on once on overy element of this YArray.
       *
       * @param {Function} f A function to execute on every element of this YArray.
       */

    }, {
      key: 'forEach',
      value: function forEach(f) {
        var index = 0;
        var n = this._start;
        while (n !== null) {
          if (!n._deleted && n._countable) {
            if (n instanceof Type) {
              f(n, index++, this);
            } else {
              var content = n._content;
              var contentLen = content.length;
              for (var i = 0; i < contentLen; i++) {
                index++;
                f(content[i], index, this);
              }
            }
          }
          n = n._right;
        }
      }

      /**
       * Computes the length of this YArray.
       */

    }, {
      key: Symbol.iterator,
      value: function value() {
        return {
          next: function next() {
            while (this._item !== null && (this._item._deleted || this._item._length <= this._itemElement)) {
              // item is deleted or itemElement does not exist (is deleted)
              this._item = this._item._right;
              this._itemElement = 0;
            }
            if (this._item === null) {
              return {
                done: true
              };
            }
            var content = void 0;
            if (this._item instanceof Type) {
              content = this._item;
            } else {
              content = this._item._content[this._itemElement++];
            }
            return {
              value: content,
              done: false
            };
          },
          _item: this._start,
          _itemElement: 0,
          _count: 0
        };
      }

      /**
       * Deletes elements starting from an index.
       *
       * @param {Integer} index Index at which to start deleting elements
       * @param {Integer} length The number of elements to remove. Defaults to 1.
       */

    }, {
      key: 'delete',
      value: function _delete(index) {
        var _this4 = this;

        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        this._y.transact(function () {
          var item = _this4._start;
          var count = 0;
          while (item !== null && length > 0) {
            if (!item._deleted && item._countable) {
              if (count <= index && index < count + item._length) {
                var diffDel = index - count;
                item = item._splitAt(_this4._y, diffDel);
                item._splitAt(_this4._y, length);
                length -= item._length;
                item._delete(_this4._y);
                count += diffDel;
              } else {
                count += item._length;
              }
            }
            item = item._right;
          }
        });
        if (length > 0) {
          throw new Error('Delete exceeds the range of the YArray');
        }
      }

      /**
       * @private
       * Inserts content after an element container.
       *
       * @param {Item} left The element container to use as a reference.
       * @param {Array} content The Array of content to insert (see {@see insert})
       */

    }, {
      key: 'insertAfter',
      value: function insertAfter(left, content) {
        var _this5 = this;

        this._transact(function (y) {
          var right = void 0;
          if (left === null) {
            right = _this5._start;
          } else {
            right = left._right;
          }
          var prevJsonIns = null;
          for (var i = 0; i < content.length; i++) {
            var c = content[i];
            if (typeof c === 'function') {
              c = new c(); // eslint-disable-line new-cap
            }
            if (c instanceof Type) {
              if (prevJsonIns !== null) {
                if (y !== null) {
                  prevJsonIns._integrate(y);
                }
                left = prevJsonIns;
                prevJsonIns = null;
              }
              c._origin = left;
              c._left = left;
              c._right = right;
              c._right_origin = right;
              c._parent = _this5;
              if (y !== null) {
                c._integrate(y);
              } else if (left === null) {
                _this5._start = c;
              } else {
                left._right = c;
              }
              left = c;
            } else {
              if (prevJsonIns === null) {
                prevJsonIns = new ItemJSON();
                prevJsonIns._origin = left;
                prevJsonIns._left = left;
                prevJsonIns._right = right;
                prevJsonIns._right_origin = right;
                prevJsonIns._parent = _this5;
                prevJsonIns._content = [];
              }
              prevJsonIns._content.push(c);
            }
          }
          if (prevJsonIns !== null) {
            if (y !== null) {
              prevJsonIns._integrate(y);
            } else if (prevJsonIns._left === null) {
              _this5._start = prevJsonIns;
            }
          }
        });
        return content;
      }

      /**
       * Inserts new content at an index.
       *
       * Important: This function expects an array of content. Not just a content
       * object. The reason for this "weirdness" is that inserting several elements
       * is very efficient when it is done as a single operation.
       *
       * @example
       *  // Insert character 'a' at position 0
       *  yarray.insert(0, ['a'])
       *  // Insert numbers 1, 2 at position 1
       *  yarray.insert(2, [1, 2])
       *
       * @param {Integer} index The index to insert content at.
       * @param {Array} content The array of content
       */

    }, {
      key: 'insert',
      value: function insert(index, content) {
        var _this6 = this;

        this._transact(function () {
          var left = null;
          var right = _this6._start;
          var count = 0;
          var y = _this6._y;
          while (right !== null) {
            var rightLen = right._deleted ? 0 : right._length - 1;
            if (count <= index && index <= count + rightLen) {
              var splitDiff = index - count;
              right = right._splitAt(y, splitDiff);
              left = right._left;
              count += splitDiff;
              break;
            }
            if (!right._deleted) {
              count += right._length;
            }
            left = right;
            right = right._right;
          }
          if (index > count) {
            throw new Error('Index exceeds array range!');
          }
          _this6.insertAfter(left, content);
        });
      }

      /**
       * Appends content to this YArray.
       *
       * @param {Array} content Array of content to append.
       */

    }, {
      key: 'push',
      value: function push(content) {
        var n = this._start;
        var lastUndeleted = null;
        while (n !== null) {
          if (!n._deleted) {
            lastUndeleted = n;
          }
          n = n._right;
        }
        this.insertAfter(lastUndeleted, content);
      }

      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('YArray', this, 'start:' + logID(this._start) + '"');
      }
    }, {
      key: 'length',
      get: function get$$1() {
        var length = 0;
        var n = this._start;
        while (n !== null) {
          if (!n._deleted && n._countable) {
            length += n._length;
          }
          n = n._right;
        }
        return length;
      }
    }]);
    return YArray;
  }(Type);

  /**
   * Event that describes the changes on a YMap.
   *
   * @param {YMap} ymap The YArray that changed.
   * @param {Set<any>} subs The keys that changed.
   * @param {boolean} remote Whether the change was created by a remote peer.
   */
  var YMapEvent = function (_YEvent) {
    inherits(YMapEvent, _YEvent);

    function YMapEvent(ymap, subs, remote) {
      classCallCheck(this, YMapEvent);

      var _this = possibleConstructorReturn(this, (YMapEvent.__proto__ || Object.getPrototypeOf(YMapEvent)).call(this, ymap));

      _this.keysChanged = subs;
      _this.remote = remote;
      return _this;
    }

    return YMapEvent;
  }(YEvent);

  /**
   * A shared Map implementation.
   */

  var YMap = function (_Type) {
    inherits(YMap, _Type);

    /**
     * @private
     * Creates YMap Event and calls observers.
     */
    function YMap() {
      classCallCheck(this, YMap);

      var _this2 = possibleConstructorReturn(this, (YMap.__proto__ || Object.getPrototypeOf(YMap)).call(this));

      console.log(_this2);
      console.log('rrrrrrrrrrrrrrrrrrrrr');
      return _this2;
    }

    createClass(YMap, [{
      key: '_callObserver',
      value: function _callObserver(transaction, parentSubs, remote) {
        this._callEventHandler(transaction, new YMapEvent(this, parentSubs, remote));
      }

      /**
       * Transforms this Shared Type to a JSON object.
       *
       * @return {Object}
       */

    }, {
      key: 'toJSON',
      value: function toJSON() {
        var map = {};
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._map[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = slicedToArray(_step.value, 2),
                key = _step$value[0],
                item = _step$value[1];

            if (!item._deleted) {
              var res = void 0;
              if (item instanceof Type) {
                if (item.toJSON !== undefined) {
                  res = item.toJSON();
                } else {
                  res = item.toString();
                }
              } else {
                res = item._content[0];
              }
              map[key] = res;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return map;
      }

      /**
       * Returns the keys for each element in the YMap Type.
       *
       * @return {Array}
       */

    }, {
      key: 'keys',
      value: function keys() {
        // TODO: Should return either Iterator or Set!
        var keys = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._map[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _step2$value = slicedToArray(_step2.value, 2),
                key = _step2$value[0],
                value = _step2$value[1];

            if (!value._deleted) {
              keys.push(key);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return keys;
      }

      /**
       * Remove a specified element from this YMap.
       *
       * @param {encodable} key The key of the element to remove.
       */

    }, {
      key: 'delete',
      value: function _delete(key) {
        var _this3 = this;

        this._transact(function (y) {
          var c = _this3._map.get(key);
          if (y !== null && c !== undefined) {
            c._delete(y);
          }
        });
      }

      /**
       * Adds or updates an element with a specified key and value.
       *
       * @param {encodable} key The key of the element to add to this YMap.
       * @param {encodable | YType} value The value of the element to add to this
       *                                  YMap.
       */

    }, {
      key: 'set',
      value: function set$$1(key, value) {
        var _this4 = this;

        this._transact(function (y) {
          var old = _this4._map.get(key) || null;
          if (old !== null) {
            if (old.constructor === ItemJSON && !old._deleted && old._content[0] === value) {
              // Trying to overwrite with same value
              // break here
              return value;
            }
            if (y !== null) {
              old._delete(y);
            }
          }
          var v = void 0;
          if (typeof value === 'function') {
            v = new value(); // eslint-disable-line new-cap
            value = v;
          } else if (value instanceof Item) {
            v = value;
          } else {
            v = new ItemJSON();
            v._content = [value];
          }
          v._right = old;
          v._right_origin = old;
          v._parent = _this4;
          v._parentSub = key;
          if (y !== null) {
            v._integrate(y);
          } else {
            _this4._map.set(key, v);
          }
        });
        return value;
      }

      /**
       * Returns a specified element from this YMap.
       *
       * @param {encodable} key The key of the element to return.
       */

    }, {
      key: 'get',
      value: function get$$1(key) {
        var v = this._map.get(key);
        if (v === undefined || v._deleted) {
          return undefined;
        }
        if (v instanceof Type) {
          return v;
        } else {
          return v._content[v._content.length - 1];
        }
      }

      /**
       * Returns a boolean indicating whether the specified key exists or not.
       *
       * @param {encodable} key The key to test.
       */

    }, {
      key: 'has',
      value: function has(key) {
        var v = this._map.get(key);
        if (v === undefined || v._deleted) {
          return false;
        } else {
          return true;
        }
      }

      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('YMap', this, 'mapSize:' + this._map.size);
      }
    }]);
    return YMap;
  }(Type);

  var ItemEmbed = function (_Item) {
    inherits(ItemEmbed, _Item);

    function ItemEmbed() {
      classCallCheck(this, ItemEmbed);

      var _this = possibleConstructorReturn(this, (ItemEmbed.__proto__ || Object.getPrototypeOf(ItemEmbed)).call(this));

      _this.embed = null;
      return _this;
    }

    createClass(ItemEmbed, [{
      key: '_copy',
      value: function _copy(undeleteChildren, copyPosition) {
        var struct = get(ItemEmbed.prototype.__proto__ || Object.getPrototypeOf(ItemEmbed.prototype), '_copy', this).call(this, undeleteChildren, copyPosition);
        struct.embed = this.embed;
        return struct;
      }
    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(ItemEmbed.prototype.__proto__ || Object.getPrototypeOf(ItemEmbed.prototype), '_fromBinary', this).call(this, y, decoder);
        this.embed = JSON.parse(decoder.readVarString());
        return missing;
      }
    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(ItemEmbed.prototype.__proto__ || Object.getPrototypeOf(ItemEmbed.prototype), '_toBinary', this).call(this, encoder);
        encoder.writeVarString(JSON.stringify(this.embed));
      }
      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('ItemEmbed', this, 'embed:' + JSON.stringify(this.embed));
      }
    }, {
      key: '_length',
      get: function get$$1() {
        return 1;
      }
    }]);
    return ItemEmbed;
  }(Item);

  var ItemFormat = function (_Item) {
    inherits(ItemFormat, _Item);

    function ItemFormat() {
      classCallCheck(this, ItemFormat);

      var _this = possibleConstructorReturn(this, (ItemFormat.__proto__ || Object.getPrototypeOf(ItemFormat)).call(this));

      _this.key = null;
      _this.value = null;
      return _this;
    }

    createClass(ItemFormat, [{
      key: '_copy',
      value: function _copy(undeleteChildren, copyPosition) {
        var struct = get(ItemFormat.prototype.__proto__ || Object.getPrototypeOf(ItemFormat.prototype), '_copy', this).call(this, undeleteChildren, copyPosition);
        struct.key = this.key;
        struct.value = this.value;
        return struct;
      }
    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(ItemFormat.prototype.__proto__ || Object.getPrototypeOf(ItemFormat.prototype), '_fromBinary', this).call(this, y, decoder);
        this.key = decoder.readVarString();
        this.value = JSON.parse(decoder.readVarString());
        return missing;
      }
    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(ItemFormat.prototype.__proto__ || Object.getPrototypeOf(ItemFormat.prototype), '_toBinary', this).call(this, encoder);
        encoder.writeVarString(this.key);
        encoder.writeVarString(JSON.stringify(this.value));
      }
      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('ItemFormat', this, 'key:' + JSON.stringify(this.key) + ',value:' + JSON.stringify(this.value));
      }
    }, {
      key: '_length',
      get: function get$$1() {
        return 1;
      }
    }, {
      key: '_countable',
      get: function get$$1() {
        return false;
      }
    }]);
    return ItemFormat;
  }(Item);

  /**
   * @private
   */
  function integrateItem(item, parent, y, left, right) {
    item._origin = left;
    item._left = left;
    item._right = right;
    item._right_origin = right;
    item._parent = parent;
    if (y !== null) {
      item._integrate(y);
    } else if (left === null) {
      parent._start = item;
    } else {
      left._right = item;
    }
  }

  /**
   * @private
   */
  function findNextPosition(currentAttributes, parent, left, right, count) {
    while (right !== null && count > 0) {
      switch (right.constructor) {
        case ItemEmbed:
        case ItemString:
          var rightLen = right._deleted ? 0 : right._length - 1;
          if (count <= rightLen) {
            right = right._splitAt(parent._y, count);
            left = right._left;
            return [left, right, currentAttributes];
          }
          if (right._deleted === false) {
            count -= right._length;
          }
          break;
        case ItemFormat:
          if (right._deleted === false) {
            updateCurrentAttributes(currentAttributes, right);
          }
          break;
      }
      left = right;
      right = right._right;
    }
    return [left, right, currentAttributes];
  }

  /**
   * @private
   */
  function findPosition(parent, index) {
    var currentAttributes = new Map();
    var left = null;
    var right = parent._start;
    return findNextPosition(currentAttributes, parent, left, right, index);
  }

  /**
   * Negate applied formats
   *
   * @private
   */
  function insertNegatedAttributes(y, parent, left, right, negatedAttributes) {
    // check if we really need to remove attributes
    while (right !== null && (right._deleted === true || right.constructor === ItemFormat && negatedAttributes.get(right.key) === right.value)) {
      if (right._deleted === false) {
        negatedAttributes.delete(right.key);
      }
      left = right;
      right = right._right;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = negatedAttributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = slicedToArray(_step.value, 2),
            key = _step$value[0],
            val = _step$value[1];

        var format = new ItemFormat();
        format.key = key;
        format.value = val;
        integrateItem(format, parent, y, left, right);
        left = format;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return [left, right];
  }

  /**
   * @private
   */
  function updateCurrentAttributes(currentAttributes, item) {
    var value = item.value;
    var key = item.key;
    if (value === null) {
      currentAttributes.delete(key);
    } else {
      currentAttributes.set(key, value);
    }
  }

  /**
   * @private
   */
  function minimizeAttributeChanges(left, right, currentAttributes, attributes) {
    // go right while attributes[right.key] === right.value (or right is deleted)
    while (true) {
      if (right === null) {
        break;
      } else if (right._deleted === true) ; else if (right.constructor === ItemFormat && (attributes[right.key] || null) === right.value) {
        // found a format, update currentAttributes and continue
        updateCurrentAttributes(currentAttributes, right);
      } else {
        break;
      }
      left = right;
      right = right._right;
    }
    return [left, right];
  }

  /**
   * @private
   */
  function insertAttributes(y, parent, left, right, attributes, currentAttributes) {
    var negatedAttributes = new Map();
    // insert format-start items
    for (var key in attributes) {
      var val = attributes[key];
      var currentVal = currentAttributes.get(key);
      if (currentVal !== val) {
        // save negated attribute (set null if currentVal undefined)
        negatedAttributes.set(key, currentVal || null);
        var format = new ItemFormat();
        format.key = key;
        format.value = val;
        integrateItem(format, parent, y, left, right);
        left = format;
      }
    }
    return [left, right, negatedAttributes];
  }

  /**
   * @private
   */
  function insertText(y, text, parent, left, right, currentAttributes, attributes) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = currentAttributes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _step2$value = slicedToArray(_step2.value, 1),
            key = _step2$value[0];

        if (attributes[key] === undefined) {
          attributes[key] = null;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var _minimizeAttributeCha = minimizeAttributeChanges(left, right, currentAttributes, attributes);

    var _minimizeAttributeCha2 = slicedToArray(_minimizeAttributeCha, 2);

    left = _minimizeAttributeCha2[0];
    right = _minimizeAttributeCha2[1];

    var negatedAttributes = void 0;

    // insert content
    var _insertAttributes = insertAttributes(y, parent, left, right, attributes, currentAttributes);

    var _insertAttributes2 = slicedToArray(_insertAttributes, 3);

    left = _insertAttributes2[0];
    right = _insertAttributes2[1];
    negatedAttributes = _insertAttributes2[2];
    var item = void 0;
    if (text.constructor === String) {
      item = new ItemString();
      item._content = text;
    } else {
      item = new ItemEmbed();
      item.embed = text;
    }
    integrateItem(item, parent, y, left, right);
    left = item;
    return insertNegatedAttributes(y, parent, left, right, negatedAttributes);
  }

  /**
   * @private
   */
  function formatText(y, length, parent, left, right, currentAttributes, attributes) {
    var _minimizeAttributeCha3 = minimizeAttributeChanges(left, right, currentAttributes, attributes);

    var _minimizeAttributeCha4 = slicedToArray(_minimizeAttributeCha3, 2);

    left = _minimizeAttributeCha4[0];
    right = _minimizeAttributeCha4[1];

    var negatedAttributes = void 0;

    // iterate until first non-format or null is found
    // delete all formats with attributes[format.key] != null
    var _insertAttributes3 = insertAttributes(y, parent, left, right, attributes, currentAttributes);

    var _insertAttributes4 = slicedToArray(_insertAttributes3, 3);

    left = _insertAttributes4[0];
    right = _insertAttributes4[1];
    negatedAttributes = _insertAttributes4[2];
    while (length > 0 && right !== null) {
      if (right._deleted === false) {
        switch (right.constructor) {
          case ItemFormat:
            var attr = attributes[right.key];
            if (attr !== undefined) {
              if (attr === right.value) {
                negatedAttributes.delete(right.key);
              } else {
                negatedAttributes.set(right.key, right.value);
              }
              right._delete(y);
            }
            updateCurrentAttributes(currentAttributes, right);
            break;
          case ItemEmbed:
          case ItemString:
            right._splitAt(y, length);
            length -= right._length;
            break;
        }
      }
      left = right;
      right = right._right;
    }
    return insertNegatedAttributes(y, parent, left, right, negatedAttributes);
  }

  /**
   * @private
   */
  function deleteText(y, length, parent, left, right, currentAttributes) {
    while (length > 0 && right !== null) {
      if (right._deleted === false) {
        switch (right.constructor) {
          case ItemFormat:
            updateCurrentAttributes(currentAttributes, right);
            break;
          case ItemEmbed:
          case ItemString:
            right._splitAt(y, length);
            length -= right._length;
            right._delete(y);
            break;
        }
      }
      left = right;
      right = right._right;
    }
    return [left, right];
  }

  // TODO: In the quill delta representation we should also use the format {ops:[..]}
  /**
   * The Quill Delta format represents changes on a text document with
   * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}
   *
   * @example
   *   {
   *     ops: [
   *       { insert: 'Gandalf', attributes: { bold: true } },
   *       { insert: ' the ' },
   *       { insert: 'Grey', attributes: { color: '#cccccc' } }
   *     ]
   *   }
   *
   * @typedef {Array<Object>} Delta
   */

  /**
    * Attributes that can be assigned to a selection of text.
    *
    * @example
    *   {
    *     bold: true,
    *     font-size: '40px'
    *   }
    *
    * @typedef {Object} TextAttributes
    */

  /**
   * Event that describes the changes on a YText type.
   *
   * @private
   */

  var YTextEvent = function (_YArrayEvent) {
    inherits(YTextEvent, _YArrayEvent);

    function YTextEvent(ytext, remote, transaction) {
      classCallCheck(this, YTextEvent);

      var _this = possibleConstructorReturn(this, (YTextEvent.__proto__ || Object.getPrototypeOf(YTextEvent)).call(this, ytext, remote, transaction));

      _this._delta = null;
      return _this;
    }
    // TODO: Should put this in a separate function. toDelta shouldn't be included
    //       in every Yjs distribution
    /**
     * Compute the changes in the delta format.
     *
     * @return {Delta} A {@link https://quilljs.com/docs/delta/|Quill Delta}) that
     *                 represents the changes on the document.
     *
     * @public
     */


    createClass(YTextEvent, [{
      key: 'delta',
      get: function get$$1() {
        var _this2 = this;

        if (this._delta === null) {
          var y = this.target._y;
          y.transact(function () {
            var item = _this2.target._start;
            var delta = [];
            var added = _this2.addedElements;
            var removed = _this2.removedElements;
            _this2._delta = delta;
            var action = null;
            var attributes = {}; // counts added or removed new attributes for retain
            var currentAttributes = new Map(); // saves all current attributes for insert
            var oldAttributes = new Map();
            var insert = '';
            var retain = 0;
            var deleteLen = 0;
            var addOp = function addOp() {
              if (action !== null) {
                var op = void 0;
                switch (action) {
                  case 'delete':
                    op = { delete: deleteLen };
                    deleteLen = 0;
                    break;
                  case 'insert':
                    op = { insert: insert };
                    if (currentAttributes.size > 0) {
                      op.attributes = {};
                      var _iteratorNormalCompletion3 = true;
                      var _didIteratorError3 = false;
                      var _iteratorError3 = undefined;

                      try {
                        for (var _iterator3 = currentAttributes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                          var _step3$value = slicedToArray(_step3.value, 2),
                              key = _step3$value[0],
                              value = _step3$value[1];

                          if (value !== null) {
                            op.attributes[key] = value;
                          }
                        }
                      } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                          }
                        } finally {
                          if (_didIteratorError3) {
                            throw _iteratorError3;
                          }
                        }
                      }
                    }
                    insert = '';
                    break;
                  case 'retain':
                    op = { retain: retain };
                    if (Object.keys(attributes).length > 0) {
                      op.attributes = {};
                      for (var key in attributes) {
                        op.attributes[key] = attributes[key];
                      }
                    }
                    retain = 0;
                    break;
                }
                delta.push(op);
                action = null;
              }
            };
            while (item !== null) {
              switch (item.constructor) {
                case ItemEmbed:
                  if (added.has(item)) {
                    addOp();
                    action = 'insert';
                    insert = item.embed;
                    addOp();
                  } else if (removed.has(item)) {
                    if (action !== 'delete') {
                      addOp();
                      action = 'delete';
                    }
                    deleteLen += 1;
                  } else if (item._deleted === false) {
                    if (action !== 'retain') {
                      addOp();
                      action = 'retain';
                    }
                    retain += 1;
                  }
                  break;
                case ItemString:
                  if (added.has(item)) {
                    if (action !== 'insert') {
                      addOp();
                      action = 'insert';
                    }
                    insert += item._content;
                  } else if (removed.has(item)) {
                    if (action !== 'delete') {
                      addOp();
                      action = 'delete';
                    }
                    deleteLen += item._length;
                  } else if (item._deleted === false) {
                    if (action !== 'retain') {
                      addOp();
                      action = 'retain';
                    }
                    retain += item._length;
                  }
                  break;
                case ItemFormat:
                  if (added.has(item)) {
                    var curVal = currentAttributes.get(item.key) || null;
                    if (curVal !== item.value) {
                      if (action === 'retain') {
                        addOp();
                      }
                      if (item.value === (oldAttributes.get(item.key) || null)) {
                        delete attributes[item.key];
                      } else {
                        attributes[item.key] = item.value;
                      }
                    } else {
                      item._delete(y);
                    }
                  } else if (removed.has(item)) {
                    oldAttributes.set(item.key, item.value);
                    var _curVal = currentAttributes.get(item.key) || null;
                    if (_curVal !== item.value) {
                      if (action === 'retain') {
                        addOp();
                      }
                      attributes[item.key] = _curVal;
                    }
                  } else if (item._deleted === false) {
                    oldAttributes.set(item.key, item.value);
                    var attr = attributes[item.key];
                    if (attr !== undefined) {
                      if (attr !== item.value) {
                        if (action === 'retain') {
                          addOp();
                        }
                        if (item.value === null) {
                          attributes[item.key] = item.value;
                        } else {
                          delete attributes[item.key];
                        }
                      } else {
                        item._delete(y);
                      }
                    }
                  }
                  if (item._deleted === false) {
                    if (action === 'insert') {
                      addOp();
                    }
                    updateCurrentAttributes(currentAttributes, item);
                  }
                  break;
              }
              item = item._right;
            }
            addOp();
            while (_this2._delta.length > 0) {
              var lastOp = _this2._delta[_this2._delta.length - 1];
              if (lastOp.retain !== undefined && lastOp.attributes === undefined) {
                // retain delta's if they don't assign attributes
                _this2._delta.pop();
              } else {
                break;
              }
            }
          });
        }
        return this._delta;
      }
    }]);
    return YTextEvent;
  }(YArrayEvent);

  /**
   * Type that represents text with formatting information.
   *
   * This type replaces y-richtext as this implementation is able to handle
   * block formats (format information on a paragraph), embeds (complex elements
   * like pictures and videos), and text formats (**bold**, *italic*).
   *
   * @param {String} string The initial value of the YText.
   */


  var YText = function (_YArray) {
    inherits(YText, _YArray);

    function YText(string) {
      classCallCheck(this, YText);

      var _this3 = possibleConstructorReturn(this, (YText.__proto__ || Object.getPrototypeOf(YText)).call(this));

      if (typeof string === 'string') {
        var start = new ItemString();
        start._parent = _this3;
        start._content = string;
        _this3._start = start;
      }
      return _this3;
    }

    /**
     * @private
     * Creates YMap Event and calls observers.
     */


    createClass(YText, [{
      key: '_callObserver',
      value: function _callObserver(transaction, parentSubs, remote) {
        this._callEventHandler(transaction, new YTextEvent(this, remote, transaction));
      }

      /**
       * Returns the unformatted string representation of this YText type.
       *
       * @public
       */

    }, {
      key: 'toString',
      value: function toString() {
        var str = '';
        var n = this._start;
        while (n !== null) {
          if (!n._deleted && n._countable) {
            str += n._content;
          }
          n = n._right;
        }
        return str;
      }

      /**
       * Apply a {@link Delta} on this shared YText type.
       *
       * @param {Delta} delta The changes to apply on this element.
       *
       * @public
       */

    }, {
      key: 'applyDelta',
      value: function applyDelta(delta) {
        var _this4 = this;

        this._transact(function (y) {
          var left = null;
          var right = _this4._start;
          var currentAttributes = new Map();
          for (var i = 0; i < delta.length; i++) {
            var op = delta[i];
            if (op.insert !== undefined) {
              var _insertText = insertText(y, op.insert, _this4, left, right, currentAttributes, op.attributes || {});

              var _insertText2 = slicedToArray(_insertText, 2);

              left = _insertText2[0];
              right = _insertText2[1];
            } else if (op.retain !== undefined) {
              var _formatText = formatText(y, op.retain, _this4, left, right, currentAttributes, op.attributes || {});

              var _formatText2 = slicedToArray(_formatText, 2);

              left = _formatText2[0];
              right = _formatText2[1];
            } else if (op.delete !== undefined) {
              var _deleteText = deleteText(y, op.delete, _this4, left, right, currentAttributes);

              var _deleteText2 = slicedToArray(_deleteText, 2);

              left = _deleteText2[0];
              right = _deleteText2[1];
            }
          }
        });
      }

      /**
       * Returns the Delta representation of this YText type.
       *
       * @return {Delta} The Delta representation of this type.
       *
       * @public
       */

    }, {
      key: 'toDelta',
      value: function toDelta() {
        var ops = [];
        var currentAttributes = new Map();
        var str = '';
        var n = this._start;
        function packStr() {
          if (str.length > 0) {
            // pack str with attributes to ops
            var attributes = {};
            var addAttributes = false;
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = currentAttributes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var _step4$value = slicedToArray(_step4.value, 2),
                    key = _step4$value[0],
                    value = _step4$value[1];

                addAttributes = true;
                attributes[key] = value;
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            var op = { insert: str };
            if (addAttributes) {
              op.attributes = attributes;
            }
            ops.push(op);
            str = '';
          }
        }
        while (n !== null) {
          if (!n._deleted) {
            switch (n.constructor) {
              case ItemString:
                str += n._content;
                break;
              case ItemFormat:
                packStr();
                updateCurrentAttributes(currentAttributes, n);
                break;
            }
          }
          n = n._right;
        }
        packStr();
        return ops;
      }

      /**
       * Insert text at a given index.
       *
       * @param {Integer} index The index at which to start inserting.
       * @param {String} text The text to insert at the specified position.
       * @param {TextAttributes} attributes Optionally define some formatting
       *                                    information to apply on the inserted
       *                                    Text.
       *
       * @public
       */

    }, {
      key: 'insert',
      value: function insert(index, text) {
        var _this5 = this;

        var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (text.length <= 0) {
          return;
        }
        this._transact(function (y) {
          var _findPosition = findPosition(_this5, index),
              _findPosition2 = slicedToArray(_findPosition, 3),
              left = _findPosition2[0],
              right = _findPosition2[1],
              currentAttributes = _findPosition2[2];

          insertText(y, text, _this5, left, right, currentAttributes, attributes);
        });
      }

      /**
       * Inserts an embed at a index.
       *
       * @param {Integer} index The index to insert the embed at.
       * @param {Object} embed The Object that represents the embed.
       * @param {TextAttributes} attributes Attribute information to apply on the
       *                                    embed
       *
       * @public
       */

    }, {
      key: 'insertEmbed',
      value: function insertEmbed(index, embed) {
        var _this6 = this;

        var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (embed.constructor !== Object) {
          throw new Error('Embed must be an Object');
        }
        this._transact(function (y) {
          var _findPosition3 = findPosition(_this6, index),
              _findPosition4 = slicedToArray(_findPosition3, 3),
              left = _findPosition4[0],
              right = _findPosition4[1],
              currentAttributes = _findPosition4[2];

          insertText(y, embed, _this6, left, right, currentAttributes, attributes);
        });
      }

      /**
       * Deletes text starting from an index.
       *
       * @param {Integer} index Index at which to start deleting.
       * @param {Integer} length The number of characters to remove. Defaults to 1.
       *
       * @public
       */

    }, {
      key: 'delete',
      value: function _delete(index, length) {
        var _this7 = this;

        if (length === 0) {
          return;
        }
        this._transact(function (y) {
          var _findPosition5 = findPosition(_this7, index),
              _findPosition6 = slicedToArray(_findPosition5, 3),
              left = _findPosition6[0],
              right = _findPosition6[1],
              currentAttributes = _findPosition6[2];

          deleteText(y, length, _this7, left, right, currentAttributes);
        });
      }

      /**
       * Assigns properties to a range of text.
       *
       * @param {Integer} index The position where to start formatting.
       * @param {Integer} length The amount of characters to assign properties to.
       * @param {TextAttributes} attributes Attribute information to apply on the
       *                                    text.
       *
       * @public
       */

    }, {
      key: 'format',
      value: function format(index, length, attributes) {
        var _this8 = this;

        this._transact(function (y) {
          var _findPosition7 = findPosition(_this8, index),
              _findPosition8 = slicedToArray(_findPosition7, 3),
              left = _findPosition8[0],
              right = _findPosition8[1],
              currentAttributes = _findPosition8[2];

          if (right === null) {
            return;
          }
          formatText(y, length, _this8, left, right, currentAttributes, attributes);
        });
      }
      // TODO: De-duplicate code. The following code is in every type.
      /**
       * Transform this YText to a readable format.
       * Useful for logging as all Items implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('YText', this);
      }
    }]);
    return YText;
  }(YArray);

  /**
   * You can manage binding to a custom type with YXmlHook.
   *
   * @public
   */

  var YXmlHook = function (_YMap) {
    inherits(YXmlHook, _YMap);

    /**
     * @param {String} hookName nodeName of the Dom Node.
     */
    function YXmlHook(hookName) {
      classCallCheck(this, YXmlHook);

      var _this = possibleConstructorReturn(this, (YXmlHook.__proto__ || Object.getPrototypeOf(YXmlHook)).call(this));

      _this.hookName = null;
      if (hookName !== undefined) {
        _this.hookName = hookName;
      }
      return _this;
    }

    /**
     * Creates an Item with the same effect as this Item (without position effect)
     *
     * @private
     */


    createClass(YXmlHook, [{
      key: '_copy',
      value: function _copy() {
        var struct = get(YXmlHook.prototype.__proto__ || Object.getPrototypeOf(YXmlHook.prototype), '_copy', this).call(this);
        struct.hookName = this.hookName;
        return struct;
      }

      /**
       * Creates a Dom Element that mirrors this YXmlElement.
       *
       * @param {Document} [_document=document] The document object (you must define
       *                                        this when calling this method in
       *                                        nodejs)
       * @param {Object<key:hookDefinition>} [hooks] Optional property to customize how hooks
       *                                             are presented in the DOM
       * @param {DomBinding} [binding] You should not set this property. This is
       *                               used if DomBinding wants to create a
       *                               association to the created DOM type
       * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
       *
       * @public
       */

    }, {
      key: 'toDom',
      value: function toDom() {

        var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var binding = arguments[2];

        var hook = hooks[this.hookName];
        var dom = void 0;
        if (hook !== undefined) {
          dom = hook.createDom(this);
        } else {
          dom = document.createElement(this.hookName);
        }
        dom.setAttribute('data-yjs-hook', this.hookName);
        createAssociation(binding, dom, this);
        return dom;
      }

      /**
       * Read the next Item in a Decoder and fill this Item with the read data.
       *
       * This is called when data is received from a remote peer.
       *
       * @param {Y} y The Yjs instance that this Item belongs to.
       * @param {BinaryDecoder} decoder The decoder object to read data from.
       *
       * @private
       */

    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(YXmlHook.prototype.__proto__ || Object.getPrototypeOf(YXmlHook.prototype), '_fromBinary', this).call(this, y, decoder);
        this.hookName = decoder.readVarString();
        return missing;
      }

      /**
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       *
       * @param {BinaryEncoder} encoder The encoder to write data to.
       *
       * @private
       */

    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(YXmlHook.prototype.__proto__ || Object.getPrototypeOf(YXmlHook.prototype), '_toBinary', this).call(this, encoder);
        encoder.writeVarString(this.hookName);
      }

      /**
       * Integrate this type into the Yjs instance.
       *
       * * Save this struct in the os
       * * This type is sent to other client
       * * Observer functions are fired
       *
       * @param {Y} y The Yjs instance
       *
       * @private
       */

    }, {
      key: '_integrate',
      value: function _integrate(y) {
        if (this.hookName === null) {
          throw new Error('hookName must be defined!');
        }
        get(YXmlHook.prototype.__proto__ || Object.getPrototypeOf(YXmlHook.prototype), '_integrate', this).call(this, y);
      }
    }]);
    return YXmlHook;
  }(YMap);

  /**
   * Define the elements to which a set of CSS queries apply.
   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
   *
   * @example
   *   query = '.classSelector'
   *   query = 'nodeSelector'
   *   query = '#idSelector'
   *
   * @typedef {string} CSS_Selector
   */

  /**
   * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a
   * position within them.
   *
   * Can be created with {@link YXmlFragment#createTreeWalker}
   *
   * @public
   */

  var YXmlTreeWalker = function () {
    function YXmlTreeWalker(root, f) {
      classCallCheck(this, YXmlTreeWalker);

      this._filter = f || function () {
        return true;
      };
      this._root = root;
      this._currentNode = root;
      this._firstCall = true;
    }

    createClass(YXmlTreeWalker, [{
      key: Symbol.iterator,
      value: function value() {
        return this;
      }
      /**
       * Get the next node.
       *
       * @return {YXmlElement} The next node.
       *
       * @public
       */

    }, {
      key: 'next',
      value: function next() {
        var n = this._currentNode;
        if (this._firstCall) {
          this._firstCall = false;
          if (!n._deleted && this._filter(n)) {
            return { value: n, done: false };
          }
        }
        do {
          if (!n._deleted && (n.constructor === YXmlFragment._YXmlElement || n.constructor === YXmlFragment) && n._start !== null) {
            // walk down in the tree
            n = n._start;
          } else {
            // walk right or up in the tree
            while (n !== this._root) {
              if (n._right !== null) {
                n = n._right;
                break;
              }
              n = n._parent;
            }
            if (n === this._root) {
              n = null;
            }
          }
          if (n === this._root) {
            break;
          }
        } while (n !== null && (n._deleted || !this._filter(n)));
        this._currentNode = n;
        if (n === null) {
          return { done: true };
        } else {
          return { value: n, done: false };
        }
      }
    }]);
    return YXmlTreeWalker;
  }();

  /**
   * An Event that describes changes on a YXml Element or Yxml Fragment
   *
   * @protected
   */

  var YXmlEvent = function (_YEvent) {
    inherits(YXmlEvent, _YEvent);

    /**
     * @param {YType} target The target on which the event is created.
     * @param {Set} subs The set of changed attributes. `null` is included if the
     *                   child list changed.
     * @param {Boolean} remote Whether this change was created by a remote peer.
     * @param {Transaction} transaction The transaction instance with wich the
     *                                  change was created.
     */
    function YXmlEvent(target, subs, remote, transaction) {
      classCallCheck(this, YXmlEvent);

      /**
       * The transaction instance for the computed change.
       * @type {Transaction}
       */
      var _this = possibleConstructorReturn(this, (YXmlEvent.__proto__ || Object.getPrototypeOf(YXmlEvent)).call(this, target));

      _this._transaction = transaction;
      /**
       * Whether the children changed.
       * @type {Boolean}
       */
      _this.childListChanged = false;
      /**
       * Set of all changed attributes.
       * @type {Set}
       */
      _this.attributesChanged = new Set();
      /**
       * Whether this change was created by a remote peer.
       * @type {Boolean}
       */
      _this.remote = remote;
      subs.forEach(function (sub) {
        if (sub === null) {
          _this.childListChanged = true;
        } else {
          _this.attributesChanged.add(sub);
        }
      });
      return _this;
    }

    return YXmlEvent;
  }(YEvent);

  /**
   * Dom filter function.
   *
   * @callback domFilter
   * @param {string} nodeName The nodeName of the element
   * @param {Map} attributes The map of attributes.
   * @return {boolean} Whether to include the Dom node in the YXmlElement.
   */

  /**
   * Define the elements to which a set of CSS queries apply.
   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
   *
   * @example
   *   query = '.classSelector'
   *   query = 'nodeSelector'
   *   query = '#idSelector'
   *
   * @typedef {string} CSS_Selector
   */

  /**
   * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.
   * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a
   * nodeName and it does not have attributes. Though it can be bound to a DOM
   * element - in this case the attributes and the nodeName are not shared.
   *
   * @public
   */

  var YXmlFragment = function (_YArray) {
    inherits(YXmlFragment, _YArray);

    function YXmlFragment() {
      classCallCheck(this, YXmlFragment);
      return possibleConstructorReturn(this, (YXmlFragment.__proto__ || Object.getPrototypeOf(YXmlFragment)).apply(this, arguments));
    }

    createClass(YXmlFragment, [{
      key: 'createTreeWalker',

      /**
       * Create a subtree of childNodes.
       *
       * @example
       * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
       * for (let node in walker) {
       *   // `node` is a div node
       *   nop(node)
       * }
       *
       * @param {Function} filter Function that is called on each child element and
       *                          returns a Boolean indicating whether the child
       *                          is to be included in the subtree.
       * @return {TreeWalker} A subtree and a position within it.
       *
       * @public
       */
      value: function createTreeWalker(filter) {
        return new YXmlTreeWalker(this, filter);
      }

      /**
       * Returns the first YXmlElement that matches the query.
       * Similar to DOM's {@link querySelector}.
       *
       * Query support:
       *   - tagname
       * TODO:
       *   - id
       *   - attribute
       *
       * @param {CSS_Selector} query The query on the children.
       * @return {?YXmlElement} The first element that matches the query or null.
       *
       * @public
       */

    }, {
      key: 'querySelector',
      value: function querySelector(query) {
        query = query.toUpperCase();
        var iterator = new YXmlTreeWalker(this, function (element) {
          return element.nodeName === query;
        });
        var next = iterator.next();
        if (next.done) {
          return null;
        } else {
          return next.value;
        }
      }

      /**
       * Returns all YXmlElements that match the query.
       * Similar to Dom's {@link querySelectorAll}.
       *
       * TODO: Does not yet support all queries. Currently only query by tagName.
       *
       * @param {CSS_Selector} query The query on the children
       * @return {Array<YXmlElement>} The elements that match this query.
       *
       * @public
       */

    }, {
      key: 'querySelectorAll',
      value: function querySelectorAll(query) {
        query = query.toUpperCase();
        return Array.from(new YXmlTreeWalker(this, function (element) {
          return element.nodeName === query;
        }));
      }

      /**
       * Creates YArray Event and calls observers.
       *
       * @private
       */

    }, {
      key: '_callObserver',
      value: function _callObserver(transaction, parentSubs, remote) {
        this._callEventHandler(transaction, new YXmlEvent(this, parentSubs, remote, transaction));
      }

      /**
       * Get the string representation of all the children of this YXmlFragment.
       *
       * @return {string} The string representation of all children.
       */

    }, {
      key: 'toString',
      value: function toString() {
        return this.map(function (xml) {
          return xml.toString();
        }).join('');
      }

      /**
       * @private
       * Unbind from Dom and mark this Item as deleted.
       *
       * @param {Y} y The Yjs instance
       * @param {boolean} createDelete Whether to propagate a message that this
       *                               Type was deleted.
       * @param {boolean} [gcChildren=y._hasUndoManager===false] Whether to garbage
       *                                         collect the children of this type.
       *
       * @private
       */

    }, {
      key: '_delete',
      value: function _delete(y, createDelete, gcChildren) {
        get(YXmlFragment.prototype.__proto__ || Object.getPrototypeOf(YXmlFragment.prototype), '_delete', this).call(this, y, createDelete, gcChildren);
      }

      /**
       * Creates a Dom Element that mirrors this YXmlElement.
       *
       * @param {Document} [_document=document] The document object (you must define
       *                                        this when calling this method in
       *                                        nodejs)
       * @param {Object<key:hookDefinition>} [hooks={}] Optional property to customize how hooks
       *                                             are presented in the DOM
       * @param {DomBinding} [binding] You should not set this property. This is
       *                               used if DomBinding wants to create a
       *                               association to the created DOM type
       * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
       *
       * @public
       */

    }, {
      key: 'toDom',
      value: function toDom() {
        var _document = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

        var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var binding = arguments[2];

        var fragment = _document.createDocumentFragment();
        createAssociation(binding, fragment, this);
        this.forEach(function (xmlType) {
          fragment.insertBefore(xmlType.toDom(_document, hooks, binding), null);
        });
        return fragment;
      }
      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('YXml', this);
      }
    }]);
    return YXmlFragment;
  }(YArray);

  /**
   * An YXmlElement imitates the behavior of a
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.
   *
   * * An YXmlElement has attributes (key value pairs)
   * * An YXmlElement has childElements that must inherit from YXmlElement
   *
   * @param {String} nodeName Node name
   */

  var YXmlElement = function (_YXmlFragment) {
    inherits(YXmlElement, _YXmlFragment);

    function YXmlElement() {
      var nodeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'UNDEFINED';
      classCallCheck(this, YXmlElement);

      var _this = possibleConstructorReturn(this, (YXmlElement.__proto__ || Object.getPrototypeOf(YXmlElement)).call(this));

      _this.nodeName = nodeName.toUpperCase();
      return _this;
    }

    /**
     * @private
     * Creates an Item with the same effect as this Item (without position effect)
     */


    createClass(YXmlElement, [{
      key: '_copy',
      value: function _copy() {
        var struct = get(YXmlElement.prototype.__proto__ || Object.getPrototypeOf(YXmlElement.prototype), '_copy', this).call(this);
        struct.nodeName = this.nodeName;
        return struct;
      }

      /**
       * @private
       * Read the next Item in a Decoder and fill this Item with the read data.
       *
       * This is called when data is received from a remote peer.
       *
       * @param {Y} y The Yjs instance that this Item belongs to.
       * @param {BinaryDecoder} decoder The decoder object to read data from.
       */

    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(YXmlElement.prototype.__proto__ || Object.getPrototypeOf(YXmlElement.prototype), '_fromBinary', this).call(this, y, decoder);
        this.nodeName = decoder.readVarString();
        return missing;
      }

      /**
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       *
       * @param {BinaryEncoder} encoder The encoder to write data to.
       *
       * @private
       */

    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(YXmlElement.prototype.__proto__ || Object.getPrototypeOf(YXmlElement.prototype), '_toBinary', this).call(this, encoder);
        encoder.writeVarString(this.nodeName);
      }

      /**
       * Integrates this Item into the shared structure.
       *
       * This method actually applies the change to the Yjs instance. In case of
       * Item it connects _left and _right to this Item and calls the
       * {@link Item#beforeChange} method.
       *
       * * Checks for nodeName
       * * Sets domFilter
       *
       * @param {Y} y The Yjs instance
       *
       * @private
       */

    }, {
      key: '_integrate',
      value: function _integrate(y) {
        if (this.nodeName === null) {
          throw new Error('nodeName must be defined!');
        }
        get(YXmlElement.prototype.__proto__ || Object.getPrototypeOf(YXmlElement.prototype), '_integrate', this).call(this, y);
      }

      /**
       * Returns the string representation of this YXmlElement.
       * The attributes are ordered by attribute-name, so you can easily use this
       * method to compare YXmlElements
       *
       * @return {String} The string representation of this type.
       *
       * @public
       */

    }, {
      key: 'toString',
      value: function toString() {
        var attrs = this.getAttributes();
        var stringBuilder = [];
        var keys = [];
        for (var key in attrs) {
          keys.push(key);
        }
        keys.sort();
        var keysLen = keys.length;
        for (var i = 0; i < keysLen; i++) {
          var _key = keys[i];
          stringBuilder.push(_key + '="' + attrs[_key] + '"');
        }
        var nodeName = this.nodeName.toLocaleLowerCase();
        var attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';
        return '<' + nodeName + attrsString + '>' + get(YXmlElement.prototype.__proto__ || Object.getPrototypeOf(YXmlElement.prototype), 'toString', this).call(this) + '</' + nodeName + '>';
      }

      /**
       * Removes an attribute from this YXmlElement.
       *
       * @param {String} attributeName The attribute name that is to be removed.
       *
       * @public
       */

    }, {
      key: 'removeAttribute',
      value: function removeAttribute(attributeName) {
        return YMap.prototype.delete.call(this, attributeName);
      }

      /**
       * Sets or updates an attribute.
       *
       * @param {String} attributeName The attribute name that is to be set.
       * @param {String} attributeValue The attribute value that is to be set.
       *
       * @public
       */

    }, {
      key: 'setAttribute',
      value: function setAttribute(attributeName, attributeValue) {
        return YMap.prototype.set.call(this, attributeName, attributeValue);
      }

      /**
       * Returns an attribute value that belongs to the attribute name.
       *
       * @param {String} attributeName The attribute name that identifies the
       *                               queried value.
       * @return {String} The queried attribute value.
       *
       * @public
       */

    }, {
      key: 'getAttribute',
      value: function getAttribute(attributeName) {
        return YMap.prototype.get.call(this, attributeName);
      }

      /**
       * Returns all attribute name/value pairs in a JSON Object.
       *
       * @return {Object} A JSON Object that describes the attributes.
       *
       * @public
       */

    }, {
      key: 'getAttributes',
      value: function getAttributes() {
        var obj = {};
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._map[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = slicedToArray(_step.value, 2),
                key = _step$value[0],
                value = _step$value[1];

            if (!value._deleted) {
              obj[key] = value._content[0];
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return obj;
      }
      // TODO: outsource the binding property.
      /**
       * Creates a Dom Element that mirrors this YXmlElement.
       *
       * @param {Document} [_document=document] The document object (you must define
       *                                        this when calling this method in
       *                                        nodejs)
       * @param {Object<key:hookDefinition>} [hooks={}] Optional property to customize how hooks
       *                                             are presented in the DOM
       * @param {DomBinding} [binding] You should not set this property. This is
       *                               used if DomBinding wants to create a
       *                               association to the created DOM type.
       * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
       *
       * @public
       */

    }, {
      key: 'toDom',
      value: function toDom() {
        var _document = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

        var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var binding = arguments[2];

        var dom = _document.createElement(this.nodeName);
        var attrs = this.getAttributes();
        for (var key in attrs) {
          dom.setAttribute(key, attrs[key]);
        }
        this.forEach(function (yxml) {
          dom.appendChild(yxml.toDom(_document, hooks, binding));
        });
        createAssociation(binding, dom, this);
        return dom;
      }
    }]);
    return YXmlElement;
  }(YXmlFragment);


  YXmlFragment._YXmlElement = YXmlElement;

  /**
   * Check if `parent` is a parent of `child`.
   *
   * @param {Type} parent
   * @param {Type} child
   * @return {Boolean} Whether `parent` is a parent of `child`.
   *
   * @public
   */
  function isParentOf(parent, child) {
    child = child._parent;
    while (child !== null) {
      if (child === parent) {
        return true;
      }
      child = child._parent;
    }
    return false;
  }

  /**
   * Default filter method (does nothing).
   *
   * @param {String} nodeName The nodeName of the element
   * @param {Map} attrs Map of key-value pairs that are attributes of the node.
   * @return {Map | null} The allowed attributes or null, if the element should be
   *                      filtered.
   */
  function defaultFilter(nodeName, attrs) {
    // TODO: implement basic filter that filters out dangerous properties!
    return attrs;
  }

  /**
   *
   */
  function filterDomAttributes(dom, filter) {
    var attrs = new Map();
    for (var i = dom.attributes.length - 1; i >= 0; i--) {
      var attr = dom.attributes[i];
      attrs.set(attr.name, attr.value);
    }
    return filter(dom.nodeName, attrs);
  }

  /**
   * Applies a filter on a type.
   *
   * @param {Y} y The Yjs instance.
   * @param {DomBinding} binding The DOM binding instance that has the dom filter.
   * @param {YXmlElement | YXmlFragment } type The type to apply the filter to.
   *
   * @private
   */
  function applyFilterOnType(y, binding, type) {
    if (isParentOf(binding.type, type)) {
      var nodeName = type.nodeName;
      var attributes = new Map();
      if (type.getAttributes !== undefined) {
        var attrs = type.getAttributes();
        for (var key in attrs) {
          attributes.set(key, attrs[key]);
        }
      }
      var filteredAttributes = binding.filter(nodeName, new Map(attributes));
      if (filteredAttributes === null) {
        type._delete(y);
      } else {
        // iterate original attributes
        attributes.forEach(function (value, key) {
          // delete all attributes that are not in filteredAttributes
          if (filteredAttributes.has(key) === false) {
            type.removeAttribute(key);
          }
        });
      }
    }
  }

  /**
   * Creates a Yjs type (YXml) based on the contents of a DOM Element.
   *
   * @param {Element|TextNode} element The DOM Element
   * @param {?Document} _document Optional. Provide the global document object
   * @param {Hooks} [hooks = {}] Optional. Set of Yjs Hooks
   * @param {Filter} [filter=defaultFilter] Optional. Dom element filter
   * @param {?DomBinding} binding Warning: This property is for internal use only!
   * @return {YXmlElement | YXmlText}
   */
  function domToType(element) {
    var _document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

    var hooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var filter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultFilter;
    var binding = arguments[4];

    var type = void 0;
    switch (element.nodeType) {
      case _document.ELEMENT_NODE:
        var hookName = null;
        var hook = void 0;
        // configure `hookName !== undefined` if element is a hook.
        if (element.hasAttribute('data-yjs-hook')) {
          hookName = element.getAttribute('data-yjs-hook');
          hook = hooks[hookName];
          if (hook === undefined) {
            console.error('Unknown hook "' + hookName + '". Deleting yjsHook dataset property.');
            delete element.removeAttribute('data-yjs-hook');
            hookName = null;
          }
        }
        if (hookName === null) {
          // Not a hook
          var attrs = filterDomAttributes(element, filter);
          if (attrs === null) {
            type = false;
          } else {
            type = new YXmlElement(element.nodeName);
            attrs.forEach(function (val, key) {
              type.setAttribute(key, val);
            });
            type.insert(0, domsToTypes(element.childNodes, document, hooks, filter, binding));
          }
        } else {
          // Is a hook
          type = new YXmlHook(hookName);
          hook.fillType(element, type);
        }
        break;
      case _document.TEXT_NODE:
        type = new YXmlText();
        type.insert(0, element.nodeValue);
        break;
      default:
        throw new Error('Can\'t transform this node type to a YXml type!');
    }
    createAssociation(binding, element, type);
    return type;
  }

  /**
   * Iterates items until an undeleted item is found.
   *
   * @private
   */
  function iterateUntilUndeleted(item) {
    while (item !== null && item._deleted) {
      item = item._right;
    }
    return item;
  }

  /**
   * Removes an association (the information that a DOM element belongs to a
   * type).
   *
   * @param {DomBinding} domBinding The binding object
   * @param {Element} dom The dom that is to be associated with type
   * @param {YXmlElement|YXmlHook} type The type that is to be associated with dom
   *
   */
  function removeAssociation(domBinding, dom, type) {
    domBinding.domToType.delete(dom);
    domBinding.typeToDom.delete(type);
  }

  /**
   * Creates an association (the information that a DOM element belongs to a
   * type).
   *
   * @param {DomBinding} domBinding The binding object
   * @param {Element} dom The dom that is to be associated with type
   * @param {YXmlElement|YXmlHook} type The type that is to be associated with dom
   *
   */
  function createAssociation(domBinding, dom, type) {
    if (domBinding !== undefined) {
      domBinding.domToType.set(dom, type);
      domBinding.typeToDom.set(type, dom);
    }
  }

  /**
   * If oldDom is associated with a type, associate newDom with the type and
   * forget about oldDom. If oldDom is not associated with any type, nothing happens.
   *
   * @param {DomBinding} domBinding The binding object
   * @param {Element} oldDom The existing dom
   * @param {Element} newDom The new dom object
   */
  function switchAssociation(domBinding, oldDom, newDom) {
    if (domBinding !== undefined) {
      var type = domBinding.domToType.get(oldDom);
      if (type !== undefined) {
        removeAssociation(domBinding, oldDom, type);
        createAssociation(domBinding, newDom, type);
      }
    }
  }

  /**
   * Insert Dom Elements after one of the children of this YXmlFragment.
   * The Dom elements will be bound to a new YXmlElement and inserted at the
   * specified position.
   *
   * @param {YXmlElement} type The type in which to insert DOM elements.
   * @param {YXmlElement|null} prev The reference node. New YxmlElements are
   *                           inserted after this node. Set null to insert at
   *                           the beginning.
   * @param {Array<Element>} doms The Dom elements to insert.
   * @param {?Document} _document Optional. Provide the global document object.
   * @param {DomBinding} binding The dom binding
   * @return {Array<YXmlElement>} The YxmlElements that are inserted.
   *
   * @private
   */
  function insertDomElementsAfter(type, prev, doms, _document, binding) {
    var types = domsToTypes(doms, _document, binding.opts.hooks, binding.filter, binding);
    return type.insertAfter(prev, types);
  }

  function domsToTypes(doms, _document, hooks, filter, binding) {
    var types = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = doms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var dom = _step.value;

        var t = domToType(dom, _document, hooks, filter, binding);
        if (t !== false) {
          types.push(t);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return types;
  }

  /**
   * @private
   */
  function insertNodeHelper(yxml, prevExpectedNode, child, _document, binding) {
    var insertedNodes = insertDomElementsAfter(yxml, prevExpectedNode, [child], _document, binding);
    if (insertedNodes.length > 0) {
      return insertedNodes[0];
    } else {
      return prevExpectedNode;
    }
  }

  /**
   * Remove children until `elem` is found.
   *
   * @param {Element} parent The parent of `elem` and `currentChild`.
   * @param {Element} currentChild Start removing elements with `currentChild`. If
   *                               `currentChild` is `elem` it won't be removed.
   * @param {Element|null} elem The elemnt to look for.
   *
   * @private
   */
  function removeDomChildrenUntilElementFound(parent, currentChild, elem) {
    while (currentChild !== elem) {
      var del = currentChild;
      currentChild = currentChild.nextSibling;
      parent.removeChild(del);
    }
  }

  /**
   * Represents text in a Dom Element. In the future this type will also handle
   * simple formatting information like bold and italic.
   *
   * @param {String} arg1 Initial value.
   */

  var YXmlText = function (_YText) {
    inherits(YXmlText, _YText);

    function YXmlText() {
      classCallCheck(this, YXmlText);
      return possibleConstructorReturn(this, (YXmlText.__proto__ || Object.getPrototypeOf(YXmlText)).apply(this, arguments));
    }

    createClass(YXmlText, [{
      key: 'toDom',

      /**
       * Creates a Dom Element that mirrors this YXmlText.
       *
       * @param {Document} [_document=document] The document object (you must define
       *                                        this when calling this method in
       *                                        nodejs)
       * @param {Object<key:hookDefinition>} [hooks] Optional property to customize how hooks
       *                                             are presented in the DOM
       * @param {DomBinding} [binding] You should not set this property. This is
       *                               used if DomBinding wants to create a
       *                               association to the created DOM type.
       * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
       *
       * @public
       */
      value: function toDom() {
        var _document = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
        var binding = arguments[2];

        var dom = _document.createTextNode(this.toString());
        createAssociation(binding, dom, this);
        return dom;
      }

      /**
       * Mark this Item as deleted.
       *
       * @param {Y} y The Yjs instance
       * @param {boolean} createDelete Whether to propagate a message that this
       *                               Type was deleted.
       * @param {boolean} [gcChildren=y._hasUndoManager===false] Whether to garbage
       *                                         collect the children of this type.
       *
       * @private
       */

    }, {
      key: '_delete',
      value: function _delete(y, createDelete, gcChildren) {
        get(YXmlText.prototype.__proto__ || Object.getPrototypeOf(YXmlText.prototype), '_delete', this).call(this, y, createDelete, gcChildren);
      }
    }]);
    return YXmlText;
  }(YText);

  var structs = new Map();
  var references = new Map();

  /**
   * Register a new Yjs types. The same type must be defined with the same
   * reference on all clients!
   *
   * @param {Number} reference
   * @param {class} structConstructor
   *
   * @public
   */
  function registerStruct(reference, structConstructor) {
    structs.set(reference, structConstructor);
    references.set(structConstructor, reference);
  }

  /**
   * @private
   */
  function getStruct(reference) {
    return structs.get(reference);
  }

  /**
   * @private
   */
  function getStructReference(typeConstructor) {
    return references.get(typeConstructor);
  }

  // TODO: reorder (Item* should have low numbers)
  registerStruct(0, ItemJSON);
  registerStruct(1, ItemString);
  registerStruct(10, ItemFormat);
  registerStruct(11, ItemEmbed);
  registerStruct(2, Delete);

  registerStruct(3, YArray);
  registerStruct(4, YMap);
  registerStruct(5, YText);
  registerStruct(6, YXmlFragment);
  registerStruct(7, YXmlElement);
  registerStruct(8, YXmlText);
  registerStruct(9, YXmlHook);

  registerStruct(12, GC);

  var RootFakeUserID = 0xFFFFFF;

  var RootID = function () {
    function RootID(name, typeConstructor) {
      classCallCheck(this, RootID);

      this.user = RootFakeUserID;
      this.name = name;
      this.type = getStructReference(typeConstructor);
    }

    createClass(RootID, [{
      key: 'equals',
      value: function equals(id) {
        return id !== null && id.user === this.user && id.name === this.name && id.type === this.type;
      }
    }, {
      key: 'lessThan',
      value: function lessThan(id) {
        if (id.constructor === RootID) {
          return this.user < id.user || this.user === id.user && (this.name < id.name || this.name === id.name && this.type < id.type);
        } else {
          return true;
        }
      }
    }]);
    return RootID;
  }();

  var OperationStore = function (_Tree) {
    inherits(OperationStore, _Tree);

    function OperationStore(y) {
      classCallCheck(this, OperationStore);

      var _this = possibleConstructorReturn(this, (OperationStore.__proto__ || Object.getPrototypeOf(OperationStore)).call(this));

      _this.y = y;
      return _this;
    }

    createClass(OperationStore, [{
      key: 'logTable',
      value: function logTable() {
        var items = [];
        this.iterate(null, null, function (item) {
          if (item.constructor === GC) {
            items.push({
              id: logID(item),
              content: item._length,
              deleted: 'GC'
            });
          } else {
            items.push({
              id: logID(item),
              origin: logID(item._origin === null ? null : item._origin._lastId),
              left: logID(item._left === null ? null : item._left._lastId),
              right: logID(item._right),
              right_origin: logID(item._right_origin),
              parent: logID(item._parent),
              parentSub: item._parentSub,
              deleted: item._deleted,
              content: JSON.stringify(item._content)
            });
          }
        });
        console.table(items);
      }
    }, {
      key: 'get',
      value: function get$$1(id) {
        var struct = this.find(id);
        if (struct === null && id instanceof RootID) {
          var Constr = getStruct(id.type);
          var y = this.y;
          struct = new Constr();
          struct._id = id;
          struct._parent = y;
          y.transact(function () {
            struct._integrate(y);
          });
          this.put(struct);
        }
        return struct;
      }
      // Use getItem for structs with _length > 1

    }, {
      key: 'getItem',
      value: function getItem(id) {
        var item = this.findWithUpperBound(id);
        if (item === null) {
          return null;
        }
        var itemID = item._id;
        if (id.user === itemID.user && id.clock < itemID.clock + item._length) {
          return item;
        } else {
          return null;
        }
      }
      // Return an insertion such that id is the first element of content
      // This function manipulates an item, if necessary

    }, {
      key: 'getItemCleanStart',
      value: function getItemCleanStart(id) {
        var ins = this.getItem(id);
        if (ins === null || ins._length === 1) {
          return ins;
        }
        var insID = ins._id;
        if (insID.clock === id.clock) {
          return ins;
        } else {
          return ins._splitAt(this.y, id.clock - insID.clock);
        }
      }
      // Return an insertion such that id is the last element of content
      // This function manipulates an operation, if necessary

    }, {
      key: 'getItemCleanEnd',
      value: function getItemCleanEnd(id) {
        var ins = this.getItem(id);
        if (ins === null || ins._length === 1) {
          return ins;
        }
        var insID = ins._id;
        if (insID.clock + ins._length - 1 === id.clock) {
          return ins;
        } else {
          ins._splitAt(this.y, id.clock - insID.clock + 1);
          return ins;
        }
      }
    }]);
    return OperationStore;
  }(Tree);

  var StateStore = function () {
    function StateStore(y) {
      classCallCheck(this, StateStore);

      this.y = y;
      this.state = new Map();
    }

    createClass(StateStore, [{
      key: 'logTable',
      value: function logTable() {
        var entries = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.state[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = slicedToArray(_step.value, 2),
                user = _step$value[0],
                state = _step$value[1];

            entries.push({
              user: user, state: state
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        console.table(entries);
      }
    }, {
      key: 'getNextID',
      value: function getNextID(len) {
        var user = this.y.userID;
        var state = this.getState(user);
        this.setState(user, state + len);
        return new ID(user, state);
      }
    }, {
      key: 'updateRemoteState',
      value: function updateRemoteState(struct) {
        var user = struct._id.user;
        var userState = this.state.get(user);
        while (struct !== null && struct._id.clock === userState) {
          userState += struct._length;
          struct = this.y.os.get(new ID(user, userState));
        }
        this.state.set(user, userState);
      }
    }, {
      key: 'getState',
      value: function getState(user) {
        var state = this.state.get(user);
        if (state == null) {
          return 0;
        }
        return state;
      }
    }, {
      key: 'setState',
      value: function setState(user, state) {
        // TODO: modify missingi structs here
        var beforeState = this.y._transaction.beforeState;
        if (!beforeState.has(user)) {
          beforeState.set(user, this.getState(user));
        }
        this.state.set(user, state);
      }
    }]);
    return StateStore;
  }();

  /* global crypto */

  function generateRandomUint32() {
    if (typeof crypto !== 'undefined' && crypto.getRandomValue != null) {
      // browser
      var arr = new Uint32Array(1);
      crypto.getRandomValues(arr);
      return arr[0];
    } else if (typeof crypto !== 'undefined' && crypto.randomBytes != null) {
      // node
      var buf = crypto.randomBytes(4);
      return new Uint32Array(buf.buffer)[0];
    } else {
      return Math.ceil(Math.random() * 0xFFFFFFFF);
    }
  }

  /**
   * Handles named events.
   */
  var NamedEventHandler = function () {
    function NamedEventHandler() {
      classCallCheck(this, NamedEventHandler);

      this._eventListener = new Map();
      this._stateListener = new Map();
    }

    /**
     * @private
     * Returns all listeners that listen to a specified name.
     *
     * @param {String} name The query event name.
     */


    createClass(NamedEventHandler, [{
      key: '_getListener',
      value: function _getListener(name) {
        var listeners = this._eventListener.get(name);
        if (listeners === undefined) {
          listeners = {
            once: new Set(),
            on: new Set()
          };
          this._eventListener.set(name, listeners);
        }
        return listeners;
      }

      /**
       * Adds a named event listener. The listener is removed after it has been
       * called once.
       *
       * @param {String} name The event name to listen to.
       * @param {Function} f The function that is executed when the event is fired.
       */

    }, {
      key: 'once',
      value: function once(name, f) {
        var listeners = this._getListener(name);
        listeners.once.add(f);
      }

      /**
       * Adds a named event listener.
       *
       * @param {String} name The event name to listen to.
       * @param {Function} f The function that is executed when the event is fired.
       */

    }, {
      key: 'on',
      value: function on(name, f) {
        var listeners = this._getListener(name);
        listeners.on.add(f);
      }

      /**
       * @private
       * Init the saved state for an event name.
       */

    }, {
      key: '_initStateListener',
      value: function _initStateListener(name) {
        var state = this._stateListener.get(name);
        if (state === undefined) {
          state = {};
          state.promise = new Promise(function (resolve) {
            state.resolve = resolve;
          });
          this._stateListener.set(name, state);
        }
        return state;
      }

      /**
       * Returns a Promise that is resolved when the event name is called.
       * The Promise is immediately resolved when the event name was called in the
       * past.
       */

    }, {
      key: 'when',
      value: function when(name) {
        return this._initStateListener(name).promise;
      }

      /**
       * Remove an event listener that was registered with either
       * {@link EventHandler#on} or {@link EventHandler#once}.
       */

    }, {
      key: 'off',
      value: function off(name, f) {
        if (name == null || f == null) {
          throw new Error('You must specify event name and function!');
        }
        var listener = this._eventListener.get(name);
        if (listener !== undefined) {
          listener.on.delete(f);
          listener.once.delete(f);
        }
      }

      /**
       * Emit a named event. All registered event listeners that listen to the
       * specified name will receive the event.
       *
       * @param {String} name The event name.
       * @param {Array} args The arguments that are applied to the event listener.
       */

    }, {
      key: 'emit',
      value: function emit(name) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        this._initStateListener(name).resolve();
        var listener = this._eventListener.get(name);
        if (listener !== undefined) {
          listener.on.forEach(function (f) {
            return f.apply(null, args);
          });
          listener.once.forEach(function (f) {
            return f.apply(null, args);
          });
          listener.once = new Set();
        } else if (name === 'error') {
          console.error(args[0]);
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this._eventListener = null;
      }
    }]);
    return NamedEventHandler;
  }();

  // TODO: Implement function to describe ranges

  /**
   * A relative position that is based on the Yjs model. In contrast to an
   * absolute position (position by index), the relative position can be
   * recomputed when remote changes are received. For example:
   *
   * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the cursor position.
   *
   * A relative cursor position can be obtained with the function
   * {@link getRelativePosition} and it can be transformed to an absolute position
   * with {@link fromRelativePosition}.
   *
   * Pro tip: Use this to implement shared cursor locations in YText or YXml!
   * The relative position is {@link encodable}, so you can send it to other
   * clients.
   *
   * @example
   * // Current cursor position is at position 10
   * let relativePosition = getRelativePosition(yText, 10)
   * // modify yText
   * yText.insert(0, 'abc')
   * yText.delete(3, 10)
   * // Compute the cursor position
   * let absolutePosition = fromRelativePosition(y, relativePosition)
   * absolutePosition.type // => yText
   * console.log('cursor location is ' + absolutePosition.offset) // => cursor location is 3
   *
   * @typedef {encodable} RelativePosition
   */

  /**
   * Create a relativePosition based on a absolute position.
   *
   * @param {YType} type The base type (e.g. YText or YArray).
   * @param {Integer} offset The absolute position.
   */
  function getRelativePosition(type, offset) {
    // TODO: rename to createRelativePosition
    var t = type._start;
    while (t !== null) {
      if (t._deleted === false) {
        if (t._length > offset) {
          return [t._id.user, t._id.clock + offset];
        }
        offset -= t._length;
      }
      t = t._right;
    }
    return ['endof', type._id.user, type._id.clock || null, type._id.name || null, type._id.type || null];
  }

  /**
   * @typedef {Object} AbsolutePosition The result of {@link fromRelativePosition}
   * @property {YType} type The type on which to apply the absolute position.
   * @property {Integer} offset The absolute offset.r
   */

  /**
   * Transforms a relative position back to a relative position.
   *
   * @param {Y} y The Yjs instance in which to query for the absolute position.
   * @param {RelativePosition} rpos The relative position.
   * @return {AbsolutePosition} The absolute position in the Yjs model
   *                            (type + offset).
   */
  function fromRelativePosition(y, rpos) {
    if (rpos[0] === 'endof') {
      var id = void 0;
      if (rpos[3] === null) {
        id = new ID(rpos[1], rpos[2]);
      } else {
        id = new RootID(rpos[3], rpos[4]);
      }
      var type = y.os.get(id);
      while (type._redone !== null) {
        type = type._redone;
      }
      if (type === null || type.constructor === GC) {
        return null;
      }
      return {
        type: type,
        offset: type.length
      };
    } else {
      var offset = 0;
      var struct = y.os.findNodeWithUpperBound(new ID(rpos[0], rpos[1])).val;
      var diff = rpos[1] - struct._id.clock;
      while (struct._redone !== null) {
        struct = struct._redone;
      }
      var parent = struct._parent;
      if (struct.constructor === GC || parent._deleted) {
        return null;
      }
      if (!struct._deleted) {
        offset = diff;
      }
      struct = struct._left;
      while (struct !== null) {
        if (!struct._deleted) {
          offset += struct._length;
        }
        struct = struct._left;
      }
      return {
        type: parent,
        offset: offset
      };
    }
  }

  // TODO: rename mutex

  /**
   * Creates a mutual exclude function with the following property:
   *
   * @example
   * const mutualExclude = createMutualExclude()
   * mutualExclude(function () {
   *   // This function is immediately executed
   *   mutualExclude(function () {
   *     // This function is never executed, as it is called with the same
   *     // mutualExclude
   *   })
   * })
   *
   * @return {Function} A mutual exclude function
   * @public
   */
  function createMutualExclude() {
    var token = true;
    return function mutualExclude(f) {
      if (token) {
        token = false;
        try {
          f();
        } catch (e) {
          console.error(e);
        }
        token = true;
      }
    };
  }

  /**
   * Abstract class for bindings.
   *
   * A binding handles data binding from a Yjs type to a data object. For example,
   * you can bind a Quill editor instance to a YText instance with the `QuillBinding` class.
   *
   * It is expected that a concrete implementation accepts two parameters
   * (type and binding target).
   *
   * @example
   *   const quill = new Quill(document.createElement('div'))
   *   const type = y.define('quill', Y.Text)
   *   const binding = new Y.QuillBinding(quill, type)
   *
   */

  var Binding = function () {
    /**
     * @param {YType} type Yjs type.
     * @param {any} target Binding Target.
     */
    function Binding(type, target) {
      classCallCheck(this, Binding);

      /**
       * The Yjs type that is bound to `target`
       * @type {YType}
       */
      this.type = type;
      /**
       * The target that `type` is bound to.
       * @type {*}
       */
      this.target = target;
      /**
       * @private
       */
      this._mutualExclude = createMutualExclude();
    }
    /**
     * Remove all data observers (both from the type and the target).
     */


    createClass(Binding, [{
      key: 'destroy',
      value: function destroy() {
        this.type = null;
        this.target = null;
      }
    }]);
    return Binding;
  }();

  /* globals getSelection */

  var relativeSelection = null;

  function _getCurrentRelativeSelection(domBinding) {
    var _getSelection = getSelection(),
        baseNode = _getSelection.baseNode,
        baseOffset = _getSelection.baseOffset,
        extentNode = _getSelection.extentNode,
        extentOffset = _getSelection.extentOffset;

    var baseNodeType = domBinding.domToType.get(baseNode);
    var extentNodeType = domBinding.domToType.get(extentNode);
    if (baseNodeType !== undefined && extentNodeType !== undefined) {
      return {
        from: getRelativePosition(baseNodeType, baseOffset),
        to: getRelativePosition(extentNodeType, extentOffset)
      };
    }
    return null;
  }

  var getCurrentRelativeSelection = typeof getSelection !== 'undefined' ? _getCurrentRelativeSelection : function () {
    return null;
  };

  function beforeTransactionSelectionFixer(domBinding, remote) {
    if (remote) {
      relativeSelection = getCurrentRelativeSelection(domBinding);
    }
  }

  /**
   * @private
   */
  function afterTransactionSelectionFixer(domBinding, remote) {
    if (relativeSelection !== null && remote) {
      domBinding.restoreSelection(relativeSelection);
    }
  }

  /* global getSelection */

  function findScrollReference(scrollingElement) {
    if (scrollingElement !== null) {
      var anchor = getSelection().anchorNode;
      if (anchor == null) {
        var children = scrollingElement.children; // only iterate through non-text nodes
        for (var i = 0; i < children.length; i++) {
          var elem = children[i];
          var rect = elem.getBoundingClientRect();
          if (rect.top >= 0) {
            return { elem: elem, top: rect.top };
          }
        }
      } else {
        if (anchor.nodeType === document.TEXT_NODE) {
          anchor = anchor.parentElement;
        }
        var top = anchor.getBoundingClientRect().top;
        return { elem: anchor, top: top };
      }
    }
    return null;
  }

  function fixScroll(scrollingElement, ref) {
    if (ref !== null) {
      var elem = ref.elem,
          top = ref.top;

      var currentTop = elem.getBoundingClientRect().top;
      var newScroll = scrollingElement.scrollTop + currentTop - top;
      if (newScroll >= 0) {
        scrollingElement.scrollTop = newScroll;
      }
    }
  }

  /**
   * @private
   */
  function typeObserver(events) {
    var _this = this;

    this._mutualExclude(function () {
      var scrollRef = findScrollReference(_this.scrollingElement);
      events.forEach(function (event) {
        var yxml = event.target;
        var dom = _this.typeToDom.get(yxml);
        if (dom !== undefined && dom !== false) {
          if (yxml.constructor === YXmlText) {
            dom.nodeValue = yxml.toString();
          } else if (event.attributesChanged !== undefined) {
            // update attributes
            event.attributesChanged.forEach(function (attributeName) {
              var value = yxml.getAttribute(attributeName);
              if (value === undefined) {
                dom.removeAttribute(attributeName);
              } else {
                dom.setAttribute(attributeName, value);
              }
            });
            /*
             * TODO: instead of hard-checking the types, it would be best to
             *       specify the type's features. E.g.
             *         - _yxmlHasAttributes
             *         - _yxmlHasChildren
             *       Furthermore, the features shouldn't be encoded in the types,
             *       only in the attributes (above)
             */
            if (event.childListChanged && yxml.constructor !== YXmlHook) {
              var currentChild = dom.firstChild;
              yxml.forEach(function (childType) {
                var childNode = _this.typeToDom.get(childType);
                switch (childNode) {
                  case undefined:
                    // Does not exist. Create it.
                    var node = childType.toDom(_this.opts.document, _this.opts.hooks, _this);
                    dom.insertBefore(node, currentChild);
                    break;
                  case false:
                    // nop
                    break;
                  default:
                    // Is already attached to the dom.
                    // Find it and remove all dom nodes in-between.
                    removeDomChildrenUntilElementFound(dom, currentChild, childNode);
                    currentChild = childNode.nextSibling;
                    break;
                }
              });
              removeDomChildrenUntilElementFound(dom, currentChild, null);
            }
          }
        }
      });
      fixScroll(_this.scrollingElement, scrollRef);
    });
  }

  /**
   * A SimpleDiff describes a change on a String.
   *
   * @example
   * console.log(a) // the old value
   * console.log(b) // the updated value
   * // Apply changes of diff (pseudocode)
   * a.remove(diff.pos, diff.remove) // Remove `diff.remove` characters
   * a.insert(diff.pos, diff.insert) // Insert `diff.insert`
   * a === b // values match
   *
   * @typedef {Object} SimpleDiff
   * @property {Number} pos The index where changes were applied
   * @property {Number} delete The number of characters to delete starting
   *                                  at `index`.
   * @property {String} insert The new text to insert at `index` after applying
   *                           `delete`
   */

  /**
   * Create a diff between two strings. This diff implementation is highly
   * efficient, but not very sophisticated.
   *
   * @public
   * @param {String} a The old version of the string
   * @param {String} b The updated version of the string
   * @return {SimpleDiff} The diff description.
   */
  function simpleDiff(a, b) {
    var left = 0; // number of same characters counting from left
    var right = 0; // number of same characters counting from right
    while (left < a.length && left < b.length && a[left] === b[left]) {
      left++;
    }
    if (left !== a.length || left !== b.length) {
      // Only check right if a !== b
      while (right + left < a.length && right + left < b.length && a[a.length - right - 1] === b[b.length - right - 1]) {
        right++;
      }
    }
    return {
      pos: left, // TODO: rename to index (also in type above)
      remove: a.length - left - right,
      insert: b.slice(left, b.length - right)
    };
  }

  /**
   * 1. Check if any of the nodes was deleted
   * 2. Iterate over the children.
   *    2.1 If a node exists that is not yet bound to a type, insert a new node
   *    2.2 If _contents.length < dom.childNodes.length, fill the
   *        rest of _content with childNodes
   *    2.3 If a node was moved, delete it and
   *       recreate a new yxml element that is bound to that node.
   *       You can detect that a node was moved because expectedId
   *       !== actualId in the list
   * @private
   */
  function applyChangesFromDom(binding, dom, yxml, _document) {
    if (yxml == null || yxml === false || yxml.constructor === YXmlHook) {
      return;
    }
    var y = yxml._y;
    var knownChildren = new Set();
    for (var i = dom.childNodes.length - 1; i >= 0; i--) {
      var type = binding.domToType.get(dom.childNodes[i]);
      if (type !== undefined && type !== false) {
        knownChildren.add(type);
      }
    }
    // 1. Check if any of the nodes was deleted
    yxml.forEach(function (childType) {
      if (knownChildren.has(childType) === false) {
        childType._delete(y);
        removeAssociation(binding, binding.typeToDom.get(childType), childType);
      }
    });
    // 2. iterate
    var childNodes = dom.childNodes;
    var len = childNodes.length;
    var prevExpectedType = null;
    var expectedType = iterateUntilUndeleted(yxml._start);
    for (var domCnt = 0; domCnt < len; domCnt++) {
      var childNode = childNodes[domCnt];
      var childType = binding.domToType.get(childNode);
      if (childType !== undefined) {
        if (childType === false) {
          // should be ignored or is going to be deleted
          continue;
        }
        if (expectedType !== null) {
          if (expectedType !== childType) {
            // 2.3 Not expected node
            if (childType._parent !== yxml) {
              // child was moved from another parent
              // childType is going to be deleted by its previous parent
              removeAssociation(binding, childNode, childType);
            } else {
              // child was moved to a different position.
              removeAssociation(binding, childNode, childType);
              childType._delete(y);
            }
            prevExpectedType = insertNodeHelper(yxml, prevExpectedType, childNode, _document, binding);
          } else {
            // Found expected node. Continue.
            prevExpectedType = expectedType;
            expectedType = iterateUntilUndeleted(expectedType._right);
          }
        } else {
          // 2.2 Fill _content with child nodes
          prevExpectedType = insertNodeHelper(yxml, prevExpectedType, childNode, _document, binding);
        }
      } else {
        // 2.1 A new node was found
        prevExpectedType = insertNodeHelper(yxml, prevExpectedType, childNode, _document, binding);
      }
    }
  }

  /**
   * @private
   */
  function domObserver(mutations, _document) {
    var _this = this;

    this._mutualExclude(function () {
      _this.type._y.transact(function () {
        var diffChildren = new Set();
        mutations.forEach(function (mutation) {
          var dom = mutation.target;
          var yxml = _this.domToType.get(dom);
          if (yxml === undefined) {
            // In case yxml is undefined, we double check if we forgot to bind the dom
            var parent = dom;
            var yParent = void 0;
            do {
              parent = parent.parentElement;
              yParent = _this.domToType.get(parent);
            } while (yParent === undefined && parent !== null);
            if (yParent !== false && yParent !== undefined && yParent.constructor !== YXmlHook) {
              diffChildren.add(parent);
            }
            return;
          } else if (yxml === false || yxml.constructor === YXmlHook) {
            // dom element is filtered / a dom hook
            return;
          }
          switch (mutation.type) {
            case 'characterData':
              var change = simpleDiff(yxml.toString(), dom.nodeValue);
              yxml.delete(change.pos, change.remove);
              yxml.insert(change.pos, change.insert);
              break;
            case 'attributes':
              if (yxml.constructor === YXmlFragment) {
                break;
              }
              var name = mutation.attributeName;
              var val = dom.getAttribute(name);
              // check if filter accepts attribute
              var attributes = new Map();
              attributes.set(name, val);
              if (yxml.constructor !== YXmlFragment && _this.filter(dom.nodeName, attributes).size > 0) {
                if (yxml.getAttribute(name) !== val) {
                  if (val == null) {
                    yxml.removeAttribute(name);
                  } else {
                    yxml.setAttribute(name, val);
                  }
                }
              }
              break;
            case 'childList':
              diffChildren.add(mutation.target);
              break;
          }
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = diffChildren[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var dom = _step.value;

            var yxml = _this.domToType.get(dom);
            applyChangesFromDom(_this, dom, yxml, _document);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      });
    });
  }

  /* global MutationObserver, getSelection */

  /**
   * A binding that binds the children of a YXmlFragment to a DOM element.
   *
   * This binding is automatically destroyed when its parent is deleted.
   *
   * @example
   * const div = document.createElement('div')
   * const type = y.define('xml', Y.XmlFragment)
   * const binding = new Y.QuillBinding(type, div)
   *
   */

  var DomBinding = function (_Binding) {
    inherits(DomBinding, _Binding);

    /**
     * @param {YXmlFragment} type The bind source. This is the ultimate source of
     *                            truth.
     * @param {Element} target The bind target. Mirrors the target.
     * @param {Object} [opts] Optional configurations
      * @param {FilterFunction} [opts.filter=defaultFilter] The filter function to use.
     */
    function DomBinding(type, target) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, DomBinding);

      var _this = possibleConstructorReturn(this, (DomBinding.__proto__ || Object.getPrototypeOf(DomBinding)).call(this, type, target));
      // Binding handles textType as this.type and domTextarea as this.target


      _this.opts = opts;
      opts.document = opts.document || document;
      opts.hooks = opts.hooks || {};
      _this.scrollingElement = opts.scrollingElement || null;
      /**
       * Maps each DOM element to the type that it is associated with.
       * @type {Map}
       */
      _this.domToType = new Map();
      /**
       * Maps each YXml type to the DOM element that it is associated with.
       * @type {Map}
       */
      _this.typeToDom = new Map();
      /**
       * Defines which DOM attributes and elements to filter out.
       * Also filters remote changes.
       * @type {FilterFunction}
       */
      _this.filter = opts.filter || defaultFilter;
      // set initial value
      target.innerHTML = '';
      type.forEach(function (child) {
        target.insertBefore(child.toDom(opts.document, opts.hooks, _this), null);
      });
      _this._typeObserver = typeObserver.bind(_this);
      _this._domObserver = function (mutations) {
        domObserver.call(_this, mutations, opts.document);
      };
      type.observeDeep(_this._typeObserver);
      _this._mutationObserver = new MutationObserver(_this._domObserver);
      _this._mutationObserver.observe(target, {
        childList: true,
        attributes: true,
        characterData: true,
        subtree: true
      });
      _this._currentSel = null;
      document.addEventListener('selectionchange', function () {
        _this._currentSel = getCurrentRelativeSelection(_this);
      });
      var y = type._y;
      _this.y = y;
      // Force flush dom changes before Type changes are applied (they might
      // modify the dom)
      _this._beforeTransactionHandler = function (y, transaction, remote) {
        _this._domObserver(_this._mutationObserver.takeRecords());
        _this._mutualExclude(function () {
          beforeTransactionSelectionFixer(_this, remote);
        });
      };
      y.on('beforeTransaction', _this._beforeTransactionHandler);
      _this._afterTransactionHandler = function (y, transaction, remote) {
        _this._mutualExclude(function () {
          afterTransactionSelectionFixer(_this, remote);
        });
        // remove associations
        // TODO: this could be done more efficiently
        // e.g. Always delete using the following approach, or removeAssociation
        // in dom/type-observer..
        transaction.deletedStructs.forEach(function (type) {
          var dom = _this.typeToDom.get(type);
          if (dom !== undefined) {
            removeAssociation(_this, dom, type);
          }
        });
      };
      y.on('afterTransaction', _this._afterTransactionHandler);
      // Before calling observers, apply dom filter to all changed and new types.
      _this._beforeObserverCallsHandler = function (y, transaction) {
        // Apply dom filter to new and changed types
        transaction.changedTypes.forEach(function (subs, type) {
          // Only check attributes. New types are filtered below.
          if (subs.size > 1 || subs.size === 1 && subs.has(null) === false) {
            applyFilterOnType(y, _this, type);
          }
        });
        transaction.newTypes.forEach(function (type) {
          applyFilterOnType(y, _this, type);
        });
      };
      y.on('beforeObserverCalls', _this._beforeObserverCallsHandler);
      createAssociation(_this, target, type);
      return _this;
    }

    /**
     * NOTE: currently does not apply filter to existing elements!
     * @param {FilterFunction} filter The filter function to use from now on.
     */


    createClass(DomBinding, [{
      key: 'setFilter',
      value: function setFilter(filter) {
        this.filter = filter;
        // TODO: apply filter to all elements
      }
    }, {
      key: '_getUndoStackInfo',
      value: function _getUndoStackInfo() {
        return this.getSelection();
      }
    }, {
      key: '_restoreUndoStackInfo',
      value: function _restoreUndoStackInfo(info) {
        this.restoreSelection(info);
      }
    }, {
      key: 'getSelection',
      value: function getSelection() {
        return this._currentSel;
      }
    }, {
      key: 'restoreSelection',
      value: function restoreSelection(selection) {
        if (selection !== null) {
          var to = selection.to,
              from = selection.from;

          var shouldUpdate = false;
          /**
           * There is little information on the difference between anchor/focus and base/extent.
           * MDN doesn't even mention base/extent anymore.. though you still have to call
           * setBaseAndExtent to change the selection..
           * I can observe that base/extend refer to notes higher up in the xml hierachy.
           * Espesially for undo/redo this is preferred. If this becomes a problem in the future,
           * we should probably go back to anchor/focus.
           */
          var browserSelection = getSelection();
          var baseNode = browserSelection.baseNode,
              baseOffset = browserSelection.baseOffset,
              extentNode = browserSelection.extentNode,
              extentOffset = browserSelection.extentOffset;

          if (from !== null) {
            var sel = fromRelativePosition(this.y, from);
            if (sel !== null) {
              var node = this.typeToDom.get(sel.type);
              var offset = sel.offset;
              if (node !== baseNode || offset !== baseOffset) {
                baseNode = node;
                baseOffset = offset;
                shouldUpdate = true;
              }
            }
          }
          if (to !== null) {
            var _sel = fromRelativePosition(this.y, to);
            if (_sel !== null) {
              var _node = this.typeToDom.get(_sel.type);
              var _offset = _sel.offset;
              if (_node !== extentNode || _offset !== extentOffset) {
                extentNode = _node;
                extentOffset = _offset;
                shouldUpdate = true;
              }
            }
          }
          if (shouldUpdate) {
            browserSelection.setBaseAndExtent(baseNode, baseOffset, extentNode, extentOffset);
          }
        }
      }

      /**
       * Remove all properties that are handled by this class.
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.domToType = null;
        this.typeToDom = null;
        this.type.unobserveDeep(this._typeObserver);
        this._mutationObserver.disconnect();
        var y = this.type._y;
        y.off('beforeTransaction', this._beforeTransactionHandler);
        y.off('beforeObserverCalls', this._beforeObserverCallsHandler);
        y.off('afterTransaction', this._afterTransactionHandler);
        get(DomBinding.prototype.__proto__ || Object.getPrototypeOf(DomBinding.prototype), 'destroy', this).call(this);
      }
    }]);
    return DomBinding;
  }(Binding);

  /**
   * Anything that can be encoded with `JSON.stringify` and can be decoded with
   * `JSON.parse`.
   *
   * The following property should hold:
   * `JSON.parse(JSON.stringify(key))===key`
   *
   * At the moment the only safe values are number and string.
   *
   * @typedef {(number|string)} encodable
   */

  /**
   * A Yjs instance handles the state of shared data.
   *
   * @param {string} room Users in the same room share the same content
   * @param {Object} opts Connector definition
   * @param {AbstractPersistence} persistence Persistence adapter instance
   */

  var Y = function (_NamedEventHandler) {
    inherits(Y, _NamedEventHandler);

    function Y(room, opts, persistence) {
      var conf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      classCallCheck(this, Y);

      var _this = possibleConstructorReturn(this, (Y.__proto__ || Object.getPrototypeOf(Y)).call(this));

      _this.gcEnabled = conf.gc || false;
      /**
       * The room name that this Yjs instance connects to.
       * @type {String}
       */
      _this.room = room;
      if (opts != null) {
        opts.connector.room = room;
      }
      _this._contentReady = false;
      _this._opts = opts;
      if (typeof opts.userID !== 'number') {
        _this.userID = generateRandomUint32();
      } else {
        _this.userID = opts.userID;
      }
      // TODO: This should be a Map so we can use encodables as keys
      _this.share = {};
      _this.ds = new DeleteStore(_this);
      _this.os = new OperationStore(_this);
      _this.ss = new StateStore(_this);
      _this._missingStructs = new Map();
      _this._readyToIntegrate = [];
      _this._transaction = null;
      /**
       * The {@link AbstractConnector}.that is used by this Yjs instance.
       * @type {AbstractConnector}
       */
      _this.connector = null;
      _this.connected = false;
      var initConnection = function initConnection() {
        if (opts != null) {
          _this.connector = new Y[opts.connector.name](_this, opts.connector);
          _this.connected = true;
          _this.emit('connectorReady');
        }
      };
      /**
       * The {@link AbstractPersistence} that is used by this Yjs instance.
       * @type {AbstractPersistence}
       */
      _this.persistence = null;
      if (persistence != null) {
        _this.persistence = persistence;
        persistence._init(_this).then(initConnection);
      } else {
        initConnection();
      }
      // for compatibility with isParentOf
      _this._parent = null;
      _this._hasUndoManager = false;
      return _this;
    }

    createClass(Y, [{
      key: '_setContentReady',
      value: function _setContentReady() {
        if (!this._contentReady) {
          this._contentReady = true;
          this.emit('content');
        }
      }
    }, {
      key: 'whenContentReady',
      value: function whenContentReady() {
        var _this2 = this;

        if (this._contentReady) {
          return Promise.resolve();
        } else {
          return new Promise(function (resolve) {
            _this2.once('content', resolve);
          });
        }
      }
    }, {
      key: '_beforeChange',
      value: function _beforeChange() {}
      /**
       * Changes that happen inside of a transaction are bundled. This means that
       * the observer fires _after_ the transaction is finished and that all changes
       * that happened inside of the transaction are sent as one message to the
       * other peers.
       *
       * @param {Function} f The function that should be executed as a transaction
       * @param {?Boolean} remote Optional. Whether this transaction is initiated by
       *                          a remote peer. This should not be set manually!
       *                          Defaults to false.
       */

    }, {
      key: 'transact',
      value: function transact(f) {
        var remote = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var initialCall = this._transaction === null;
        if (initialCall) {
          this._transaction = new Transaction(this);
          this.emit('beforeTransaction', this, this._transaction, remote);
        }
        try {
          f(this);
        } catch (e) {
          console.error(e);
        }
        if (initialCall) {
          this.emit('beforeObserverCalls', this, this._transaction, remote);
          var transaction = this._transaction;
          this._transaction = null;
          // emit change events on changed types
          transaction.changedTypes.forEach(function (subs, type) {
            if (!type._deleted) {
              type._callObserver(transaction, subs, remote);
            }
          });
          transaction.changedParentTypes.forEach(function (events, type) {
            if (!type._deleted) {
              events = events.filter(function (event) {
                return !event.target._deleted;
              });
              events.forEach(function (event) {
                event.currentTarget = type;
              });
              // we don't have to check for events.length
              // because there is no way events is empty..
              type._deepEventHandler.callEventListeners(transaction, events);
            }
          });
          // when all changes & events are processed, emit afterTransaction event
          this.emit('afterTransaction', this, transaction, remote);
        }
      }

      /**
       * @private
       * Fake _start for root properties (y.set('name', type))
       */

    }, {
      key: 'define',


      /**
       * Define a shared data type.
       *
       * Multiple calls of `y.define(name, TypeConstructor)` yield the same result
       * and do not overwrite each other. I.e.
       * `y.define(name, type) === y.define(name, type)`
       *
       * After this method is called, the type is also available on `y.share[name]`.
       *
       * *Best Practices:*
       * Either define all types right after the Yjs instance is created or always
       * use `y.define(..)` when accessing a type.
       *
       * @example
       *   // Option 1
       *   const y = new Y(..)
       *   y.define('myArray', YArray)
       *   y.define('myMap', YMap)
       *   // .. when accessing the type use y.share[name]
       *   y.share.myArray.insert(..)
       *   y.share.myMap.set(..)
       *
       *   // Option2
       *   const y = new Y(..)
       *   // .. when accessing the type use `y.define(..)`
       *   y.define('myArray', YArray).insert(..)
       *   y.define('myMap', YMap).set(..)
       *
       * @param {String} name
       * @param {YType Constructor} TypeConstructor The constructor of the type definition
       * @returns {YType} The created type
       */
      value: function define(name, TypeConstructor) {
        var id = new RootID(name, TypeConstructor);
        var type = this.os.get(id);
        if (this.share[name] === undefined) {
          this.share[name] = type;
        } else if (this.share[name] !== type) {
          throw new Error('Type is already defined with a different constructor');
        }
        return type;
      }

      /**
       * Get a defined type. The type must be defined locally. First define the
       * type with {@link define}.
       *
       * This returns the same value as `y.share[name]`
       *
       * @param {String} name The typename
       */

    }, {
      key: 'get',
      value: function get$$1(name) {
        return this.share[name];
      }

      /**
       * Disconnect this Yjs Instance from the network. The connector will
       * unsubscribe from the room and document updates are not shared anymore.
       */

    }, {
      key: 'disconnect',
      value: function disconnect() {
        if (this.connected) {
          this.connected = false;
          return this.connector.disconnect();
        } else {
          return Promise.resolve();
        }
      }

      /**
       * If disconnected, tell the connector to reconnect to the room.
       */

    }, {
      key: 'reconnect',
      value: function reconnect() {
        if (!this.connected) {
          this.connected = true;
          return this.connector.reconnect();
        } else {
          return Promise.resolve();
        }
      }

      /**
       * Disconnect from the room, and destroy all traces of this Yjs instance.
       * Persisted data will remain until removed by the persistence adapter.
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        get(Y.prototype.__proto__ || Object.getPrototypeOf(Y.prototype), 'destroy', this).call(this);
        this.share = null;
        if (this.connector != null) {
          if (this.connector.destroy != null) {
            this.connector.destroy();
          } else {
            this.connector.disconnect();
          }
        }
        if (this.persistence !== null) {
          this.persistence.deinit(this);
          this.persistence = null;
        }
        this.os = null;
        this.ds = null;
        this.ss = null;
      }
    }, {
      key: '_start',
      get: function get$$1() {
        return null;
      }

      /**
       * @private
       * Fake _start for root properties (y.set('name', type))
       */
      ,
      set: function set$$1(start) {
        return null;
      }
    }]);
    return Y;
  }(NamedEventHandler);


  Y.extend = function extendYjs() {
    for (var i = 0; i < arguments.length; i++) {
      var f = arguments[i];
      if (typeof f === 'function') {
        f(Y);
      } else {
        throw new Error('Expected a function!');
      }
    }
  };

  var ReverseOperation = function ReverseOperation(y, transaction, bindingInfos) {
    var _this = this;

    classCallCheck(this, ReverseOperation);

    this.created = new Date();
    var beforeState = transaction.beforeState;
    if (beforeState.has(y.userID)) {
      this.toState = new ID(y.userID, y.ss.getState(y.userID) - 1);
      this.fromState = new ID(y.userID, beforeState.get(y.userID));
    } else {
      this.toState = null;
      this.fromState = null;
    }
    this.deletedStructs = new Set();
    transaction.deletedStructs.forEach(function (struct) {
      _this.deletedStructs.add({
        from: struct._id,
        len: struct._length
      });
    });
    /**
     * Maps from binding to binding information (e.g. cursor information)
     */
    this.bindingInfos = bindingInfos;
  };

  function applyReverseOperation(y, scope, reverseBuffer) {
    var performedUndo = false;
    var undoOp = void 0;
    y.transact(function () {
      var _loop = function _loop() {
        undoOp = reverseBuffer.pop();
        // make sure that it is possible to iterate {from}-{to}
        if (undoOp.fromState !== null) {
          y.os.getItemCleanStart(undoOp.fromState);
          y.os.getItemCleanEnd(undoOp.toState);
          y.os.iterate(undoOp.fromState, undoOp.toState, function (op) {
            while (op._deleted && op._redone !== null) {
              op = op._redone;
            }
            if (op._deleted === false && isParentOf(scope, op)) {
              performedUndo = true;
              op._delete(y);
            }
          });
        }
        var redoitems = new Set();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = undoOp.deletedStructs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var del = _step.value;

            var fromState = del.from;
            var toState = new ID(fromState.user, fromState.clock + del.len - 1);
            y.os.getItemCleanStart(fromState);
            y.os.getItemCleanEnd(toState);
            y.os.iterate(fromState, toState, function (op) {
              if (isParentOf(scope, op) && op._parent !== y && (op._id.user !== y.userID || undoOp.fromState === null || op._id.clock < undoOp.fromState.clock || op._id.clock > undoOp.toState.clock)) {
                redoitems.add(op);
              }
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        redoitems.forEach(function (op) {
          var opUndone = op._redo(y, redoitems);
          performedUndo = performedUndo || opUndone;
        });
      };

      while (!performedUndo && reverseBuffer.length > 0) {
        _loop();
      }
    });
    if (performedUndo) {
      // should be performed after the undo transaction
      undoOp.bindingInfos.forEach(function (info, binding) {
        binding._restoreUndoStackInfo(info);
      });
    }
    return performedUndo;
  }

  /**
   * Saves a history of locally applied operations. The UndoManager handles the
   * undoing and redoing of locally created changes.
   */

  var UndoManager = function () {
    /**
     * @param {YType} scope The scope on which to listen for changes.
     * @param {Object} options Optionally provided configuration.
     */
    function UndoManager(scope) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      classCallCheck(this, UndoManager);

      this.options = options;
      this._bindings = new Set(options.bindings);
      options.captureTimeout = options.captureTimeout == null ? 500 : options.captureTimeout;
      this._undoBuffer = [];
      this._redoBuffer = [];
      this._scope = scope;
      this._undoing = false;
      this._redoing = false;
      this._lastTransactionWasUndo = false;
      var y = scope._y;
      this.y = y;
      y._hasUndoManager = true;
      var bindingInfos = void 0;
      y.on('beforeTransaction', function (y, transaction, remote) {
        if (!remote) {
          // Store binding information before transaction is executed
          // By restoring the binding information, we can make sure that the state
          // before the transaction can be recovered
          bindingInfos = new Map();
          _this2._bindings.forEach(function (binding) {
            bindingInfos.set(binding, binding._getUndoStackInfo());
          });
        }
      });
      y.on('afterTransaction', function (y, transaction, remote) {
        if (!remote && transaction.changedParentTypes.has(scope)) {
          var reverseOperation = new ReverseOperation(y, transaction, bindingInfos);
          if (!_this2._undoing) {
            var lastUndoOp = _this2._undoBuffer.length > 0 ? _this2._undoBuffer[_this2._undoBuffer.length - 1] : null;
            if (_this2._redoing === false && _this2._lastTransactionWasUndo === false && lastUndoOp !== null && (options.captureTimeout < 0 || reverseOperation.created - lastUndoOp.created <= options.captureTimeout)) {
              lastUndoOp.created = reverseOperation.created;
              if (reverseOperation.toState !== null) {
                lastUndoOp.toState = reverseOperation.toState;
                if (lastUndoOp.fromState === null) {
                  lastUndoOp.fromState = reverseOperation.fromState;
                }
              }
              reverseOperation.deletedStructs.forEach(lastUndoOp.deletedStructs.add, lastUndoOp.deletedStructs);
            } else {
              _this2._lastTransactionWasUndo = false;
              _this2._undoBuffer.push(reverseOperation);
            }
            if (!_this2._redoing) {
              _this2._redoBuffer = [];
            }
          } else {
            _this2._lastTransactionWasUndo = true;
            _this2._redoBuffer.push(reverseOperation);
          }
        }
      });
    }

    /**
     * Enforce that the next change is created as a separate item in the undo stack
     */


    createClass(UndoManager, [{
      key: 'flushChanges',
      value: function flushChanges() {
        this._lastTransactionWasUndo = true;
      }

      /**
       * Undo the last locally created change.
       */

    }, {
      key: 'undo',
      value: function undo() {
        this._undoing = true;
        var performedUndo = applyReverseOperation(this.y, this._scope, this._undoBuffer);
        this._undoing = false;
        return performedUndo;
      }

      /**
       * Redo the last locally created change.
       */

    }, {
      key: 'redo',
      value: function redo() {
        this._redoing = true;
        var performedRedo = applyReverseOperation(this.y, this._scope, this._redoBuffer);
        this._redoing = false;
        return performedRedo;
      }
    }]);
    return UndoManager;
  }();

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  var index = function index(val, options) {
    options = options || {};
    var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (ms >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (ms >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (ms >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + ' ' + name;
    }
    return Math.ceil(ms / n) + ' ' + name + 's';
  }

  var debug = createCommonjsModule(function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = index;

    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    exports.formatters = {};

    /**
     * Previous log timestamp.
     */

    var prevTime;

    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectColor(namespace) {
      var hash = 0,
          i;

      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return exports.colors[Math.abs(hash) % exports.colors.length];
    }

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function createDebug(namespace) {

      function debug() {
        // disabled?
        if (!debug.enabled) return;

        var self = debug;

        // set `diff` timestamp
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;

        // turn the `arguments` into a proper Array
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }

        args[0] = exports.coerce(args[0]);

        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %O
          args.unshift('%O');
        }

        // apply any `formatters` transformations
        var index$$1 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index$$1++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index$$1];
            match = formatter.call(self, val);

            // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index$$1, 1);
            index$$1--;
          }
          return match;
        });

        // apply env-specific formatting (colors, etc.)
        exports.formatArgs.call(self, args);

        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);

      // env-specific initialization logic for debug instances
      if ('function' === typeof exports.init) {
        exports.init(debug);
      }

      return debug;
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
      exports.save(namespaces);

      exports.names = [];
      exports.skips = [];

      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (var i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
      exports.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  });
  var debug_1 = debug.coerce;
  var debug_2 = debug.disable;
  var debug_3 = debug.enable;
  var debug_4 = debug.enabled;
  var debug_5 = debug.humanize;
  var debug_6 = debug.names;
  var debug_7 = debug.skips;
  var debug_8 = debug.formatters;

  var browser = createCommonjsModule(function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = debug;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

    /**
     * Colors.
     */

    exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
        return true;
      }

      // is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
      // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
      // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
      // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    exports.formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return '[UnexpectedJSONParseError]: ' + err.message;
      }
    };

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var useColors = this.useColors;

      args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

      if (!useColors) return;

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if ('%%' === match) return;
        index++;
        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });

      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {}

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

    exports.enable(load());

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
  });
  var browser_1 = browser.log;
  var browser_2 = browser.formatArgs;
  var browser_3 = browser.save;
  var browser_4 = browser.load;
  var browser_5 = browser.useColors;
  var browser_6 = browser.storage;
  var browser_7 = browser.colors;

  // TODO: rename Connector

  var AbstractConnector = function () {
    function AbstractConnector(y, opts) {
      classCallCheck(this, AbstractConnector);

      this.y = y;
      this.opts = opts;
      if (opts.role == null || opts.role === 'master') {
        this.role = 'master';
      } else if (opts.role === 'slave') {
        this.role = 'slave';
      } else {
        throw new Error("Role must be either 'master' or 'slave'!");
      }
      this.log = browser('y:connector');
      this.logMessage = browser('y:connector-message');
      this._forwardAppliedStructs = opts.forwardAppliedOperations || false; // TODO: rename
      this.role = opts.role;
      this.connections = new Map();
      this.isSynced = false;
      this.userEventListeners = [];
      this.whenSyncedListeners = [];
      this.currentSyncTarget = null;
      this.debug = opts.debug === true;
      this.broadcastBuffer = new BinaryEncoder();
      this.broadcastBufferSize = 0;
      this.protocolVersion = 11;
      this.authInfo = opts.auth || null;
      this.checkAuth = opts.checkAuth || function () {
        return Promise.resolve('write');
      }; // default is everyone has write access
      if (opts.maxBufferLength == null) {
        this.maxBufferLength = -1;
      } else {
        this.maxBufferLength = opts.maxBufferLength;
      }
    }

    createClass(AbstractConnector, [{
      key: 'reconnect',
      value: function reconnect() {
        this.log('reconnecting..');
      }
    }, {
      key: 'disconnect',
      value: function disconnect() {
        this.log('discronnecting..');
        this.connections = new Map();
        this.isSynced = false;
        this.currentSyncTarget = null;
        this.whenSyncedListeners = [];
        return Promise.resolve();
      }
    }, {
      key: 'onUserEvent',
      value: function onUserEvent(f) {
        this.userEventListeners.push(f);
      }
    }, {
      key: 'removeUserEventListener',
      value: function removeUserEventListener(f) {
        this.userEventListeners = this.userEventListeners.filter(function (g) {
          return f !== g;
        });
      }
    }, {
      key: 'userLeft',
      value: function userLeft(user) {
        if (this.connections.has(user)) {
          this.log('%s: User left %s', this.y.userID, user);
          this.connections.delete(user);
          // check if isSynced event can be sent now
          this._setSyncedWith(null);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.userEventListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var f = _step.value;

              f({
                action: 'userLeft',
                user: user
              });
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }
    }, {
      key: 'userJoined',
      value: function userJoined(user, role, auth) {
        if (role == null) {
          throw new Error('You must specify the role of the joined user!');
        }
        if (this.connections.has(user)) {
          throw new Error('This user already joined!');
        }
        this.log('%s: User joined %s', this.y.userID, user);
        this.connections.set(user, {
          uid: user,
          isSynced: false,
          role: role,
          processAfterAuth: [],
          processAfterSync: [],
          auth: auth || null,
          receivedSyncStep2: false
        });
        var defer = {};
        defer.promise = new Promise(function (resolve) {
          defer.resolve = resolve;
        });
        this.connections.get(user).syncStep2 = defer;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.userEventListeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var f = _step2.value;

            f({
              action: 'userJoined',
              user: user,
              role: role
            });
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        this._syncWithUser(user);
      }

      // Execute a function _when_ we are connected.
      // If not connected, wait until connected

    }, {
      key: 'whenSynced',
      value: function whenSynced(f) {
        if (this.isSynced) {
          f();
        } else {
          this.whenSyncedListeners.push(f);
        }
      }
    }, {
      key: '_syncWithUser',
      value: function _syncWithUser(userID) {
        if (this.role === 'slave') {
          return; // "The current sync has not finished or this is controlled by a master!"
        }
        sendSyncStep1(this, userID);
      }
    }, {
      key: '_fireIsSyncedListeners',
      value: function _fireIsSyncedListeners() {
        if (!this.isSynced) {
          this.isSynced = true;
          // It is safer to remove this!
          // call whensynced listeners
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this.whenSyncedListeners[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var f = _step3.value;

              f();
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          this.whenSyncedListeners = [];
          this.y._setContentReady();
          this.y.emit('synced');
        }
      }
    }, {
      key: 'send',
      value: function send(uid, buffer) {
        var y = this.y;
        if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {
          throw new Error('Expected Message to be an ArrayBuffer or Uint8Array - don\'t use this method to send custom messages');
        }
        this.log('User%s to User%s: Send \'%y\'', y.userID, uid, buffer);
        this.logMessage('User%s to User%s: Send %Y', y.userID, uid, [y, buffer]);
      }
    }, {
      key: 'broadcast',
      value: function broadcast(buffer) {
        var y = this.y;
        if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {
          throw new Error('Expected Message to be an ArrayBuffer or Uint8Array - don\'t use this method to send custom messages');
        }
        this.log('User%s: Broadcast \'%y\'', y.userID, buffer);
        this.logMessage('User%s: Broadcast: %Y', y.userID, [y, buffer]);
      }

      /*
        Buffer operations, and broadcast them when ready.
      */

    }, {
      key: 'broadcastStruct',
      value: function broadcastStruct(struct) {
        var _this = this;

        var firstContent = this.broadcastBuffer.length === 0;
        if (firstContent) {
          this.broadcastBuffer.writeVarString(this.y.room);
          this.broadcastBuffer.writeVarString('update');
          this.broadcastBufferSize = 0;
          this.broadcastBufferSizePos = this.broadcastBuffer.pos;
          this.broadcastBuffer.writeUint32(0);
        }
        this.broadcastBufferSize++;
        struct._toBinary(this.broadcastBuffer);
        if (this.maxBufferLength > 0 && this.broadcastBuffer.length > this.maxBufferLength) {
          // it is necessary to send the buffer now
          // cache the buffer and check if server is responsive
          var buffer = this.broadcastBuffer;
          buffer.setUint32(this.broadcastBufferSizePos, this.broadcastBufferSize);
          this.broadcastBuffer = new BinaryEncoder();
          this.whenRemoteResponsive().then(function () {
            _this.broadcast(buffer.createBuffer());
          });
        } else if (firstContent) {
          // send the buffer when all transactions are finished
          // (or buffer exceeds maxBufferLength)
          setTimeout(function () {
            if (_this.broadcastBuffer.length > 0) {
              var _buffer = _this.broadcastBuffer;
              _buffer.setUint32(_this.broadcastBufferSizePos, _this.broadcastBufferSize);
              _this.broadcast(_buffer.createBuffer());
              _this.broadcastBuffer = new BinaryEncoder();
            }
          }, 0);
        }
      }

      /*
       * Somehow check the responsiveness of the remote clients/server
       * Default behavior:
       *   Wait 100ms before broadcasting the next batch of operations
       *
       * Only used when maxBufferLength is set
       *
       */

    }, {
      key: 'whenRemoteResponsive',
      value: function whenRemoteResponsive() {
        return new Promise(function (resolve) {
          setTimeout(resolve, 100);
        });
      }

      /*
        You received a raw message, and you know that it is intended for Yjs. Then call this function.
      */

    }, {
      key: 'receiveMessage',
      value: function receiveMessage(sender, buffer, skipAuth) {
        var _this2 = this;

        var y = this.y;
        var userID = y.userID;
        skipAuth = skipAuth || false;
        if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {
          return Promise.reject(new Error('Expected Message to be an ArrayBuffer or Uint8Array!'));
        }
        if (sender === userID) {
          return Promise.resolve();
        }
        var decoder = new BinaryDecoder(buffer);
        var encoder = new BinaryEncoder();
        var roomname = decoder.readVarString(); // read room name
        encoder.writeVarString(roomname);
        var messageType = decoder.readVarString();
        var senderConn = this.connections.get(sender);
        this.log('User%s from User%s: Receive \'%s\'', userID, sender, messageType);
        this.logMessage('User%s from User%s: Receive %Y', userID, sender, [y, buffer]);
        if (senderConn == null && !skipAuth) {
          throw new Error('Received message from unknown peer!');
        }
        if (messageType === 'sync step 1' || messageType === 'sync step 2') {
          var auth = decoder.readVarUint();
          if (senderConn.auth == null) {
            senderConn.processAfterAuth.push([messageType, senderConn, decoder, encoder, sender]);
            // check auth
            return this.checkAuth(auth, y, sender).then(function (authPermissions) {
              if (senderConn.auth == null) {
                senderConn.auth = authPermissions;
                y.emit('userAuthenticated', {
                  user: senderConn.uid,
                  auth: authPermissions
                });
              }
              var messages = senderConn.processAfterAuth;
              senderConn.processAfterAuth = [];

              messages.forEach(function (m) {
                return _this2.computeMessage(m[0], m[1], m[2], m[3], m[4]);
              });
            });
          }
        }
        if ((skipAuth || senderConn.auth != null) && (messageType !== 'update' || senderConn.isSynced)) {
          this.computeMessage(messageType, senderConn, decoder, encoder, sender, skipAuth);
        } else {
          senderConn.processAfterSync.push([messageType, senderConn, decoder, encoder, sender, false]);
        }
      }
    }, {
      key: 'computeMessage',
      value: function computeMessage(messageType, senderConn, decoder, encoder, sender, skipAuth) {
        if (messageType === 'sync step 1' && (senderConn.auth === 'write' || senderConn.auth === 'read')) {
          // cannot wait for sync step 1 to finish, because we may wait for sync step 2 in sync step 1 (->lock)
          readSyncStep1(decoder, encoder, this.y, senderConn, sender);
        } else {
          var y = this.y;
          y.transact(function () {
            if (messageType === 'sync step 2' && senderConn.auth === 'write') {
              readSyncStep2(decoder, encoder, y, senderConn, sender);
            } else if (messageType === 'update' && (skipAuth || senderConn.auth === 'write')) {
              integrateRemoteStructs(y, decoder);
            } else {
              throw new Error('Unable to receive message');
            }
          }, true);
        }
      }
    }, {
      key: '_setSyncedWith',
      value: function _setSyncedWith(user) {
        var _this3 = this;

        if (user != null) {
          var userConn = this.connections.get(user);
          userConn.isSynced = true;
          var messages = userConn.processAfterSync;
          userConn.processAfterSync = [];
          messages.forEach(function (m) {
            _this3.computeMessage(m[0], m[1], m[2], m[3], m[4]);
          });
        }
        var conns = Array.from(this.connections.values());
        if (conns.length > 0 && conns.every(function (u) {
          return u.isSynced;
        })) {
          this._fireIsSyncedListeners();
        }
      }
    }]);
    return AbstractConnector;
  }();

  /**
   * Read the Decoder and fill the Yjs instance with data in the decoder.
   *
   * @param {Y} y The Yjs instance
   * @param {BinaryDecoder} decoder The BinaryDecoder to read from.
   */
  function fromBinary(y, decoder) {
    y.transact(function () {
      integrateRemoteStructs(y, decoder);
      readDeleteSet(y, decoder);
    });
  }

  /**
   * Encode the Yjs model to binary format.
   *
   * @param {Y} y The Yjs instance
   * @return {BinaryEncoder} The encoder instance that can be transformed
   *                         to ArrayBuffer or Buffer.
   */
  function toBinary(y) {
    var encoder = new BinaryEncoder();
    writeStructs(y, encoder, new Map());
    writeDeleteSet(y, encoder);
    return encoder;
  }

  function getFreshCnf() {
    var buffer = new BinaryEncoder();
    buffer.writeUint32(0);
    return {
      len: 0,
      buffer: buffer
    };
  }

  /**
   * Abstract persistence class.
   */

  var AbstractPersistence = function () {
    function AbstractPersistence(opts) {
      classCallCheck(this, AbstractPersistence);

      this.opts = opts;
      this.ys = new Map();
    }

    createClass(AbstractPersistence, [{
      key: '_init',
      value: function _init(y) {
        var _this = this;

        var cnf = this.ys.get(y);
        if (cnf === undefined) {
          cnf = getFreshCnf();
          cnf.mutualExclude = createMutualExclude();
          this.ys.set(y, cnf);
          return this.init(y).then(function () {
            y.on('afterTransaction', function (y, transaction) {
              var cnf = _this.ys.get(y);
              if (cnf.len > 0) {
                cnf.buffer.setUint32(0, cnf.len);
                _this.saveUpdate(y, cnf.buffer.createBuffer(), transaction);
                var _cnf = getFreshCnf();
                for (var key in _cnf) {
                  cnf[key] = _cnf[key];
                }
              }
            });
            return _this.retrieve(y);
          }).then(function () {
            return Promise.resolve(cnf);
          });
        } else {
          return Promise.resolve(cnf);
        }
      }
    }, {
      key: 'deinit',
      value: function deinit(y) {
        this.ys.delete(y);
        y.persistence = null;
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.ys = null;
      }

      /**
       * Remove all persisted data that belongs to a room.
       * Automatically destroys all Yjs all Yjs instances that persist to
       * the room. If `destroyYjsInstances = false` the persistence functionality
       * will be removed from the Yjs instances.
       *
       * ** Must be overwritten! **
       */

    }, {
      key: 'removePersistedData',
      value: function removePersistedData(room) {
        var _this2 = this;

        var destroyYjsInstances = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        this.ys.forEach(function (cnf, y) {
          if (y.room === room) {
            if (destroyYjsInstances) {
              y.destroy();
            } else {
              _this2.deinit(y);
            }
          }
        });
      }

      /* overwrite */

    }, {
      key: 'saveUpdate',
      value: function saveUpdate(buffer) {}

      /**
       * Save struct to update buffer.
       * saveUpdate is called when transaction ends
       */

    }, {
      key: 'saveStruct',
      value: function saveStruct(y, struct) {
        var cnf = this.ys.get(y);
        if (cnf !== undefined) {
          cnf.mutualExclude(function () {
            struct._toBinary(cnf.buffer);
            cnf.len++;
          });
        }
      }

      /* overwrite */

    }, {
      key: 'retrieve',
      value: function retrieve(y, model, updates) {
        var cnf = this.ys.get(y);
        if (cnf !== undefined) {
          cnf.mutualExclude(function () {
            y.transact(function () {
              if (model != null) {
                fromBinary(y, new BinaryDecoder(new Uint8Array(model)));
              }
              if (updates != null) {
                for (var i = 0; i < updates.length; i++) {
                  integrateRemoteStructs(y, new BinaryDecoder(new Uint8Array(updates[i])));
                }
              }
            });
            y.emit('persistenceReady');
          });
        }
      }

      /* overwrite */

    }, {
      key: 'persist',
      value: function persist(y) {
        return toBinary(y).createBuffer();
      }
    }]);
    return AbstractPersistence;
  }();

  function typeObserver$1() {
    var _this = this;

    this._mutualExclude(function () {
      var textarea = _this.target;
      var textType = _this.type;
      var relativeStart = getRelativePosition(textType, textarea.selectionStart);
      var relativeEnd = getRelativePosition(textType, textarea.selectionEnd);
      textarea.value = textType.toString();
      var start = fromRelativePosition(textType._y, relativeStart);
      var end = fromRelativePosition(textType._y, relativeEnd);
      textarea.setSelectionRange(start, end);
    });
  }

  function domObserver$1() {
    var _this2 = this;

    this._mutualExclude(function () {
      var diff = simpleDiff(_this2.type.toString(), _this2.target.value);
      _this2.type.delete(diff.pos, diff.remove);
      _this2.type.insert(diff.pos, diff.insert);
    });
  }

  /**
   * A binding that binds a YText to a dom textarea.
   *
   * This binding is automatically destroyed when its parent is deleted.
   *
   * @example
   *   const textare = document.createElement('textarea')
   *   const type = y.define('textarea', Y.Text)
   *   const binding = new Y.QuillBinding(type, textarea)
   *
   */

  var TextareaBinding = function (_Binding) {
    inherits(TextareaBinding, _Binding);

    function TextareaBinding(textType, domTextarea) {
      classCallCheck(this, TextareaBinding);

      // set initial value
      var _this3 = possibleConstructorReturn(this, (TextareaBinding.__proto__ || Object.getPrototypeOf(TextareaBinding)).call(this, textType, domTextarea));
      // Binding handles textType as this.type and domTextarea as this.target


      domTextarea.value = textType.toString();
      // Observers are handled by this class
      _this3._typeObserver = typeObserver$1.bind(_this3);
      _this3._domObserver = domObserver$1.bind(_this3);
      textType.observe(_this3._typeObserver);
      domTextarea.addEventListener('input', _this3._domObserver);
      return _this3;
    }

    createClass(TextareaBinding, [{
      key: 'destroy',
      value: function destroy() {
        // Remove everything that is handled by this class
        this.type.unobserve(this._typeObserver);
        this.target.unobserve(this._domObserver);
        get(TextareaBinding.prototype.__proto__ || Object.getPrototypeOf(TextareaBinding.prototype), 'destroy', this).call(this);
      }
    }]);
    return TextareaBinding;
  }(Binding);

  function typeObserver$2(event) {
    var quill = this.target;
    // Force flush Quill changes.
    quill.update('yjs');
    this._mutualExclude(function () {
      // Apply computed delta.
      quill.updateContents(event.delta, 'yjs');
      // Force flush Quill changes. Ignore applied changes.
      quill.update('yjs');
    });
  }

  function quillObserver(delta) {
    var _this = this;

    this._mutualExclude(function () {
      _this.type.applyDelta(delta.ops);
    });
  }

  /**
   * A Binding that binds a YText type to a Quill editor.
   *
   * @example
   * const quill = new Quill(document.createElement('div'))
   * const type = y.define('quill', Y.Text)
   * const binding = new Y.QuillBinding(quill, type)
   * // Now modifications on the DOM will be reflected in the Type, and the other
   * // way around!
   */

  var QuillBinding = function (_Binding) {
    inherits(QuillBinding, _Binding);

    /**
     * @param {YText} textType
     * @param {Quill} quill
     */
    function QuillBinding(textType, quill) {
      classCallCheck(this, QuillBinding);

      // Set initial value.
      var _this2 = possibleConstructorReturn(this, (QuillBinding.__proto__ || Object.getPrototypeOf(QuillBinding)).call(this, textType, quill));
      // Binding handles textType as this.type and quill as this.target.


      quill.setContents(textType.toDelta(), 'yjs');
      // Observers are handled by this class.
      _this2._typeObserver = typeObserver$2.bind(_this2);
      _this2._quillObserver = quillObserver.bind(_this2);
      textType.observe(_this2._typeObserver);
      quill.on('text-change', _this2._quillObserver);
      return _this2;
    }

    createClass(QuillBinding, [{
      key: 'destroy',
      value: function destroy() {
        // Remove everything that is handled by this class.
        this.type.unobserve(this._typeObserver);
        this.target.off('text-change', this._quillObserver);
        get(QuillBinding.prototype.__proto__ || Object.getPrototypeOf(QuillBinding.prototype), 'destroy', this).call(this);
      }
    }]);
    return QuillBinding;
  }(Binding);

  function typeObserver$3(event) {
    var _this = this;

    this._mutualExclude(function () {
      var codeMirror = _this.target;
      var deltas = event.delta;
      var index = 0;
      var from = codeMirror.posFromIndex(index);
      for (var i = 0; i < deltas.length; i++) {
        var delta = deltas[i];
        if (delta.retain) {
          index = delta.retain;
          from = codeMirror.posFromIndex(index);
        } else if (delta.insert) {
          codeMirror.replaceRange(delta.insert, from, from);
        } else if (delta.delete) {
          codeMirror.replaceRange('', from, codeMirror.posFromIndex(index + delta.delete));
        }
      }
    });
  }

  function codeMirrorObserver(codeMirror, deltas) {
    var _this2 = this;

    this._mutualExclude(function () {
      for (var i = 0; i < deltas.length; i++) {
        var delta = deltas[i];
        var start = codeMirror.indexFromPos(delta.from);
        // apply the delete operation first
        if (delta.removed.length > 0) {
          var delLength = 0;
          for (var j = 0; j < delta.removed.length; j++) {
            delLength += delta.removed[j].length;
          }
          // "enter" is also a character in our case
          delLength += delta.removed.length - 1;
          _this2.type.delete(start, delLength);
        }
        // apply insert operation
        _this2.type.insert(start, delta.text.join('\n'));
      }
    });
  }

  /**
   * A binding that binds a YText to a codemirror.
   *
   * This binding is automatically destroyed when its parent is deleted.
   *
   */

  var CodeMirrorBinding = function (_Binding) {
    inherits(CodeMirrorBinding, _Binding);

    function CodeMirrorBinding(textType, codeMirror) {
      classCallCheck(this, CodeMirrorBinding);

      // set initial value
      var _this3 = possibleConstructorReturn(this, (CodeMirrorBinding.__proto__ || Object.getPrototypeOf(CodeMirrorBinding)).call(this, textType, codeMirror));

      codeMirror.setValue(textType.toString());
      // Observers are handled by this class
      _this3._typeObserver = typeObserver$3.bind(_this3);
      _this3._codeMirrorObserver = codeMirrorObserver.bind(_this3);
      textType.observe(_this3._typeObserver);
      codeMirror.on('changes', _this3._codeMirrorObserver);
      return _this3;
    }

    createClass(CodeMirrorBinding, [{
      key: 'destroy',
      value: function destroy() {
        // Remove everything that is handled by this class
        this.type.unobserve(this._typeObserver);
        this.target.unobserve(this._codeMirrorObserver);
        get(CodeMirrorBinding.prototype.__proto__ || Object.getPrototypeOf(CodeMirrorBinding.prototype), 'destroy', this).call(this);
      }
    }]);
    return CodeMirrorBinding;
  }(Binding);

  // TODO: The following assignments should be moved to yjs-dist
  Y.AbstractConnector = AbstractConnector;
  Y.AbstractPersistence = AbstractPersistence;
  Y.Array = YArray;
  Y.Map = YMap;
  Y.Text = YText;
  Y.XmlElement = YXmlElement;
  Y.XmlFragment = YXmlFragment;
  Y.XmlText = YXmlText;
  Y.XmlHook = YXmlHook;

  Y.TextareaBinding = TextareaBinding;
  Y.QuillBinding = QuillBinding;
  Y.DomBinding = DomBinding;
  Y.CodeMirrorBinding = CodeMirrorBinding;

  DomBinding.domToType = domToType;
  DomBinding.domsToTypes = domsToTypes;
  DomBinding.switchAssociation = switchAssociation;

  Y.utils = {
    BinaryDecoder: BinaryDecoder,
    UndoManager: UndoManager,
    getRelativePosition: getRelativePosition,
    fromRelativePosition: fromRelativePosition,
    registerStruct: registerStruct,
    integrateRemoteStructs: integrateRemoteStructs,
    toBinary: toBinary,
    fromBinary: fromBinary
  };

  Y.debug = browser;
  browser.formatters.Y = messageToString;
  browser.formatters.y = messageToRoomname;

  return Y;

})));


}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":4,"buffer":2}],7:[function(require,module,exports){
(function (process,Buffer){

/**
 * yjs - A framework for real-time p2p shared editing on any data
 * @version v13.0.0-62
 * @license MIT
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Y = factory());
}(this, (function () { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  function rotate(tree, parent, newParent, n) {
    if (parent === null) {
      tree.root = newParent;
      newParent._parent = null;
    } else if (parent.left === n) {
      parent.left = newParent;
    } else if (parent.right === n) {
      parent.right = newParent;
    } else {
      throw new Error('The elements are wrongly connected!');
    }
  }

  var N = function () {
    // A created node is always red!
    function N(val) {
      classCallCheck(this, N);

      this.val = val;
      this.color = true;
      this._left = null;
      this._right = null;
      this._parent = null;
    }

    createClass(N, [{
      key: 'isRed',
      value: function isRed() {
        return this.color;
      }
    }, {
      key: 'isBlack',
      value: function isBlack() {
        return !this.color;
      }
    }, {
      key: 'redden',
      value: function redden() {
        this.color = true;return this;
      }
    }, {
      key: 'blacken',
      value: function blacken() {
        this.color = false;return this;
      }
    }, {
      key: 'rotateLeft',
      value: function rotateLeft(tree) {
        var parent = this.parent;
        var newParent = this.right;
        var newRight = this.right.left;
        newParent.left = this;
        this.right = newRight;
        rotate(tree, parent, newParent, this);
      }
    }, {
      key: 'next',
      value: function next() {
        if (this.right !== null) {
          // search the most left node in the right tree
          var o = this.right;
          while (o.left !== null) {
            o = o.left;
          }
          return o;
        } else {
          var p = this;
          while (p.parent !== null && p !== p.parent.left) {
            p = p.parent;
          }
          return p.parent;
        }
      }
    }, {
      key: 'prev',
      value: function prev() {
        if (this.left !== null) {
          // search the most right node in the left tree
          var o = this.left;
          while (o.right !== null) {
            o = o.right;
          }
          return o;
        } else {
          var p = this;
          while (p.parent !== null && p !== p.parent.right) {
            p = p.parent;
          }
          return p.parent;
        }
      }
    }, {
      key: 'rotateRight',
      value: function rotateRight(tree) {
        var parent = this.parent;
        var newParent = this.left;
        var newLeft = this.left.right;
        newParent.right = this;
        this.left = newLeft;
        rotate(tree, parent, newParent, this);
      }
    }, {
      key: 'getUncle',
      value: function getUncle() {
        // we can assume that grandparent exists when this is called!
        if (this.parent === this.parent.parent.left) {
          return this.parent.parent.right;
        } else {
          return this.parent.parent.left;
        }
      }
    }, {
      key: 'grandparent',
      get: function get$$1() {
        return this.parent.parent;
      }
    }, {
      key: 'parent',
      get: function get$$1() {
        return this._parent;
      }
    }, {
      key: 'sibling',
      get: function get$$1() {
        return this === this.parent.left ? this.parent.right : this.parent.left;
      }
    }, {
      key: 'left',
      get: function get$$1() {
        return this._left;
      },
      set: function set$$1(n) {
        if (n !== null) {
          n._parent = this;
        }
        this._left = n;
      }
    }, {
      key: 'right',
      get: function get$$1() {
        return this._right;
      },
      set: function set$$1(n) {
        if (n !== null) {
          n._parent = this;
        }
        this._right = n;
      }
    }]);
    return N;
  }();

  /*
   * This is a Red Black Tree implementation
   */


  var Tree = function () {
    function Tree() {
      classCallCheck(this, Tree);

      this.root = null;
      this.length = 0;
    }

    createClass(Tree, [{
      key: 'findNext',
      value: function findNext(id) {
        var nextID = id.clone();
        nextID.clock += 1;
        return this.findWithLowerBound(nextID);
      }
    }, {
      key: 'findPrev',
      value: function findPrev(id) {
        var prevID = id.clone();
        prevID.clock -= 1;
        return this.findWithUpperBound(prevID);
      }
    }, {
      key: 'findNodeWithLowerBound',
      value: function findNodeWithLowerBound(from) {
        var o = this.root;
        if (o === null) {
          return null;
        } else {
          while (true) {
            if (from === null || from.lessThan(o.val._id) && o.left !== null) {
              // o is included in the bound
              // try to find an element that is closer to the bound
              o = o.left;
            } else if (from !== null && o.val._id.lessThan(from)) {
              // o is not within the bound, maybe one of the right elements is..
              if (o.right !== null) {
                o = o.right;
              } else {
                // there is no right element. Search for the next bigger element,
                // this should be within the bounds
                return o.next();
              }
            } else {
              return o;
            }
          }
        }
      }
    }, {
      key: 'findNodeWithUpperBound',
      value: function findNodeWithUpperBound(to) {
        if (to === void 0) {
          throw new Error('You must define from!');
        }
        var o = this.root;
        if (o === null) {
          return null;
        } else {
          while (true) {
            if ((to === null || o.val._id.lessThan(to)) && o.right !== null) {
              // o is included in the bound
              // try to find an element that is closer to the bound
              o = o.right;
            } else if (to !== null && to.lessThan(o.val._id)) {
              // o is not within the bound, maybe one of the left elements is..
              if (o.left !== null) {
                o = o.left;
              } else {
                // there is no left element. Search for the prev smaller element,
                // this should be within the bounds
                return o.prev();
              }
            } else {
              return o;
            }
          }
        }
      }
    }, {
      key: 'findSmallestNode',
      value: function findSmallestNode() {
        var o = this.root;
        while (o != null && o.left != null) {
          o = o.left;
        }
        return o;
      }
    }, {
      key: 'findWithLowerBound',
      value: function findWithLowerBound(from) {
        var n = this.findNodeWithLowerBound(from);
        return n == null ? null : n.val;
      }
    }, {
      key: 'findWithUpperBound',
      value: function findWithUpperBound(to) {
        var n = this.findNodeWithUpperBound(to);
        return n == null ? null : n.val;
      }
    }, {
      key: 'iterate',
      value: function iterate(from, to, f) {
        var o;
        if (from === null) {
          o = this.findSmallestNode();
        } else {
          o = this.findNodeWithLowerBound(from);
        }
        while (o !== null && (to === null || // eslint-disable-line no-unmodified-loop-condition
        o.val._id.lessThan(to) || o.val._id.equals(to))) {
          f(o.val);
          o = o.next();
        }
      }
    }, {
      key: 'find',
      value: function find(id) {
        var n = this.findNode(id);
        if (n !== null) {
          return n.val;
        } else {
          return null;
        }
      }
    }, {
      key: 'findNode',
      value: function findNode(id) {
        var o = this.root;
        if (o === null) {
          return null;
        } else {
          while (true) {
            if (o === null) {
              return null;
            }
            if (id.lessThan(o.val._id)) {
              o = o.left;
            } else if (o.val._id.lessThan(id)) {
              o = o.right;
            } else {
              return o;
            }
          }
        }
      }
    }, {
      key: 'delete',
      value: function _delete(id) {
        var d = this.findNode(id);
        if (d == null) {
          // throw new Error('Element does not exist!')
          return;
        }
        this.length--;
        if (d.left !== null && d.right !== null) {
          // switch d with the greates element in the left subtree.
          // o should have at most one child.
          var o = d.left;
          // find
          while (o.right !== null) {
            o = o.right;
          }
          // switch
          d.val = o.val;
          d = o;
        }
        // d has at most one child
        // let n be the node that replaces d
        var isFakeChild;
        var child = d.left || d.right;
        if (child === null) {
          isFakeChild = true;
          child = new N(null);
          child.blacken();
          d.right = child;
        } else {
          isFakeChild = false;
        }

        if (d.parent === null) {
          if (!isFakeChild) {
            this.root = child;
            child.blacken();
            child._parent = null;
          } else {
            this.root = null;
          }
          return;
        } else if (d.parent.left === d) {
          d.parent.left = child;
        } else if (d.parent.right === d) {
          d.parent.right = child;
        } else {
          throw new Error('Impossible!');
        }
        if (d.isBlack()) {
          if (child.isRed()) {
            child.blacken();
          } else {
            this._fixDelete(child);
          }
        }
        this.root.blacken();
        if (isFakeChild) {
          if (child.parent.left === child) {
            child.parent.left = null;
          } else if (child.parent.right === child) {
            child.parent.right = null;
          } else {
            throw new Error('Impossible #3');
          }
        }
      }
    }, {
      key: '_fixDelete',
      value: function _fixDelete(n) {
        function isBlack(node) {
          return node !== null ? node.isBlack() : true;
        }
        function isRed(node) {
          return node !== null ? node.isRed() : false;
        }
        if (n.parent === null) {
          // this can only be called after the first iteration of fixDelete.
          return;
        }
        // d was already replaced by the child
        // d is not the root
        // d and child are black
        var sibling = n.sibling;
        if (isRed(sibling)) {
          // make sibling the grandfather
          n.parent.redden();
          sibling.blacken();
          if (n === n.parent.left) {
            n.parent.rotateLeft(this);
          } else if (n === n.parent.right) {
            n.parent.rotateRight(this);
          } else {
            throw new Error('Impossible #2');
          }
          sibling = n.sibling;
        }
        // parent, sibling, and children of n are black
        if (n.parent.isBlack() && sibling.isBlack() && isBlack(sibling.left) && isBlack(sibling.right)) {
          sibling.redden();
          this._fixDelete(n.parent);
        } else if (n.parent.isRed() && sibling.isBlack() && isBlack(sibling.left) && isBlack(sibling.right)) {
          sibling.redden();
          n.parent.blacken();
        } else {
          if (n === n.parent.left && sibling.isBlack() && isRed(sibling.left) && isBlack(sibling.right)) {
            sibling.redden();
            sibling.left.blacken();
            sibling.rotateRight(this);
            sibling = n.sibling;
          } else if (n === n.parent.right && sibling.isBlack() && isRed(sibling.right) && isBlack(sibling.left)) {
            sibling.redden();
            sibling.right.blacken();
            sibling.rotateLeft(this);
            sibling = n.sibling;
          }
          sibling.color = n.parent.color;
          n.parent.blacken();
          if (n === n.parent.left) {
            sibling.right.blacken();
            n.parent.rotateLeft(this);
          } else {
            sibling.left.blacken();
            n.parent.rotateRight(this);
          }
        }
      }
    }, {
      key: 'put',
      value: function put(v) {
        var node = new N(v);
        if (this.root !== null) {
          var p = this.root; // p abbrev. parent
          while (true) {
            if (node.val._id.lessThan(p.val._id)) {
              if (p.left === null) {
                p.left = node;
                break;
              } else {
                p = p.left;
              }
            } else if (p.val._id.lessThan(node.val._id)) {
              if (p.right === null) {
                p.right = node;
                break;
              } else {
                p = p.right;
              }
            } else {
              p.val = node.val;
              return p;
            }
          }
          this._fixInsert(node);
        } else {
          this.root = node;
        }
        this.length++;
        this.root.blacken();
        return node;
      }
    }, {
      key: '_fixInsert',
      value: function _fixInsert(n) {
        if (n.parent === null) {
          n.blacken();
          return;
        } else if (n.parent.isBlack()) {
          return;
        }
        var uncle = n.getUncle();
        if (uncle !== null && uncle.isRed()) {
          // Note: parent: red, uncle: red
          n.parent.blacken();
          uncle.blacken();
          n.grandparent.redden();
          this._fixInsert(n.grandparent);
        } else {
          // Note: parent: red, uncle: black or null
          // Now we transform the tree in such a way that
          // either of these holds:
          //   1) grandparent.left.isRed
          //     and grandparent.left.left.isRed
          //   2) grandparent.right.isRed
          //     and grandparent.right.right.isRed
          if (n === n.parent.right && n.parent === n.grandparent.left) {
            n.parent.rotateLeft(this);
            // Since we rotated and want to use the previous
            // cases, we need to set n in such a way that
            // n.parent.isRed again
            n = n.left;
          } else if (n === n.parent.left && n.parent === n.grandparent.right) {
            n.parent.rotateRight(this);
            // see above
            n = n.right;
          }
          // Case 1) or 2) hold from here on.
          // Now traverse grandparent, make parent a black node
          // on the highest level which holds two red nodes.
          n.parent.blacken();
          n.grandparent.redden();
          if (n === n.parent.left) {
            // Case 1
            n.grandparent.rotateRight(this);
          } else {
            // Case 2
            n.grandparent.rotateLeft(this);
          }
        }
      }
    }]);
    return Tree;
  }();

  var ID = function () {
    function ID(user, clock) {
      classCallCheck(this, ID);

      this.user = user; // TODO: rename to client
      this.clock = clock;
    }

    createClass(ID, [{
      key: "clone",
      value: function clone() {
        return new ID(this.user, this.clock);
      }
    }, {
      key: "equals",
      value: function equals(id) {
        return id !== null && id.user === this.user && id.clock === this.clock;
      }
    }, {
      key: "lessThan",
      value: function lessThan(id) {
        if (id.constructor === ID) {
          return this.user < id.user || this.user === id.user && this.clock < id.clock;
        } else {
          return false;
        }
      }
    }]);
    return ID;
  }();

  var DSNode = function () {
    function DSNode(id, len, gc) {
      classCallCheck(this, DSNode);

      this._id = id;
      this.len = len;
      this.gc = gc;
    }

    createClass(DSNode, [{
      key: 'clone',
      value: function clone() {
        return new DSNode(this._id, this.len, this.gc);
      }
    }]);
    return DSNode;
  }();

  var DeleteStore = function (_Tree) {
    inherits(DeleteStore, _Tree);

    function DeleteStore() {
      classCallCheck(this, DeleteStore);
      return possibleConstructorReturn(this, (DeleteStore.__proto__ || Object.getPrototypeOf(DeleteStore)).apply(this, arguments));
    }

    createClass(DeleteStore, [{
      key: 'logTable',
      value: function logTable() {
        var deletes = [];
        this.iterate(null, null, function (n) {
          deletes.push({
            user: n._id.user,
            clock: n._id.clock,
            len: n.len,
            gc: n.gc
          });
        });
        console.table(deletes);
      }
    }, {
      key: 'isDeleted',
      value: function isDeleted(id) {
        var n = this.findWithUpperBound(id);
        return n !== null && n._id.user === id.user && id.clock < n._id.clock + n.len;
      }
    }, {
      key: 'mark',
      value: function mark(id, length, gc) {
        if (length === 0) return;
        // Step 1. Unmark range
        var leftD = this.findWithUpperBound(new ID(id.user, id.clock - 1));
        // Resize left DSNode if necessary
        if (leftD !== null && leftD._id.user === id.user) {
          if (leftD._id.clock < id.clock && id.clock < leftD._id.clock + leftD.len) {
            // node is overlapping. need to resize
            if (id.clock + length < leftD._id.clock + leftD.len) {
              // overlaps new mark range and some more
              // create another DSNode to the right of new mark
              this.put(new DSNode(new ID(id.user, id.clock + length), leftD._id.clock + leftD.len - id.clock - length, leftD.gc));
            }
            // resize left DSNode
            leftD.len = id.clock - leftD._id.clock;
          } // Otherwise there is no overlapping
        }
        // Resize right DSNode if necessary
        var upper = new ID(id.user, id.clock + length - 1);
        var rightD = this.findWithUpperBound(upper);
        if (rightD !== null && rightD._id.user === id.user) {
          if (rightD._id.clock < id.clock + length && id.clock <= rightD._id.clock && id.clock + length < rightD._id.clock + rightD.len) {
            // we only consider the case where we resize the node
            var d = id.clock + length - rightD._id.clock;
            rightD._id = new ID(rightD._id.user, rightD._id.clock + d);
            rightD.len -= d;
          }
        }
        // Now we only have to delete all inner marks
        var deleteNodeIds = [];
        this.iterate(id, upper, function (m) {
          deleteNodeIds.push(m._id);
        });
        for (var i = deleteNodeIds.length - 1; i >= 0; i--) {
          this.delete(deleteNodeIds[i]);
        }
        var newMark = new DSNode(id, length, gc);
        // Step 2. Check if we can extend left or right
        if (leftD !== null && leftD._id.user === id.user && leftD._id.clock + leftD.len === id.clock && leftD.gc === gc) {
          // We can extend left
          leftD.len += length;
          newMark = leftD;
        }
        var rightNext = this.find(new ID(id.user, id.clock + length));
        if (rightNext !== null && rightNext._id.user === id.user && id.clock + length === rightNext._id.clock && gc === rightNext.gc) {
          // We can merge newMark and rightNext
          newMark.len += rightNext.len;
          this.delete(rightNext._id);
        }
        if (leftD !== newMark) {
          // only put if we didn't extend left
          this.put(newMark);
        }
      }
      // TODO: exchange markDeleted for mark()

    }, {
      key: 'markDeleted',
      value: function markDeleted(id, length) {
        this.mark(id, length, false);
      }
    }]);
    return DeleteStore;
  }(Tree);

  /**
   * A BinaryDecoder handles the decoding of an ArrayBuffer.
   */

  var BinaryDecoder = function () {
    /**
     * @param {Uint8Array|Buffer} buffer The binary data that this instance
     *                                   decodes.
     */
    function BinaryDecoder(buffer) {
      classCallCheck(this, BinaryDecoder);

      if (buffer instanceof ArrayBuffer) {
        this.uint8arr = new Uint8Array(buffer);
      } else if (buffer instanceof Uint8Array || typeof Buffer !== 'undefined' && buffer instanceof Buffer) {
        this.uint8arr = buffer;
      } else {
        throw new Error('Expected an ArrayBuffer or Uint8Array!');
      }
      this.pos = 0;
    }

    /**
     * Clone this decoder instance.
     * Optionally set a new position parameter.
     */


    createClass(BinaryDecoder, [{
      key: 'clone',
      value: function clone() {
        var newPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pos;

        var decoder = new BinaryDecoder(this.uint8arr);
        decoder.pos = newPos;
        return decoder;
      }

      /**
       * Number of bytes.
       */

    }, {
      key: 'skip8',


      /**
       * Skip one byte, jump to the next position.
       */
      value: function skip8() {
        this.pos++;
      }

      /**
       * Read one byte as unsigned integer.
       */

    }, {
      key: 'readUint8',
      value: function readUint8() {
        return this.uint8arr[this.pos++];
      }

      /**
       * Read 4 bytes as unsigned integer.
       *
       * @return {number} An unsigned integer.
       */

    }, {
      key: 'readUint32',
      value: function readUint32() {
        var uint = this.uint8arr[this.pos] + (this.uint8arr[this.pos + 1] << 8) + (this.uint8arr[this.pos + 2] << 16) + (this.uint8arr[this.pos + 3] << 24);
        this.pos += 4;
        return uint;
      }

      /**
       * Look ahead without incrementing position.
       * to the next byte and read it as unsigned integer.
       *
       * @return {number} An unsigned integer.
       */

    }, {
      key: 'peekUint8',
      value: function peekUint8() {
        return this.uint8arr[this.pos];
      }

      /**
       * Read unsigned integer (32bit) with variable length.
       * 1/8th of the storage is used as encoding overhead.
       *  * numbers < 2^7 is stored in one byte.
       *  * numbers < 2^14 is stored in two bytes.
       *
       * @return {number} An unsigned integer.
       */

    }, {
      key: 'readVarUint',
      value: function readVarUint() {
        var num = 0;
        var len = 0;
        while (true) {
          var r = this.uint8arr[this.pos++];
          num = num | (r & 127) << len;
          len += 7;
          if (r < 1 << 7) {
            return num >>> 0; // return unsigned number!
          }
          if (len > 35) {
            throw new Error('Integer out of range!');
          }
        }
      }

      /**
       * Read string of variable length
       * * varUint is used to store the length of the string
       *
       * @return {String} The read String.
       */

    }, {
      key: 'readVarString',
      value: function readVarString() {
        var len = this.readVarUint();
        var bytes = new Array(len);
        for (var i = 0; i < len; i++) {
          bytes[i] = this.uint8arr[this.pos++];
        }
        var encodedString = bytes.map(function (b) {
          return String.fromCodePoint(b);
        }).join('');
        return decodeURIComponent(escape(encodedString));
      }

      /**
       * Look ahead and read varString without incrementing position
       */

    }, {
      key: 'peekVarString',
      value: function peekVarString() {
        var pos = this.pos;
        var s = this.readVarString();
        this.pos = pos;
        return s;
      }

      /**
       * Read ID.
       * * If first varUint read is 0xFFFFFF a RootID is returned.
       * * Otherwise an ID is returned.
       *
       * @return ID
       */

    }, {
      key: 'readID',
      value: function readID() {
        var user = this.readVarUint();
        if (user === RootFakeUserID) {
          // read property name and type id
          var rid = new RootID(this.readVarString(), null);
          rid.type = this.readVarUint();
          return rid;
        }
        return new ID(user, this.readVarUint());
      }
    }, {
      key: 'length',
      get: function get$$1() {
        return this.uint8arr.length;
      }
    }]);
    return BinaryDecoder;
  }();

  // TODO should have the same base class as Item

  var GC = function () {
    function GC() {
      classCallCheck(this, GC);

      this._id = null;
      this._length = 0;
    }

    createClass(GC, [{
      key: '_integrate',
      value: function _integrate(y) {
        var id = this._id;
        var userState = y.ss.getState(id.user);
        if (id.clock === userState) {
          y.ss.setState(id.user, id.clock + this._length);
        }
        y.ds.mark(this._id, this._length, true);
        var n = y.os.put(this);
        var prev = n.prev().val;
        if (prev !== null && prev.constructor === GC && prev._id.user === n.val._id.user && prev._id.clock + prev._length === n.val._id.clock) {
          // TODO: do merging for all items!
          prev._length += n.val._length;
          y.os.delete(n.val._id);
          n = prev;
        }
        if (n.val) {
          n = n.val;
        }
        var next = y.os.findNext(n._id);
        if (next !== null && next.constructor === GC && next._id.user === n._id.user && next._id.clock === n._id.clock + n._length) {
          n._length += next._length;
          y.os.delete(next._id);
        }
        if (id.user !== RootFakeUserID) {
          if (y.connector !== null && (y.connector._forwardAppliedStructs || id.user === y.userID)) {
            y.connector.broadcastStruct(this);
          }
          if (y.persistence !== null) {
            y.persistence.saveStruct(y, this);
          }
        }
      }

      /**
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       *
       * @param {BinaryEncoder} encoder The encoder to write data to.
       * @private
       */

    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        encoder.writeUint8(getStructReference(this.constructor));
        encoder.writeID(this._id);
        encoder.writeVarUint(this._length);
      }

      /**
       * Read the next Item in a Decoder and fill this Item with the read data.
       *
       * This is called when data is received from a remote peer.
       *
       * @param {Y} y The Yjs instance that this Item belongs to.
       * @param {BinaryDecoder} decoder The decoder object to read data from.
       * @private
       */

    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var id = decoder.readID();
        this._id = id;
        this._length = decoder.readVarUint();
        var missing = [];
        if (y.ss.getState(id.user) < id.clock) {
          missing.push(new ID(id.user, id.clock - 1));
        }
        return missing;
      }
    }, {
      key: '_splitAt',
      value: function _splitAt() {
        return this;
      }
    }, {
      key: '_clonePartial',
      value: function _clonePartial(diff) {
        var gc = new GC();
        gc._id = new ID(this._id.user, this._id.clock + diff);
        gc._length = this._length - diff;
        return gc;
      }
    }, {
      key: '_deleted',
      get: function get$$1() {
        return true;
      }
    }]);
    return GC;
  }();

  var MissingEntry = function MissingEntry(decoder, missing, struct) {
    classCallCheck(this, MissingEntry);

    this.decoder = decoder;
    this.missing = missing.length;
    this.struct = struct;
  };

  /**
   * @private
   * Integrate remote struct
   * When a remote struct is integrated, other structs might be ready to ready to
   * integrate.
   */


  function _integrateRemoteStructHelper(y, struct) {
    var id = struct._id;
    if (id === undefined) {
      struct._integrate(y);
    } else {
      if (y.ss.getState(id.user) > id.clock) {
        return;
      }
      if (!y.gcEnabled || struct.constructor === GC || struct._parent.constructor !== GC && struct._parent._deleted === false) {
        // Is either a GC or Item with an undeleted parent
        // save to integrate
        struct._integrate(y);
      } else {
        // Is an Item. parent was deleted.
        struct._gc(y);
      }
      var msu = y._missingStructs.get(id.user);
      if (msu != null) {
        var clock = id.clock;
        var finalClock = clock + struct._length;
        for (; clock < finalClock; clock++) {
          var missingStructs = msu.get(clock);
          if (missingStructs !== undefined) {
            missingStructs.forEach(function (missingDef) {
              missingDef.missing--;
              if (missingDef.missing === 0) {
                var decoder = missingDef.decoder;
                var oldPos = decoder.pos;
                var missing = missingDef.struct._fromBinary(y, decoder);
                decoder.pos = oldPos;
                if (missing.length === 0) {
                  y._readyToIntegrate.push(missingDef.struct);
                }
              }
            });
            msu.delete(clock);
          }
        }
      }
    }
  }

  function stringifyStructs(y, decoder, strBuilder) {
    var len = decoder.readUint32();
    for (var i = 0; i < len; i++) {
      var reference = decoder.readVarUint();
      var Constr = getStruct(reference);
      var struct = new Constr();
      var missing = struct._fromBinary(y, decoder);
      var logMessage = '  ' + struct._logString();
      if (missing.length > 0) {
        logMessage += ' .. missing: ' + missing.map(logID).join(', ');
      }
      strBuilder.push(logMessage);
    }
  }

  function integrateRemoteStructs(y, decoder) {
    var len = decoder.readUint32();
    for (var i = 0; i < len; i++) {
      var reference = decoder.readVarUint();
      var Constr = getStruct(reference);
      var struct = new Constr();
      var decoderPos = decoder.pos;
      var missing = struct._fromBinary(y, decoder);
      if (missing.length === 0) {
        while (struct != null) {
          _integrateRemoteStructHelper(y, struct);
          struct = y._readyToIntegrate.shift();
        }
      } else {
        var _decoder = new BinaryDecoder(decoder.uint8arr);
        _decoder.pos = decoderPos;
        var missingEntry = new MissingEntry(_decoder, missing, struct);
        var missingStructs = y._missingStructs;
        for (var _i = missing.length - 1; _i >= 0; _i--) {
          var m = missing[_i];
          if (!missingStructs.has(m.user)) {
            missingStructs.set(m.user, new Map());
          }
          var msu = missingStructs.get(m.user);
          if (!msu.has(m.clock)) {
            msu.set(m.clock, []);
          }
          var mArray = msu = msu.get(m.clock);
          mArray.push(missingEntry);
        }
      }
    }
  }

  var bits7 = 127;
  var bits8 = 255;

  /**
   * A BinaryEncoder handles the encoding to an ArrayBuffer.
   */

  var BinaryEncoder = function () {
    function BinaryEncoder() {
      classCallCheck(this, BinaryEncoder);

      // TODO: implement chained Uint8Array buffers instead of Array buffer
      // TODO: Rewrite all methods as functions!
      this.data = [];
    }

    /**
     * The current length of the encoded data.
     */


    createClass(BinaryEncoder, [{
      key: 'createBuffer',


      /**
       * Create an ArrayBuffer.
       *
       * @return {Uint8Array} A Uint8Array that represents the written data.
       */
      value: function createBuffer() {
        return Uint8Array.from(this.data).buffer;
      }

      /**
       * Write one byte as an unsigned integer.
       *
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'writeUint8',
      value: function writeUint8(num) {
        this.data.push(num & bits8);
      }

      /**
       * Write one byte as an unsigned Integer at a specific location.
       *
       * @param {number} pos The location where the data will be written.
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'setUint8',
      value: function setUint8(pos, num) {
        this.data[pos] = num & bits8;
      }

      /**
       * Write two bytes as an unsigned integer.
       *
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'writeUint16',
      value: function writeUint16(num) {
        this.data.push(num & bits8, num >>> 8 & bits8);
      }
      /**
       * Write two bytes as an unsigned integer at a specific location.
       *
       * @param {number} pos The location where the data will be written.
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'setUint16',
      value: function setUint16(pos, num) {
        this.data[pos] = num & bits8;
        this.data[pos + 1] = num >>> 8 & bits8;
      }

      /**
       * Write two bytes as an unsigned integer
       *
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'writeUint32',
      value: function writeUint32(num) {
        for (var i = 0; i < 4; i++) {
          this.data.push(num & bits8);
          num >>>= 8;
        }
      }

      /**
       * Write two bytes as an unsigned integer at a specific location.
       *
       * @param {number} pos The location where the data will be written.
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'setUint32',
      value: function setUint32(pos, num) {
        for (var i = 0; i < 4; i++) {
          this.data[pos + i] = num & bits8;
          num >>>= 8;
        }
      }

      /**
       * Write a variable length unsigned integer.
       *
       * @param {number} num The number that is to be encoded.
       */

    }, {
      key: 'writeVarUint',
      value: function writeVarUint(num) {
        while (num >= 128) {
          this.data.push(128 | bits7 & num);
          num >>>= 7;
        }
        this.data.push(bits7 & num);
      }

      /**
       * Write a variable length string.
       *
       * @param {String} str The string that is to be encoded.
       */

    }, {
      key: 'writeVarString',
      value: function writeVarString(str) {
        var encodedString = unescape(encodeURIComponent(str));
        var bytes = encodedString.split('').map(function (c) {
          return c.codePointAt();
        });
        var len = bytes.length;
        this.writeVarUint(len);
        for (var i = 0; i < len; i++) {
          this.data.push(bytes[i]);
        }
      }

      /**
       * Write an ID at the current position.
       *
       * @param {ID} id The ID that is to be written.
       */

    }, {
      key: 'writeID',
      value: function writeID(id) {
        var user = id.user;
        this.writeVarUint(user);
        if (user !== RootFakeUserID) {
          this.writeVarUint(id.clock);
        } else {
          this.writeVarString(id.name);
          this.writeVarUint(id.type);
        }
      }
    }, {
      key: 'length',
      get: function get$$1() {
        return this.data.length;
      }

      /**
       * The current write pointer (the same as {@link length}).
       */

    }, {
      key: 'pos',
      get: function get$$1() {
        return this.data.length;
      }
    }]);
    return BinaryEncoder;
  }();

  function readStateSet(decoder) {
    var ss = new Map();
    var ssLength = decoder.readUint32();
    for (var i = 0; i < ssLength; i++) {
      var user = decoder.readVarUint();
      var clock = decoder.readVarUint();
      ss.set(user, clock);
    }
    return ss;
  }

  function writeStateSet(y, encoder) {
    var lenPosition = encoder.pos;
    var len = 0;
    encoder.writeUint32(0);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = y.ss.state[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = slicedToArray(_step.value, 2),
            user = _step$value[0],
            clock = _step$value[1];

        encoder.writeVarUint(user);
        encoder.writeVarUint(clock);
        len++;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    encoder.setUint32(lenPosition, len);
  }

  function writeDeleteSet(y, encoder) {
    var currentUser = null;
    var currentLength = void 0;
    var lastLenPos = void 0;

    var numberOfUsers = 0;
    var laterDSLenPus = encoder.pos;
    encoder.writeUint32(0);

    y.ds.iterate(null, null, function (n) {
      var user = n._id.user;
      var clock = n._id.clock;
      var len = n.len;
      var gc = n.gc;
      if (currentUser !== user) {
        numberOfUsers++;
        // a new user was found
        if (currentUser !== null) {
          // happens on first iteration
          encoder.setUint32(lastLenPos, currentLength);
        }
        currentUser = user;
        encoder.writeVarUint(user);
        // pseudo-fill pos
        lastLenPos = encoder.pos;
        encoder.writeUint32(0);
        currentLength = 0;
      }
      encoder.writeVarUint(clock);
      encoder.writeVarUint(len);
      encoder.writeUint8(gc ? 1 : 0);
      currentLength++;
    });
    if (currentUser !== null) {
      // happens on first iteration
      encoder.setUint32(lastLenPos, currentLength);
    }
    encoder.setUint32(laterDSLenPus, numberOfUsers);
  }

  function readDeleteSet(y, decoder) {
    var dsLength = decoder.readUint32();

    var _loop = function _loop(i) {
      var user = decoder.readVarUint();
      var dv = [];
      var dvLength = decoder.readUint32();
      for (var j = 0; j < dvLength; j++) {
        var from = decoder.readVarUint();
        var len = decoder.readVarUint();
        var gc = decoder.readUint8() === 1;
        dv.push([from, len, gc]);
      }
      if (dvLength > 0) {
        var pos = 0;
        var d = dv[pos];
        var deletions = [];
        y.ds.iterate(new ID(user, 0), new ID(user, Number.MAX_VALUE), function (n) {
          // cases:
          // 1. d deletes something to the right of n
          //  => go to next n (break)
          // 2. d deletes something to the left of n
          //  => create deletions
          //  => reset d accordingly
          //  *)=> if d doesn't delete anything anymore, go to next d (continue)
          // 3. not 2) and d deletes something that also n deletes
          //  => reset d so that it doesn't contain n's deletion
          //  *)=> if d does not delete anything anymore, go to next d (continue)
          while (d != null) {
            var diff = 0; // describe the diff of length in 1) and 2)
            if (n._id.clock + n.len <= d[0]) {
              // 1)
              break;
            } else if (d[0] < n._id.clock) {
              // 2)
              // delete maximum the len of d
              // else delete as much as possible
              diff = Math.min(n._id.clock - d[0], d[1]);
              // deleteItemRange(y, user, d[0], diff, true)
              deletions.push([user, d[0], diff]);
            } else {
              // 3)
              diff = n._id.clock + n.len - d[0]; // never null (see 1)
              if (d[2] && !n.gc) {
                // d marks as gc'd but n does not
                // then delete either way
                // deleteItemRange(y, user, d[0], Math.min(diff, d[1]), true)
                deletions.push([user, d[0], Math.min(diff, d[1])]);
              }
            }
            if (d[1] <= diff) {
              // d doesn't delete anything anymore
              d = dv[++pos];
            } else {
              d[0] = d[0] + diff; // reset pos
              d[1] = d[1] - diff; // reset length
            }
          }
        });
        // TODO: It would be more performant to apply the deletes in the above loop
        // Adapt the Tree implementation to support delete while iterating
        for (var _i = deletions.length - 1; _i >= 0; _i--) {
          var del = deletions[_i];
          deleteItemRange(y, del[0], del[1], del[2], true);
        }
        // for the rest.. just apply it
        for (; pos < dv.length; pos++) {
          d = dv[pos];
          deleteItemRange(y, user, d[0], d[1], true);
          // deletions.push([user, d[0], d[1], d[2]])
        }
      }
    };

    for (var i = 0; i < dsLength; i++) {
      _loop(i);
    }
  }

  function stringifySyncStep1(y, decoder, strBuilder) {
    var auth = decoder.readVarString();
    var protocolVersion = decoder.readVarUint();
    strBuilder.push('  - auth: "' + auth + '"');
    strBuilder.push('  - protocolVersion: ' + protocolVersion);
    // write SS
    var ssBuilder = [];
    var len = decoder.readUint32();
    for (var i = 0; i < len; i++) {
      var user = decoder.readVarUint();
      var clock = decoder.readVarUint();
      ssBuilder.push('(' + user + ':' + clock + ')');
    }
    strBuilder.push('  == SS: ' + ssBuilder.join(','));
  }

  function sendSyncStep1(connector, syncUser) {
    var encoder = new BinaryEncoder();
    encoder.writeVarString(connector.y.room);
    encoder.writeVarString('sync step 1');
    encoder.writeVarString(connector.authInfo || '');
    encoder.writeVarUint(connector.protocolVersion);
    writeStateSet(connector.y, encoder);
    connector.send(syncUser, encoder.createBuffer());
  }

  /**
   * @private
   * Write all Items that are not not included in ss to
   * the encoder object.
   */
  function writeStructs(y, encoder, ss) {
    var lenPos = encoder.pos;
    encoder.writeUint32(0);
    var len = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = y.ss.state.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var user = _step.value;

        var clock = ss.get(user) || 0;
        if (user !== RootFakeUserID) {
          var minBound = new ID(user, clock);
          var overlappingLeft = y.os.findPrev(minBound);
          var rightID = overlappingLeft === null ? null : overlappingLeft._id;
          if (rightID !== null && rightID.user === user && rightID.clock + overlappingLeft._length > clock) {
            var struct = overlappingLeft._clonePartial(clock - rightID.clock);
            struct._toBinary(encoder);
            len++;
          }
          y.os.iterate(minBound, new ID(user, Number.MAX_VALUE), function (struct) {
            struct._toBinary(encoder);
            len++;
          });
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    encoder.setUint32(lenPos, len);
  }

  function readSyncStep1(decoder, encoder, y, senderConn, sender) {
    var protocolVersion = decoder.readVarUint();
    // check protocol version
    if (protocolVersion !== y.connector.protocolVersion) {
      console.warn('You tried to sync with a Yjs instance that has a different protocol version\n      (You: ' + protocolVersion + ', Client: ' + protocolVersion + ').\n      ');
      y.destroy();
    }
    // write sync step 2
    encoder.writeVarString('sync step 2');
    encoder.writeVarString(y.connector.authInfo || '');
    var ss = readStateSet(decoder);
    writeStructs(y, encoder, ss);
    writeDeleteSet(y, encoder);
    y.connector.send(senderConn.uid, encoder.createBuffer());
    senderConn.receivedSyncStep2 = true;
    if (y.connector.role === 'slave') {
      sendSyncStep1(y.connector, sender);
    }
  }

  function stringifySyncStep2(y, decoder, strBuilder) {
    strBuilder.push('     - auth: ' + decoder.readVarString());
    strBuilder.push('  == OS:');
    stringifyStructs(y, decoder, strBuilder);
    // write DS to string
    strBuilder.push('  == DS:');
    var len = decoder.readUint32();
    for (var i = 0; i < len; i++) {
      var user = decoder.readVarUint();
      strBuilder.push('    User: ' + user + ': ');
      var len2 = decoder.readUint32();
      for (var j = 0; j < len2; j++) {
        var from = decoder.readVarUint();
        var to = decoder.readVarUint();
        var gc = decoder.readUint8() === 1;
        strBuilder.push('[' + from + ', ' + to + ', ' + gc + ']');
      }
    }
  }

  function readSyncStep2(decoder, encoder, y, senderConn, sender) {
    integrateRemoteStructs(y, decoder);
    readDeleteSet(y, decoder);
    y.connector._setSyncedWith(sender);
  }

  function messageToString(_ref) {
    var _ref2 = slicedToArray(_ref, 2),
        y = _ref2[0],
        buffer = _ref2[1];

    var decoder = new BinaryDecoder(buffer);
    decoder.readVarString(); // read roomname
    var type = decoder.readVarString();
    var strBuilder = [];
    strBuilder.push('\n === ' + type + ' ===');
    if (type === 'update') {
      stringifyStructs(y, decoder, strBuilder);
    } else if (type === 'sync step 1') {
      stringifySyncStep1(y, decoder, strBuilder);
    } else if (type === 'sync step 2') {
      stringifySyncStep2(y, decoder, strBuilder);
    } else {
      strBuilder.push('-- Unknown message type - probably an encoding issue!!!');
    }
    return strBuilder.join('\n');
  }

  function messageToRoomname(buffer) {
    var decoder = new BinaryDecoder(buffer);
    decoder.readVarString(); // roomname
    return decoder.readVarString(); // messageType
  }

  function logID(id) {
    if (id !== null && id._id != null) {
      id = id._id;
    }
    if (id === null) {
      return '()';
    } else if (id instanceof ID) {
      return '(' + id.user + ',' + id.clock + ')';
    } else if (id instanceof RootID) {
      return '(' + id.name + ',' + id.type + ')';
    } else if (id.constructor === Y) {
      return 'y';
    } else {
      throw new Error('This is not a valid ID!');
    }
  }

  /**
   * Helper utility to convert an item to a readable format.
   *
   * @param {String} name The name of the item class (YText, ItemString, ..).
   * @param {Item} item The item instance.
   * @param {String} [append] Additional information to append to the returned
   *                          string.
   * @return {String} A readable string that represents the item object.
   *
   * @private
   */
  function logItemHelper(name, item, append) {
    var left = item._left !== null ? item._left._lastId : null;
    var origin = item._origin !== null ? item._origin._lastId : null;
    return name + '(id:' + logID(item._id) + ',left:' + logID(left) + ',origin:' + logID(origin) + ',right:' + logID(item._right) + ',parent:' + logID(item._parent) + ',parentSub:' + item._parentSub + (append !== undefined ? ' - ' + append : '') + ')';
  }

  /**
   * @private
   * Delete all items in an ID-range
   * TODO: implement getItemCleanStartNode for better performance (only one lookup)
   */
  function deleteItemRange(y, user, clock, range, gcChildren) {
    var createDelete = y.connector !== null && y.connector._forwardAppliedStructs;
    var item = y.os.getItemCleanStart(new ID(user, clock));
    if (item !== null) {
      if (!item._deleted) {
        item._splitAt(y, range);
        item._delete(y, createDelete, true);
      }
      var itemLen = item._length;
      range -= itemLen;
      clock += itemLen;
      if (range > 0) {
        var node = y.os.findNode(new ID(user, clock));
        while (node !== null && node.val !== null && range > 0 && node.val._id.equals(new ID(user, clock))) {
          var nodeVal = node.val;
          if (!nodeVal._deleted) {
            nodeVal._splitAt(y, range);
            nodeVal._delete(y, createDelete, gcChildren);
          }
          var nodeLen = nodeVal._length;
          range -= nodeLen;
          clock += nodeLen;
          node = node.next();
        }
      }
    }
  }

  /**
   * @private
   * A Delete change is not a real Item, but it provides the same interface as an
   * Item. The only difference is that it will not be saved in the ItemStore
   * (OperationStore), but instead it is safed in the DeleteStore.
   */

  var Delete = function () {
    function Delete() {
      classCallCheck(this, Delete);

      this._target = null;
      this._length = null;
    }

    /**
     * @private
     * Read the next Item in a Decoder and fill this Item with the read data.
     *
     * This is called when data is received from a remote peer.
     *
     * @param {Y} y The Yjs instance that this Item belongs to.
     * @param {BinaryDecoder} decoder The decoder object to read data from.
     */


    createClass(Delete, [{
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        // TODO: set target, and add it to missing if not found
        // There is an edge case in p2p networks!
        var targetID = decoder.readID();
        this._targetID = targetID;
        this._length = decoder.readVarUint();
        if (y.os.getItem(targetID) === null) {
          return [targetID];
        } else {
          return [];
        }
      }

      /**
       * @private
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       *
       * @param {BinaryEncoder} encoder The encoder to write data to.
       */

    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        encoder.writeUint8(getStructReference(this.constructor));
        encoder.writeID(this._targetID);
        encoder.writeVarUint(this._length);
      }

      /**
       * @private
       * Integrates this Item into the shared structure.
       *
       * This method actually applies the change to the Yjs instance. In the case of
       * Delete it marks the delete target as deleted.
       *
       * * If created remotely (a remote user deleted something),
       *   this Delete is applied to all structs in id-range.
       * * If created lokally (e.g. when y-array deletes a range of elements),
       *   this struct is broadcasted only (it is already executed)
       */

    }, {
      key: '_integrate',
      value: function _integrate(y) {
        var locallyCreated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (!locallyCreated) {
          // from remote
          var id = this._targetID;
          deleteItemRange(y, id.user, id.clock, this._length, false);
        } else if (y.connector !== null) {
          // from local
          y.connector.broadcastStruct(this);
        }
        if (y.persistence !== null) {
          y.persistence.saveStruct(y, this);
        }
      }

      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return 'Delete - target: ' + logID(this._targetID) + ', len: ' + this._length;
      }
    }]);
    return Delete;
  }();

  /**
   * A transaction is created for every change on the Yjs model. It is possible
   * to bundle changes on the Yjs model in a single transaction to
   * minimize the number on messages sent and the number of observer calls.
   * If possible the user of this library should bundle as many changes as
   * possible. Here is an example to illustrate the advantages of bundling:
   *
   * @example
   * const map = y.define('map', YMap)
   * // Log content when change is triggered
   * map.observe(function () {
   *   console.log('change triggered')
   * })
   * // Each change on the map type triggers a log message:
   * map.set('a', 0) // => "change triggered"
   * map.set('b', 0) // => "change triggered"
   * // When put in a transaction, it will trigger the log after the transaction:
   * y.transact(function () {
   *   map.set('a', 1)
   *   map.set('b', 1)
   * }) // => "change triggered"
   *
   */
  var Transaction = function Transaction(y) {
    classCallCheck(this, Transaction);

    /**
     * @type {Y} The Yjs instance.
     */
    this.y = y;
    /**
     * All new types that are added during a transaction.
     * @type {Set<Item>}
     */
    this.newTypes = new Set();
    /**
     * All types that were directly modified (property added or child
     * inserted/deleted). New types are not included in this Set.
     * Maps from type to parentSubs (`item._parentSub = null` for YArray)
     * @type {Set<YType,String>}
     */
    this.changedTypes = new Map();
    // TODO: rename deletedTypes
    /**
     * Set of all deleted Types and Structs.
     * @type {Set<Item>}
     */
    this.deletedStructs = new Set();
    /**
     * Saves the old state set of the Yjs instance. If a state was modified,
     * the original value is saved here.
     * @type {Map<Number,Number>}
     */
    this.beforeState = new Map();
    /**
     * Stores the events for the types that observe also child elements.
     * It is mainly used by `observeDeep`.
     * @type {Map<YType,Array<YEvent>>}
     */
    this.changedParentTypes = new Map();
  };
  function transactionTypeChanged(y, type, sub) {
    if (type !== y && !type._deleted && !y._transaction.newTypes.has(type)) {
      var changedTypes = y._transaction.changedTypes;
      var subs = changedTypes.get(type);
      if (subs === undefined) {
        // create if it doesn't exist yet
        subs = new Set();
        changedTypes.set(type, subs);
      }
      subs.add(sub);
    }
  }

  /**
   * @private
   * Helper utility to split an Item (see {@link Item#_splitAt})
   * - copies all properties from a to b
   * - connects a to b
   * - assigns the correct _id
   * - saves b to os
   */
  function splitHelper(y, a, b, diff) {
    var aID = a._id;
    b._id = new ID(aID.user, aID.clock + diff);
    b._origin = a;
    b._left = a;
    b._right = a._right;
    if (b._right !== null) {
      b._right._left = b;
    }
    b._right_origin = a._right_origin;
    // do not set a._right_origin, as this will lead to problems when syncing
    a._right = b;
    b._parent = a._parent;
    b._parentSub = a._parentSub;
    b._deleted = a._deleted;
    // now search all relevant items to the right and update origin
    // if origin is not it foundOrigins, we don't have to search any longer
    var foundOrigins = new Set();
    foundOrigins.add(a);
    var o = b._right;
    while (o !== null && foundOrigins.has(o._origin)) {
      if (o._origin === a) {
        o._origin = b;
      }
      foundOrigins.add(o);
      o = o._right;
    }
    y.os.put(b);
    if (y._transaction.newTypes.has(a)) {
      y._transaction.newTypes.add(b);
    } else if (y._transaction.deletedStructs.has(a)) {
      y._transaction.deletedStructs.add(b);
    }
  }

  /**
   * Abstract class that represents any content.
   */

  var Item = function () {
    function Item() {
      classCallCheck(this, Item);

      /**
       * The uniqe identifier of this type.
       * @type {ID}
       */
      this._id = null;
      /**
       * The item that was originally to the left of this item.
       * @type {Item}
       */
      this._origin = null;
      /**
       * The item that is currently to the left of this item.
       * @type {Item}
       */
      this._left = null;
      /**
       * The item that is currently to the right of this item.
       * @type {Item}
       */
      this._right = null;
      /**
       * The item that was originally to the right of this item.
       * @type {Item}
       */
      this._right_origin = null;
      /**
       * The parent type.
       * @type {Y|YType}
       */
      this._parent = null;
      /**
       * If the parent refers to this item with some kind of key (e.g. YMap, the
       * key is specified here. The key is then used to refer to the list in which
       * to insert this item. If `parentSub = null` type._start is the list in
       * which to insert to. Otherwise it is `parent._start`.
       * @type {String}
       */
      this._parentSub = null;
      /**
       * Whether this item was deleted or not.
       * @type {Boolean}
       */
      this._deleted = false;
      /**
       * If this type's effect is reundone this type refers to the type that undid
       * this operation.
       * @type {Item}
       */
      this._redone = null;
    }

    /**
     * Creates an Item with the same effect as this Item (without position effect)
     *
     * @private
     */


    createClass(Item, [{
      key: '_copy',
      value: function _copy() {
        return new this.constructor();
      }

      /**
       * Redoes the effect of this operation.
       *
       * @param {Y} y The Yjs instance.
       *
       * @private
       */

    }, {
      key: '_redo',
      value: function _redo(y, redoitems) {
        if (this._redone !== null) {
          return this._redone;
        }
        var struct = this._copy();
        var left = this._left;
        var right = this;
        var parent = this._parent;
        // make sure that parent is redone
        if (parent._deleted === true && parent._redone === null) {
          // try to undo parent if it will be undone anyway
          if (!redoitems.has(parent) || !parent._redo(y, redoitems)) {
            return false;
          }
        }
        if (parent._redone !== null) {
          parent = parent._redone;
          // find next cloned items
          while (left !== null) {
            if (left._redone !== null && left._redone._parent === parent) {
              left = left._redone;
              break;
            }
            left = left._left;
          }
          while (right !== null) {
            if (right._redone !== null && right._redone._parent === parent) {
              right = right._redone;
            }
            right = right._right;
          }
        }
        struct._origin = left;
        struct._left = left;
        struct._right = right;
        struct._right_origin = right;
        struct._parent = parent;
        struct._parentSub = this._parentSub;
        struct._integrate(y);
        this._redone = struct;
        return true;
      }

      /**
       * Computes the last content address of this Item.
       *
       * @private
       */

    }, {
      key: '_splitAt',


      /**
       * Splits this Item so that another Items can be inserted in-between.
       * This must be overwritten if _length > 1
       * Returns right part after split
       * * diff === 0 => this
       * * diff === length => this._right
       * * otherwise => split _content and return right part of split
       * (see {@link ItemJSON}/{@link ItemString} for implementation)
       *
       * @private
       */
      value: function _splitAt(y, diff) {
        if (diff === 0) {
          return this;
        }
        return this._right;
      }

      /**
       * Mark this Item as deleted.
       *
       * @param {Y} y The Yjs instance
       * @param {boolean} createDelete Whether to propagate a message that this
       *                               Type was deleted.
       *
       * @private
       */

    }, {
      key: '_delete',
      value: function _delete(y) {
        var createDelete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (!this._deleted) {
          this._deleted = true;
          y.ds.mark(this._id, this._length, false);
          var del = new Delete();
          del._targetID = this._id;
          del._length = this._length;
          if (createDelete) {
            // broadcast and persists Delete
            del._integrate(y, true);
          } else if (y.persistence !== null) {
            // only persist Delete
            y.persistence.saveStruct(y, del);
          }
          transactionTypeChanged(y, this._parent, this._parentSub);
          y._transaction.deletedStructs.add(this);
        }
      }
    }, {
      key: '_gcChildren',
      value: function _gcChildren(y) {}
    }, {
      key: '_gc',
      value: function _gc(y) {
        var gc = new GC();
        gc._id = this._id;
        gc._length = this._length;
        y.os.delete(this._id);
        gc._integrate(y);
      }

      /**
       * This is called right before this Item receives any children.
       * It can be overwritten to apply pending changes before applying remote changes
       *
       * @private
       */

    }, {
      key: '_beforeChange',
      value: function _beforeChange() {}
      // nop


      /**
       * Integrates this Item into the shared structure.
       *
       * This method actually applies the change to the Yjs instance. In case of
       * Item it connects _left and _right to this Item and calls the
       * {@link Item#beforeChange} method.
       *
       * * Integrate the struct so that other types/structs can see it
       * * Add this struct to y.os
       * * Check if this is struct deleted
       *
       * @private
       */

    }, {
      key: '_integrate',
      value: function _integrate(y) {
        y._transaction.newTypes.add(this);
        var parent = this._parent;
        var selfID = this._id;
        var user = selfID === null ? y.userID : selfID.user;
        var userState = y.ss.getState(user);
        if (selfID === null) {
          this._id = y.ss.getNextID(this._length);
        } else if (selfID.user === RootFakeUserID) ; else if (selfID.clock < userState) {
          // already applied..
          return [];
        } else if (selfID.clock === userState) {
          y.ss.setState(selfID.user, userState + this._length);
        } else {
          // missing content from user
          throw new Error('Can not apply yet!');
        }
        if (!parent._deleted && !y._transaction.changedTypes.has(parent) && !y._transaction.newTypes.has(parent)) {
          // this is the first time parent is updated
          // or this types is new
          this._parent._beforeChange();
        }

        /*
        # $this has to find a unique position between origin and the next known character
        # case 1: $origin equals $o.origin: the $creator parameter decides if left or right
        #         let $OL= [o1,o2,o3,o4], whereby $this is to be inserted between o1 and o4
        #         o2,o3 and o4 origin is 1 (the position of o2)
        #         there is the case that $this.creator < o2.creator, but o3.creator < $this.creator
        #         then o2 knows o3. Since on another client $OL could be [o1,o3,o4] the problem is complex
        #         therefore $this would be always to the right of o3
        # case 2: $origin < $o.origin
        #         if current $this insert_position > $o origin: $this ins
        #         else $insert_position will not change
        #         (maybe we encounter case 1 later, then this will be to the right of $o)
        # case 3: $origin > $o.origin
        #         $this insert_position is to the left of $o (forever!)
        */
        // handle conflicts
        var o = void 0;
        // set o to the first conflicting item
        if (this._left !== null) {
          o = this._left._right;
        } else if (this._parentSub !== null) {
          o = this._parent._map.get(this._parentSub) || null;
        } else {
          o = this._parent._start;
        }
        var conflictingItems = new Set();
        var itemsBeforeOrigin = new Set();
        // Let c in conflictingItems, b in itemsBeforeOrigin
        // ***{origin}bbbb{this}{c,b}{c,b}{o}***
        // Note that conflictingItems is a subset of itemsBeforeOrigin
        while (o !== null && o !== this._right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (this._origin === o._origin) {
            // case 1
            if (o._id.user < this._id.user) {
              this._left = o;
              conflictingItems.clear();
            }
          } else if (itemsBeforeOrigin.has(o._origin)) {
            // case 2
            if (!conflictingItems.has(o._origin)) {
              this._left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          // TODO: try to use right_origin instead.
          // Then you could basically omit conflictingItems!
          // Note: you probably can't use right_origin in every case.. only when setting _left
          o = o._right;
        }
        // reconnect left/right + update parent map/start if necessary
        var parentSub = this._parentSub;
        if (this._left === null) {
          var right = void 0;
          if (parentSub !== null) {
            var pmap = parent._map;
            right = pmap.get(parentSub) || null;
            pmap.set(parentSub, this);
          } else {
            right = parent._start;
            parent._start = this;
          }
          this._right = right;
          if (right !== null) {
            right._left = this;
          }
        } else {
          var left = this._left;
          var _right = left._right;
          this._right = _right;
          left._right = this;
          if (_right !== null) {
            _right._left = this;
          }
        }
        if (parent._deleted) {
          this._delete(y, false);
        }
        y.os.put(this);
        transactionTypeChanged(y, parent, parentSub);
        if (this._id.user !== RootFakeUserID) {
          if (y.connector !== null && (y.connector._forwardAppliedStructs || this._id.user === y.userID)) {
            y.connector.broadcastStruct(this);
          }
          if (y.persistence !== null) {
            y.persistence.saveStruct(y, this);
          }
        }
      }

      /**
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       *
       * @param {BinaryEncoder} encoder The encoder to write data to.
       *
       * @private
       */

    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        encoder.writeUint8(getStructReference(this.constructor));
        var info = 0;
        if (this._origin !== null) {
          info += 1; // origin is defined
        }
        // TODO: remove
        /* no longer send _left
        if (this._left !== this._origin) {
          info += 0b10 // do not copy origin to left
        }
        */
        if (this._right_origin !== null) {
          info += 4;
        }
        if (this._parentSub !== null) {
          info += 8;
        }
        encoder.writeUint8(info);
        encoder.writeID(this._id);
        if (info & 1) {
          encoder.writeID(this._origin._lastId);
        }
        // TODO: remove
        /* see above
        if (info & 0b10) {
          encoder.writeID(this._left._lastId)
        }
        */
        if (info & 4) {
          encoder.writeID(this._right_origin._id);
        }
        if ((info & 5) === 0) {
          // neither origin nor right is defined
          encoder.writeID(this._parent._id);
        }
        if (info & 8) {
          encoder.writeVarString(JSON.stringify(this._parentSub));
        }
      }

      /**
       * Read the next Item in a Decoder and fill this Item with the read data.
       *
       * This is called when data is received from a remote peer.
       *
       * @param {Y} y The Yjs instance that this Item belongs to.
       * @param {BinaryDecoder} decoder The decoder object to read data from.
       *
       * @private
       */

    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = [];
        var info = decoder.readUint8();
        var id = decoder.readID();
        this._id = id;
        // read origin
        if (info & 1) {
          // origin != null
          var originID = decoder.readID();
          // we have to query for left again because it might have been split/merged..
          var origin = y.os.getItemCleanEnd(originID);
          if (origin === null) {
            missing.push(originID);
          } else {
            this._origin = origin;
            this._left = this._origin;
          }
        }
        // read right
        if (info & 4) {
          // right != null
          var rightID = decoder.readID();
          // we have to query for right again because it might have been split/merged..
          var right = y.os.getItemCleanStart(rightID);
          if (right === null) {
            missing.push(rightID);
          } else {
            this._right = right;
            this._right_origin = right;
          }
        }
        // read parent
        if ((info & 5) === 0) {
          // neither origin nor right is defined
          var parentID = decoder.readID();
          // parent does not change, so we don't have to search for it again
          if (this._parent === null) {
            var parent = void 0;
            if (parentID.constructor === RootID) {
              parent = y.os.get(parentID);
            } else {
              parent = y.os.getItem(parentID);
            }
            if (parent === null) {
              missing.push(parentID);
            } else {
              this._parent = parent;
            }
          }
        } else if (this._parent === null) {
          if (this._origin !== null) {
            if (this._origin.constructor === GC) {
              // if origin is a gc, set parent also gc'd
              this._parent = this._origin;
            } else {
              this._parent = this._origin._parent;
            }
          } else if (this._right_origin !== null) {
            // if origin is a gc, set parent also gc'd
            if (this._right_origin.constructor === GC) {
              this._parent = this._right_origin;
            } else {
              this._parent = this._right_origin._parent;
            }
          }
        }
        if (info & 8) {
          // TODO: maybe put this in read parent condition (you can also read parentsub from left/right)
          this._parentSub = JSON.parse(decoder.readVarString());
        }
        if (y.ss.getState(id.user) < id.clock) {
          missing.push(new ID(id.user, id.clock - 1));
        }
        return missing;
      }
    }, {
      key: '_lastId',
      get: function get$$1() {
        return new ID(this._id.user, this._id.clock + this._length - 1);
      }

      /**
       * Computes the length of this Item.
       *
       * @private
       */

    }, {
      key: '_length',
      get: function get$$1() {
        return 1;
      }

      /**
       * Should return false if this Item is some kind of meta information
       * (e.g. format information).
       *
       * * Whether this Item should be addressable via `yarray.get(i)`
       * * Whether this Item should be counted when computing yarray.length
       *
       * @private
       */

    }, {
      key: '_countable',
      get: function get$$1() {
        return true;
      }
    }]);
    return Item;
  }();

  /**
   * General event handler implementation.
   */
  var EventHandler = function () {
    function EventHandler() {
      classCallCheck(this, EventHandler);

      this.eventListeners = [];
    }

    /**
     * To prevent memory leaks, call this method when the eventListeners won't be
     * used anymore.
     */


    createClass(EventHandler, [{
      key: "destroy",
      value: function destroy() {
        this.eventListeners = null;
      }

      /**
       * Adds an event listener that is called when
       * {@link EventHandler#callEventListeners} is called.
       *
       * @param {Function} f The event handler.
       */

    }, {
      key: "addEventListener",
      value: function addEventListener(f) {
        this.eventListeners.push(f);
      }

      /**
       * Removes an event listener.
       *
       * @param {Function} f The event handler that was added with
       *                     {@link EventHandler#addEventListener}
       */

    }, {
      key: "removeEventListener",
      value: function removeEventListener(f) {
        this.eventListeners = this.eventListeners.filter(function (g) {
          return f !== g;
        });
      }

      /**
       * Removes all event listeners.
       */

    }, {
      key: "removeAllEventListeners",
      value: function removeAllEventListeners() {
        this.eventListeners = [];
      }

      /**
       * Call all event listeners that were added via
       * {@link EventHandler#addEventListener}.
       *
       * @param {Transaction} transaction The transaction object // TODO: do we need this?
       * @param {YEvent} event An event object that describes the change on a type.
       */

    }, {
      key: "callEventListeners",
      value: function callEventListeners(transaction, event) {
        for (var i = 0; i < this.eventListeners.length; i++) {
          try {
            var f = this.eventListeners[i];
            f(event);
          } catch (e) {
            /*
              Your observer threw an error. This error was caught so that Yjs
              can ensure data consistency! In order to debug this error you
              have to check "Pause On Caught Exceptions" in developer tools.
            */
            console.error(e);
          }
        }
      }
    }]);
    return EventHandler;
  }();

  // restructure children as if they were inserted one after another
  function integrateChildren(y, start) {
    var right = void 0;
    do {
      right = start._right;
      start._right = null;
      start._right_origin = null;
      start._origin = start._left;
      start._integrate(y);
      start = right;
    } while (right !== null);
  }

  function gcChildren(y, item) {
    while (item !== null) {
      item._delete(y, false, true);
      item._gc(y);
      item = item._right;
    }
  }

  /**
   * Abstract Yjs Type class
   */

  var Type = function (_Item) {
    inherits(Type, _Item);

    function Type() {
      classCallCheck(this, Type);

      var _this = possibleConstructorReturn(this, (Type.__proto__ || Object.getPrototypeOf(Type)).call(this));

      _this._map = new Map();
      _this._start = null;
      _this._y = null;
      _this._eventHandler = new EventHandler();
      _this._deepEventHandler = new EventHandler();
      return _this;
    }

    /**
     * Compute the path from this type to the specified target.
     *
     * @example
     * It should be accessible via `this.get(result[0]).get(result[1])..`
     * const path = type.getPathTo(child)
     * // assuming `type instanceof YArray`
     * console.log(path) // might look like => [2, 'key1']
     * child === type.get(path[0]).get(path[1])
     *
     * @param {YType} type Type target
     * @return {Array<string>} Path to the target
     */


    createClass(Type, [{
      key: 'getPathTo',
      value: function getPathTo(type) {
        if (type === this) {
          return [];
        }
        var path = [];
        var y = this._y;
        while (type !== this && type !== y) {
          var parent = type._parent;
          if (type._parentSub !== null) {
            path.unshift(type._parentSub);
          } else {
            // parent is array-ish
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = parent[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = slicedToArray(_step.value, 2),
                    i = _step$value[0],
                    child = _step$value[1];

                if (child === type) {
                  path.unshift(i);
                  break;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
          type = parent;
        }
        if (type !== this) {
          throw new Error('The type is not a child of this node');
        }
        return path;
      }

      /**
       * @private
       * Call event listeners with an event. This will also add an event to all
       * parents (for `.observeDeep` handlers).
       */

    }, {
      key: '_callEventHandler',
      value: function _callEventHandler(transaction, event) {
        var changedParentTypes = transaction.changedParentTypes;
        this._eventHandler.callEventListeners(transaction, event);
        var type = this;
        while (type !== this._y) {
          var events = changedParentTypes.get(type);
          if (events === undefined) {
            events = [];
            changedParentTypes.set(type, events);
          }
          events.push(event);
          type = type._parent;
        }
      }

      /**
       * @private
       * Helper method to transact if the y instance is available.
       *
       * TODO: Currently event handlers are not thrown when a type is not registered
       *       with a Yjs instance.
       */

    }, {
      key: '_transact',
      value: function _transact(f) {
        var y = this._y;
        if (y !== null) {
          y.transact(f);
        } else {
          f(y);
        }
      }

      /**
       * Observe all events that are created on this type.
       *
       * @param {Function} f Observer function
       */

    }, {
      key: 'observe',
      value: function observe(f) {}
      //this._eventHandler.addEventListener(function (e) {
      //    console.log('eeeeeeeeeeeeeeeeeeeeeee');
      //    console.log(e);
      //});


      /**
       * Observe all events that are created by this type and its children.
       *
       * @param {Function} f Observer function
       */

    }, {
      key: 'observeDeep',
      value: function observeDeep(f) {
        this._deepEventHandler.addEventListener(f);
      }

      /**
       * Unregister an observer function.
       *
       * @param {Function} f Observer function
       */

    }, {
      key: 'unobserve',
      value: function unobserve(f) {
        this._eventHandler.removeEventListener(f);
      }

      /**
       * Unregister an observer function.
       *
       * @param {Function} f Observer function
       */

    }, {
      key: 'unobserveDeep',
      value: function unobserveDeep(f) {
        this._deepEventHandler.removeEventListener(f);
      }

      /**
       * @private
       * Integrate this type into the Yjs instance.
       *
       * * Save this struct in the os
       * * This type is sent to other client
       * * Observer functions are fired
       *
       * @param {Y} y The Yjs instance
       */

    }, {
      key: '_integrate',
      value: function _integrate(y) {
        get(Type.prototype.__proto__ || Object.getPrototypeOf(Type.prototype), '_integrate', this).call(this, y);
        this._y = y;
        // when integrating children we must make sure to
        // integrate start
        var start = this._start;
        if (start !== null) {
          this._start = null;
          integrateChildren(y, start);
        }
        // integrate map children
        var map = this._map;
        this._map = new Map();
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = map.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var t = _step2.value;

            // TODO make sure that right elements are deleted!
            integrateChildren(y, t);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }, {
      key: '_gcChildren',
      value: function _gcChildren(y) {
        gcChildren(y, this._start);
        this._start = null;
        this._map.forEach(function (item) {
          gcChildren(y, item);
        });
        this._map = new Map();
      }
    }, {
      key: '_gc',
      value: function _gc(y) {
        this._gcChildren(y);
        get(Type.prototype.__proto__ || Object.getPrototypeOf(Type.prototype), '_gc', this).call(this, y);
      }

      /**
       * @private
       * Mark this Item as deleted.
       *
       * @param {Y} y The Yjs instance
       * @param {boolean} createDelete Whether to propagate a message that this
       *                               Type was deleted.
       * @param {boolean} [gcChildren=y._hasUndoManager===false] Whether to garbage
       *                                         collect the children of this type.
       */

    }, {
      key: '_delete',
      value: function _delete(y, createDelete, gcChildren) {
        if (gcChildren === undefined || !y.gcEnabled) {
          gcChildren = y._hasUndoManager === false && y.gcEnabled;
        }
        get(Type.prototype.__proto__ || Object.getPrototypeOf(Type.prototype), '_delete', this).call(this, y, createDelete, gcChildren);
        y._transaction.changedTypes.delete(this);
        // delete map types
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this._map.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var value = _step3.value;

            if (value instanceof Item && !value._deleted) {
              value._delete(y, false, gcChildren);
            }
          }
          // delete array types
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        var t = this._start;
        while (t !== null) {
          if (!t._deleted) {
            t._delete(y, false, gcChildren);
          }
          t = t._right;
        }
        if (gcChildren) {
          this._gcChildren(y);
        }
      }
    }]);
    return Type;
  }(Item);

  var ItemJSON = function (_Item) {
    inherits(ItemJSON, _Item);

    function ItemJSON() {
      classCallCheck(this, ItemJSON);

      var _this = possibleConstructorReturn(this, (ItemJSON.__proto__ || Object.getPrototypeOf(ItemJSON)).call(this));

      _this._content = null;
      return _this;
    }

    createClass(ItemJSON, [{
      key: '_copy',
      value: function _copy() {
        var struct = get(ItemJSON.prototype.__proto__ || Object.getPrototypeOf(ItemJSON.prototype), '_copy', this).call(this);
        struct._content = this._content;
        return struct;
      }
    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(ItemJSON.prototype.__proto__ || Object.getPrototypeOf(ItemJSON.prototype), '_fromBinary', this).call(this, y, decoder);
        var len = decoder.readVarUint();
        this._content = new Array(len);
        for (var i = 0; i < len; i++) {
          var ctnt = decoder.readVarString();
          var parsed = void 0;
          if (ctnt === 'undefined') {
            parsed = undefined;
          } else {
            parsed = JSON.parse(ctnt);
          }
          this._content[i] = parsed;
        }
        return missing;
      }
    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(ItemJSON.prototype.__proto__ || Object.getPrototypeOf(ItemJSON.prototype), '_toBinary', this).call(this, encoder);
        var len = this._content.length;
        encoder.writeVarUint(len);
        for (var i = 0; i < len; i++) {
          var encoded = void 0;
          var content = this._content[i];
          if (content === undefined) {
            encoded = 'undefined';
          } else {
            encoded = JSON.stringify(content);
          }
          encoder.writeVarString(encoded);
        }
      }
      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('ItemJSON', this, 'content:' + JSON.stringify(this._content));
      }
    }, {
      key: '_splitAt',
      value: function _splitAt(y, diff) {
        if (diff === 0) {
          return this;
        } else if (diff >= this._length) {
          return this._right;
        }
        var item = new ItemJSON();
        item._content = this._content.splice(diff);
        splitHelper(y, this, item, diff);
        return item;
      }
    }, {
      key: '_length',
      get: function get$$1() {
        return this._content.length;
      }
    }]);
    return ItemJSON;
  }(Item);

  var ItemString = function (_Item) {
    inherits(ItemString, _Item);

    function ItemString() {
      classCallCheck(this, ItemString);

      var _this = possibleConstructorReturn(this, (ItemString.__proto__ || Object.getPrototypeOf(ItemString)).call(this));

      _this._content = null;
      return _this;
    }

    createClass(ItemString, [{
      key: '_copy',
      value: function _copy() {
        var struct = get(ItemString.prototype.__proto__ || Object.getPrototypeOf(ItemString.prototype), '_copy', this).call(this);
        struct._content = this._content;
        return struct;
      }
    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(ItemString.prototype.__proto__ || Object.getPrototypeOf(ItemString.prototype), '_fromBinary', this).call(this, y, decoder);
        this._content = decoder.readVarString();
        return missing;
      }
    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(ItemString.prototype.__proto__ || Object.getPrototypeOf(ItemString.prototype), '_toBinary', this).call(this, encoder);
        encoder.writeVarString(this._content);
      }
      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('ItemString', this, 'content:"' + this._content + '"');
      }
    }, {
      key: '_splitAt',
      value: function _splitAt(y, diff) {
        if (diff === 0) {
          return this;
        } else if (diff >= this._length) {
          return this._right;
        }
        var item = new ItemString();
        item._content = this._content.slice(diff);
        this._content = this._content.slice(0, diff);
        splitHelper(y, this, item, diff);
        return item;
      }
    }, {
      key: '_length',
      get: function get$$1() {
        return this._content.length;
      }
    }]);
    return ItemString;
  }(Item);

  /**
   * YEvent describes the changes on a YType.
   */
  var YEvent = function () {
    /**
     * @param {YType} target The changed type.
     */
    function YEvent(target) {
      classCallCheck(this, YEvent);

      /**
       * The type on which this event was created on.
       * @type {YType}
       */
      this.target = target;
      /**
       * The current target on which the observe callback is called.
       * @type {YType}
       */
      this.currentTarget = target;
    }

    /**
     * Computes the path from `y` to the changed type.
     *
     * The following property holds:
     * @example
     *   let type = y
     *   event.path.forEach(function (dir) {
     *     type = type.get(dir)
     *   })
     *   type === event.target // => true
     */


    createClass(YEvent, [{
      key: "path",
      get: function get$$1() {
        return this.currentTarget.getPathTo(this.target);
      }
    }]);
    return YEvent;
  }();

  /**
   * Event that describes the changes on a YArray
   *
   * @param {YArray} yarray The changed type
   * @param {Boolean} remote Whether the changed was caused by a remote peer
   * @param {Transaction} transaction The transaction object
   */
  var YArrayEvent = function (_YEvent) {
    inherits(YArrayEvent, _YEvent);

    function YArrayEvent(yarray, remote, transaction) {
      classCallCheck(this, YArrayEvent);

      var _this = possibleConstructorReturn(this, (YArrayEvent.__proto__ || Object.getPrototypeOf(YArrayEvent)).call(this, yarray));

      _this.remote = remote;
      _this._transaction = transaction;
      _this._addedElements = null;
      _this._removedElements = null;
      return _this;
    }

    /**
     * Child elements that were added in this transaction.
     *
     * @return {Set}
     */


    createClass(YArrayEvent, [{
      key: 'addedElements',
      get: function get$$1() {
        if (this._addedElements === null) {
          var target = this.target;
          var transaction = this._transaction;
          var addedElements = new Set();
          transaction.newTypes.forEach(function (type) {
            if (type._parent === target && !transaction.deletedStructs.has(type)) {
              addedElements.add(type);
            }
          });
          this._addedElements = addedElements;
        }
        return this._addedElements;
      }

      /**
       * Child elements that were removed in this transaction.
       *
       * @return {Set}
       */

    }, {
      key: 'removedElements',
      get: function get$$1() {
        if (this._removedElements === null) {
          var target = this.target;
          var transaction = this._transaction;
          var removedElements = new Set();
          transaction.deletedStructs.forEach(function (struct) {
            if (struct._parent === target && !transaction.newTypes.has(struct)) {
              removedElements.add(struct);
            }
          });
          this._removedElements = removedElements;
        }
        return this._removedElements;
      }
    }]);
    return YArrayEvent;
  }(YEvent);

  /**
   * A shared Array implementation.
   */

  var YArray = function (_Type) {
    inherits(YArray, _Type);

    function YArray() {
      classCallCheck(this, YArray);
      return possibleConstructorReturn(this, (YArray.__proto__ || Object.getPrototypeOf(YArray)).apply(this, arguments));
    }

    createClass(YArray, [{
      key: '_callObserver',

      /**
       * @private
       * Creates YArray Event and calls observers.
       */
      value: function _callObserver(transaction, parentSubs, remote) {
        this._callEventHandler(transaction, new YArrayEvent(this, remote, transaction));
      }

      /**
       * Returns the i-th element from a YArray.
       *
       * @param {Integer} index The index of the element to return from the YArray
       */

    }, {
      key: 'get',
      value: function get$$1(index) {
        var n = this._start;
        while (n !== null) {
          if (!n._deleted && n._countable) {
            if (index < n._length) {
              if (n.constructor === ItemJSON || n.constructor === ItemString) {
                return n._content[index];
              } else {
                return n;
              }
            }
            index -= n._length;
          }
          n = n._right;
        }
      }

      /**
       * Transforms this YArray to a JavaScript Array.
       *
       * @return {Array}
       */

    }, {
      key: 'toArray',
      value: function toArray$$1() {
        return this.map(function (c) {
          return c;
        });
      }

      /**
       * Transforms this Shared Type to a JSON object.
       *
       * @return {Array}
       */

    }, {
      key: 'toJSON',
      value: function toJSON() {
        return this.map(function (c) {
          if (c instanceof Type) {
            if (c.toJSON !== null) {
              return c.toJSON();
            } else {
              return c.toString();
            }
          }
          return c;
        });
      }

      /**
       * Returns an Array with the result of calling a provided function on every
       * element of this YArray.
       *
       * @param {Function} f Function that produces an element of the new Array
       * @return {Array} A new array with each element being the result of the
       *                 callback function
       */

    }, {
      key: 'map',
      value: function map(f) {
        var _this3 = this;

        var res = [];
        this.forEach(function (c, i) {
          res.push(f(c, i, _this3));
        });
        return res;
      }

      /**
       * Executes a provided function on once on overy element of this YArray.
       *
       * @param {Function} f A function to execute on every element of this YArray.
       */

    }, {
      key: 'forEach',
      value: function forEach(f) {
        var index = 0;
        var n = this._start;
        while (n !== null) {
          if (!n._deleted && n._countable) {
            if (n instanceof Type) {
              f(n, index++, this);
            } else {
              var content = n._content;
              var contentLen = content.length;
              for (var i = 0; i < contentLen; i++) {
                index++;
                f(content[i], index, this);
              }
            }
          }
          n = n._right;
        }
      }

      /**
       * Computes the length of this YArray.
       */

    }, {
      key: Symbol.iterator,
      value: function value() {
        return {
          next: function next() {
            while (this._item !== null && (this._item._deleted || this._item._length <= this._itemElement)) {
              // item is deleted or itemElement does not exist (is deleted)
              this._item = this._item._right;
              this._itemElement = 0;
            }
            if (this._item === null) {
              return {
                done: true
              };
            }
            var content = void 0;
            if (this._item instanceof Type) {
              content = this._item;
            } else {
              content = this._item._content[this._itemElement++];
            }
            return {
              value: content,
              done: false
            };
          },
          _item: this._start,
          _itemElement: 0,
          _count: 0
        };
      }

      /**
       * Deletes elements starting from an index.
       *
       * @param {Integer} index Index at which to start deleting elements
       * @param {Integer} length The number of elements to remove. Defaults to 1.
       */

    }, {
      key: 'delete',
      value: function _delete(index) {
        var _this4 = this;

        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        this._y.transact(function () {
          var item = _this4._start;
          var count = 0;
          while (item !== null && length > 0) {
            if (!item._deleted && item._countable) {
              if (count <= index && index < count + item._length) {
                var diffDel = index - count;
                item = item._splitAt(_this4._y, diffDel);
                item._splitAt(_this4._y, length);
                length -= item._length;
                item._delete(_this4._y);
                count += diffDel;
              } else {
                count += item._length;
              }
            }
            item = item._right;
          }
        });
        if (length > 0) {
          throw new Error('Delete exceeds the range of the YArray');
        }
      }

      /**
       * @private
       * Inserts content after an element container.
       *
       * @param {Item} left The element container to use as a reference.
       * @param {Array} content The Array of content to insert (see {@see insert})
       */

    }, {
      key: 'insertAfter',
      value: function insertAfter(left, content) {
        var _this5 = this;

        this._transact(function (y) {
          var right = void 0;
          if (left === null) {
            right = _this5._start;
          } else {
            right = left._right;
          }
          var prevJsonIns = null;
          for (var i = 0; i < content.length; i++) {
            var c = content[i];
            if (typeof c === 'function') {
              c = new c(); // eslint-disable-line new-cap
            }
            if (c instanceof Type) {
              if (prevJsonIns !== null) {
                if (y !== null) {
                  prevJsonIns._integrate(y);
                }
                left = prevJsonIns;
                prevJsonIns = null;
              }
              c._origin = left;
              c._left = left;
              c._right = right;
              c._right_origin = right;
              c._parent = _this5;
              if (y !== null) {
                c._integrate(y);
              } else if (left === null) {
                _this5._start = c;
              } else {
                left._right = c;
              }
              left = c;
            } else {
              if (prevJsonIns === null) {
                prevJsonIns = new ItemJSON();
                prevJsonIns._origin = left;
                prevJsonIns._left = left;
                prevJsonIns._right = right;
                prevJsonIns._right_origin = right;
                prevJsonIns._parent = _this5;
                prevJsonIns._content = [];
              }
              prevJsonIns._content.push(c);
            }
          }
          if (prevJsonIns !== null) {
            if (y !== null) {
              prevJsonIns._integrate(y);
            } else if (prevJsonIns._left === null) {
              _this5._start = prevJsonIns;
            }
          }
        });
        return content;
      }

      /**
       * Inserts new content at an index.
       *
       * Important: This function expects an array of content. Not just a content
       * object. The reason for this "weirdness" is that inserting several elements
       * is very efficient when it is done as a single operation.
       *
       * @example
       *  // Insert character 'a' at position 0
       *  yarray.insert(0, ['a'])
       *  // Insert numbers 1, 2 at position 1
       *  yarray.insert(2, [1, 2])
       *
       * @param {Integer} index The index to insert content at.
       * @param {Array} content The array of content
       */

    }, {
      key: 'insert',
      value: function insert(index, content) {
        var _this6 = this;

        this._transact(function () {
          var left = null;
          var right = _this6._start;
          var count = 0;
          var y = _this6._y;
          while (right !== null) {
            var rightLen = right._deleted ? 0 : right._length - 1;
            if (count <= index && index <= count + rightLen) {
              var splitDiff = index - count;
              right = right._splitAt(y, splitDiff);
              left = right._left;
              count += splitDiff;
              break;
            }
            if (!right._deleted) {
              count += right._length;
            }
            left = right;
            right = right._right;
          }
          if (index > count) {
            throw new Error('Index exceeds array range!');
          }
          _this6.insertAfter(left, content);
        });
      }

      /**
       * Appends content to this YArray.
       *
       * @param {Array} content Array of content to append.
       */

    }, {
      key: 'push',
      value: function push(content) {
        var n = this._start;
        var lastUndeleted = null;
        while (n !== null) {
          if (!n._deleted) {
            lastUndeleted = n;
          }
          n = n._right;
        }
        this.insertAfter(lastUndeleted, content);
      }

      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('YArray', this, 'start:' + logID(this._start) + '"');
      }
    }, {
      key: 'length',
      get: function get$$1() {
        var length = 0;
        var n = this._start;
        while (n !== null) {
          if (!n._deleted && n._countable) {
            length += n._length;
          }
          n = n._right;
        }
        return length;
      }
    }]);
    return YArray;
  }(Type);

  /**
   * Event that describes the changes on a YMap.
   *
   * @param {YMap} ymap The YArray that changed.
   * @param {Set<any>} subs The keys that changed.
   * @param {boolean} remote Whether the change was created by a remote peer.
   */
  var YMapEvent = function (_YEvent) {
    inherits(YMapEvent, _YEvent);

    function YMapEvent(ymap, subs, remote) {
      classCallCheck(this, YMapEvent);

      var _this = possibleConstructorReturn(this, (YMapEvent.__proto__ || Object.getPrototypeOf(YMapEvent)).call(this, ymap));

      _this.keysChanged = subs;
      _this.remote = remote;
      return _this;
    }

    return YMapEvent;
  }(YEvent);

  /**
   * A shared Map implementation.
   */

  var YMap = function (_Type) {
    inherits(YMap, _Type);

    /**
     * @private
     * Creates YMap Event and calls observers.
     */
    function YMap() {
      classCallCheck(this, YMap);

      var _this2 = possibleConstructorReturn(this, (YMap.__proto__ || Object.getPrototypeOf(YMap)).call(this));

      console.log('constructedddddddddddddddddddd');
      _this2._eventHandler.addEventListener(function (e) {
        console.log('ffffffffffffffffffffffff');
        console.log(e);
        var x = 9999999999999;
        console.log(x);
      });
      return _this2;
    }

    createClass(YMap, [{
      key: '_callObserver',
      value: function _callObserver(transaction, parentSubs, remote) {
        this._callEventHandler(transaction, new YMapEvent(this, parentSubs, remote));
      }

      /**
       * Transforms this Shared Type to a JSON object.
       *
       * @return {Object}
       */

    }, {
      key: 'toJSON',
      value: function toJSON() {
        var map = {};
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._map[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = slicedToArray(_step.value, 2),
                key = _step$value[0],
                item = _step$value[1];

            if (!item._deleted) {
              var res = void 0;
              if (item instanceof Type) {
                if (item.toJSON !== undefined) {
                  res = item.toJSON();
                } else {
                  res = item.toString();
                }
              } else {
                res = item._content[0];
              }
              map[key] = res;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return map;
      }

      /**
       * Returns the keys for each element in the YMap Type.
       *
       * @return {Array}
       */

    }, {
      key: 'keys',
      value: function keys() {
        // TODO: Should return either Iterator or Set!
        var keys = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._map[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _step2$value = slicedToArray(_step2.value, 2),
                key = _step2$value[0],
                value = _step2$value[1];

            if (!value._deleted) {
              keys.push(key);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return keys;
      }

      /**
       * Remove a specified element from this YMap.
       *
       * @param {encodable} key The key of the element to remove.
       */

    }, {
      key: 'delete',
      value: function _delete(key) {
        var _this3 = this;

        this._transact(function (y) {
          var c = _this3._map.get(key);
          if (y !== null && c !== undefined) {
            c._delete(y);
          }
        });
      }

      /**
       * Adds or updates an element with a specified key and value.
       *
       * @param {encodable} key The key of the element to add to this YMap.
       * @param {encodable | YType} value The value of the element to add to this
       *                                  YMap.
       */

    }, {
      key: 'set',
      value: function set$$1(key, value) {
        var _this4 = this;

        this._transact(function (y) {
          var old = _this4._map.get(key) || null;
          if (old !== null) {
            if (old.constructor === ItemJSON && !old._deleted && old._content[0] === value) {
              // Trying to overwrite with same value
              // break here
              return value;
            }
            if (y !== null) {
              old._delete(y);
            }
          }
          var v = void 0;
          if (typeof value === 'function') {
            v = new value(); // eslint-disable-line new-cap
            value = v;
          } else if (value instanceof Item) {
            v = value;
          } else {
            v = new ItemJSON();
            v._content = [value];
          }
          v._right = old;
          v._right_origin = old;
          v._parent = _this4;
          v._parentSub = key;
          if (y !== null) {
            v._integrate(y);
          } else {
            _this4._map.set(key, v);
          }
        });
        return value;
      }

      /**
       * Returns a specified element from this YMap.
       *
       * @param {encodable} key The key of the element to return.
       */

    }, {
      key: 'get',
      value: function get$$1(key) {
        var v = this._map.get(key);
        if (v === undefined || v._deleted) {
          return undefined;
        }
        if (v instanceof Type) {
          return v;
        } else {
          return v._content[v._content.length - 1];
        }
      }

      /**
       * Returns a boolean indicating whether the specified key exists or not.
       *
       * @param {encodable} key The key to test.
       */

    }, {
      key: 'has',
      value: function has(key) {
        var v = this._map.get(key);
        if (v === undefined || v._deleted) {
          return false;
        } else {
          return true;
        }
      }

      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('YMap', this, 'mapSize:' + this._map.size);
      }
    }]);
    return YMap;
  }(Type);

  var ItemEmbed = function (_Item) {
    inherits(ItemEmbed, _Item);

    function ItemEmbed() {
      classCallCheck(this, ItemEmbed);

      var _this = possibleConstructorReturn(this, (ItemEmbed.__proto__ || Object.getPrototypeOf(ItemEmbed)).call(this));

      _this.embed = null;
      return _this;
    }

    createClass(ItemEmbed, [{
      key: '_copy',
      value: function _copy(undeleteChildren, copyPosition) {
        var struct = get(ItemEmbed.prototype.__proto__ || Object.getPrototypeOf(ItemEmbed.prototype), '_copy', this).call(this, undeleteChildren, copyPosition);
        struct.embed = this.embed;
        return struct;
      }
    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(ItemEmbed.prototype.__proto__ || Object.getPrototypeOf(ItemEmbed.prototype), '_fromBinary', this).call(this, y, decoder);
        this.embed = JSON.parse(decoder.readVarString());
        return missing;
      }
    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(ItemEmbed.prototype.__proto__ || Object.getPrototypeOf(ItemEmbed.prototype), '_toBinary', this).call(this, encoder);
        encoder.writeVarString(JSON.stringify(this.embed));
      }
      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('ItemEmbed', this, 'embed:' + JSON.stringify(this.embed));
      }
    }, {
      key: '_length',
      get: function get$$1() {
        return 1;
      }
    }]);
    return ItemEmbed;
  }(Item);

  var ItemFormat = function (_Item) {
    inherits(ItemFormat, _Item);

    function ItemFormat() {
      classCallCheck(this, ItemFormat);

      var _this = possibleConstructorReturn(this, (ItemFormat.__proto__ || Object.getPrototypeOf(ItemFormat)).call(this));

      _this.key = null;
      _this.value = null;
      return _this;
    }

    createClass(ItemFormat, [{
      key: '_copy',
      value: function _copy(undeleteChildren, copyPosition) {
        var struct = get(ItemFormat.prototype.__proto__ || Object.getPrototypeOf(ItemFormat.prototype), '_copy', this).call(this, undeleteChildren, copyPosition);
        struct.key = this.key;
        struct.value = this.value;
        return struct;
      }
    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(ItemFormat.prototype.__proto__ || Object.getPrototypeOf(ItemFormat.prototype), '_fromBinary', this).call(this, y, decoder);
        this.key = decoder.readVarString();
        this.value = JSON.parse(decoder.readVarString());
        return missing;
      }
    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(ItemFormat.prototype.__proto__ || Object.getPrototypeOf(ItemFormat.prototype), '_toBinary', this).call(this, encoder);
        encoder.writeVarString(this.key);
        encoder.writeVarString(JSON.stringify(this.value));
      }
      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('ItemFormat', this, 'key:' + JSON.stringify(this.key) + ',value:' + JSON.stringify(this.value));
      }
    }, {
      key: '_length',
      get: function get$$1() {
        return 1;
      }
    }, {
      key: '_countable',
      get: function get$$1() {
        return false;
      }
    }]);
    return ItemFormat;
  }(Item);

  /**
   * @private
   */
  function integrateItem(item, parent, y, left, right) {
    item._origin = left;
    item._left = left;
    item._right = right;
    item._right_origin = right;
    item._parent = parent;
    if (y !== null) {
      item._integrate(y);
    } else if (left === null) {
      parent._start = item;
    } else {
      left._right = item;
    }
  }

  /**
   * @private
   */
  function findNextPosition(currentAttributes, parent, left, right, count) {
    while (right !== null && count > 0) {
      switch (right.constructor) {
        case ItemEmbed:
        case ItemString:
          var rightLen = right._deleted ? 0 : right._length - 1;
          if (count <= rightLen) {
            right = right._splitAt(parent._y, count);
            left = right._left;
            return [left, right, currentAttributes];
          }
          if (right._deleted === false) {
            count -= right._length;
          }
          break;
        case ItemFormat:
          if (right._deleted === false) {
            updateCurrentAttributes(currentAttributes, right);
          }
          break;
      }
      left = right;
      right = right._right;
    }
    return [left, right, currentAttributes];
  }

  /**
   * @private
   */
  function findPosition(parent, index) {
    var currentAttributes = new Map();
    var left = null;
    var right = parent._start;
    return findNextPosition(currentAttributes, parent, left, right, index);
  }

  /**
   * Negate applied formats
   *
   * @private
   */
  function insertNegatedAttributes(y, parent, left, right, negatedAttributes) {
    // check if we really need to remove attributes
    while (right !== null && (right._deleted === true || right.constructor === ItemFormat && negatedAttributes.get(right.key) === right.value)) {
      if (right._deleted === false) {
        negatedAttributes.delete(right.key);
      }
      left = right;
      right = right._right;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = negatedAttributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = slicedToArray(_step.value, 2),
            key = _step$value[0],
            val = _step$value[1];

        var format = new ItemFormat();
        format.key = key;
        format.value = val;
        integrateItem(format, parent, y, left, right);
        left = format;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return [left, right];
  }

  /**
   * @private
   */
  function updateCurrentAttributes(currentAttributes, item) {
    var value = item.value;
    var key = item.key;
    if (value === null) {
      currentAttributes.delete(key);
    } else {
      currentAttributes.set(key, value);
    }
  }

  /**
   * @private
   */
  function minimizeAttributeChanges(left, right, currentAttributes, attributes) {
    // go right while attributes[right.key] === right.value (or right is deleted)
    while (true) {
      if (right === null) {
        break;
      } else if (right._deleted === true) ; else if (right.constructor === ItemFormat && (attributes[right.key] || null) === right.value) {
        // found a format, update currentAttributes and continue
        updateCurrentAttributes(currentAttributes, right);
      } else {
        break;
      }
      left = right;
      right = right._right;
    }
    return [left, right];
  }

  /**
   * @private
   */
  function insertAttributes(y, parent, left, right, attributes, currentAttributes) {
    var negatedAttributes = new Map();
    // insert format-start items
    for (var key in attributes) {
      var val = attributes[key];
      var currentVal = currentAttributes.get(key);
      if (currentVal !== val) {
        // save negated attribute (set null if currentVal undefined)
        negatedAttributes.set(key, currentVal || null);
        var format = new ItemFormat();
        format.key = key;
        format.value = val;
        integrateItem(format, parent, y, left, right);
        left = format;
      }
    }
    return [left, right, negatedAttributes];
  }

  /**
   * @private
   */
  function insertText(y, text, parent, left, right, currentAttributes, attributes) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = currentAttributes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _step2$value = slicedToArray(_step2.value, 1),
            key = _step2$value[0];

        if (attributes[key] === undefined) {
          attributes[key] = null;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var _minimizeAttributeCha = minimizeAttributeChanges(left, right, currentAttributes, attributes);

    var _minimizeAttributeCha2 = slicedToArray(_minimizeAttributeCha, 2);

    left = _minimizeAttributeCha2[0];
    right = _minimizeAttributeCha2[1];

    var negatedAttributes = void 0;

    // insert content
    var _insertAttributes = insertAttributes(y, parent, left, right, attributes, currentAttributes);

    var _insertAttributes2 = slicedToArray(_insertAttributes, 3);

    left = _insertAttributes2[0];
    right = _insertAttributes2[1];
    negatedAttributes = _insertAttributes2[2];
    var item = void 0;
    if (text.constructor === String) {
      item = new ItemString();
      item._content = text;
    } else {
      item = new ItemEmbed();
      item.embed = text;
    }
    integrateItem(item, parent, y, left, right);
    left = item;
    return insertNegatedAttributes(y, parent, left, right, negatedAttributes);
  }

  /**
   * @private
   */
  function formatText(y, length, parent, left, right, currentAttributes, attributes) {
    var _minimizeAttributeCha3 = minimizeAttributeChanges(left, right, currentAttributes, attributes);

    var _minimizeAttributeCha4 = slicedToArray(_minimizeAttributeCha3, 2);

    left = _minimizeAttributeCha4[0];
    right = _minimizeAttributeCha4[1];

    var negatedAttributes = void 0;

    // iterate until first non-format or null is found
    // delete all formats with attributes[format.key] != null
    var _insertAttributes3 = insertAttributes(y, parent, left, right, attributes, currentAttributes);

    var _insertAttributes4 = slicedToArray(_insertAttributes3, 3);

    left = _insertAttributes4[0];
    right = _insertAttributes4[1];
    negatedAttributes = _insertAttributes4[2];
    while (length > 0 && right !== null) {
      if (right._deleted === false) {
        switch (right.constructor) {
          case ItemFormat:
            var attr = attributes[right.key];
            if (attr !== undefined) {
              if (attr === right.value) {
                negatedAttributes.delete(right.key);
              } else {
                negatedAttributes.set(right.key, right.value);
              }
              right._delete(y);
            }
            updateCurrentAttributes(currentAttributes, right);
            break;
          case ItemEmbed:
          case ItemString:
            right._splitAt(y, length);
            length -= right._length;
            break;
        }
      }
      left = right;
      right = right._right;
    }
    return insertNegatedAttributes(y, parent, left, right, negatedAttributes);
  }

  /**
   * @private
   */
  function deleteText(y, length, parent, left, right, currentAttributes) {
    while (length > 0 && right !== null) {
      if (right._deleted === false) {
        switch (right.constructor) {
          case ItemFormat:
            updateCurrentAttributes(currentAttributes, right);
            break;
          case ItemEmbed:
          case ItemString:
            right._splitAt(y, length);
            length -= right._length;
            right._delete(y);
            break;
        }
      }
      left = right;
      right = right._right;
    }
    return [left, right];
  }

  // TODO: In the quill delta representation we should also use the format {ops:[..]}
  /**
   * The Quill Delta format represents changes on a text document with
   * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}
   *
   * @example
   *   {
   *     ops: [
   *       { insert: 'Gandalf', attributes: { bold: true } },
   *       { insert: ' the ' },
   *       { insert: 'Grey', attributes: { color: '#cccccc' } }
   *     ]
   *   }
   *
   * @typedef {Array<Object>} Delta
   */

  /**
    * Attributes that can be assigned to a selection of text.
    *
    * @example
    *   {
    *     bold: true,
    *     font-size: '40px'
    *   }
    *
    * @typedef {Object} TextAttributes
    */

  /**
   * Event that describes the changes on a YText type.
   *
   * @private
   */

  var YTextEvent = function (_YArrayEvent) {
    inherits(YTextEvent, _YArrayEvent);

    function YTextEvent(ytext, remote, transaction) {
      classCallCheck(this, YTextEvent);

      var _this = possibleConstructorReturn(this, (YTextEvent.__proto__ || Object.getPrototypeOf(YTextEvent)).call(this, ytext, remote, transaction));

      _this._delta = null;
      return _this;
    }
    // TODO: Should put this in a separate function. toDelta shouldn't be included
    //       in every Yjs distribution
    /**
     * Compute the changes in the delta format.
     *
     * @return {Delta} A {@link https://quilljs.com/docs/delta/|Quill Delta}) that
     *                 represents the changes on the document.
     *
     * @public
     */


    createClass(YTextEvent, [{
      key: 'delta',
      get: function get$$1() {
        var _this2 = this;

        if (this._delta === null) {
          var y = this.target._y;
          y.transact(function () {
            var item = _this2.target._start;
            var delta = [];
            var added = _this2.addedElements;
            var removed = _this2.removedElements;
            _this2._delta = delta;
            var action = null;
            var attributes = {}; // counts added or removed new attributes for retain
            var currentAttributes = new Map(); // saves all current attributes for insert
            var oldAttributes = new Map();
            var insert = '';
            var retain = 0;
            var deleteLen = 0;
            var addOp = function addOp() {
              if (action !== null) {
                var op = void 0;
                switch (action) {
                  case 'delete':
                    op = { delete: deleteLen };
                    deleteLen = 0;
                    break;
                  case 'insert':
                    op = { insert: insert };
                    if (currentAttributes.size > 0) {
                      op.attributes = {};
                      var _iteratorNormalCompletion3 = true;
                      var _didIteratorError3 = false;
                      var _iteratorError3 = undefined;

                      try {
                        for (var _iterator3 = currentAttributes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                          var _step3$value = slicedToArray(_step3.value, 2),
                              key = _step3$value[0],
                              value = _step3$value[1];

                          if (value !== null) {
                            op.attributes[key] = value;
                          }
                        }
                      } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                          }
                        } finally {
                          if (_didIteratorError3) {
                            throw _iteratorError3;
                          }
                        }
                      }
                    }
                    insert = '';
                    break;
                  case 'retain':
                    op = { retain: retain };
                    if (Object.keys(attributes).length > 0) {
                      op.attributes = {};
                      for (var key in attributes) {
                        op.attributes[key] = attributes[key];
                      }
                    }
                    retain = 0;
                    break;
                }
                delta.push(op);
                action = null;
              }
            };
            while (item !== null) {
              switch (item.constructor) {
                case ItemEmbed:
                  if (added.has(item)) {
                    addOp();
                    action = 'insert';
                    insert = item.embed;
                    addOp();
                  } else if (removed.has(item)) {
                    if (action !== 'delete') {
                      addOp();
                      action = 'delete';
                    }
                    deleteLen += 1;
                  } else if (item._deleted === false) {
                    if (action !== 'retain') {
                      addOp();
                      action = 'retain';
                    }
                    retain += 1;
                  }
                  break;
                case ItemString:
                  if (added.has(item)) {
                    if (action !== 'insert') {
                      addOp();
                      action = 'insert';
                    }
                    insert += item._content;
                  } else if (removed.has(item)) {
                    if (action !== 'delete') {
                      addOp();
                      action = 'delete';
                    }
                    deleteLen += item._length;
                  } else if (item._deleted === false) {
                    if (action !== 'retain') {
                      addOp();
                      action = 'retain';
                    }
                    retain += item._length;
                  }
                  break;
                case ItemFormat:
                  if (added.has(item)) {
                    var curVal = currentAttributes.get(item.key) || null;
                    if (curVal !== item.value) {
                      if (action === 'retain') {
                        addOp();
                      }
                      if (item.value === (oldAttributes.get(item.key) || null)) {
                        delete attributes[item.key];
                      } else {
                        attributes[item.key] = item.value;
                      }
                    } else {
                      item._delete(y);
                    }
                  } else if (removed.has(item)) {
                    oldAttributes.set(item.key, item.value);
                    var _curVal = currentAttributes.get(item.key) || null;
                    if (_curVal !== item.value) {
                      if (action === 'retain') {
                        addOp();
                      }
                      attributes[item.key] = _curVal;
                    }
                  } else if (item._deleted === false) {
                    oldAttributes.set(item.key, item.value);
                    var attr = attributes[item.key];
                    if (attr !== undefined) {
                      if (attr !== item.value) {
                        if (action === 'retain') {
                          addOp();
                        }
                        if (item.value === null) {
                          attributes[item.key] = item.value;
                        } else {
                          delete attributes[item.key];
                        }
                      } else {
                        item._delete(y);
                      }
                    }
                  }
                  if (item._deleted === false) {
                    if (action === 'insert') {
                      addOp();
                    }
                    updateCurrentAttributes(currentAttributes, item);
                  }
                  break;
              }
              item = item._right;
            }
            addOp();
            while (_this2._delta.length > 0) {
              var lastOp = _this2._delta[_this2._delta.length - 1];
              if (lastOp.retain !== undefined && lastOp.attributes === undefined) {
                // retain delta's if they don't assign attributes
                _this2._delta.pop();
              } else {
                break;
              }
            }
          });
        }
        return this._delta;
      }
    }]);
    return YTextEvent;
  }(YArrayEvent);

  /**
   * Type that represents text with formatting information.
   *
   * This type replaces y-richtext as this implementation is able to handle
   * block formats (format information on a paragraph), embeds (complex elements
   * like pictures and videos), and text formats (**bold**, *italic*).
   *
   * @param {String} string The initial value of the YText.
   */


  var YText = function (_YArray) {
    inherits(YText, _YArray);

    function YText(string) {
      classCallCheck(this, YText);

      var _this3 = possibleConstructorReturn(this, (YText.__proto__ || Object.getPrototypeOf(YText)).call(this));

      if (typeof string === 'string') {
        var start = new ItemString();
        start._parent = _this3;
        start._content = string;
        _this3._start = start;
      }
      return _this3;
    }

    /**
     * @private
     * Creates YMap Event and calls observers.
     */


    createClass(YText, [{
      key: '_callObserver',
      value: function _callObserver(transaction, parentSubs, remote) {
        this._callEventHandler(transaction, new YTextEvent(this, remote, transaction));
      }

      /**
       * Returns the unformatted string representation of this YText type.
       *
       * @public
       */

    }, {
      key: 'toString',
      value: function toString() {
        var str = '';
        var n = this._start;
        while (n !== null) {
          if (!n._deleted && n._countable) {
            str += n._content;
          }
          n = n._right;
        }
        return str;
      }

      /**
       * Apply a {@link Delta} on this shared YText type.
       *
       * @param {Delta} delta The changes to apply on this element.
       *
       * @public
       */

    }, {
      key: 'applyDelta',
      value: function applyDelta(delta) {
        var _this4 = this;

        this._transact(function (y) {
          var left = null;
          var right = _this4._start;
          var currentAttributes = new Map();
          for (var i = 0; i < delta.length; i++) {
            var op = delta[i];
            if (op.insert !== undefined) {
              var _insertText = insertText(y, op.insert, _this4, left, right, currentAttributes, op.attributes || {});

              var _insertText2 = slicedToArray(_insertText, 2);

              left = _insertText2[0];
              right = _insertText2[1];
            } else if (op.retain !== undefined) {
              var _formatText = formatText(y, op.retain, _this4, left, right, currentAttributes, op.attributes || {});

              var _formatText2 = slicedToArray(_formatText, 2);

              left = _formatText2[0];
              right = _formatText2[1];
            } else if (op.delete !== undefined) {
              var _deleteText = deleteText(y, op.delete, _this4, left, right, currentAttributes);

              var _deleteText2 = slicedToArray(_deleteText, 2);

              left = _deleteText2[0];
              right = _deleteText2[1];
            }
          }
        });
      }

      /**
       * Returns the Delta representation of this YText type.
       *
       * @return {Delta} The Delta representation of this type.
       *
       * @public
       */

    }, {
      key: 'toDelta',
      value: function toDelta() {
        var ops = [];
        var currentAttributes = new Map();
        var str = '';
        var n = this._start;
        function packStr() {
          if (str.length > 0) {
            // pack str with attributes to ops
            var attributes = {};
            var addAttributes = false;
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = currentAttributes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var _step4$value = slicedToArray(_step4.value, 2),
                    key = _step4$value[0],
                    value = _step4$value[1];

                addAttributes = true;
                attributes[key] = value;
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            var op = { insert: str };
            if (addAttributes) {
              op.attributes = attributes;
            }
            ops.push(op);
            str = '';
          }
        }
        while (n !== null) {
          if (!n._deleted) {
            switch (n.constructor) {
              case ItemString:
                str += n._content;
                break;
              case ItemFormat:
                packStr();
                updateCurrentAttributes(currentAttributes, n);
                break;
            }
          }
          n = n._right;
        }
        packStr();
        return ops;
      }

      /**
       * Insert text at a given index.
       *
       * @param {Integer} index The index at which to start inserting.
       * @param {String} text The text to insert at the specified position.
       * @param {TextAttributes} attributes Optionally define some formatting
       *                                    information to apply on the inserted
       *                                    Text.
       *
       * @public
       */

    }, {
      key: 'insert',
      value: function insert(index, text) {
        var _this5 = this;

        var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (text.length <= 0) {
          return;
        }
        this._transact(function (y) {
          var _findPosition = findPosition(_this5, index),
              _findPosition2 = slicedToArray(_findPosition, 3),
              left = _findPosition2[0],
              right = _findPosition2[1],
              currentAttributes = _findPosition2[2];

          insertText(y, text, _this5, left, right, currentAttributes, attributes);
        });
      }

      /**
       * Inserts an embed at a index.
       *
       * @param {Integer} index The index to insert the embed at.
       * @param {Object} embed The Object that represents the embed.
       * @param {TextAttributes} attributes Attribute information to apply on the
       *                                    embed
       *
       * @public
       */

    }, {
      key: 'insertEmbed',
      value: function insertEmbed(index, embed) {
        var _this6 = this;

        var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        if (embed.constructor !== Object) {
          throw new Error('Embed must be an Object');
        }
        this._transact(function (y) {
          var _findPosition3 = findPosition(_this6, index),
              _findPosition4 = slicedToArray(_findPosition3, 3),
              left = _findPosition4[0],
              right = _findPosition4[1],
              currentAttributes = _findPosition4[2];

          insertText(y, embed, _this6, left, right, currentAttributes, attributes);
        });
      }

      /**
       * Deletes text starting from an index.
       *
       * @param {Integer} index Index at which to start deleting.
       * @param {Integer} length The number of characters to remove. Defaults to 1.
       *
       * @public
       */

    }, {
      key: 'delete',
      value: function _delete(index, length) {
        var _this7 = this;

        if (length === 0) {
          return;
        }
        this._transact(function (y) {
          var _findPosition5 = findPosition(_this7, index),
              _findPosition6 = slicedToArray(_findPosition5, 3),
              left = _findPosition6[0],
              right = _findPosition6[1],
              currentAttributes = _findPosition6[2];

          deleteText(y, length, _this7, left, right, currentAttributes);
        });
      }

      /**
       * Assigns properties to a range of text.
       *
       * @param {Integer} index The position where to start formatting.
       * @param {Integer} length The amount of characters to assign properties to.
       * @param {TextAttributes} attributes Attribute information to apply on the
       *                                    text.
       *
       * @public
       */

    }, {
      key: 'format',
      value: function format(index, length, attributes) {
        var _this8 = this;

        this._transact(function (y) {
          var _findPosition7 = findPosition(_this8, index),
              _findPosition8 = slicedToArray(_findPosition7, 3),
              left = _findPosition8[0],
              right = _findPosition8[1],
              currentAttributes = _findPosition8[2];

          if (right === null) {
            return;
          }
          formatText(y, length, _this8, left, right, currentAttributes, attributes);
        });
      }
      // TODO: De-duplicate code. The following code is in every type.
      /**
       * Transform this YText to a readable format.
       * Useful for logging as all Items implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('YText', this);
      }
    }]);
    return YText;
  }(YArray);

  /**
   * You can manage binding to a custom type with YXmlHook.
   *
   * @public
   */

  var YXmlHook = function (_YMap) {
    inherits(YXmlHook, _YMap);

    /**
     * @param {String} hookName nodeName of the Dom Node.
     */
    function YXmlHook(hookName) {
      classCallCheck(this, YXmlHook);

      var _this = possibleConstructorReturn(this, (YXmlHook.__proto__ || Object.getPrototypeOf(YXmlHook)).call(this));

      _this.hookName = null;
      if (hookName !== undefined) {
        _this.hookName = hookName;
      }
      return _this;
    }

    /**
     * Creates an Item with the same effect as this Item (without position effect)
     *
     * @private
     */


    createClass(YXmlHook, [{
      key: '_copy',
      value: function _copy() {
        var struct = get(YXmlHook.prototype.__proto__ || Object.getPrototypeOf(YXmlHook.prototype), '_copy', this).call(this);
        struct.hookName = this.hookName;
        return struct;
      }

      /**
       * Creates a Dom Element that mirrors this YXmlElement.
       *
       * @param {Document} [_document=document] The document object (you must define
       *                                        this when calling this method in
       *                                        nodejs)
       * @param {Object<key:hookDefinition>} [hooks] Optional property to customize how hooks
       *                                             are presented in the DOM
       * @param {DomBinding} [binding] You should not set this property. This is
       *                               used if DomBinding wants to create a
       *                               association to the created DOM type
       * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
       *
       * @public
       */

    }, {
      key: 'toDom',
      value: function toDom() {

        var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var binding = arguments[2];

        var hook = hooks[this.hookName];
        var dom = void 0;
        if (hook !== undefined) {
          dom = hook.createDom(this);
        } else {
          dom = document.createElement(this.hookName);
        }
        dom.setAttribute('data-yjs-hook', this.hookName);
        createAssociation(binding, dom, this);
        return dom;
      }

      /**
       * Read the next Item in a Decoder and fill this Item with the read data.
       *
       * This is called when data is received from a remote peer.
       *
       * @param {Y} y The Yjs instance that this Item belongs to.
       * @param {BinaryDecoder} decoder The decoder object to read data from.
       *
       * @private
       */

    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(YXmlHook.prototype.__proto__ || Object.getPrototypeOf(YXmlHook.prototype), '_fromBinary', this).call(this, y, decoder);
        this.hookName = decoder.readVarString();
        return missing;
      }

      /**
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       *
       * @param {BinaryEncoder} encoder The encoder to write data to.
       *
       * @private
       */

    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(YXmlHook.prototype.__proto__ || Object.getPrototypeOf(YXmlHook.prototype), '_toBinary', this).call(this, encoder);
        encoder.writeVarString(this.hookName);
      }

      /**
       * Integrate this type into the Yjs instance.
       *
       * * Save this struct in the os
       * * This type is sent to other client
       * * Observer functions are fired
       *
       * @param {Y} y The Yjs instance
       *
       * @private
       */

    }, {
      key: '_integrate',
      value: function _integrate(y) {
        if (this.hookName === null) {
          throw new Error('hookName must be defined!');
        }
        get(YXmlHook.prototype.__proto__ || Object.getPrototypeOf(YXmlHook.prototype), '_integrate', this).call(this, y);
      }
    }]);
    return YXmlHook;
  }(YMap);

  /**
   * Define the elements to which a set of CSS queries apply.
   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
   *
   * @example
   *   query = '.classSelector'
   *   query = 'nodeSelector'
   *   query = '#idSelector'
   *
   * @typedef {string} CSS_Selector
   */

  /**
   * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a
   * position within them.
   *
   * Can be created with {@link YXmlFragment#createTreeWalker}
   *
   * @public
   */

  var YXmlTreeWalker = function () {
    function YXmlTreeWalker(root, f) {
      classCallCheck(this, YXmlTreeWalker);

      this._filter = f || function () {
        return true;
      };
      this._root = root;
      this._currentNode = root;
      this._firstCall = true;
    }

    createClass(YXmlTreeWalker, [{
      key: Symbol.iterator,
      value: function value() {
        return this;
      }
      /**
       * Get the next node.
       *
       * @return {YXmlElement} The next node.
       *
       * @public
       */

    }, {
      key: 'next',
      value: function next() {
        var n = this._currentNode;
        if (this._firstCall) {
          this._firstCall = false;
          if (!n._deleted && this._filter(n)) {
            return { value: n, done: false };
          }
        }
        do {
          if (!n._deleted && (n.constructor === YXmlFragment._YXmlElement || n.constructor === YXmlFragment) && n._start !== null) {
            // walk down in the tree
            n = n._start;
          } else {
            // walk right or up in the tree
            while (n !== this._root) {
              if (n._right !== null) {
                n = n._right;
                break;
              }
              n = n._parent;
            }
            if (n === this._root) {
              n = null;
            }
          }
          if (n === this._root) {
            break;
          }
        } while (n !== null && (n._deleted || !this._filter(n)));
        this._currentNode = n;
        if (n === null) {
          return { done: true };
        } else {
          return { value: n, done: false };
        }
      }
    }]);
    return YXmlTreeWalker;
  }();

  /**
   * An Event that describes changes on a YXml Element or Yxml Fragment
   *
   * @protected
   */

  var YXmlEvent = function (_YEvent) {
    inherits(YXmlEvent, _YEvent);

    /**
     * @param {YType} target The target on which the event is created.
     * @param {Set} subs The set of changed attributes. `null` is included if the
     *                   child list changed.
     * @param {Boolean} remote Whether this change was created by a remote peer.
     * @param {Transaction} transaction The transaction instance with wich the
     *                                  change was created.
     */
    function YXmlEvent(target, subs, remote, transaction) {
      classCallCheck(this, YXmlEvent);

      /**
       * The transaction instance for the computed change.
       * @type {Transaction}
       */
      var _this = possibleConstructorReturn(this, (YXmlEvent.__proto__ || Object.getPrototypeOf(YXmlEvent)).call(this, target));

      _this._transaction = transaction;
      /**
       * Whether the children changed.
       * @type {Boolean}
       */
      _this.childListChanged = false;
      /**
       * Set of all changed attributes.
       * @type {Set}
       */
      _this.attributesChanged = new Set();
      /**
       * Whether this change was created by a remote peer.
       * @type {Boolean}
       */
      _this.remote = remote;
      subs.forEach(function (sub) {
        if (sub === null) {
          _this.childListChanged = true;
        } else {
          _this.attributesChanged.add(sub);
        }
      });
      return _this;
    }

    return YXmlEvent;
  }(YEvent);

  /**
   * Dom filter function.
   *
   * @callback domFilter
   * @param {string} nodeName The nodeName of the element
   * @param {Map} attributes The map of attributes.
   * @return {boolean} Whether to include the Dom node in the YXmlElement.
   */

  /**
   * Define the elements to which a set of CSS queries apply.
   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
   *
   * @example
   *   query = '.classSelector'
   *   query = 'nodeSelector'
   *   query = '#idSelector'
   *
   * @typedef {string} CSS_Selector
   */

  /**
   * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.
   * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a
   * nodeName and it does not have attributes. Though it can be bound to a DOM
   * element - in this case the attributes and the nodeName are not shared.
   *
   * @public
   */

  var YXmlFragment = function (_YArray) {
    inherits(YXmlFragment, _YArray);

    function YXmlFragment() {
      classCallCheck(this, YXmlFragment);
      return possibleConstructorReturn(this, (YXmlFragment.__proto__ || Object.getPrototypeOf(YXmlFragment)).apply(this, arguments));
    }

    createClass(YXmlFragment, [{
      key: 'createTreeWalker',

      /**
       * Create a subtree of childNodes.
       *
       * @example
       * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
       * for (let node in walker) {
       *   // `node` is a div node
       *   nop(node)
       * }
       *
       * @param {Function} filter Function that is called on each child element and
       *                          returns a Boolean indicating whether the child
       *                          is to be included in the subtree.
       * @return {TreeWalker} A subtree and a position within it.
       *
       * @public
       */
      value: function createTreeWalker(filter) {
        return new YXmlTreeWalker(this, filter);
      }

      /**
       * Returns the first YXmlElement that matches the query.
       * Similar to DOM's {@link querySelector}.
       *
       * Query support:
       *   - tagname
       * TODO:
       *   - id
       *   - attribute
       *
       * @param {CSS_Selector} query The query on the children.
       * @return {?YXmlElement} The first element that matches the query or null.
       *
       * @public
       */

    }, {
      key: 'querySelector',
      value: function querySelector(query) {
        query = query.toUpperCase();
        var iterator = new YXmlTreeWalker(this, function (element) {
          return element.nodeName === query;
        });
        var next = iterator.next();
        if (next.done) {
          return null;
        } else {
          return next.value;
        }
      }

      /**
       * Returns all YXmlElements that match the query.
       * Similar to Dom's {@link querySelectorAll}.
       *
       * TODO: Does not yet support all queries. Currently only query by tagName.
       *
       * @param {CSS_Selector} query The query on the children
       * @return {Array<YXmlElement>} The elements that match this query.
       *
       * @public
       */

    }, {
      key: 'querySelectorAll',
      value: function querySelectorAll(query) {
        query = query.toUpperCase();
        return Array.from(new YXmlTreeWalker(this, function (element) {
          return element.nodeName === query;
        }));
      }

      /**
       * Creates YArray Event and calls observers.
       *
       * @private
       */

    }, {
      key: '_callObserver',
      value: function _callObserver(transaction, parentSubs, remote) {
        this._callEventHandler(transaction, new YXmlEvent(this, parentSubs, remote, transaction));
      }

      /**
       * Get the string representation of all the children of this YXmlFragment.
       *
       * @return {string} The string representation of all children.
       */

    }, {
      key: 'toString',
      value: function toString() {
        return this.map(function (xml) {
          return xml.toString();
        }).join('');
      }

      /**
       * @private
       * Unbind from Dom and mark this Item as deleted.
       *
       * @param {Y} y The Yjs instance
       * @param {boolean} createDelete Whether to propagate a message that this
       *                               Type was deleted.
       * @param {boolean} [gcChildren=y._hasUndoManager===false] Whether to garbage
       *                                         collect the children of this type.
       *
       * @private
       */

    }, {
      key: '_delete',
      value: function _delete(y, createDelete, gcChildren) {
        get(YXmlFragment.prototype.__proto__ || Object.getPrototypeOf(YXmlFragment.prototype), '_delete', this).call(this, y, createDelete, gcChildren);
      }

      /**
       * Creates a Dom Element that mirrors this YXmlElement.
       *
       * @param {Document} [_document=document] The document object (you must define
       *                                        this when calling this method in
       *                                        nodejs)
       * @param {Object<key:hookDefinition>} [hooks={}] Optional property to customize how hooks
       *                                             are presented in the DOM
       * @param {DomBinding} [binding] You should not set this property. This is
       *                               used if DomBinding wants to create a
       *                               association to the created DOM type
       * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
       *
       * @public
       */

    }, {
      key: 'toDom',
      value: function toDom() {
        var _document = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

        var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var binding = arguments[2];

        var fragment = _document.createDocumentFragment();
        createAssociation(binding, fragment, this);
        this.forEach(function (xmlType) {
          fragment.insertBefore(xmlType.toDom(_document, hooks, binding), null);
        });
        return fragment;
      }
      /**
       * Transform this YXml Type to a readable format.
       * Useful for logging as all Items and Delete implement this method.
       *
       * @private
       */

    }, {
      key: '_logString',
      value: function _logString() {
        return logItemHelper('YXml', this);
      }
    }]);
    return YXmlFragment;
  }(YArray);

  /**
   * An YXmlElement imitates the behavior of a
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.
   *
   * * An YXmlElement has attributes (key value pairs)
   * * An YXmlElement has childElements that must inherit from YXmlElement
   *
   * @param {String} nodeName Node name
   */

  var YXmlElement = function (_YXmlFragment) {
    inherits(YXmlElement, _YXmlFragment);

    function YXmlElement() {
      var nodeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'UNDEFINED';
      classCallCheck(this, YXmlElement);

      var _this = possibleConstructorReturn(this, (YXmlElement.__proto__ || Object.getPrototypeOf(YXmlElement)).call(this));

      _this.nodeName = nodeName.toUpperCase();
      return _this;
    }

    /**
     * @private
     * Creates an Item with the same effect as this Item (without position effect)
     */


    createClass(YXmlElement, [{
      key: '_copy',
      value: function _copy() {
        var struct = get(YXmlElement.prototype.__proto__ || Object.getPrototypeOf(YXmlElement.prototype), '_copy', this).call(this);
        struct.nodeName = this.nodeName;
        return struct;
      }

      /**
       * @private
       * Read the next Item in a Decoder and fill this Item with the read data.
       *
       * This is called when data is received from a remote peer.
       *
       * @param {Y} y The Yjs instance that this Item belongs to.
       * @param {BinaryDecoder} decoder The decoder object to read data from.
       */

    }, {
      key: '_fromBinary',
      value: function _fromBinary(y, decoder) {
        var missing = get(YXmlElement.prototype.__proto__ || Object.getPrototypeOf(YXmlElement.prototype), '_fromBinary', this).call(this, y, decoder);
        this.nodeName = decoder.readVarString();
        return missing;
      }

      /**
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       *
       * @param {BinaryEncoder} encoder The encoder to write data to.
       *
       * @private
       */

    }, {
      key: '_toBinary',
      value: function _toBinary(encoder) {
        get(YXmlElement.prototype.__proto__ || Object.getPrototypeOf(YXmlElement.prototype), '_toBinary', this).call(this, encoder);
        encoder.writeVarString(this.nodeName);
      }

      /**
       * Integrates this Item into the shared structure.
       *
       * This method actually applies the change to the Yjs instance. In case of
       * Item it connects _left and _right to this Item and calls the
       * {@link Item#beforeChange} method.
       *
       * * Checks for nodeName
       * * Sets domFilter
       *
       * @param {Y} y The Yjs instance
       *
       * @private
       */

    }, {
      key: '_integrate',
      value: function _integrate(y) {
        if (this.nodeName === null) {
          throw new Error('nodeName must be defined!');
        }
        get(YXmlElement.prototype.__proto__ || Object.getPrototypeOf(YXmlElement.prototype), '_integrate', this).call(this, y);
      }

      /**
       * Returns the string representation of this YXmlElement.
       * The attributes are ordered by attribute-name, so you can easily use this
       * method to compare YXmlElements
       *
       * @return {String} The string representation of this type.
       *
       * @public
       */

    }, {
      key: 'toString',
      value: function toString() {
        var attrs = this.getAttributes();
        var stringBuilder = [];
        var keys = [];
        for (var key in attrs) {
          keys.push(key);
        }
        keys.sort();
        var keysLen = keys.length;
        for (var i = 0; i < keysLen; i++) {
          var _key = keys[i];
          stringBuilder.push(_key + '="' + attrs[_key] + '"');
        }
        var nodeName = this.nodeName.toLocaleLowerCase();
        var attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';
        return '<' + nodeName + attrsString + '>' + get(YXmlElement.prototype.__proto__ || Object.getPrototypeOf(YXmlElement.prototype), 'toString', this).call(this) + '</' + nodeName + '>';
      }

      /**
       * Removes an attribute from this YXmlElement.
       *
       * @param {String} attributeName The attribute name that is to be removed.
       *
       * @public
       */

    }, {
      key: 'removeAttribute',
      value: function removeAttribute(attributeName) {
        return YMap.prototype.delete.call(this, attributeName);
      }

      /**
       * Sets or updates an attribute.
       *
       * @param {String} attributeName The attribute name that is to be set.
       * @param {String} attributeValue The attribute value that is to be set.
       *
       * @public
       */

    }, {
      key: 'setAttribute',
      value: function setAttribute(attributeName, attributeValue) {
        return YMap.prototype.set.call(this, attributeName, attributeValue);
      }

      /**
       * Returns an attribute value that belongs to the attribute name.
       *
       * @param {String} attributeName The attribute name that identifies the
       *                               queried value.
       * @return {String} The queried attribute value.
       *
       * @public
       */

    }, {
      key: 'getAttribute',
      value: function getAttribute(attributeName) {
        return YMap.prototype.get.call(this, attributeName);
      }

      /**
       * Returns all attribute name/value pairs in a JSON Object.
       *
       * @return {Object} A JSON Object that describes the attributes.
       *
       * @public
       */

    }, {
      key: 'getAttributes',
      value: function getAttributes() {
        var obj = {};
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._map[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = slicedToArray(_step.value, 2),
                key = _step$value[0],
                value = _step$value[1];

            if (!value._deleted) {
              obj[key] = value._content[0];
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return obj;
      }
      // TODO: outsource the binding property.
      /**
       * Creates a Dom Element that mirrors this YXmlElement.
       *
       * @param {Document} [_document=document] The document object (you must define
       *                                        this when calling this method in
       *                                        nodejs)
       * @param {Object<key:hookDefinition>} [hooks={}] Optional property to customize how hooks
       *                                             are presented in the DOM
       * @param {DomBinding} [binding] You should not set this property. This is
       *                               used if DomBinding wants to create a
       *                               association to the created DOM type.
       * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
       *
       * @public
       */

    }, {
      key: 'toDom',
      value: function toDom() {
        var _document = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

        var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var binding = arguments[2];

        var dom = _document.createElement(this.nodeName);
        var attrs = this.getAttributes();
        for (var key in attrs) {
          dom.setAttribute(key, attrs[key]);
        }
        this.forEach(function (yxml) {
          dom.appendChild(yxml.toDom(_document, hooks, binding));
        });
        createAssociation(binding, dom, this);
        return dom;
      }
    }]);
    return YXmlElement;
  }(YXmlFragment);


  YXmlFragment._YXmlElement = YXmlElement;

  /**
   * Check if `parent` is a parent of `child`.
   *
   * @param {Type} parent
   * @param {Type} child
   * @return {Boolean} Whether `parent` is a parent of `child`.
   *
   * @public
   */
  function isParentOf(parent, child) {
    child = child._parent;
    while (child !== null) {
      if (child === parent) {
        return true;
      }
      child = child._parent;
    }
    return false;
  }

  /**
   * Default filter method (does nothing).
   *
   * @param {String} nodeName The nodeName of the element
   * @param {Map} attrs Map of key-value pairs that are attributes of the node.
   * @return {Map | null} The allowed attributes or null, if the element should be
   *                      filtered.
   */
  function defaultFilter(nodeName, attrs) {
    // TODO: implement basic filter that filters out dangerous properties!
    return attrs;
  }

  /**
   *
   */
  function filterDomAttributes(dom, filter) {
    var attrs = new Map();
    for (var i = dom.attributes.length - 1; i >= 0; i--) {
      var attr = dom.attributes[i];
      attrs.set(attr.name, attr.value);
    }
    return filter(dom.nodeName, attrs);
  }

  /**
   * Applies a filter on a type.
   *
   * @param {Y} y The Yjs instance.
   * @param {DomBinding} binding The DOM binding instance that has the dom filter.
   * @param {YXmlElement | YXmlFragment } type The type to apply the filter to.
   *
   * @private
   */
  function applyFilterOnType(y, binding, type) {
    if (isParentOf(binding.type, type)) {
      var nodeName = type.nodeName;
      var attributes = new Map();
      if (type.getAttributes !== undefined) {
        var attrs = type.getAttributes();
        for (var key in attrs) {
          attributes.set(key, attrs[key]);
        }
      }
      var filteredAttributes = binding.filter(nodeName, new Map(attributes));
      if (filteredAttributes === null) {
        type._delete(y);
      } else {
        // iterate original attributes
        attributes.forEach(function (value, key) {
          // delete all attributes that are not in filteredAttributes
          if (filteredAttributes.has(key) === false) {
            type.removeAttribute(key);
          }
        });
      }
    }
  }

  /**
   * Creates a Yjs type (YXml) based on the contents of a DOM Element.
   *
   * @param {Element|TextNode} element The DOM Element
   * @param {?Document} _document Optional. Provide the global document object
   * @param {Hooks} [hooks = {}] Optional. Set of Yjs Hooks
   * @param {Filter} [filter=defaultFilter] Optional. Dom element filter
   * @param {?DomBinding} binding Warning: This property is for internal use only!
   * @return {YXmlElement | YXmlText}
   */
  function domToType(element) {
    var _document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

    var hooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var filter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultFilter;
    var binding = arguments[4];

    var type = void 0;
    switch (element.nodeType) {
      case _document.ELEMENT_NODE:
        var hookName = null;
        var hook = void 0;
        // configure `hookName !== undefined` if element is a hook.
        if (element.hasAttribute('data-yjs-hook')) {
          hookName = element.getAttribute('data-yjs-hook');
          hook = hooks[hookName];
          if (hook === undefined) {
            console.error('Unknown hook "' + hookName + '". Deleting yjsHook dataset property.');
            delete element.removeAttribute('data-yjs-hook');
            hookName = null;
          }
        }
        if (hookName === null) {
          // Not a hook
          var attrs = filterDomAttributes(element, filter);
          if (attrs === null) {
            type = false;
          } else {
            type = new YXmlElement(element.nodeName);
            attrs.forEach(function (val, key) {
              type.setAttribute(key, val);
            });
            type.insert(0, domsToTypes(element.childNodes, document, hooks, filter, binding));
          }
        } else {
          // Is a hook
          type = new YXmlHook(hookName);
          hook.fillType(element, type);
        }
        break;
      case _document.TEXT_NODE:
        type = new YXmlText();
        type.insert(0, element.nodeValue);
        break;
      default:
        throw new Error('Can\'t transform this node type to a YXml type!');
    }
    createAssociation(binding, element, type);
    return type;
  }

  /**
   * Iterates items until an undeleted item is found.
   *
   * @private
   */
  function iterateUntilUndeleted(item) {
    while (item !== null && item._deleted) {
      item = item._right;
    }
    return item;
  }

  /**
   * Removes an association (the information that a DOM element belongs to a
   * type).
   *
   * @param {DomBinding} domBinding The binding object
   * @param {Element} dom The dom that is to be associated with type
   * @param {YXmlElement|YXmlHook} type The type that is to be associated with dom
   *
   */
  function removeAssociation(domBinding, dom, type) {
    domBinding.domToType.delete(dom);
    domBinding.typeToDom.delete(type);
  }

  /**
   * Creates an association (the information that a DOM element belongs to a
   * type).
   *
   * @param {DomBinding} domBinding The binding object
   * @param {Element} dom The dom that is to be associated with type
   * @param {YXmlElement|YXmlHook} type The type that is to be associated with dom
   *
   */
  function createAssociation(domBinding, dom, type) {
    if (domBinding !== undefined) {
      domBinding.domToType.set(dom, type);
      domBinding.typeToDom.set(type, dom);
    }
  }

  /**
   * If oldDom is associated with a type, associate newDom with the type and
   * forget about oldDom. If oldDom is not associated with any type, nothing happens.
   *
   * @param {DomBinding} domBinding The binding object
   * @param {Element} oldDom The existing dom
   * @param {Element} newDom The new dom object
   */
  function switchAssociation(domBinding, oldDom, newDom) {
    if (domBinding !== undefined) {
      var type = domBinding.domToType.get(oldDom);
      if (type !== undefined) {
        removeAssociation(domBinding, oldDom, type);
        createAssociation(domBinding, newDom, type);
      }
    }
  }

  /**
   * Insert Dom Elements after one of the children of this YXmlFragment.
   * The Dom elements will be bound to a new YXmlElement and inserted at the
   * specified position.
   *
   * @param {YXmlElement} type The type in which to insert DOM elements.
   * @param {YXmlElement|null} prev The reference node. New YxmlElements are
   *                           inserted after this node. Set null to insert at
   *                           the beginning.
   * @param {Array<Element>} doms The Dom elements to insert.
   * @param {?Document} _document Optional. Provide the global document object.
   * @param {DomBinding} binding The dom binding
   * @return {Array<YXmlElement>} The YxmlElements that are inserted.
   *
   * @private
   */
  function insertDomElementsAfter(type, prev, doms, _document, binding) {
    var types = domsToTypes(doms, _document, binding.opts.hooks, binding.filter, binding);
    return type.insertAfter(prev, types);
  }

  function domsToTypes(doms, _document, hooks, filter, binding) {
    var types = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = doms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var dom = _step.value;

        var t = domToType(dom, _document, hooks, filter, binding);
        if (t !== false) {
          types.push(t);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return types;
  }

  /**
   * @private
   */
  function insertNodeHelper(yxml, prevExpectedNode, child, _document, binding) {
    var insertedNodes = insertDomElementsAfter(yxml, prevExpectedNode, [child], _document, binding);
    if (insertedNodes.length > 0) {
      return insertedNodes[0];
    } else {
      return prevExpectedNode;
    }
  }

  /**
   * Remove children until `elem` is found.
   *
   * @param {Element} parent The parent of `elem` and `currentChild`.
   * @param {Element} currentChild Start removing elements with `currentChild`. If
   *                               `currentChild` is `elem` it won't be removed.
   * @param {Element|null} elem The elemnt to look for.
   *
   * @private
   */
  function removeDomChildrenUntilElementFound(parent, currentChild, elem) {
    while (currentChild !== elem) {
      var del = currentChild;
      currentChild = currentChild.nextSibling;
      parent.removeChild(del);
    }
  }

  /**
   * Represents text in a Dom Element. In the future this type will also handle
   * simple formatting information like bold and italic.
   *
   * @param {String} arg1 Initial value.
   */

  var YXmlText = function (_YText) {
    inherits(YXmlText, _YText);

    function YXmlText() {
      classCallCheck(this, YXmlText);
      return possibleConstructorReturn(this, (YXmlText.__proto__ || Object.getPrototypeOf(YXmlText)).apply(this, arguments));
    }

    createClass(YXmlText, [{
      key: 'toDom',

      /**
       * Creates a Dom Element that mirrors this YXmlText.
       *
       * @param {Document} [_document=document] The document object (you must define
       *                                        this when calling this method in
       *                                        nodejs)
       * @param {Object<key:hookDefinition>} [hooks] Optional property to customize how hooks
       *                                             are presented in the DOM
       * @param {DomBinding} [binding] You should not set this property. This is
       *                               used if DomBinding wants to create a
       *                               association to the created DOM type.
       * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
       *
       * @public
       */
      value: function toDom() {
        var _document = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
        var binding = arguments[2];

        var dom = _document.createTextNode(this.toString());
        createAssociation(binding, dom, this);
        return dom;
      }

      /**
       * Mark this Item as deleted.
       *
       * @param {Y} y The Yjs instance
       * @param {boolean} createDelete Whether to propagate a message that this
       *                               Type was deleted.
       * @param {boolean} [gcChildren=y._hasUndoManager===false] Whether to garbage
       *                                         collect the children of this type.
       *
       * @private
       */

    }, {
      key: '_delete',
      value: function _delete(y, createDelete, gcChildren) {
        get(YXmlText.prototype.__proto__ || Object.getPrototypeOf(YXmlText.prototype), '_delete', this).call(this, y, createDelete, gcChildren);
      }
    }]);
    return YXmlText;
  }(YText);

  var structs = new Map();
  var references = new Map();

  /**
   * Register a new Yjs types. The same type must be defined with the same
   * reference on all clients!
   *
   * @param {Number} reference
   * @param {class} structConstructor
   *
   * @public
   */
  function registerStruct(reference, structConstructor) {
    structs.set(reference, structConstructor);
    references.set(structConstructor, reference);
  }

  /**
   * @private
   */
  function getStruct(reference) {
    return structs.get(reference);
  }

  /**
   * @private
   */
  function getStructReference(typeConstructor) {
    return references.get(typeConstructor);
  }

  // TODO: reorder (Item* should have low numbers)
  registerStruct(0, ItemJSON);
  registerStruct(1, ItemString);
  registerStruct(10, ItemFormat);
  registerStruct(11, ItemEmbed);
  registerStruct(2, Delete);

  registerStruct(3, YArray);
  registerStruct(4, YMap);
  registerStruct(5, YText);
  registerStruct(6, YXmlFragment);
  registerStruct(7, YXmlElement);
  registerStruct(8, YXmlText);
  registerStruct(9, YXmlHook);

  registerStruct(12, GC);

  var RootFakeUserID = 0xFFFFFF;

  var RootID = function () {
    function RootID(name, typeConstructor) {
      classCallCheck(this, RootID);

      this.user = RootFakeUserID;
      this.name = name;
      this.type = getStructReference(typeConstructor);
    }

    createClass(RootID, [{
      key: 'equals',
      value: function equals(id) {
        return id !== null && id.user === this.user && id.name === this.name && id.type === this.type;
      }
    }, {
      key: 'lessThan',
      value: function lessThan(id) {
        if (id.constructor === RootID) {
          return this.user < id.user || this.user === id.user && (this.name < id.name || this.name === id.name && this.type < id.type);
        } else {
          return true;
        }
      }
    }]);
    return RootID;
  }();

  var OperationStore = function (_Tree) {
    inherits(OperationStore, _Tree);

    function OperationStore(y) {
      classCallCheck(this, OperationStore);

      var _this = possibleConstructorReturn(this, (OperationStore.__proto__ || Object.getPrototypeOf(OperationStore)).call(this));

      _this.y = y;
      return _this;
    }

    createClass(OperationStore, [{
      key: 'logTable',
      value: function logTable() {
        var items = [];
        this.iterate(null, null, function (item) {
          if (item.constructor === GC) {
            items.push({
              id: logID(item),
              content: item._length,
              deleted: 'GC'
            });
          } else {
            items.push({
              id: logID(item),
              origin: logID(item._origin === null ? null : item._origin._lastId),
              left: logID(item._left === null ? null : item._left._lastId),
              right: logID(item._right),
              right_origin: logID(item._right_origin),
              parent: logID(item._parent),
              parentSub: item._parentSub,
              deleted: item._deleted,
              content: JSON.stringify(item._content)
            });
          }
        });
        console.table(items);
      }
    }, {
      key: 'get',
      value: function get$$1(id) {
        var struct = this.find(id);
        if (struct === null && id instanceof RootID) {
          var Constr = getStruct(id.type);
          var y = this.y;
          struct = new Constr();
          struct._id = id;
          struct._parent = y;
          y.transact(function () {
            struct._integrate(y);
          });
          this.put(struct);
        }
        return struct;
      }
      // Use getItem for structs with _length > 1

    }, {
      key: 'getItem',
      value: function getItem(id) {
        var item = this.findWithUpperBound(id);
        if (item === null) {
          return null;
        }
        var itemID = item._id;
        if (id.user === itemID.user && id.clock < itemID.clock + item._length) {
          return item;
        } else {
          return null;
        }
      }
      // Return an insertion such that id is the first element of content
      // This function manipulates an item, if necessary

    }, {
      key: 'getItemCleanStart',
      value: function getItemCleanStart(id) {
        var ins = this.getItem(id);
        if (ins === null || ins._length === 1) {
          return ins;
        }
        var insID = ins._id;
        if (insID.clock === id.clock) {
          return ins;
        } else {
          return ins._splitAt(this.y, id.clock - insID.clock);
        }
      }
      // Return an insertion such that id is the last element of content
      // This function manipulates an operation, if necessary

    }, {
      key: 'getItemCleanEnd',
      value: function getItemCleanEnd(id) {
        var ins = this.getItem(id);
        if (ins === null || ins._length === 1) {
          return ins;
        }
        var insID = ins._id;
        if (insID.clock + ins._length - 1 === id.clock) {
          return ins;
        } else {
          ins._splitAt(this.y, id.clock - insID.clock + 1);
          return ins;
        }
      }
    }]);
    return OperationStore;
  }(Tree);

  var StateStore = function () {
    function StateStore(y) {
      classCallCheck(this, StateStore);

      this.y = y;
      this.state = new Map();
    }

    createClass(StateStore, [{
      key: 'logTable',
      value: function logTable() {
        var entries = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.state[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = slicedToArray(_step.value, 2),
                user = _step$value[0],
                state = _step$value[1];

            entries.push({
              user: user, state: state
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        console.table(entries);
      }
    }, {
      key: 'getNextID',
      value: function getNextID(len) {
        var user = this.y.userID;
        var state = this.getState(user);
        this.setState(user, state + len);
        return new ID(user, state);
      }
    }, {
      key: 'updateRemoteState',
      value: function updateRemoteState(struct) {
        var user = struct._id.user;
        var userState = this.state.get(user);
        while (struct !== null && struct._id.clock === userState) {
          userState += struct._length;
          struct = this.y.os.get(new ID(user, userState));
        }
        this.state.set(user, userState);
      }
    }, {
      key: 'getState',
      value: function getState(user) {
        var state = this.state.get(user);
        if (state == null) {
          return 0;
        }
        return state;
      }
    }, {
      key: 'setState',
      value: function setState(user, state) {
        // TODO: modify missingi structs here
        var beforeState = this.y._transaction.beforeState;
        if (!beforeState.has(user)) {
          beforeState.set(user, this.getState(user));
        }
        this.state.set(user, state);
      }
    }]);
    return StateStore;
  }();

  /* global crypto */

  function generateRandomUint32() {
    if (typeof crypto !== 'undefined' && crypto.getRandomValue != null) {
      // browser
      var arr = new Uint32Array(1);
      crypto.getRandomValues(arr);
      return arr[0];
    } else if (typeof crypto !== 'undefined' && crypto.randomBytes != null) {
      // node
      var buf = crypto.randomBytes(4);
      return new Uint32Array(buf.buffer)[0];
    } else {
      return Math.ceil(Math.random() * 0xFFFFFFFF);
    }
  }

  /**
   * Handles named events.
   */
  var NamedEventHandler = function () {
    function NamedEventHandler() {
      classCallCheck(this, NamedEventHandler);

      this._eventListener = new Map();
      this._stateListener = new Map();
    }

    /**
     * @private
     * Returns all listeners that listen to a specified name.
     *
     * @param {String} name The query event name.
     */


    createClass(NamedEventHandler, [{
      key: '_getListener',
      value: function _getListener(name) {
        var listeners = this._eventListener.get(name);
        if (listeners === undefined) {
          listeners = {
            once: new Set(),
            on: new Set()
          };
          this._eventListener.set(name, listeners);
        }
        return listeners;
      }

      /**
       * Adds a named event listener. The listener is removed after it has been
       * called once.
       *
       * @param {String} name The event name to listen to.
       * @param {Function} f The function that is executed when the event is fired.
       */

    }, {
      key: 'once',
      value: function once(name, f) {
        var listeners = this._getListener(name);
        listeners.once.add(f);
      }

      /**
       * Adds a named event listener.
       *
       * @param {String} name The event name to listen to.
       * @param {Function} f The function that is executed when the event is fired.
       */

    }, {
      key: 'on',
      value: function on(name, f) {
        var listeners = this._getListener(name);
        listeners.on.add(f);
      }

      /**
       * @private
       * Init the saved state for an event name.
       */

    }, {
      key: '_initStateListener',
      value: function _initStateListener(name) {
        var state = this._stateListener.get(name);
        if (state === undefined) {
          state = {};
          state.promise = new Promise(function (resolve) {
            state.resolve = resolve;
          });
          this._stateListener.set(name, state);
        }
        return state;
      }

      /**
       * Returns a Promise that is resolved when the event name is called.
       * The Promise is immediately resolved when the event name was called in the
       * past.
       */

    }, {
      key: 'when',
      value: function when(name) {
        return this._initStateListener(name).promise;
      }

      /**
       * Remove an event listener that was registered with either
       * {@link EventHandler#on} or {@link EventHandler#once}.
       */

    }, {
      key: 'off',
      value: function off(name, f) {
        if (name == null || f == null) {
          throw new Error('You must specify event name and function!');
        }
        var listener = this._eventListener.get(name);
        if (listener !== undefined) {
          listener.on.delete(f);
          listener.once.delete(f);
        }
      }

      /**
       * Emit a named event. All registered event listeners that listen to the
       * specified name will receive the event.
       *
       * @param {String} name The event name.
       * @param {Array} args The arguments that are applied to the event listener.
       */

    }, {
      key: 'emit',
      value: function emit(name) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        this._initStateListener(name).resolve();
        var listener = this._eventListener.get(name);
        if (listener !== undefined) {
          listener.on.forEach(function (f) {
            return f.apply(null, args);
          });
          listener.once.forEach(function (f) {
            return f.apply(null, args);
          });
          listener.once = new Set();
        } else if (name === 'error') {
          console.error(args[0]);
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this._eventListener = null;
      }
    }]);
    return NamedEventHandler;
  }();

  // TODO: Implement function to describe ranges

  /**
   * A relative position that is based on the Yjs model. In contrast to an
   * absolute position (position by index), the relative position can be
   * recomputed when remote changes are received. For example:
   *
   * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the cursor position.
   *
   * A relative cursor position can be obtained with the function
   * {@link getRelativePosition} and it can be transformed to an absolute position
   * with {@link fromRelativePosition}.
   *
   * Pro tip: Use this to implement shared cursor locations in YText or YXml!
   * The relative position is {@link encodable}, so you can send it to other
   * clients.
   *
   * @example
   * // Current cursor position is at position 10
   * let relativePosition = getRelativePosition(yText, 10)
   * // modify yText
   * yText.insert(0, 'abc')
   * yText.delete(3, 10)
   * // Compute the cursor position
   * let absolutePosition = fromRelativePosition(y, relativePosition)
   * absolutePosition.type // => yText
   * console.log('cursor location is ' + absolutePosition.offset) // => cursor location is 3
   *
   * @typedef {encodable} RelativePosition
   */

  /**
   * Create a relativePosition based on a absolute position.
   *
   * @param {YType} type The base type (e.g. YText or YArray).
   * @param {Integer} offset The absolute position.
   */
  function getRelativePosition(type, offset) {
    // TODO: rename to createRelativePosition
    var t = type._start;
    while (t !== null) {
      if (t._deleted === false) {
        if (t._length > offset) {
          return [t._id.user, t._id.clock + offset];
        }
        offset -= t._length;
      }
      t = t._right;
    }
    return ['endof', type._id.user, type._id.clock || null, type._id.name || null, type._id.type || null];
  }

  /**
   * @typedef {Object} AbsolutePosition The result of {@link fromRelativePosition}
   * @property {YType} type The type on which to apply the absolute position.
   * @property {Integer} offset The absolute offset.r
   */

  /**
   * Transforms a relative position back to a relative position.
   *
   * @param {Y} y The Yjs instance in which to query for the absolute position.
   * @param {RelativePosition} rpos The relative position.
   * @return {AbsolutePosition} The absolute position in the Yjs model
   *                            (type + offset).
   */
  function fromRelativePosition(y, rpos) {
    if (rpos[0] === 'endof') {
      var id = void 0;
      if (rpos[3] === null) {
        id = new ID(rpos[1], rpos[2]);
      } else {
        id = new RootID(rpos[3], rpos[4]);
      }
      var type = y.os.get(id);
      while (type._redone !== null) {
        type = type._redone;
      }
      if (type === null || type.constructor === GC) {
        return null;
      }
      return {
        type: type,
        offset: type.length
      };
    } else {
      var offset = 0;
      var struct = y.os.findNodeWithUpperBound(new ID(rpos[0], rpos[1])).val;
      var diff = rpos[1] - struct._id.clock;
      while (struct._redone !== null) {
        struct = struct._redone;
      }
      var parent = struct._parent;
      if (struct.constructor === GC || parent._deleted) {
        return null;
      }
      if (!struct._deleted) {
        offset = diff;
      }
      struct = struct._left;
      while (struct !== null) {
        if (!struct._deleted) {
          offset += struct._length;
        }
        struct = struct._left;
      }
      return {
        type: parent,
        offset: offset
      };
    }
  }

  // TODO: rename mutex

  /**
   * Creates a mutual exclude function with the following property:
   *
   * @example
   * const mutualExclude = createMutualExclude()
   * mutualExclude(function () {
   *   // This function is immediately executed
   *   mutualExclude(function () {
   *     // This function is never executed, as it is called with the same
   *     // mutualExclude
   *   })
   * })
   *
   * @return {Function} A mutual exclude function
   * @public
   */
  function createMutualExclude() {
    var token = true;
    return function mutualExclude(f) {
      if (token) {
        token = false;
        try {
          f();
        } catch (e) {
          console.error(e);
        }
        token = true;
      }
    };
  }

  /**
   * Abstract class for bindings.
   *
   * A binding handles data binding from a Yjs type to a data object. For example,
   * you can bind a Quill editor instance to a YText instance with the `QuillBinding` class.
   *
   * It is expected that a concrete implementation accepts two parameters
   * (type and binding target).
   *
   * @example
   *   const quill = new Quill(document.createElement('div'))
   *   const type = y.define('quill', Y.Text)
   *   const binding = new Y.QuillBinding(quill, type)
   *
   */

  var Binding = function () {
    /**
     * @param {YType} type Yjs type.
     * @param {any} target Binding Target.
     */
    function Binding(type, target) {
      classCallCheck(this, Binding);

      /**
       * The Yjs type that is bound to `target`
       * @type {YType}
       */
      this.type = type;
      /**
       * The target that `type` is bound to.
       * @type {*}
       */
      this.target = target;
      /**
       * @private
       */
      this._mutualExclude = createMutualExclude();
    }
    /**
     * Remove all data observers (both from the type and the target).
     */


    createClass(Binding, [{
      key: 'destroy',
      value: function destroy() {
        this.type = null;
        this.target = null;
      }
    }]);
    return Binding;
  }();

  /* globals getSelection */

  var relativeSelection = null;

  function _getCurrentRelativeSelection(domBinding) {
    var _getSelection = getSelection(),
        baseNode = _getSelection.baseNode,
        baseOffset = _getSelection.baseOffset,
        extentNode = _getSelection.extentNode,
        extentOffset = _getSelection.extentOffset;

    var baseNodeType = domBinding.domToType.get(baseNode);
    var extentNodeType = domBinding.domToType.get(extentNode);
    if (baseNodeType !== undefined && extentNodeType !== undefined) {
      return {
        from: getRelativePosition(baseNodeType, baseOffset),
        to: getRelativePosition(extentNodeType, extentOffset)
      };
    }
    return null;
  }

  var getCurrentRelativeSelection = typeof getSelection !== 'undefined' ? _getCurrentRelativeSelection : function () {
    return null;
  };

  function beforeTransactionSelectionFixer(domBinding, remote) {
    if (remote) {
      relativeSelection = getCurrentRelativeSelection(domBinding);
    }
  }

  /**
   * @private
   */
  function afterTransactionSelectionFixer(domBinding, remote) {
    if (relativeSelection !== null && remote) {
      domBinding.restoreSelection(relativeSelection);
    }
  }

  /* global getSelection */

  function findScrollReference(scrollingElement) {
    if (scrollingElement !== null) {
      var anchor = getSelection().anchorNode;
      if (anchor == null) {
        var children = scrollingElement.children; // only iterate through non-text nodes
        for (var i = 0; i < children.length; i++) {
          var elem = children[i];
          var rect = elem.getBoundingClientRect();
          if (rect.top >= 0) {
            return { elem: elem, top: rect.top };
          }
        }
      } else {
        if (anchor.nodeType === document.TEXT_NODE) {
          anchor = anchor.parentElement;
        }
        var top = anchor.getBoundingClientRect().top;
        return { elem: anchor, top: top };
      }
    }
    return null;
  }

  function fixScroll(scrollingElement, ref) {
    if (ref !== null) {
      var elem = ref.elem,
          top = ref.top;

      var currentTop = elem.getBoundingClientRect().top;
      var newScroll = scrollingElement.scrollTop + currentTop - top;
      if (newScroll >= 0) {
        scrollingElement.scrollTop = newScroll;
      }
    }
  }

  /**
   * @private
   */
  function typeObserver(events) {
    var _this = this;

    this._mutualExclude(function () {
      var scrollRef = findScrollReference(_this.scrollingElement);
      events.forEach(function (event) {
        var yxml = event.target;
        var dom = _this.typeToDom.get(yxml);
        if (dom !== undefined && dom !== false) {
          if (yxml.constructor === YXmlText) {
            dom.nodeValue = yxml.toString();
          } else if (event.attributesChanged !== undefined) {
            // update attributes
            event.attributesChanged.forEach(function (attributeName) {
              var value = yxml.getAttribute(attributeName);
              if (value === undefined) {
                dom.removeAttribute(attributeName);
              } else {
                dom.setAttribute(attributeName, value);
              }
            });
            /*
             * TODO: instead of hard-checking the types, it would be best to
             *       specify the type's features. E.g.
             *         - _yxmlHasAttributes
             *         - _yxmlHasChildren
             *       Furthermore, the features shouldn't be encoded in the types,
             *       only in the attributes (above)
             */
            if (event.childListChanged && yxml.constructor !== YXmlHook) {
              var currentChild = dom.firstChild;
              yxml.forEach(function (childType) {
                var childNode = _this.typeToDom.get(childType);
                switch (childNode) {
                  case undefined:
                    // Does not exist. Create it.
                    var node = childType.toDom(_this.opts.document, _this.opts.hooks, _this);
                    dom.insertBefore(node, currentChild);
                    break;
                  case false:
                    // nop
                    break;
                  default:
                    // Is already attached to the dom.
                    // Find it and remove all dom nodes in-between.
                    removeDomChildrenUntilElementFound(dom, currentChild, childNode);
                    currentChild = childNode.nextSibling;
                    break;
                }
              });
              removeDomChildrenUntilElementFound(dom, currentChild, null);
            }
          }
        }
      });
      fixScroll(_this.scrollingElement, scrollRef);
    });
  }

  /**
   * A SimpleDiff describes a change on a String.
   *
   * @example
   * console.log(a) // the old value
   * console.log(b) // the updated value
   * // Apply changes of diff (pseudocode)
   * a.remove(diff.pos, diff.remove) // Remove `diff.remove` characters
   * a.insert(diff.pos, diff.insert) // Insert `diff.insert`
   * a === b // values match
   *
   * @typedef {Object} SimpleDiff
   * @property {Number} pos The index where changes were applied
   * @property {Number} delete The number of characters to delete starting
   *                                  at `index`.
   * @property {String} insert The new text to insert at `index` after applying
   *                           `delete`
   */

  /**
   * Create a diff between two strings. This diff implementation is highly
   * efficient, but not very sophisticated.
   *
   * @public
   * @param {String} a The old version of the string
   * @param {String} b The updated version of the string
   * @return {SimpleDiff} The diff description.
   */
  function simpleDiff(a, b) {
    var left = 0; // number of same characters counting from left
    var right = 0; // number of same characters counting from right
    while (left < a.length && left < b.length && a[left] === b[left]) {
      left++;
    }
    if (left !== a.length || left !== b.length) {
      // Only check right if a !== b
      while (right + left < a.length && right + left < b.length && a[a.length - right - 1] === b[b.length - right - 1]) {
        right++;
      }
    }
    return {
      pos: left, // TODO: rename to index (also in type above)
      remove: a.length - left - right,
      insert: b.slice(left, b.length - right)
    };
  }

  /**
   * 1. Check if any of the nodes was deleted
   * 2. Iterate over the children.
   *    2.1 If a node exists that is not yet bound to a type, insert a new node
   *    2.2 If _contents.length < dom.childNodes.length, fill the
   *        rest of _content with childNodes
   *    2.3 If a node was moved, delete it and
   *       recreate a new yxml element that is bound to that node.
   *       You can detect that a node was moved because expectedId
   *       !== actualId in the list
   * @private
   */
  function applyChangesFromDom(binding, dom, yxml, _document) {
    if (yxml == null || yxml === false || yxml.constructor === YXmlHook) {
      return;
    }
    var y = yxml._y;
    var knownChildren = new Set();
    for (var i = dom.childNodes.length - 1; i >= 0; i--) {
      var type = binding.domToType.get(dom.childNodes[i]);
      if (type !== undefined && type !== false) {
        knownChildren.add(type);
      }
    }
    // 1. Check if any of the nodes was deleted
    yxml.forEach(function (childType) {
      if (knownChildren.has(childType) === false) {
        childType._delete(y);
        removeAssociation(binding, binding.typeToDom.get(childType), childType);
      }
    });
    // 2. iterate
    var childNodes = dom.childNodes;
    var len = childNodes.length;
    var prevExpectedType = null;
    var expectedType = iterateUntilUndeleted(yxml._start);
    for (var domCnt = 0; domCnt < len; domCnt++) {
      var childNode = childNodes[domCnt];
      var childType = binding.domToType.get(childNode);
      if (childType !== undefined) {
        if (childType === false) {
          // should be ignored or is going to be deleted
          continue;
        }
        if (expectedType !== null) {
          if (expectedType !== childType) {
            // 2.3 Not expected node
            if (childType._parent !== yxml) {
              // child was moved from another parent
              // childType is going to be deleted by its previous parent
              removeAssociation(binding, childNode, childType);
            } else {
              // child was moved to a different position.
              removeAssociation(binding, childNode, childType);
              childType._delete(y);
            }
            prevExpectedType = insertNodeHelper(yxml, prevExpectedType, childNode, _document, binding);
          } else {
            // Found expected node. Continue.
            prevExpectedType = expectedType;
            expectedType = iterateUntilUndeleted(expectedType._right);
          }
        } else {
          // 2.2 Fill _content with child nodes
          prevExpectedType = insertNodeHelper(yxml, prevExpectedType, childNode, _document, binding);
        }
      } else {
        // 2.1 A new node was found
        prevExpectedType = insertNodeHelper(yxml, prevExpectedType, childNode, _document, binding);
      }
    }
  }

  /**
   * @private
   */
  function domObserver(mutations, _document) {
    var _this = this;

    this._mutualExclude(function () {
      _this.type._y.transact(function () {
        var diffChildren = new Set();
        mutations.forEach(function (mutation) {
          var dom = mutation.target;
          var yxml = _this.domToType.get(dom);
          if (yxml === undefined) {
            // In case yxml is undefined, we double check if we forgot to bind the dom
            var parent = dom;
            var yParent = void 0;
            do {
              parent = parent.parentElement;
              yParent = _this.domToType.get(parent);
            } while (yParent === undefined && parent !== null);
            if (yParent !== false && yParent !== undefined && yParent.constructor !== YXmlHook) {
              diffChildren.add(parent);
            }
            return;
          } else if (yxml === false || yxml.constructor === YXmlHook) {
            // dom element is filtered / a dom hook
            return;
          }
          switch (mutation.type) {
            case 'characterData':
              var change = simpleDiff(yxml.toString(), dom.nodeValue);
              yxml.delete(change.pos, change.remove);
              yxml.insert(change.pos, change.insert);
              break;
            case 'attributes':
              if (yxml.constructor === YXmlFragment) {
                break;
              }
              var name = mutation.attributeName;
              var val = dom.getAttribute(name);
              // check if filter accepts attribute
              var attributes = new Map();
              attributes.set(name, val);
              if (yxml.constructor !== YXmlFragment && _this.filter(dom.nodeName, attributes).size > 0) {
                if (yxml.getAttribute(name) !== val) {
                  if (val == null) {
                    yxml.removeAttribute(name);
                  } else {
                    yxml.setAttribute(name, val);
                  }
                }
              }
              break;
            case 'childList':
              diffChildren.add(mutation.target);
              break;
          }
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = diffChildren[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var dom = _step.value;

            var yxml = _this.domToType.get(dom);
            applyChangesFromDom(_this, dom, yxml, _document);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      });
    });
  }

  /* global MutationObserver, getSelection */

  /**
   * A binding that binds the children of a YXmlFragment to a DOM element.
   *
   * This binding is automatically destroyed when its parent is deleted.
   *
   * @example
   * const div = document.createElement('div')
   * const type = y.define('xml', Y.XmlFragment)
   * const binding = new Y.QuillBinding(type, div)
   *
   */

  var DomBinding = function (_Binding) {
    inherits(DomBinding, _Binding);

    /**
     * @param {YXmlFragment} type The bind source. This is the ultimate source of
     *                            truth.
     * @param {Element} target The bind target. Mirrors the target.
     * @param {Object} [opts] Optional configurations
      * @param {FilterFunction} [opts.filter=defaultFilter] The filter function to use.
     */
    function DomBinding(type, target) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, DomBinding);

      var _this = possibleConstructorReturn(this, (DomBinding.__proto__ || Object.getPrototypeOf(DomBinding)).call(this, type, target));
      // Binding handles textType as this.type and domTextarea as this.target


      _this.opts = opts;
      opts.document = opts.document || document;
      opts.hooks = opts.hooks || {};
      _this.scrollingElement = opts.scrollingElement || null;
      /**
       * Maps each DOM element to the type that it is associated with.
       * @type {Map}
       */
      _this.domToType = new Map();
      /**
       * Maps each YXml type to the DOM element that it is associated with.
       * @type {Map}
       */
      _this.typeToDom = new Map();
      /**
       * Defines which DOM attributes and elements to filter out.
       * Also filters remote changes.
       * @type {FilterFunction}
       */
      _this.filter = opts.filter || defaultFilter;
      // set initial value
      target.innerHTML = '';
      type.forEach(function (child) {
        target.insertBefore(child.toDom(opts.document, opts.hooks, _this), null);
      });
      _this._typeObserver = typeObserver.bind(_this);
      _this._domObserver = function (mutations) {
        domObserver.call(_this, mutations, opts.document);
      };
      type.observeDeep(_this._typeObserver);
      _this._mutationObserver = new MutationObserver(_this._domObserver);
      _this._mutationObserver.observe(target, {
        childList: true,
        attributes: true,
        characterData: true,
        subtree: true
      });
      _this._currentSel = null;
      document.addEventListener('selectionchange', function () {
        _this._currentSel = getCurrentRelativeSelection(_this);
      });
      var y = type._y;
      _this.y = y;
      // Force flush dom changes before Type changes are applied (they might
      // modify the dom)
      _this._beforeTransactionHandler = function (y, transaction, remote) {
        _this._domObserver(_this._mutationObserver.takeRecords());
        _this._mutualExclude(function () {
          beforeTransactionSelectionFixer(_this, remote);
        });
      };
      y.on('beforeTransaction', _this._beforeTransactionHandler);
      _this._afterTransactionHandler = function (y, transaction, remote) {
        _this._mutualExclude(function () {
          afterTransactionSelectionFixer(_this, remote);
        });
        // remove associations
        // TODO: this could be done more efficiently
        // e.g. Always delete using the following approach, or removeAssociation
        // in dom/type-observer..
        transaction.deletedStructs.forEach(function (type) {
          var dom = _this.typeToDom.get(type);
          if (dom !== undefined) {
            removeAssociation(_this, dom, type);
          }
        });
      };
      y.on('afterTransaction', _this._afterTransactionHandler);
      // Before calling observers, apply dom filter to all changed and new types.
      _this._beforeObserverCallsHandler = function (y, transaction) {
        // Apply dom filter to new and changed types
        transaction.changedTypes.forEach(function (subs, type) {
          // Only check attributes. New types are filtered below.
          if (subs.size > 1 || subs.size === 1 && subs.has(null) === false) {
            applyFilterOnType(y, _this, type);
          }
        });
        transaction.newTypes.forEach(function (type) {
          applyFilterOnType(y, _this, type);
        });
      };
      y.on('beforeObserverCalls', _this._beforeObserverCallsHandler);
      createAssociation(_this, target, type);
      return _this;
    }

    /**
     * NOTE: currently does not apply filter to existing elements!
     * @param {FilterFunction} filter The filter function to use from now on.
     */


    createClass(DomBinding, [{
      key: 'setFilter',
      value: function setFilter(filter) {
        this.filter = filter;
        // TODO: apply filter to all elements
      }
    }, {
      key: '_getUndoStackInfo',
      value: function _getUndoStackInfo() {
        return this.getSelection();
      }
    }, {
      key: '_restoreUndoStackInfo',
      value: function _restoreUndoStackInfo(info) {
        this.restoreSelection(info);
      }
    }, {
      key: 'getSelection',
      value: function getSelection() {
        return this._currentSel;
      }
    }, {
      key: 'restoreSelection',
      value: function restoreSelection(selection) {
        if (selection !== null) {
          var to = selection.to,
              from = selection.from;

          var shouldUpdate = false;
          /**
           * There is little information on the difference between anchor/focus and base/extent.
           * MDN doesn't even mention base/extent anymore.. though you still have to call
           * setBaseAndExtent to change the selection..
           * I can observe that base/extend refer to notes higher up in the xml hierachy.
           * Espesially for undo/redo this is preferred. If this becomes a problem in the future,
           * we should probably go back to anchor/focus.
           */
          var browserSelection = getSelection();
          var baseNode = browserSelection.baseNode,
              baseOffset = browserSelection.baseOffset,
              extentNode = browserSelection.extentNode,
              extentOffset = browserSelection.extentOffset;

          if (from !== null) {
            var sel = fromRelativePosition(this.y, from);
            if (sel !== null) {
              var node = this.typeToDom.get(sel.type);
              var offset = sel.offset;
              if (node !== baseNode || offset !== baseOffset) {
                baseNode = node;
                baseOffset = offset;
                shouldUpdate = true;
              }
            }
          }
          if (to !== null) {
            var _sel = fromRelativePosition(this.y, to);
            if (_sel !== null) {
              var _node = this.typeToDom.get(_sel.type);
              var _offset = _sel.offset;
              if (_node !== extentNode || _offset !== extentOffset) {
                extentNode = _node;
                extentOffset = _offset;
                shouldUpdate = true;
              }
            }
          }
          if (shouldUpdate) {
            browserSelection.setBaseAndExtent(baseNode, baseOffset, extentNode, extentOffset);
          }
        }
      }

      /**
       * Remove all properties that are handled by this class.
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this.domToType = null;
        this.typeToDom = null;
        this.type.unobserveDeep(this._typeObserver);
        this._mutationObserver.disconnect();
        var y = this.type._y;
        y.off('beforeTransaction', this._beforeTransactionHandler);
        y.off('beforeObserverCalls', this._beforeObserverCallsHandler);
        y.off('afterTransaction', this._afterTransactionHandler);
        get(DomBinding.prototype.__proto__ || Object.getPrototypeOf(DomBinding.prototype), 'destroy', this).call(this);
      }
    }]);
    return DomBinding;
  }(Binding);

  /**
   * Anything that can be encoded with `JSON.stringify` and can be decoded with
   * `JSON.parse`.
   *
   * The following property should hold:
   * `JSON.parse(JSON.stringify(key))===key`
   *
   * At the moment the only safe values are number and string.
   *
   * @typedef {(number|string)} encodable
   */

  /**
   * A Yjs instance handles the state of shared data.
   *
   * @param {string} room Users in the same room share the same content
   * @param {Object} opts Connector definition
   * @param {AbstractPersistence} persistence Persistence adapter instance
   */

  var Y = function (_NamedEventHandler) {
    inherits(Y, _NamedEventHandler);

    function Y(room, opts, persistence) {
      var conf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      classCallCheck(this, Y);

      var _this = possibleConstructorReturn(this, (Y.__proto__ || Object.getPrototypeOf(Y)).call(this));

      _this.gcEnabled = conf.gc || false;
      /**
       * The room name that this Yjs instance connects to.
       * @type {String}
       */
      _this.room = room;
      if (opts != null) {
        opts.connector.room = room;
      }
      _this._contentReady = false;
      _this._opts = opts;
      if (typeof opts.userID !== 'number') {
        _this.userID = generateRandomUint32();
      } else {
        _this.userID = opts.userID;
      }
      // TODO: This should be a Map so we can use encodables as keys
      _this.share = {};
      _this.ds = new DeleteStore(_this);
      _this.os = new OperationStore(_this);
      _this.ss = new StateStore(_this);
      _this._missingStructs = new Map();
      _this._readyToIntegrate = [];
      _this._transaction = null;
      /**
       * The {@link AbstractConnector}.that is used by this Yjs instance.
       * @type {AbstractConnector}
       */
      _this.connector = null;
      _this.connected = false;
      var initConnection = function initConnection() {
        if (opts != null) {
          _this.connector = new Y[opts.connector.name](_this, opts.connector);
          _this.connected = true;
          _this.emit('connectorReady');
        }
      };
      /**
       * The {@link AbstractPersistence} that is used by this Yjs instance.
       * @type {AbstractPersistence}
       */
      _this.persistence = null;
      if (persistence != null) {
        _this.persistence = persistence;
        persistence._init(_this).then(initConnection);
      } else {
        initConnection();
      }
      // for compatibility with isParentOf
      _this._parent = null;
      _this._hasUndoManager = false;
      return _this;
    }

    createClass(Y, [{
      key: '_setContentReady',
      value: function _setContentReady() {
        if (!this._contentReady) {
          this._contentReady = true;
          this.emit('content');
        }
      }
    }, {
      key: 'whenContentReady',
      value: function whenContentReady() {
        var _this2 = this;

        if (this._contentReady) {
          return Promise.resolve();
        } else {
          return new Promise(function (resolve) {
            _this2.once('content', resolve);
          });
        }
      }
    }, {
      key: '_beforeChange',
      value: function _beforeChange() {}
      /**
       * Changes that happen inside of a transaction are bundled. This means that
       * the observer fires _after_ the transaction is finished and that all changes
       * that happened inside of the transaction are sent as one message to the
       * other peers.
       *
       * @param {Function} f The function that should be executed as a transaction
       * @param {?Boolean} remote Optional. Whether this transaction is initiated by
       *                          a remote peer. This should not be set manually!
       *                          Defaults to false.
       */

    }, {
      key: 'transact',
      value: function transact(f) {
        var remote = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var initialCall = this._transaction === null;
        if (initialCall) {
          this._transaction = new Transaction(this);
          this.emit('beforeTransaction', this, this._transaction, remote);
        }
        try {
          f(this);
        } catch (e) {
          console.error(e);
        }
        if (initialCall) {
          this.emit('beforeObserverCalls', this, this._transaction, remote);
          var transaction = this._transaction;
          this._transaction = null;
          // emit change events on changed types
          transaction.changedTypes.forEach(function (subs, type) {
            if (!type._deleted) {
              type._callObserver(transaction, subs, remote);
            }
          });
          transaction.changedParentTypes.forEach(function (events, type) {
            if (!type._deleted) {
              events = events.filter(function (event) {
                return !event.target._deleted;
              });
              events.forEach(function (event) {
                event.currentTarget = type;
              });
              // we don't have to check for events.length
              // because there is no way events is empty..
              type._deepEventHandler.callEventListeners(transaction, events);
            }
          });
          // when all changes & events are processed, emit afterTransaction event
          this.emit('afterTransaction', this, transaction, remote);
        }
      }

      /**
       * @private
       * Fake _start for root properties (y.set('name', type))
       */

    }, {
      key: 'define',


      /**
       * Define a shared data type.
       *
       * Multiple calls of `y.define(name, TypeConstructor)` yield the same result
       * and do not overwrite each other. I.e.
       * `y.define(name, type) === y.define(name, type)`
       *
       * After this method is called, the type is also available on `y.share[name]`.
       *
       * *Best Practices:*
       * Either define all types right after the Yjs instance is created or always
       * use `y.define(..)` when accessing a type.
       *
       * @example
       *   // Option 1
       *   const y = new Y(..)
       *   y.define('myArray', YArray)
       *   y.define('myMap', YMap)
       *   // .. when accessing the type use y.share[name]
       *   y.share.myArray.insert(..)
       *   y.share.myMap.set(..)
       *
       *   // Option2
       *   const y = new Y(..)
       *   // .. when accessing the type use `y.define(..)`
       *   y.define('myArray', YArray).insert(..)
       *   y.define('myMap', YMap).set(..)
       *
       * @param {String} name
       * @param {YType Constructor} TypeConstructor The constructor of the type definition
       * @returns {YType} The created type
       */
      value: function define(name, TypeConstructor) {
        var id = new RootID(name, TypeConstructor);
        var type = this.os.get(id);
        if (this.share[name] === undefined) {
          this.share[name] = type;
        } else if (this.share[name] !== type) {
          throw new Error('Type is already defined with a different constructor');
        }
        return type;
      }

      /**
       * Get a defined type. The type must be defined locally. First define the
       * type with {@link define}.
       *
       * This returns the same value as `y.share[name]`
       *
       * @param {String} name The typename
       */

    }, {
      key: 'get',
      value: function get$$1(name) {
        return this.share[name];
      }

      /**
       * Disconnect this Yjs Instance from the network. The connector will
       * unsubscribe from the room and document updates are not shared anymore.
       */

    }, {
      key: 'disconnect',
      value: function disconnect() {
        if (this.connected) {
          this.connected = false;
          return this.connector.disconnect();
        } else {
          return Promise.resolve();
        }
      }

      /**
       * If disconnected, tell the connector to reconnect to the room.
       */

    }, {
      key: 'reconnect',
      value: function reconnect() {
        if (!this.connected) {
          this.connected = true;
          return this.connector.reconnect();
        } else {
          return Promise.resolve();
        }
      }

      /**
       * Disconnect from the room, and destroy all traces of this Yjs instance.
       * Persisted data will remain until removed by the persistence adapter.
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        get(Y.prototype.__proto__ || Object.getPrototypeOf(Y.prototype), 'destroy', this).call(this);
        this.share = null;
        if (this.connector != null) {
          if (this.connector.destroy != null) {
            this.connector.destroy();
          } else {
            this.connector.disconnect();
          }
        }
        if (this.persistence !== null) {
          this.persistence.deinit(this);
          this.persistence = null;
        }
        this.os = null;
        this.ds = null;
        this.ss = null;
      }
    }, {
      key: '_start',
      get: function get$$1() {
        return null;
      }

      /**
       * @private
       * Fake _start for root properties (y.set('name', type))
       */
      ,
      set: function set$$1(start) {
        return null;
      }
    }]);
    return Y;
  }(NamedEventHandler);


  Y.extend = function extendYjs() {
    for (var i = 0; i < arguments.length; i++) {
      var f = arguments[i];
      if (typeof f === 'function') {
        f(Y);
      } else {
        throw new Error('Expected a function!');
      }
    }
  };

  var ReverseOperation = function ReverseOperation(y, transaction, bindingInfos) {
    var _this = this;

    classCallCheck(this, ReverseOperation);

    this.created = new Date();
    var beforeState = transaction.beforeState;
    if (beforeState.has(y.userID)) {
      this.toState = new ID(y.userID, y.ss.getState(y.userID) - 1);
      this.fromState = new ID(y.userID, beforeState.get(y.userID));
    } else {
      this.toState = null;
      this.fromState = null;
    }
    this.deletedStructs = new Set();
    transaction.deletedStructs.forEach(function (struct) {
      _this.deletedStructs.add({
        from: struct._id,
        len: struct._length
      });
    });
    /**
     * Maps from binding to binding information (e.g. cursor information)
     */
    this.bindingInfos = bindingInfos;
  };

  function applyReverseOperation(y, scope, reverseBuffer) {
    var performedUndo = false;
    var undoOp = void 0;
    y.transact(function () {
      var _loop = function _loop() {
        undoOp = reverseBuffer.pop();
        // make sure that it is possible to iterate {from}-{to}
        if (undoOp.fromState !== null) {
          y.os.getItemCleanStart(undoOp.fromState);
          y.os.getItemCleanEnd(undoOp.toState);
          y.os.iterate(undoOp.fromState, undoOp.toState, function (op) {
            while (op._deleted && op._redone !== null) {
              op = op._redone;
            }
            if (op._deleted === false && isParentOf(scope, op)) {
              performedUndo = true;
              op._delete(y);
            }
          });
        }
        var redoitems = new Set();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = undoOp.deletedStructs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var del = _step.value;

            var fromState = del.from;
            var toState = new ID(fromState.user, fromState.clock + del.len - 1);
            y.os.getItemCleanStart(fromState);
            y.os.getItemCleanEnd(toState);
            y.os.iterate(fromState, toState, function (op) {
              if (isParentOf(scope, op) && op._parent !== y && (op._id.user !== y.userID || undoOp.fromState === null || op._id.clock < undoOp.fromState.clock || op._id.clock > undoOp.toState.clock)) {
                redoitems.add(op);
              }
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        redoitems.forEach(function (op) {
          var opUndone = op._redo(y, redoitems);
          performedUndo = performedUndo || opUndone;
        });
      };

      while (!performedUndo && reverseBuffer.length > 0) {
        _loop();
      }
    });
    if (performedUndo) {
      // should be performed after the undo transaction
      undoOp.bindingInfos.forEach(function (info, binding) {
        binding._restoreUndoStackInfo(info);
      });
    }
    return performedUndo;
  }

  /**
   * Saves a history of locally applied operations. The UndoManager handles the
   * undoing and redoing of locally created changes.
   */

  var UndoManager = function () {
    /**
     * @param {YType} scope The scope on which to listen for changes.
     * @param {Object} options Optionally provided configuration.
     */
    function UndoManager(scope) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      classCallCheck(this, UndoManager);

      this.options = options;
      this._bindings = new Set(options.bindings);
      options.captureTimeout = options.captureTimeout == null ? 500 : options.captureTimeout;
      this._undoBuffer = [];
      this._redoBuffer = [];
      this._scope = scope;
      this._undoing = false;
      this._redoing = false;
      this._lastTransactionWasUndo = false;
      var y = scope._y;
      this.y = y;
      y._hasUndoManager = true;
      var bindingInfos = void 0;
      y.on('beforeTransaction', function (y, transaction, remote) {
        if (!remote) {
          // Store binding information before transaction is executed
          // By restoring the binding information, we can make sure that the state
          // before the transaction can be recovered
          bindingInfos = new Map();
          _this2._bindings.forEach(function (binding) {
            bindingInfos.set(binding, binding._getUndoStackInfo());
          });
        }
      });
      y.on('afterTransaction', function (y, transaction, remote) {
        if (!remote && transaction.changedParentTypes.has(scope)) {
          var reverseOperation = new ReverseOperation(y, transaction, bindingInfos);
          if (!_this2._undoing) {
            var lastUndoOp = _this2._undoBuffer.length > 0 ? _this2._undoBuffer[_this2._undoBuffer.length - 1] : null;
            if (_this2._redoing === false && _this2._lastTransactionWasUndo === false && lastUndoOp !== null && (options.captureTimeout < 0 || reverseOperation.created - lastUndoOp.created <= options.captureTimeout)) {
              lastUndoOp.created = reverseOperation.created;
              if (reverseOperation.toState !== null) {
                lastUndoOp.toState = reverseOperation.toState;
                if (lastUndoOp.fromState === null) {
                  lastUndoOp.fromState = reverseOperation.fromState;
                }
              }
              reverseOperation.deletedStructs.forEach(lastUndoOp.deletedStructs.add, lastUndoOp.deletedStructs);
            } else {
              _this2._lastTransactionWasUndo = false;
              _this2._undoBuffer.push(reverseOperation);
            }
            if (!_this2._redoing) {
              _this2._redoBuffer = [];
            }
          } else {
            _this2._lastTransactionWasUndo = true;
            _this2._redoBuffer.push(reverseOperation);
          }
        }
      });
    }

    /**
     * Enforce that the next change is created as a separate item in the undo stack
     */


    createClass(UndoManager, [{
      key: 'flushChanges',
      value: function flushChanges() {
        this._lastTransactionWasUndo = true;
      }

      /**
       * Undo the last locally created change.
       */

    }, {
      key: 'undo',
      value: function undo() {
        this._undoing = true;
        var performedUndo = applyReverseOperation(this.y, this._scope, this._undoBuffer);
        this._undoing = false;
        return performedUndo;
      }

      /**
       * Redo the last locally created change.
       */

    }, {
      key: 'redo',
      value: function redo() {
        this._redoing = true;
        var performedRedo = applyReverseOperation(this.y, this._scope, this._redoBuffer);
        this._redoing = false;
        return performedRedo;
      }
    }]);
    return UndoManager;
  }();

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  var index = function index(val, options) {
    options = options || {};
    var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (ms >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (ms >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (ms >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + ' ' + name;
    }
    return Math.ceil(ms / n) + ' ' + name + 's';
  }

  var debug = createCommonjsModule(function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = index;

    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    exports.formatters = {};

    /**
     * Previous log timestamp.
     */

    var prevTime;

    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectColor(namespace) {
      var hash = 0,
          i;

      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return exports.colors[Math.abs(hash) % exports.colors.length];
    }

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function createDebug(namespace) {

      function debug() {
        // disabled?
        if (!debug.enabled) return;

        var self = debug;

        // set `diff` timestamp
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;

        // turn the `arguments` into a proper Array
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }

        args[0] = exports.coerce(args[0]);

        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %O
          args.unshift('%O');
        }

        // apply any `formatters` transformations
        var index$$1 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index$$1++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index$$1];
            match = formatter.call(self, val);

            // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index$$1, 1);
            index$$1--;
          }
          return match;
        });

        // apply env-specific formatting (colors, etc.)
        exports.formatArgs.call(self, args);

        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);

      // env-specific initialization logic for debug instances
      if ('function' === typeof exports.init) {
        exports.init(debug);
      }

      return debug;
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
      exports.save(namespaces);

      exports.names = [];
      exports.skips = [];

      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (var i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
      exports.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  });
  var debug_1 = debug.coerce;
  var debug_2 = debug.disable;
  var debug_3 = debug.enable;
  var debug_4 = debug.enabled;
  var debug_5 = debug.humanize;
  var debug_6 = debug.names;
  var debug_7 = debug.skips;
  var debug_8 = debug.formatters;

  var browser = createCommonjsModule(function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = debug;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

    /**
     * Colors.
     */

    exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
        return true;
      }

      // is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
      // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
      // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
      // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    exports.formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return '[UnexpectedJSONParseError]: ' + err.message;
      }
    };

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var useColors = this.useColors;

      args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

      if (!useColors) return;

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if ('%%' === match) return;
        index++;
        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });

      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {}

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

    exports.enable(load());

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
  });
  var browser_1 = browser.log;
  var browser_2 = browser.formatArgs;
  var browser_3 = browser.save;
  var browser_4 = browser.load;
  var browser_5 = browser.useColors;
  var browser_6 = browser.storage;
  var browser_7 = browser.colors;

  // TODO: rename Connector

  var AbstractConnector = function () {
    function AbstractConnector(y, opts) {
      classCallCheck(this, AbstractConnector);

      this.y = y;
      this.opts = opts;
      if (opts.role == null || opts.role === 'master') {
        this.role = 'master';
      } else if (opts.role === 'slave') {
        this.role = 'slave';
      } else {
        throw new Error("Role must be either 'master' or 'slave'!");
      }
      this.log = browser('y:connector');
      this.logMessage = browser('y:connector-message');
      this._forwardAppliedStructs = opts.forwardAppliedOperations || false; // TODO: rename
      this.role = opts.role;
      this.connections = new Map();
      this.isSynced = false;
      this.userEventListeners = [];
      this.whenSyncedListeners = [];
      this.currentSyncTarget = null;
      this.debug = opts.debug === true;
      this.broadcastBuffer = new BinaryEncoder();
      this.broadcastBufferSize = 0;
      this.protocolVersion = 11;
      this.authInfo = opts.auth || null;
      this.checkAuth = opts.checkAuth || function () {
        return Promise.resolve('write');
      }; // default is everyone has write access
      if (opts.maxBufferLength == null) {
        this.maxBufferLength = -1;
      } else {
        this.maxBufferLength = opts.maxBufferLength;
      }
    }

    createClass(AbstractConnector, [{
      key: 'reconnect',
      value: function reconnect() {
        this.log('reconnecting..');
      }
    }, {
      key: 'disconnect',
      value: function disconnect() {
        this.log('discronnecting..');
        this.connections = new Map();
        this.isSynced = false;
        this.currentSyncTarget = null;
        this.whenSyncedListeners = [];
        return Promise.resolve();
      }
    }, {
      key: 'onUserEvent',
      value: function onUserEvent(f) {
        this.userEventListeners.push(f);
      }
    }, {
      key: 'removeUserEventListener',
      value: function removeUserEventListener(f) {
        this.userEventListeners = this.userEventListeners.filter(function (g) {
          return f !== g;
        });
      }
    }, {
      key: 'userLeft',
      value: function userLeft(user) {
        if (this.connections.has(user)) {
          this.log('%s: User left %s', this.y.userID, user);
          this.connections.delete(user);
          // check if isSynced event can be sent now
          this._setSyncedWith(null);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.userEventListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var f = _step.value;

              f({
                action: 'userLeft',
                user: user
              });
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }
    }, {
      key: 'userJoined',
      value: function userJoined(user, role, auth) {
        if (role == null) {
          throw new Error('You must specify the role of the joined user!');
        }
        if (this.connections.has(user)) {
          throw new Error('This user already joined!');
        }
        this.log('%s: User joined %s', this.y.userID, user);
        this.connections.set(user, {
          uid: user,
          isSynced: false,
          role: role,
          processAfterAuth: [],
          processAfterSync: [],
          auth: auth || null,
          receivedSyncStep2: false
        });
        var defer = {};
        defer.promise = new Promise(function (resolve) {
          defer.resolve = resolve;
        });
        this.connections.get(user).syncStep2 = defer;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.userEventListeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var f = _step2.value;

            f({
              action: 'userJoined',
              user: user,
              role: role
            });
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        this._syncWithUser(user);
      }

      // Execute a function _when_ we are connected.
      // If not connected, wait until connected

    }, {
      key: 'whenSynced',
      value: function whenSynced(f) {
        if (this.isSynced) {
          f();
        } else {
          this.whenSyncedListeners.push(f);
        }
      }
    }, {
      key: '_syncWithUser',
      value: function _syncWithUser(userID) {
        if (this.role === 'slave') {
          return; // "The current sync has not finished or this is controlled by a master!"
        }
        sendSyncStep1(this, userID);
      }
    }, {
      key: '_fireIsSyncedListeners',
      value: function _fireIsSyncedListeners() {
        if (!this.isSynced) {
          this.isSynced = true;
          // It is safer to remove this!
          // call whensynced listeners
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this.whenSyncedListeners[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var f = _step3.value;

              f();
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          this.whenSyncedListeners = [];
          this.y._setContentReady();
          this.y.emit('synced');
        }
      }
    }, {
      key: 'send',
      value: function send(uid, buffer) {
        var y = this.y;
        if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {
          throw new Error('Expected Message to be an ArrayBuffer or Uint8Array - don\'t use this method to send custom messages');
        }
        this.log('User%s to User%s: Send \'%y\'', y.userID, uid, buffer);
        this.logMessage('User%s to User%s: Send %Y', y.userID, uid, [y, buffer]);
      }
    }, {
      key: 'broadcast',
      value: function broadcast(buffer) {
        var y = this.y;
        if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {
          throw new Error('Expected Message to be an ArrayBuffer or Uint8Array - don\'t use this method to send custom messages');
        }
        this.log('User%s: Broadcast \'%y\'', y.userID, buffer);
        this.logMessage('User%s: Broadcast: %Y', y.userID, [y, buffer]);
      }

      /*
        Buffer operations, and broadcast them when ready.
      */

    }, {
      key: 'broadcastStruct',
      value: function broadcastStruct(struct) {
        var _this = this;

        var firstContent = this.broadcastBuffer.length === 0;
        if (firstContent) {
          this.broadcastBuffer.writeVarString(this.y.room);
          this.broadcastBuffer.writeVarString('update');
          this.broadcastBufferSize = 0;
          this.broadcastBufferSizePos = this.broadcastBuffer.pos;
          this.broadcastBuffer.writeUint32(0);
        }
        this.broadcastBufferSize++;
        struct._toBinary(this.broadcastBuffer);
        if (this.maxBufferLength > 0 && this.broadcastBuffer.length > this.maxBufferLength) {
          // it is necessary to send the buffer now
          // cache the buffer and check if server is responsive
          var buffer = this.broadcastBuffer;
          buffer.setUint32(this.broadcastBufferSizePos, this.broadcastBufferSize);
          this.broadcastBuffer = new BinaryEncoder();
          this.whenRemoteResponsive().then(function () {
            _this.broadcast(buffer.createBuffer());
          });
        } else if (firstContent) {
          // send the buffer when all transactions are finished
          // (or buffer exceeds maxBufferLength)
          setTimeout(function () {
            if (_this.broadcastBuffer.length > 0) {
              var _buffer = _this.broadcastBuffer;
              _buffer.setUint32(_this.broadcastBufferSizePos, _this.broadcastBufferSize);
              _this.broadcast(_buffer.createBuffer());
              _this.broadcastBuffer = new BinaryEncoder();
            }
          }, 0);
        }
      }

      /*
       * Somehow check the responsiveness of the remote clients/server
       * Default behavior:
       *   Wait 100ms before broadcasting the next batch of operations
       *
       * Only used when maxBufferLength is set
       *
       */

    }, {
      key: 'whenRemoteResponsive',
      value: function whenRemoteResponsive() {
        return new Promise(function (resolve) {
          setTimeout(resolve, 100);
        });
      }

      /*
        You received a raw message, and you know that it is intended for Yjs. Then call this function.
      */

    }, {
      key: 'receiveMessage',
      value: function receiveMessage(sender, buffer, skipAuth) {
        var _this2 = this;

        var y = this.y;
        var userID = y.userID;
        skipAuth = skipAuth || false;
        if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {
          return Promise.reject(new Error('Expected Message to be an ArrayBuffer or Uint8Array!'));
        }
        if (sender === userID) {
          return Promise.resolve();
        }
        var decoder = new BinaryDecoder(buffer);
        var encoder = new BinaryEncoder();
        var roomname = decoder.readVarString(); // read room name
        encoder.writeVarString(roomname);
        var messageType = decoder.readVarString();
        var senderConn = this.connections.get(sender);
        this.log('User%s from User%s: Receive \'%s\'', userID, sender, messageType);
        this.logMessage('User%s from User%s: Receive %Y', userID, sender, [y, buffer]);
        if (senderConn == null && !skipAuth) {
          throw new Error('Received message from unknown peer!');
        }
        if (messageType === 'sync step 1' || messageType === 'sync step 2') {
          var auth = decoder.readVarUint();
          if (senderConn.auth == null) {
            senderConn.processAfterAuth.push([messageType, senderConn, decoder, encoder, sender]);
            // check auth
            return this.checkAuth(auth, y, sender).then(function (authPermissions) {
              if (senderConn.auth == null) {
                senderConn.auth = authPermissions;
                y.emit('userAuthenticated', {
                  user: senderConn.uid,
                  auth: authPermissions
                });
              }
              var messages = senderConn.processAfterAuth;
              senderConn.processAfterAuth = [];

              messages.forEach(function (m) {
                return _this2.computeMessage(m[0], m[1], m[2], m[3], m[4]);
              });
            });
          }
        }
        if ((skipAuth || senderConn.auth != null) && (messageType !== 'update' || senderConn.isSynced)) {
          this.computeMessage(messageType, senderConn, decoder, encoder, sender, skipAuth);
        } else {
          senderConn.processAfterSync.push([messageType, senderConn, decoder, encoder, sender, false]);
        }
      }
    }, {
      key: 'computeMessage',
      value: function computeMessage(messageType, senderConn, decoder, encoder, sender, skipAuth) {
        if (messageType === 'sync step 1' && (senderConn.auth === 'write' || senderConn.auth === 'read')) {
          // cannot wait for sync step 1 to finish, because we may wait for sync step 2 in sync step 1 (->lock)
          readSyncStep1(decoder, encoder, this.y, senderConn, sender);
        } else {
          var y = this.y;
          y.transact(function () {
            if (messageType === 'sync step 2' && senderConn.auth === 'write') {
              readSyncStep2(decoder, encoder, y, senderConn, sender);
            } else if (messageType === 'update' && (skipAuth || senderConn.auth === 'write')) {
              integrateRemoteStructs(y, decoder);
            } else {
              throw new Error('Unable to receive message');
            }
          }, true);
        }
      }
    }, {
      key: '_setSyncedWith',
      value: function _setSyncedWith(user) {
        var _this3 = this;

        if (user != null) {
          var userConn = this.connections.get(user);
          userConn.isSynced = true;
          var messages = userConn.processAfterSync;
          userConn.processAfterSync = [];
          messages.forEach(function (m) {
            _this3.computeMessage(m[0], m[1], m[2], m[3], m[4]);
          });
        }
        var conns = Array.from(this.connections.values());
        if (conns.length > 0 && conns.every(function (u) {
          return u.isSynced;
        })) {
          this._fireIsSyncedListeners();
        }
      }
    }]);
    return AbstractConnector;
  }();

  /**
   * Read the Decoder and fill the Yjs instance with data in the decoder.
   *
   * @param {Y} y The Yjs instance
   * @param {BinaryDecoder} decoder The BinaryDecoder to read from.
   */
  function fromBinary(y, decoder) {
    y.transact(function () {
      integrateRemoteStructs(y, decoder);
      readDeleteSet(y, decoder);
    });
  }

  /**
   * Encode the Yjs model to binary format.
   *
   * @param {Y} y The Yjs instance
   * @return {BinaryEncoder} The encoder instance that can be transformed
   *                         to ArrayBuffer or Buffer.
   */
  function toBinary(y) {
    var encoder = new BinaryEncoder();
    writeStructs(y, encoder, new Map());
    writeDeleteSet(y, encoder);
    return encoder;
  }

  function getFreshCnf() {
    var buffer = new BinaryEncoder();
    buffer.writeUint32(0);
    return {
      len: 0,
      buffer: buffer
    };
  }

  /**
   * Abstract persistence class.
   */

  var AbstractPersistence = function () {
    function AbstractPersistence(opts) {
      classCallCheck(this, AbstractPersistence);

      this.opts = opts;
      this.ys = new Map();
    }

    createClass(AbstractPersistence, [{
      key: '_init',
      value: function _init(y) {
        var _this = this;

        var cnf = this.ys.get(y);
        if (cnf === undefined) {
          cnf = getFreshCnf();
          cnf.mutualExclude = createMutualExclude();
          this.ys.set(y, cnf);
          return this.init(y).then(function () {
            y.on('afterTransaction', function (y, transaction) {
              var cnf = _this.ys.get(y);
              if (cnf.len > 0) {
                cnf.buffer.setUint32(0, cnf.len);
                _this.saveUpdate(y, cnf.buffer.createBuffer(), transaction);
                var _cnf = getFreshCnf();
                for (var key in _cnf) {
                  cnf[key] = _cnf[key];
                }
              }
            });
            return _this.retrieve(y);
          }).then(function () {
            return Promise.resolve(cnf);
          });
        } else {
          return Promise.resolve(cnf);
        }
      }
    }, {
      key: 'deinit',
      value: function deinit(y) {
        this.ys.delete(y);
        y.persistence = null;
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.ys = null;
      }

      /**
       * Remove all persisted data that belongs to a room.
       * Automatically destroys all Yjs all Yjs instances that persist to
       * the room. If `destroyYjsInstances = false` the persistence functionality
       * will be removed from the Yjs instances.
       *
       * ** Must be overwritten! **
       */

    }, {
      key: 'removePersistedData',
      value: function removePersistedData(room) {
        var _this2 = this;

        var destroyYjsInstances = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        this.ys.forEach(function (cnf, y) {
          if (y.room === room) {
            if (destroyYjsInstances) {
              y.destroy();
            } else {
              _this2.deinit(y);
            }
          }
        });
      }

      /* overwrite */

    }, {
      key: 'saveUpdate',
      value: function saveUpdate(buffer) {}

      /**
       * Save struct to update buffer.
       * saveUpdate is called when transaction ends
       */

    }, {
      key: 'saveStruct',
      value: function saveStruct(y, struct) {
        var cnf = this.ys.get(y);
        if (cnf !== undefined) {
          cnf.mutualExclude(function () {
            struct._toBinary(cnf.buffer);
            cnf.len++;
          });
        }
      }

      /* overwrite */

    }, {
      key: 'retrieve',
      value: function retrieve(y, model, updates) {
        var cnf = this.ys.get(y);
        if (cnf !== undefined) {
          cnf.mutualExclude(function () {
            y.transact(function () {
              if (model != null) {
                fromBinary(y, new BinaryDecoder(new Uint8Array(model)));
              }
              if (updates != null) {
                for (var i = 0; i < updates.length; i++) {
                  integrateRemoteStructs(y, new BinaryDecoder(new Uint8Array(updates[i])));
                }
              }
            });
            y.emit('persistenceReady');
          });
        }
      }

      /* overwrite */

    }, {
      key: 'persist',
      value: function persist(y) {
        return toBinary(y).createBuffer();
      }
    }]);
    return AbstractPersistence;
  }();

  function typeObserver$1() {
    var _this = this;

    this._mutualExclude(function () {
      var textarea = _this.target;
      var textType = _this.type;
      var relativeStart = getRelativePosition(textType, textarea.selectionStart);
      var relativeEnd = getRelativePosition(textType, textarea.selectionEnd);
      textarea.value = textType.toString();
      var start = fromRelativePosition(textType._y, relativeStart);
      var end = fromRelativePosition(textType._y, relativeEnd);
      textarea.setSelectionRange(start, end);
    });
  }

  function domObserver$1() {
    var _this2 = this;

    this._mutualExclude(function () {
      var diff = simpleDiff(_this2.type.toString(), _this2.target.value);
      _this2.type.delete(diff.pos, diff.remove);
      _this2.type.insert(diff.pos, diff.insert);
    });
  }

  /**
   * A binding that binds a YText to a dom textarea.
   *
   * This binding is automatically destroyed when its parent is deleted.
   *
   * @example
   *   const textare = document.createElement('textarea')
   *   const type = y.define('textarea', Y.Text)
   *   const binding = new Y.QuillBinding(type, textarea)
   *
   */

  var TextareaBinding = function (_Binding) {
    inherits(TextareaBinding, _Binding);

    function TextareaBinding(textType, domTextarea) {
      classCallCheck(this, TextareaBinding);

      // set initial value
      var _this3 = possibleConstructorReturn(this, (TextareaBinding.__proto__ || Object.getPrototypeOf(TextareaBinding)).call(this, textType, domTextarea));
      // Binding handles textType as this.type and domTextarea as this.target


      domTextarea.value = textType.toString();
      // Observers are handled by this class
      _this3._typeObserver = typeObserver$1.bind(_this3);
      _this3._domObserver = domObserver$1.bind(_this3);
      textType.observe(_this3._typeObserver);
      domTextarea.addEventListener('input', _this3._domObserver);
      return _this3;
    }

    createClass(TextareaBinding, [{
      key: 'destroy',
      value: function destroy() {
        // Remove everything that is handled by this class
        this.type.unobserve(this._typeObserver);
        this.target.unobserve(this._domObserver);
        get(TextareaBinding.prototype.__proto__ || Object.getPrototypeOf(TextareaBinding.prototype), 'destroy', this).call(this);
      }
    }]);
    return TextareaBinding;
  }(Binding);

  function typeObserver$2(event) {
    var quill = this.target;
    // Force flush Quill changes.
    quill.update('yjs');
    this._mutualExclude(function () {
      // Apply computed delta.
      quill.updateContents(event.delta, 'yjs');
      // Force flush Quill changes. Ignore applied changes.
      quill.update('yjs');
    });
  }

  function quillObserver(delta) {
    var _this = this;

    this._mutualExclude(function () {
      _this.type.applyDelta(delta.ops);
    });
  }

  /**
   * A Binding that binds a YText type to a Quill editor.
   *
   * @example
   * const quill = new Quill(document.createElement('div'))
   * const type = y.define('quill', Y.Text)
   * const binding = new Y.QuillBinding(quill, type)
   * // Now modifications on the DOM will be reflected in the Type, and the other
   * // way around!
   */

  var QuillBinding = function (_Binding) {
    inherits(QuillBinding, _Binding);

    /**
     * @param {YText} textType
     * @param {Quill} quill
     */
    function QuillBinding(textType, quill) {
      classCallCheck(this, QuillBinding);

      // Set initial value.
      var _this2 = possibleConstructorReturn(this, (QuillBinding.__proto__ || Object.getPrototypeOf(QuillBinding)).call(this, textType, quill));
      // Binding handles textType as this.type and quill as this.target.


      quill.setContents(textType.toDelta(), 'yjs');
      // Observers are handled by this class.
      _this2._typeObserver = typeObserver$2.bind(_this2);
      _this2._quillObserver = quillObserver.bind(_this2);
      textType.observe(_this2._typeObserver);
      quill.on('text-change', _this2._quillObserver);
      return _this2;
    }

    createClass(QuillBinding, [{
      key: 'destroy',
      value: function destroy() {
        // Remove everything that is handled by this class.
        this.type.unobserve(this._typeObserver);
        this.target.off('text-change', this._quillObserver);
        get(QuillBinding.prototype.__proto__ || Object.getPrototypeOf(QuillBinding.prototype), 'destroy', this).call(this);
      }
    }]);
    return QuillBinding;
  }(Binding);

  function typeObserver$3(event) {
    var _this = this;

    this._mutualExclude(function () {
      var codeMirror = _this.target;
      var deltas = event.delta;
      var index = 0;
      var from = codeMirror.posFromIndex(index);
      for (var i = 0; i < deltas.length; i++) {
        var delta = deltas[i];
        if (delta.retain) {
          index = delta.retain;
          from = codeMirror.posFromIndex(index);
        } else if (delta.insert) {
          codeMirror.replaceRange(delta.insert, from, from);
        } else if (delta.delete) {
          codeMirror.replaceRange('', from, codeMirror.posFromIndex(index + delta.delete));
        }
      }
    });
  }

  function codeMirrorObserver(codeMirror, deltas) {
    var _this2 = this;

    this._mutualExclude(function () {
      for (var i = 0; i < deltas.length; i++) {
        var delta = deltas[i];
        var start = codeMirror.indexFromPos(delta.from);
        // apply the delete operation first
        if (delta.removed.length > 0) {
          var delLength = 0;
          for (var j = 0; j < delta.removed.length; j++) {
            delLength += delta.removed[j].length;
          }
          // "enter" is also a character in our case
          delLength += delta.removed.length - 1;
          _this2.type.delete(start, delLength);
        }
        // apply insert operation
        _this2.type.insert(start, delta.text.join('\n'));
      }
    });
  }

  /**
   * A binding that binds a YText to a codemirror.
   *
   * This binding is automatically destroyed when its parent is deleted.
   *
   */

  var CodeMirrorBinding = function (_Binding) {
    inherits(CodeMirrorBinding, _Binding);

    function CodeMirrorBinding(textType, codeMirror) {
      classCallCheck(this, CodeMirrorBinding);

      // set initial value
      var _this3 = possibleConstructorReturn(this, (CodeMirrorBinding.__proto__ || Object.getPrototypeOf(CodeMirrorBinding)).call(this, textType, codeMirror));

      codeMirror.setValue(textType.toString());
      // Observers are handled by this class
      _this3._typeObserver = typeObserver$3.bind(_this3);
      _this3._codeMirrorObserver = codeMirrorObserver.bind(_this3);
      textType.observe(_this3._typeObserver);
      codeMirror.on('changes', _this3._codeMirrorObserver);
      return _this3;
    }

    createClass(CodeMirrorBinding, [{
      key: 'destroy',
      value: function destroy() {
        // Remove everything that is handled by this class
        this.type.unobserve(this._typeObserver);
        this.target.unobserve(this._codeMirrorObserver);
        get(CodeMirrorBinding.prototype.__proto__ || Object.getPrototypeOf(CodeMirrorBinding.prototype), 'destroy', this).call(this);
      }
    }]);
    return CodeMirrorBinding;
  }(Binding);

  // TODO: The following assignments should be moved to yjs-dist
  Y.AbstractConnector = AbstractConnector;
  Y.AbstractPersistence = AbstractPersistence;
  Y.Array = YArray;
  Y.Map = YMap;
  Y.Text = YText;
  Y.XmlElement = YXmlElement;
  Y.XmlFragment = YXmlFragment;
  Y.XmlText = YXmlText;
  Y.XmlHook = YXmlHook;

  Y.TextareaBinding = TextareaBinding;
  Y.QuillBinding = QuillBinding;
  Y.DomBinding = DomBinding;
  Y.CodeMirrorBinding = CodeMirrorBinding;

  DomBinding.domToType = domToType;
  DomBinding.domsToTypes = domsToTypes;
  DomBinding.switchAssociation = switchAssociation;

  Y.utils = {
    BinaryDecoder: BinaryDecoder,
    UndoManager: UndoManager,
    getRelativePosition: getRelativePosition,
    fromRelativePosition: fromRelativePosition,
    registerStruct: registerStruct,
    integrateRemoteStructs: integrateRemoteStructs,
    toBinary: toBinary,
    fromBinary: fromBinary
  };

  Y.debug = browser;
  browser.formatters.Y = messageToString;
  browser.formatters.y = messageToRoomname;

  return Y;

})));


}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":4,"buffer":2}],8:[function(require,module,exports){
var Y = require('yjs');
window.Y = Y;
require('y-webrtc3')(Y);

var Y2 = require('yjs2');
window.Y2 = Y2;
require('y-webrtc3')(Y2);

let y = new Y('ynotebook', {
    connector: {
        name: 'webrtc',
        room: 'dinesh',
        url: 'http://finwin.io:1256'
    }
});
window.y = y;

let y2 = new Y2('ynotebook2', {
    connector: {
        name: 'webrtc',
        room: 'dinesh2',
        url: 'http://finwin.io:1257'
    }
});
window.y2 = y2;

function load_ynotebook(y) {
    function load_ynotebook2(y) {
        if (typeof Jupyter !== 'undefined') {
            if (typeof Jupyter.notebook !== 'undefined') {
                load_ynotebook3(y);
            } else {
                setTimeout(load_ynotebook2, 0, y);
            }
        } else {
            setTimeout(load_ynotebook2, 0, y);
        }
    }

    function load_ynotebook3(y) {
        var ymap = y.define('ymap', Y.Map);
        Jupyter.notebook.y = y;
        Jupyter.notebook.ymap = ymap;
        ymap.observe(function (e) {
            console.log(e);
            for (let index of e.keysChanged) {
                let data = ymap.get(index);
                var cell = Jupyter.notebook.insert_cell_at_index(data.cell_data.cell_type, index);
                new Y.CodeMirrorBinding(y.define('ycodemirror'+data.id, Y.Text), cell.code_mirror);
                if (y.connector.sockets === 0) {
                    cell.fromJSON(data.cell_data);
                }
                if (data.cell_data.cell_type !== 'markdown') {
                    new Y.DomBinding(y.define('yxml'+data.id, Y.XmlFragment), cell.output_area.element[0]);
                }
                console.log(index);
            }
        });

        if (y.connector.sockets === 0) {
            Jupyter.notebook.is_first = true;
            Jupyter.notebook.load_notebook(Jupyter.notebook.notebook_path);
        } else {
            Jupyter.notebook.is_first = false;
            Jupyter.notebook.load_notebook(Jupyter.notebook.notebook_path);
        }
    }

    load_ynotebook2(y);
}

function load_ynotebook4(y) {
    if (y.connector.sockets >= 0) {
        load_ynotebook(y);
    } else {
        setTimeout(load_ynotebook4, 0, y);
    }
}

//load_ynotebook4(y);

},{"y-webrtc3":5,"yjs":6,"yjs2":7}]},{},[8])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy95LXdlYnJ0YzMveS13ZWJydGMuanMiLCJub2RlX21vZHVsZXMveWpzL3kuanMiLCJub2RlX21vZHVsZXMveWpzMi95LmpzIiwic3JjL2FwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4c0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3B5UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzV5UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8ICh2YWx1ZSAmJiBpc0FycmF5QnVmZmVyKHZhbHVlLmJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWVcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYnVmKSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0FycmF5QnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXJzIGZyb20gYW5vdGhlciBjb250ZXh0IChpLmUuIGFuIGlmcmFtZSkgZG8gbm90IHBhc3MgdGhlIGBpbnN0YW5jZW9mYCBjaGVja1xuLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgICAgdHlwZW9mIG9iai5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJylcbn1cblxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJcbi8qKlxuICogeS13ZWJydGMzIC0gXG4gKiBAdmVyc2lvbiB2Mi40LjBcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC55d2VicnRjID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cblx0ZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRcdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcblx0fVxuXG5cdC8qKlxyXG5cdCAqIFBhcnNlcyBhbiBVUklcclxuXHQgKlxyXG5cdCAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcclxuXHQgKiBAYXBpIHByaXZhdGVcclxuXHQgKi9cblxuXHR2YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxuXHR2YXIgcGFydHMgPSBbJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXTtcblxuXHR2YXIgcGFyc2V1cmkgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcblx0ICAgIHZhciBzcmMgPSBzdHIsXG5cdCAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXG5cdCAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XG5cblx0ICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcblx0ICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcblx0ICAgICAgICB1cmkgPSB7fSxcblx0ICAgICAgICBpID0gMTQ7XG5cblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcblx0ICAgIH1cblxuXHQgICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuXHQgICAgICAgIHVyaS5zb3VyY2UgPSBzcmM7XG5cdCAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuXHQgICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG5cdCAgICAgICAgdXJpLmlwdjZ1cmkgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdXJpO1xuXHR9O1xuXG5cdHZhciBwYXJzZXVyaSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IHBhcnNldXJpLFxuXHRcdF9fbW9kdWxlRXhwb3J0czogcGFyc2V1cmlcblx0fSk7XG5cblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcblx0ICByZXR1cm4gdHlwZW9mIG9iajtcblx0fSA6IGZ1bmN0aW9uIChvYmopIHtcblx0ICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcblx0fTtcblxuXHR2YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG5cdCAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcblx0ICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuXHQgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdCAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuXHQgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcblx0ICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuXHQgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuXHQgIH07XG5cdH0oKTtcblxuXHR2YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcblx0ICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcblx0ICB9XG5cblx0ICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcblx0ICAgIGNvbnN0cnVjdG9yOiB7XG5cdCAgICAgIHZhbHVlOiBzdWJDbGFzcyxcblx0ICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgIHdyaXRhYmxlOiB0cnVlLFxuXHQgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH1cblx0ICB9KTtcblx0ICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG5cdH07XG5cblx0dmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuXHQgIGlmICghc2VsZikge1xuXHQgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuXHQgIH1cblxuXHQgIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBIZWxwZXJzLlxuXHQgKi9cblxuXHR2YXIgcyA9IDEwMDA7XG5cdHZhciBtID0gcyAqIDYwO1xuXHR2YXIgaCA9IG0gKiA2MDtcblx0dmFyIGQgPSBoICogMjQ7XG5cdHZhciB5ID0gZCAqIDM2NS4yNTtcblxuXHQvKipcblx0ICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cblx0ICpcblx0ICogT3B0aW9uczpcblx0ICpcblx0ICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cblx0ICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG5cdCAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdHZhciBtcyA9IGZ1bmN0aW9uIG1zKHZhbCwgb3B0aW9ucykge1xuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgIHZhciB0eXBlID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKTtcblx0ICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcblx0ICAgIHJldHVybiBwYXJzZSh2YWwpO1xuXHQgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuXHQgIH1cblx0ICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG5cdCAgc3RyID0gU3RyaW5nKHN0cik7XG5cdCAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuXHQgIGlmICghbWF0Y2gpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcblx0ICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuXHQgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgY2FzZSAneWVhcnMnOlxuXHQgICAgY2FzZSAneWVhcic6XG5cdCAgICBjYXNlICd5cnMnOlxuXHQgICAgY2FzZSAneXInOlxuXHQgICAgY2FzZSAneSc6XG5cdCAgICAgIHJldHVybiBuICogeTtcblx0ICAgIGNhc2UgJ2RheXMnOlxuXHQgICAgY2FzZSAnZGF5Jzpcblx0ICAgIGNhc2UgJ2QnOlxuXHQgICAgICByZXR1cm4gbiAqIGQ7XG5cdCAgICBjYXNlICdob3Vycyc6XG5cdCAgICBjYXNlICdob3VyJzpcblx0ICAgIGNhc2UgJ2hycyc6XG5cdCAgICBjYXNlICdocic6XG5cdCAgICBjYXNlICdoJzpcblx0ICAgICAgcmV0dXJuIG4gKiBoO1xuXHQgICAgY2FzZSAnbWludXRlcyc6XG5cdCAgICBjYXNlICdtaW51dGUnOlxuXHQgICAgY2FzZSAnbWlucyc6XG5cdCAgICBjYXNlICdtaW4nOlxuXHQgICAgY2FzZSAnbSc6XG5cdCAgICAgIHJldHVybiBuICogbTtcblx0ICAgIGNhc2UgJ3NlY29uZHMnOlxuXHQgICAgY2FzZSAnc2Vjb25kJzpcblx0ICAgIGNhc2UgJ3NlY3MnOlxuXHQgICAgY2FzZSAnc2VjJzpcblx0ICAgIGNhc2UgJ3MnOlxuXHQgICAgICByZXR1cm4gbiAqIHM7XG5cdCAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuXHQgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuXHQgICAgY2FzZSAnbXNlY3MnOlxuXHQgICAgY2FzZSAnbXNlYyc6XG5cdCAgICBjYXNlICdtcyc6XG5cdCAgICAgIHJldHVybiBuO1xuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbXNcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcblx0ICBpZiAobXMgPj0gZCkge1xuXHQgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcblx0ICB9XG5cdCAgaWYgKG1zID49IGgpIHtcblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG5cdCAgfVxuXHQgIGlmIChtcyA+PSBtKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuXHQgIH1cblx0ICBpZiAobXMgPj0gcykge1xuXHQgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcblx0ICB9XG5cdCAgcmV0dXJuIG1zICsgJ21zJztcblx0fVxuXG5cdC8qKlxuXHQgKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1zXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGZtdExvbmcobXMpIHtcblx0ICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8IG1zICsgJyBtcyc7XG5cdH1cblxuXHQvKipcblx0ICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuXHQgIGlmIChtcyA8IG4pIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKG1zIDwgbiAqIDEuNSkge1xuXHQgICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG5cdH1cblxuXHR2YXIgbXMkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBtcyxcblx0XHRfX21vZHVsZUV4cG9ydHM6IG1zXG5cdH0pO1xuXG5cdHZhciByZXF1aXJlJCQwID0gKCBtcyQxICYmIG1zICkgfHwgbXMkMTtcblxuXHR2YXIgZGVidWcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCAgLyoqXG5cdCAgICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuXHQgICAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG5cdCAgICpcblx0ICAgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG5cdCAgICovXG5cblx0ICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1Zztcblx0ICBleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcblx0ICBleHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuXHQgIGV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuXHQgIGV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdCAgZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUkJDA7XG5cblx0ICAvKipcblx0ICAgKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG5cdCAgICovXG5cdCAgZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcblxuXHQgIC8qKlxuXHQgICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQgICAqL1xuXG5cdCAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuXHQgIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuXHQgIC8qKlxuXHQgICAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0ICAgKlxuXHQgICAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0ICAgKi9cblxuXHQgIGV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG5cdCAgLyoqXG5cdCAgICogU2VsZWN0IGEgY29sb3IuXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQgICAqIEByZXR1cm4ge051bWJlcn1cblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHQgICAgdmFyIGhhc2ggPSAwLFxuXHQgICAgICAgIGk7XG5cblx0ICAgIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcblx0ICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHQgICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuXHQgICAgdmFyIHByZXZUaW1lO1xuXG5cdCAgICBmdW5jdGlvbiBkZWJ1ZygpIHtcblx0ICAgICAgLy8gZGlzYWJsZWQ/XG5cdCAgICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG5cdCAgICAgIHZhciBzZWxmID0gZGVidWc7XG5cblx0ICAgICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0ICAgICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcblx0ICAgICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0ICAgICAgc2VsZi5kaWZmID0gbXM7XG5cdCAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHQgICAgICBzZWxmLmN1cnIgPSBjdXJyO1xuXHQgICAgICBwcmV2VGltZSA9IGN1cnI7XG5cblx0ICAgICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuXHQgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuXHQgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG5cdCAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0ICAgICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHQgICAgICB2YXIgaW5kZXggPSAwO1xuXHQgICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcblx0ICAgICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdCAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG5cdCAgICAgICAgaW5kZXgrKztcblx0ICAgICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdCAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcblx0ICAgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcblx0ICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHQgICAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHQgICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgaW5kZXgtLTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG1hdGNoO1xuXHQgICAgICB9KTtcblxuXHQgICAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHQgICAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHQgICAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcblx0ICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdCAgICB9XG5cblx0ICAgIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0ICAgIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0ICAgIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG5cdCAgICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdCAgICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHQgICAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0ICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG5cdCAgICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG5cdCAgICB9XG5cblx0ICAgIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG5cdCAgICByZXR1cm4gZGVidWc7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cdCAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgIGV4cG9ydHMuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0ICAgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0ICAgIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuXHQgICAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuXHQgICAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG5cdCAgICB2YXIgaTtcblx0ICAgIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdCAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdCAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXHQgICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdCAgICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBpbnN0YW5jZSA9IGV4cG9ydHMuaW5zdGFuY2VzW2ldO1xuXHQgICAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCAgICpcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0ICAgIGV4cG9ydHMuZW5hYmxlKCcnKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQgICAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAgICogQGFwaSBwdWJsaWNcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHQgICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgdmFyIGksIGxlbjtcblx0ICAgIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBDb2VyY2UgYHZhbGAuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge01peGVkfSB2YWxcblx0ICAgKiBAcmV0dXJuIHtNaXhlZH1cblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0ICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0ICAgIHJldHVybiB2YWw7XG5cdCAgfVxuXHR9KTtcblx0dmFyIGRlYnVnXzEgPSBkZWJ1Zy5jb2VyY2U7XG5cdHZhciBkZWJ1Z18yID0gZGVidWcuZGlzYWJsZTtcblx0dmFyIGRlYnVnXzMgPSBkZWJ1Zy5lbmFibGU7XG5cdHZhciBkZWJ1Z180ID0gZGVidWcuZW5hYmxlZDtcblx0dmFyIGRlYnVnXzUgPSBkZWJ1Zy5odW1hbml6ZTtcblx0dmFyIGRlYnVnXzYgPSBkZWJ1Zy5pbnN0YW5jZXM7XG5cdHZhciBkZWJ1Z183ID0gZGVidWcubmFtZXM7XG5cdHZhciBkZWJ1Z184ID0gZGVidWcuc2tpcHM7XG5cdHZhciBkZWJ1Z185ID0gZGVidWcuZm9ybWF0dGVycztcblxuXHR2YXIgZGVidWckMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBkZWJ1Zyxcblx0XHRfX21vZHVsZUV4cG9ydHM6IGRlYnVnLFxuXHRcdGNvZXJjZTogZGVidWdfMSxcblx0XHRkaXNhYmxlOiBkZWJ1Z18yLFxuXHRcdGVuYWJsZTogZGVidWdfMyxcblx0XHRlbmFibGVkOiBkZWJ1Z180LFxuXHRcdGh1bWFuaXplOiBkZWJ1Z181LFxuXHRcdGluc3RhbmNlczogZGVidWdfNixcblx0XHRuYW1lczogZGVidWdfNyxcblx0XHRza2lwczogZGVidWdfOCxcblx0XHRmb3JtYXR0ZXJzOiBkZWJ1Z185XG5cdH0pO1xuXG5cdHZhciByZXF1aXJlJCQwJDEgPSAoIGRlYnVnJDEgJiYgZGVidWcgKSB8fCBkZWJ1ZyQxO1xuXG5cdHZhciBicm93c2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQgIC8qKlxuXHQgICAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cblx0ICAgKlxuXHQgICAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cblx0ICAgKi9cblxuXHQgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUkJDAkMTtcblx0ICBleHBvcnRzLmxvZyA9IGxvZztcblx0ICBleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuXHQgIGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5cdCAgZXhwb3J0cy5sb2FkID0gbG9hZDtcblx0ICBleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblx0ICBleHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZSA/IGNocm9tZS5zdG9yYWdlLmxvY2FsIDogbG9jYWxzdG9yYWdlKCk7XG5cblx0ICAvKipcblx0ICAgKiBDb2xvcnMuXG5cdCAgICovXG5cblx0ICBleHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuXG5cdCAgLyoqXG5cdCAgICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcblx0ICAgKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cblx0ICAgKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG5cdCAgICpcblx0ICAgKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQgICAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQgICAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0ICAgIC8vIGV4cGxpY2l0bHlcblx0ICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdCAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQgICAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0ICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHxcblx0ICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0ICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8IHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkgfHxcblx0ICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuXHQgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdCAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8XG5cdCAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdCAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG5cdCAgICovXG5cblx0ICBleHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdCAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG5cdCAgICpcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdCAgICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cblx0ICAgIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdCAgICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG5cdCAgICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdCAgICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQgICAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0ICAgIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0ICAgIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHQgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgIHZhciBsYXN0QyA9IDA7XG5cdCAgICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG5cdCAgICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuXHQgICAgICBpbmRleCsrO1xuXHQgICAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcblx0ICAgICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0ICAgICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHQgICAgICAgIGxhc3RDID0gaW5kZXg7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG5cdCAgICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBsb2coKSB7XG5cdCAgICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuXHQgICAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcblx0ICAgIHJldHVybiAnb2JqZWN0JyA9PT0gKHR5cGVvZiBjb25zb2xlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25zb2xlKSkgJiYgY29uc29sZS5sb2cgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogU2F2ZSBgbmFtZXNwYWNlc2AuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG5cdCAgICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcblx0ICAgICAgfVxuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBMb2FkIGBuYW1lc3BhY2VzYC5cblx0ICAgKlxuXHQgICAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIGxvYWQoKSB7XG5cdCAgICB2YXIgcjtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXG5cdCAgICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdCAgICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0ICAgICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcjtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuXHQgICAqL1xuXG5cdCAgZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuXHQgIC8qKlxuXHQgICAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cblx0ICAgKlxuXHQgICAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuXHQgICAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG5cdCAgICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cblx0ICAgKlxuXHQgICAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICB9XG5cdH0pO1xuXHR2YXIgYnJvd3Nlcl8xID0gYnJvd3Nlci5sb2c7XG5cdHZhciBicm93c2VyXzIgPSBicm93c2VyLmZvcm1hdEFyZ3M7XG5cdHZhciBicm93c2VyXzMgPSBicm93c2VyLnNhdmU7XG5cdHZhciBicm93c2VyXzQgPSBicm93c2VyLmxvYWQ7XG5cdHZhciBicm93c2VyXzUgPSBicm93c2VyLnVzZUNvbG9ycztcblx0dmFyIGJyb3dzZXJfNiA9IGJyb3dzZXIuc3RvcmFnZTtcblx0dmFyIGJyb3dzZXJfNyA9IGJyb3dzZXIuY29sb3JzO1xuXG5cdHZhciBicm93c2VyJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogYnJvd3Nlcixcblx0XHRfX21vZHVsZUV4cG9ydHM6IGJyb3dzZXIsXG5cdFx0bG9nOiBicm93c2VyXzEsXG5cdFx0Zm9ybWF0QXJnczogYnJvd3Nlcl8yLFxuXHRcdHNhdmU6IGJyb3dzZXJfMyxcblx0XHRsb2FkOiBicm93c2VyXzQsXG5cdFx0dXNlQ29sb3JzOiBicm93c2VyXzUsXG5cdFx0c3RvcmFnZTogYnJvd3Nlcl82LFxuXHRcdGNvbG9yczogYnJvd3Nlcl83XG5cdH0pO1xuXG5cdHZhciBwYXJzZXVyaSQyID0gKCBwYXJzZXVyaSQxICYmIHBhcnNldXJpICkgfHwgcGFyc2V1cmkkMTtcblxuXHR2YXIgcmVxdWlyZSQkMCQyID0gKCBicm93c2VyJDEgJiYgYnJvd3NlciApIHx8IGJyb3dzZXIkMTtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIGRlYnVnJDIgPSByZXF1aXJlJCQwJDIoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHR2YXIgdXJsXzEgPSB1cmw7XG5cblx0LyoqXG5cdCAqIFVSTCBwYXJzZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcblx0ICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG5cdCAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHVybCh1cmksIGxvYykge1xuXHQgIHZhciBvYmogPSB1cmk7XG5cblx0ICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuXHQgIGxvYyA9IGxvYyB8fCBjb21tb25qc0dsb2JhbC5sb2NhdGlvbjtcblx0ICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuXHQgIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuXHQgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVyaSkge1xuXHQgICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgwKSkge1xuXHQgICAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDEpKSB7XG5cdCAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG5cdCAgICAgIGRlYnVnJDIoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcblx0ICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG5cdCAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIHBhcnNlXG5cdCAgICBkZWJ1ZyQyKCdwYXJzZSAlcycsIHVyaSk7XG5cdCAgICBvYmogPSBwYXJzZXVyaSQyKHVyaSk7XG5cdCAgfVxuXG5cdCAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG5cdCAgaWYgKCFvYmoucG9ydCkge1xuXHQgICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG5cdCAgICAgIG9iai5wb3J0ID0gJzgwJztcblx0ICAgIH0gZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG5cdCAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cblx0ICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG5cdCAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuXHQgIC8vIGRlZmluZSB1bmlxdWUgaWRcblx0ICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcblx0ICAvLyBkZWZpbmUgaHJlZlxuXHQgIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PT0gb2JqLnBvcnQgPyAnJyA6ICc6JyArIG9iai5wb3J0KTtcblxuXHQgIHJldHVybiBvYmo7XG5cdH1cblxuXHR2YXIgdXJsJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogdXJsXzEsXG5cdFx0X19tb2R1bGVFeHBvcnRzOiB1cmxfMVxuXHR9KTtcblxuXHR2YXIgY29tcG9uZW50RW1pdHRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0ICAvKipcclxuXHQgICAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcblx0ICAgKi9cblxuXHQgIHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblx0ICB9XG5cblx0ICAvKipcclxuXHQgICAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG5cdCAgICpcclxuXHQgICAqIEBhcGkgcHVibGljXHJcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG5cdCAgICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcblx0ICB9XG5cdCAgLyoqXHJcblx0ICAgKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuXHQgICAqIEByZXR1cm4ge09iamVjdH1cclxuXHQgICAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBtaXhpbihvYmopIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuXHQgICAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb2JqO1xuXHQgIH1cblxuXHQgIC8qKlxyXG5cdCAgICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcblx0ICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG5cdCAgICogQGFwaSBwdWJsaWNcclxuXHQgICAqL1xuXG5cdCAgRW1pdHRlci5wcm90b3R5cGUub24gPSBFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuXHQgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgICAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKS5wdXNoKGZuKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvKipcclxuXHQgICAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG5cdCAgICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcblx0ICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG5cdCAgICogQGFwaSBwdWJsaWNcclxuXHQgICAqL1xuXG5cdCAgRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcblx0ICAgIGZ1bmN0aW9uIG9uKCkge1xuXHQgICAgICB0aGlzLm9mZihldmVudCwgb24pO1xuXHQgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfVxuXG5cdCAgICBvbi5mbiA9IGZuO1xuXHQgICAgdGhpcy5vbihldmVudCwgb24pO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8qKlxyXG5cdCAgICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuXHQgICAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG5cdCAgICpcclxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuXHQgICAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcblx0ICAgKiBAYXBpIHB1YmxpY1xyXG5cdCAgICovXG5cblx0ICBFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG5cdCAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cblx0ICAgIC8vIGFsbFxuXHQgICAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuXHQgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIC8vIHNwZWNpZmljIGV2ZW50XG5cdCAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblx0ICAgIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuXHQgICAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXHQgICAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuXHQgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG5cdCAgICB2YXIgY2I7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBjYiA9IGNhbGxiYWNrc1tpXTtcblx0ICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcblx0ICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLyoqXHJcblx0ICAgKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgICAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG5cdCAgICogQHJldHVybiB7RW1pdHRlcn1cclxuXHQgICAqL1xuXG5cdCAgRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG5cdCAgICAgICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuXHQgICAgaWYgKGNhbGxiYWNrcykge1xuXHQgICAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0ICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8qKlxyXG5cdCAgICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuXHQgICAqXHJcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgICAqIEByZXR1cm4ge0FycmF5fVxyXG5cdCAgICogQGFwaSBwdWJsaWNcclxuXHQgICAqL1xuXG5cdCAgRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdCAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcblx0ICB9O1xuXG5cdCAgLyoqXHJcblx0ICAgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcblx0ICAgKlxyXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcblx0ICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAgICogQGFwaSBwdWJsaWNcclxuXHQgICAqL1xuXG5cdCAgRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICByZXR1cm4gISF0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xuXHQgIH07XG5cdH0pO1xuXG5cdHZhciBjb21wb25lbnRFbWl0dGVyJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogY29tcG9uZW50RW1pdHRlcixcblx0XHRfX21vZHVsZUV4cG9ydHM6IGNvbXBvbmVudEVtaXR0ZXJcblx0fSk7XG5cblx0dmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cblx0dmFyIGlzYXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcblx0ICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cblx0dmFyIGlzYXJyYXkkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBpc2FycmF5LFxuXHRcdF9fbW9kdWxlRXhwb3J0czogaXNhcnJheVxuXHR9KTtcblxuXHR2YXIgaXNCdWZmZXIgPSBpc0J1ZjtcblxuXHR2YXIgd2l0aE5hdGl2ZUJ1ZmZlciA9IHR5cGVvZiBjb21tb25qc0dsb2JhbC5CdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbW1vbmpzR2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcblx0dmFyIHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBjb21tb25qc0dsb2JhbC5BcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcblxuXHR2YXIgaXNWaWV3ID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiYgdHlwZW9mIGNvbW1vbmpzR2xvYmFsLkFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgcmV0dXJuIGNvbW1vbmpzR2xvYmFsLkFycmF5QnVmZmVyLmlzVmlldztcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgcmV0dXJuIG9iai5idWZmZXIgaW5zdGFuY2VvZiBjb21tb25qc0dsb2JhbC5BcnJheUJ1ZmZlcjtcblx0ICAgIH07XG5cdCAgfVxuXHR9KCk7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBpc0J1ZihvYmopIHtcblx0ICByZXR1cm4gd2l0aE5hdGl2ZUJ1ZmZlciAmJiBjb21tb25qc0dsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSB8fCB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiYgKG9iaiBpbnN0YW5jZW9mIGNvbW1vbmpzR2xvYmFsLkFycmF5QnVmZmVyIHx8IGlzVmlldyhvYmopKTtcblx0fVxuXG5cdHZhciBpc0J1ZmZlciQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IGlzQnVmZmVyLFxuXHRcdF9fbW9kdWxlRXhwb3J0czogaXNCdWZmZXJcblx0fSk7XG5cblx0dmFyIGlzQXJyYXkgPSAoIGlzYXJyYXkkMSAmJiBpc2FycmF5ICkgfHwgaXNhcnJheSQxO1xuXG5cdHZhciBpc0J1ZiQxID0gKCBpc0J1ZmZlciQxICYmIGlzQnVmZmVyICkgfHwgaXNCdWZmZXIkMTtcblxuXHQvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG5cdCAqL1xuXG5cdHZhciB0b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsLkJsb2IgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmckMS5jYWxsKGNvbW1vbmpzR2xvYmFsLkJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcblx0dmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsLkZpbGUgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmckMS5jYWxsKGNvbW1vbmpzR2xvYmFsLkZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuXHQvKipcblx0ICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cblx0ICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuXHQgKiBoZXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHR2YXIgZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbiBkZWNvbnN0cnVjdFBhY2tldChwYWNrZXQpIHtcblx0ICB2YXIgYnVmZmVycyA9IFtdO1xuXHQgIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG5cdCAgdmFyIHBhY2sgPSBwYWNrZXQ7XG5cdCAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEsIGJ1ZmZlcnMpO1xuXHQgIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG5cdCAgcmV0dXJuIHsgcGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzIH07XG5cdH07XG5cblx0ZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcblx0ICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG5cdCAgaWYgKGlzQnVmJDEoZGF0YSkpIHtcblx0ICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG5cdCAgICBidWZmZXJzLnB1c2goZGF0YSk7XG5cdCAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG5cdCAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG5cdCAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXdEYXRhO1xuXHQgIH0gZWxzZSBpZiAoKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkYXRhKSkgPT09ICdvYmplY3QnICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG5cdCAgICB2YXIgbmV3RGF0YSA9IHt9O1xuXHQgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcblx0ICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3RGF0YTtcblx0ICB9XG5cdCAgcmV0dXJuIGRhdGE7XG5cdH1cblxuXHQvKipcblx0ICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdHZhciByZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uIHJlY29uc3RydWN0UGFja2V0KHBhY2tldCwgYnVmZmVycykge1xuXHQgIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcblx0ICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcblx0ICByZXR1cm4gcGFja2V0O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG5cdCAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuXHQgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG5cdCAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuXHQgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG5cdCAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBkYXRhO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuXHQgKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuXHQgKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHR2YXIgcmVtb3ZlQmxvYnMgPSBmdW5jdGlvbiByZW1vdmVCbG9icyhkYXRhLCBjYWxsYmFjaykge1xuXHQgIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuXHQgICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cblx0ICAgIC8vIGNvbnZlcnQgYW55IGJsb2Jcblx0ICAgIGlmICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iIHx8IHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpIHtcblx0ICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cblx0ICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuXHQgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdCAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG5cdCAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcblx0ICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcblx0ICAgICAgICBpZiAoISAtLXBlbmRpbmdCbG9icykge1xuXHQgICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cblx0ICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG5cdCAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkge1xuXHQgICAgICAvLyBoYW5kbGUgYXJyYXlcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKCh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSA9PT0gJ29iamVjdCcgJiYgIWlzQnVmJDEob2JqKSkge1xuXHQgICAgICAvLyBhbmQgb2JqZWN0XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0ICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuXHQgIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuXHQgIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuXHQgIGlmICghcGVuZGluZ0Jsb2JzKSB7XG5cdCAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgYmluYXJ5ID0ge1xuXHQgIGRlY29uc3RydWN0UGFja2V0OiBkZWNvbnN0cnVjdFBhY2tldCxcblx0ICByZWNvbnN0cnVjdFBhY2tldDogcmVjb25zdHJ1Y3RQYWNrZXQsXG5cdCAgcmVtb3ZlQmxvYnM6IHJlbW92ZUJsb2JzXG5cdH07XG5cblx0dmFyIGJpbmFyeSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IGJpbmFyeSxcblx0XHRfX21vZHVsZUV4cG9ydHM6IGJpbmFyeSxcblx0XHRkZWNvbnN0cnVjdFBhY2tldDogZGVjb25zdHJ1Y3RQYWNrZXQsXG5cdFx0cmVjb25zdHJ1Y3RQYWNrZXQ6IHJlY29uc3RydWN0UGFja2V0LFxuXHRcdHJlbW92ZUJsb2JzOiByZW1vdmVCbG9ic1xuXHR9KTtcblxuXHR2YXIgRW1pdHRlciA9ICggY29tcG9uZW50RW1pdHRlciQxICYmIGNvbXBvbmVudEVtaXR0ZXIgKSB8fCBjb21wb25lbnRFbWl0dGVyJDE7XG5cblx0dmFyIGJpbmFyeSQyID0gKCBiaW5hcnkkMSAmJiBiaW5hcnkgKSB8fCBiaW5hcnkkMTtcblxuXHR2YXIgc29ja2V0X2lvUGFyc2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQgIC8qKlxuXHQgICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAgICovXG5cblx0ICB2YXIgZGVidWcgPSByZXF1aXJlJCQwJDIoJ3NvY2tldC5pby1wYXJzZXInKTtcblxuXHQgIC8qKlxuXHQgICAqIFByb3RvY29sIHZlcnNpb24uXG5cdCAgICpcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cblx0ICAvKipcblx0ICAgKiBQYWNrZXQgdHlwZXMuXG5cdCAgICpcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZXhwb3J0cy50eXBlcyA9IFsnQ09OTkVDVCcsICdESVNDT05ORUNUJywgJ0VWRU5UJywgJ0FDSycsICdFUlJPUicsICdCSU5BUllfRVZFTlQnLCAnQklOQVJZX0FDSyddO1xuXG5cdCAgLyoqXG5cdCAgICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuXHQgICAqXG5cdCAgICogQGFwaSBwdWJsaWNcblx0ICAgKi9cblxuXHQgIGV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cblx0ICAvKipcblx0ICAgKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG5cdCAgICpcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuXHQgIC8qKlxuXHQgICAqIFBhY2tldCB0eXBlIGBldmVudGAuXG5cdCAgICpcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZXhwb3J0cy5FVkVOVCA9IDI7XG5cblx0ICAvKipcblx0ICAgKiBQYWNrZXQgdHlwZSBgYWNrYC5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBleHBvcnRzLkFDSyA9IDM7XG5cblx0ICAvKipcblx0ICAgKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuXHQgICAqXG5cdCAgICogQGFwaSBwdWJsaWNcblx0ICAgKi9cblxuXHQgIGV4cG9ydHMuRVJST1IgPSA0O1xuXG5cdCAgLyoqXG5cdCAgICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBleHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cblx0ICAvKipcblx0ICAgKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBleHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG5cdCAgLyoqXG5cdCAgICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBleHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG5cdCAgLyoqXG5cdCAgICogRGVjb2RlciBjb25zdHJ1Y3Rvci5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBleHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG5cdCAgLyoqXG5cdCAgICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuXHQgICAqXG5cdCAgICogQGFwaSBwdWJsaWNcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG5cdCAgdmFyIEVSUk9SX1BBQ0tFVCA9IGV4cG9ydHMuRVJST1IgKyAnXCJlbmNvZGUgZXJyb3JcIic7XG5cblx0ICAvKipcblx0ICAgKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcblx0ICAgKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBoYW5kbGUgZW5jb2RpbmdzIChsaWtlbHkgZW5naW5lLndyaXRlKVxuXHQgICAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3Ncblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcblx0ICAgIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcblx0ICAgICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuXHQgICAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAgICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG5cdCAgICogQGFwaSBwcml2YXRlXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcblxuXHQgICAgLy8gZmlyc3QgaXMgdHlwZVxuXHQgICAgdmFyIHN0ciA9ICcnICsgb2JqLnR5cGU7XG5cblx0ICAgIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuXHQgICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG5cdCAgICAgIHN0ciArPSBvYmouYXR0YWNobWVudHMgKyAnLSc7XG5cdCAgICB9XG5cblx0ICAgIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2Bcblx0ICAgIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuXHQgICAgaWYgKG9iai5uc3AgJiYgJy8nICE9PSBvYmoubnNwKSB7XG5cdCAgICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuXHQgICAgfVxuXG5cdCAgICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcblx0ICAgIGlmIChudWxsICE9IG9iai5pZCkge1xuXHQgICAgICBzdHIgKz0gb2JqLmlkO1xuXHQgICAgfVxuXG5cdCAgICAvLyBqc29uIGRhdGFcblx0ICAgIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG5cdCAgICAgIHZhciBwYXlsb2FkID0gdHJ5U3RyaW5naWZ5KG9iai5kYXRhKTtcblx0ICAgICAgaWYgKHBheWxvYWQgIT09IGZhbHNlKSB7XG5cdCAgICAgICAgc3RyICs9IHBheWxvYWQ7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIEVSUk9SX1BBQ0tFVDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcblx0ICAgIHJldHVybiBzdHI7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KHN0cikge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cik7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcblx0ICAgKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG5cdCAgICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAgICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG5cdCAgICogQGFwaSBwcml2YXRlXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cblx0ICAgIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG5cdCAgICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeSQyLmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG5cdCAgICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcblx0ICAgICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG5cdCAgICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3Rcblx0ICAgICAgY2FsbGJhY2soYnVmZmVycyk7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuXHQgICAgfVxuXG5cdCAgICBiaW5hcnkkMi5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2Vcblx0ICAgKlxuXHQgICAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBEZWNvZGVyKCkge1xuXHQgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cblx0ICAgKi9cblxuXHQgIEVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG5cdCAgLyoqXG5cdCAgICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG5cdCAgICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgdmFyIHBhY2tldDtcblx0ICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHQgICAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcblx0ICAgICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHBhY2tldC50eXBlKSB7XG5cdCAgICAgICAgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cblx0ICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG5cdCAgICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcblx0ICAgICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cyA9PT0gMCkge1xuXHQgICAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuXHQgICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoaXNCdWYkMShvYmopIHx8IG9iai5iYXNlNjQpIHtcblx0ICAgICAgLy8gcmF3IGJpbmFyeSBkYXRhXG5cdCAgICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXQnKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcblx0ICAgICAgICBpZiAocGFja2V0KSB7XG5cdCAgICAgICAgICAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcblx0ICAgICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG5cdCAgICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAgICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcblx0ICAgIHZhciBpID0gMDtcblx0ICAgIC8vIGxvb2sgdXAgdHlwZVxuXHQgICAgdmFyIHAgPSB7XG5cdCAgICAgIHR5cGU6IE51bWJlcihzdHIuY2hhckF0KDApKVxuXHQgICAgfTtcblxuXHQgICAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSB7XG5cdCAgICAgIHJldHVybiBlcnJvcigndW5rbm93biBwYWNrZXQgdHlwZSAnICsgcC50eXBlKTtcblx0ICAgIH1cblxuXHQgICAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuXHQgICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwLnR5cGUpIHtcblx0ICAgICAgdmFyIGJ1ZiA9ICcnO1xuXHQgICAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9PSAnLScpIHtcblx0ICAgICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcblx0ICAgICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcblx0ICAgICAgfVxuXHQgICAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT09ICctJykge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuXHQgICAgICB9XG5cdCAgICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcblx0ICAgIH1cblxuXHQgICAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcblx0ICAgIGlmICgnLycgPT09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG5cdCAgICAgIHAubnNwID0gJyc7XG5cdCAgICAgIHdoaWxlICgrK2kpIHtcblx0ICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG5cdCAgICAgICAgaWYgKCcsJyA9PT0gYykgYnJlYWs7XG5cdCAgICAgICAgcC5uc3AgKz0gYztcblx0ICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHAubnNwID0gJy8nO1xuXHQgICAgfVxuXG5cdCAgICAvLyBsb29rIHVwIGlkXG5cdCAgICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuXHQgICAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG5cdCAgICAgIHAuaWQgPSAnJztcblx0ICAgICAgd2hpbGUgKCsraSkge1xuXHQgICAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcblx0ICAgICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG5cdCAgICAgICAgICAtLWk7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuXHQgICAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcblx0ICAgICAgfVxuXHQgICAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBsb29rIHVwIGpzb24gZGF0YVxuXHQgICAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuXHQgICAgICB2YXIgcGF5bG9hZCA9IHRyeVBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuXHQgICAgICB2YXIgaXNQYXlsb2FkVmFsaWQgPSBwYXlsb2FkICE9PSBmYWxzZSAmJiAocC50eXBlID09PSBleHBvcnRzLkVSUk9SIHx8IGlzQXJyYXkocGF5bG9hZCkpO1xuXHQgICAgICBpZiAoaXNQYXlsb2FkVmFsaWQpIHtcblx0ICAgICAgICBwLmRhdGEgPSBwYXlsb2FkO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBlcnJvcignaW52YWxpZCBwYXlsb2FkJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuXHQgICAgcmV0dXJuIHA7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdHJ5UGFyc2Uoc3RyKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBEZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuXHQgICAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG5cdCAgICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcblx0ICAgKiBkZWNvZGVkLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgICAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3Jcblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG5cdCAgICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcblx0ICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cblx0ICAgKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuXHQgICAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG5cdCAgICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG5cdCAgICogQGFwaSBwcml2YXRlXG5cdCAgICovXG5cblx0ICBCaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uIChiaW5EYXRhKSB7XG5cdCAgICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcblx0ICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykge1xuXHQgICAgICAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3Rcblx0ICAgICAgdmFyIHBhY2tldCA9IGJpbmFyeSQyLnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuXHQgICAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcblx0ICAgICAgcmV0dXJuIHBhY2tldDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG5cdCAgICpcblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIEJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG5cdCAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gZXJyb3IobXNnKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuXHQgICAgICBkYXRhOiAncGFyc2VyIGVycm9yOiAnICsgbXNnXG5cdCAgICB9O1xuXHQgIH1cblx0fSk7XG5cdHZhciBzb2NrZXRfaW9QYXJzZXJfMSA9IHNvY2tldF9pb1BhcnNlci5wcm90b2NvbDtcblx0dmFyIHNvY2tldF9pb1BhcnNlcl8yID0gc29ja2V0X2lvUGFyc2VyLnR5cGVzO1xuXHR2YXIgc29ja2V0X2lvUGFyc2VyXzMgPSBzb2NrZXRfaW9QYXJzZXIuQ09OTkVDVDtcblx0dmFyIHNvY2tldF9pb1BhcnNlcl80ID0gc29ja2V0X2lvUGFyc2VyLkRJU0NPTk5FQ1Q7XG5cdHZhciBzb2NrZXRfaW9QYXJzZXJfNSA9IHNvY2tldF9pb1BhcnNlci5FVkVOVDtcblx0dmFyIHNvY2tldF9pb1BhcnNlcl82ID0gc29ja2V0X2lvUGFyc2VyLkFDSztcblx0dmFyIHNvY2tldF9pb1BhcnNlcl83ID0gc29ja2V0X2lvUGFyc2VyLkVSUk9SO1xuXHR2YXIgc29ja2V0X2lvUGFyc2VyXzggPSBzb2NrZXRfaW9QYXJzZXIuQklOQVJZX0VWRU5UO1xuXHR2YXIgc29ja2V0X2lvUGFyc2VyXzkgPSBzb2NrZXRfaW9QYXJzZXIuQklOQVJZX0FDSztcblx0dmFyIHNvY2tldF9pb1BhcnNlcl8xMCA9IHNvY2tldF9pb1BhcnNlci5FbmNvZGVyO1xuXHR2YXIgc29ja2V0X2lvUGFyc2VyXzExID0gc29ja2V0X2lvUGFyc2VyLkRlY29kZXI7XG5cblx0dmFyIHNvY2tldF9pb1BhcnNlciQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IHNvY2tldF9pb1BhcnNlcixcblx0XHRfX21vZHVsZUV4cG9ydHM6IHNvY2tldF9pb1BhcnNlcixcblx0XHRwcm90b2NvbDogc29ja2V0X2lvUGFyc2VyXzEsXG5cdFx0dHlwZXM6IHNvY2tldF9pb1BhcnNlcl8yLFxuXHRcdENPTk5FQ1Q6IHNvY2tldF9pb1BhcnNlcl8zLFxuXHRcdERJU0NPTk5FQ1Q6IHNvY2tldF9pb1BhcnNlcl80LFxuXHRcdEVWRU5UOiBzb2NrZXRfaW9QYXJzZXJfNSxcblx0XHRBQ0s6IHNvY2tldF9pb1BhcnNlcl82LFxuXHRcdEVSUk9SOiBzb2NrZXRfaW9QYXJzZXJfNyxcblx0XHRCSU5BUllfRVZFTlQ6IHNvY2tldF9pb1BhcnNlcl84LFxuXHRcdEJJTkFSWV9BQ0s6IHNvY2tldF9pb1BhcnNlcl85LFxuXHRcdEVuY29kZXI6IHNvY2tldF9pb1BhcnNlcl8xMCxcblx0XHREZWNvZGVyOiBzb2NrZXRfaW9QYXJzZXJfMTFcblx0fSk7XG5cblx0dmFyIGhhc0NvcnMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdCAgLyoqXG5cdCAgICogTW9kdWxlIGV4cG9ydHMuXG5cdCAgICpcblx0ICAgKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcblx0ICAgKlxuXHQgICAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuXHQgICAqL1xuXG5cdCAgdHJ5IHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0ICB9IGNhdGNoIChlcnIpIHtcblx0ICAgIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcblx0ICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBoYXNDb3JzJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogaGFzQ29ycyxcblx0XHRfX21vZHVsZUV4cG9ydHM6IGhhc0NvcnNcblx0fSk7XG5cblx0dmFyIGhhc0NPUlMgPSAoIGhhc0NvcnMkMSAmJiBoYXNDb3JzICkgfHwgaGFzQ29ycyQxO1xuXG5cdC8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG5cblxuXHR2YXIgeG1saHR0cHJlcXVlc3QgPSBmdW5jdGlvbiB4bWxodHRwcmVxdWVzdChvcHRzKSB7XG5cdCAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cblx0ICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3Rcblx0ICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG5cdCAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cblx0ICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuXHQgIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG5cdCAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG5cdCAgdHJ5IHtcblx0ICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuXHQgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgICB9XG5cdCAgfSBjYXRjaCAoZSkge31cblxuXHQgIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuXHQgIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG5cdCAgdHJ5IHtcblx0ICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUpIHt9XG5cblx0ICBpZiAoIXhkb21haW4pIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHJldHVybiBuZXcgY29tbW9uanNHbG9iYWxbWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKV0oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgIH1cblx0fTtcblxuXHR2YXIgeG1saHR0cHJlcXVlc3QkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiB4bWxodHRwcmVxdWVzdCxcblx0XHRfX21vZHVsZUV4cG9ydHM6IHhtbGh0dHByZXF1ZXN0XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMob2JqKSB7XG5cdCAgdmFyIGFyciA9IFtdO1xuXHQgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cdCAgZm9yICh2YXIgaSBpbiBvYmopIHtcblx0ICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG5cdCAgICAgIGFyci5wdXNoKGkpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gYXJyO1xuXHR9O1xuXG5cdHZhciBrZXlzJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDoga2V5cyxcblx0XHRfX21vZHVsZUV4cG9ydHM6IGtleXNcblx0fSk7XG5cblx0LyogZ2xvYmFsIEJsb2IgRmlsZSAqL1xuXG5cdC8qXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG5cdCAqL1xuXG5cdHZhciB0b1N0cmluZyQyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIHdpdGhOYXRpdmVCbG9iJDEgPSB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmckMi5jYWxsKEJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcblx0dmFyIHdpdGhOYXRpdmVGaWxlJDEgPSB0eXBlb2YgRmlsZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmckMi5jYWxsKEZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdHZhciBoYXNCaW5hcnkyID0gaGFzQmluYXJ5O1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuXHQgKlxuXHQgKiBTdXBwb3J0cyBCdWZmZXIsIEFycmF5QnVmZmVyLCBCbG9iIGFuZCBGaWxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gaGFzQmluYXJ5KG9iaikge1xuXHQgIGlmICghb2JqIHx8ICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSAhPT0gJ29iamVjdCcpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAoaXNBcnJheShvYmopKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgaWYgKGhhc0JpbmFyeShvYmpbaV0pKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgdHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IHdpdGhOYXRpdmVCbG9iJDEgJiYgb2JqIGluc3RhbmNlb2YgQmxvYiB8fCB3aXRoTmF0aXZlRmlsZSQxICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcblx0ICBpZiAob2JqLnRvSlNPTiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICByZXR1cm4gaGFzQmluYXJ5KG9iai50b0pTT04oKSwgdHJ1ZSk7XG5cdCAgfVxuXG5cdCAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgaGFzQmluYXJ5KG9ialtrZXldKSkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgaGFzQmluYXJ5MiQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IGhhc0JpbmFyeTIsXG5cdFx0X19tb2R1bGVFeHBvcnRzOiBoYXNCaW5hcnkyXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cblx0ICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0dmFyIGFycmF5YnVmZmVyX3NsaWNlID0gZnVuY3Rpb24gYXJyYXlidWZmZXJfc2xpY2UoYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcblx0ICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuXHQgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0ICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cblx0ICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHtcblx0ICAgIHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcblx0ICB9XG5cblx0ICBpZiAoc3RhcnQgPCAwKSB7XG5cdCAgICBzdGFydCArPSBieXRlcztcblx0ICB9XG5cdCAgaWYgKGVuZCA8IDApIHtcblx0ICAgIGVuZCArPSBieXRlcztcblx0ICB9XG5cdCAgaWYgKGVuZCA+IGJ5dGVzKSB7XG5cdCAgICBlbmQgPSBieXRlcztcblx0ICB9XG5cblx0ICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG5cdCAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuXHQgIH1cblxuXHQgIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cdCAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcblx0ICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG5cdCAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcblx0fTtcblxuXHR2YXIgYXJyYXlidWZmZXJfc2xpY2UkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBhcnJheWJ1ZmZlcl9zbGljZSxcblx0XHRfX21vZHVsZUV4cG9ydHM6IGFycmF5YnVmZmVyX3NsaWNlXG5cdH0pO1xuXG5cdHZhciBhZnRlcl8xID0gYWZ0ZXI7XG5cblx0ZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcblx0ICAgIHZhciBiYWlsID0gZmFsc2U7XG5cdCAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcDtcblx0ICAgIHByb3h5LmNvdW50ID0gY291bnQ7XG5cblx0ICAgIHJldHVybiBjb3VudCA9PT0gMCA/IGNhbGxiYWNrKCkgOiBwcm94eTtcblxuXHQgICAgZnVuY3Rpb24gcHJveHkoZXJyLCByZXN1bHQpIHtcblx0ICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAtLXByb3h5LmNvdW50O1xuXG5cdCAgICAgICAgLy8gYWZ0ZXIgZmlyc3QgZXJyb3IsIHJlc3QgYXJlIHBhc3NlZCB0byBlcnJfY2Jcblx0ICAgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgICAgIGJhaWwgPSB0cnVlO1xuXHQgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuXHQgICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuXHQgICAgICAgICAgICBjYWxsYmFjayA9IGVycl9jYjtcblx0ICAgICAgICB9IGVsc2UgaWYgKHByb3h5LmNvdW50ID09PSAwICYmICFiYWlsKSB7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblx0dmFyIGFmdGVyJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogYWZ0ZXJfMSxcblx0XHRfX21vZHVsZUV4cG9ydHM6IGFmdGVyXzFcblx0fSk7XG5cblx0dmFyIHV0ZjggPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdChmdW5jdGlvbiAocm9vdCkge1xuXG5cdFx0XHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdFx0XHR2YXIgZnJlZUV4cG9ydHMgPSBleHBvcnRzO1xuXG5cdFx0XHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHRcdFx0dmFyIGZyZWVNb2R1bGUgPSBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdFx0XHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHRcdFx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0XHRcdHZhciBmcmVlR2xvYmFsID0gX3R5cGVvZihjb21tb25qc0dsb2JhbCkgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWw7XG5cdFx0XHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRcdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdFx0XHR9XG5cblx0XHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdFx0XHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHRcdFx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0XHRcdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0XHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHRcdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0XHR2YXIgZXh0cmE7XG5cdFx0XHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRcdFx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdFx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpIHtcblx0XHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0XHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdFx0XHRcdHRocm93IEVycm9yKCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRcdFx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+IHNoaWZ0ICYgMHgzRiB8IDB4ODApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpIHtcblx0XHRcdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7XG5cdFx0XHRcdFx0Ly8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRcdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7XG5cdFx0XHRcdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCA+PiA2ICYgMHgxRiB8IDB4QzApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7XG5cdFx0XHRcdFx0Ly8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRcdFx0aWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuXHRcdFx0XHRcdFx0Y29kZVBvaW50ID0gMHhGRkZEO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+IDEyICYgMHgwRiB8IDB4RTApO1xuXHRcdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHtcblx0XHRcdFx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50ID4+IDE4ICYgMHgwNyB8IDB4RjApO1xuXHRcdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQgJiAweDNGIHwgMHg4MCk7XG5cdFx0XHRcdHJldHVybiBzeW1ib2w7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nLCBvcHRzKSB7XG5cdFx0XHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdFx0XHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdFx0XHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0XHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdFx0XHR2YXIgY29kZVBvaW50O1xuXHRcdFx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdFx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0XHRcdH1cblxuXHRcdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0XHRcdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdFx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdFx0XHRieXRlSW5kZXgrKztcblxuXHRcdFx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woc3RyaWN0KSB7XG5cdFx0XHRcdHZhciBieXRlMTtcblx0XHRcdFx0dmFyIGJ5dGUyO1xuXHRcdFx0XHR2YXIgYnl0ZTM7XG5cdFx0XHRcdHZhciBieXRlNDtcblx0XHRcdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdFx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRcdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0XHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0XHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdFx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0XHRcdHJldHVybiBieXRlMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0XHRjb2RlUG9pbnQgPSAoYnl0ZTEgJiAweDFGKSA8PCA2IHwgYnl0ZTI7XG5cdFx0XHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRcdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRcdGNvZGVQb2ludCA9IChieXRlMSAmIDB4MEYpIDw8IDEyIHwgYnl0ZTIgPDwgNiB8IGJ5dGUzO1xuXHRcdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkgPyBjb2RlUG9pbnQgOiAweEZGRkQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdFx0Y29kZVBvaW50ID0gKGJ5dGUxICYgMHgwNykgPDwgMHgxMiB8IGJ5dGUyIDw8IDB4MEMgfCBieXRlMyA8PCAweDA2IHwgYnl0ZTQ7XG5cdFx0XHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGJ5dGVBcnJheTtcblx0XHRcdHZhciBieXRlQ291bnQ7XG5cdFx0XHR2YXIgYnl0ZUluZGV4O1xuXHRcdFx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nLCBvcHRzKSB7XG5cdFx0XHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdFx0XHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdFx0XHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0XHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0XHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0XHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0XHRcdHZhciB0bXA7XG5cdFx0XHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKHN0cmljdCkpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRcdFx0dmFyIHV0ZjggPSB7XG5cdFx0XHRcdCd2ZXJzaW9uJzogJzIuMS4yJyxcblx0XHRcdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0XHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0XHRcdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0XHRcdGlmICh0eXBlb2YgdW5kZWZpbmVkID09ICdmdW5jdGlvbicgJiYgX3R5cGVvZih1bmRlZmluZWQuYW1kKSA9PSAnb2JqZWN0JyAmJiB1bmRlZmluZWQuYW1kKSB7XG5cdFx0XHRcdHVuZGVmaW5lZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0Zjg7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRcdFx0aWYgKGZyZWVNb2R1bGUpIHtcblx0XHRcdFx0XHQvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdFx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHRcdFx0fVxuXHRcdH0pKGNvbW1vbmpzR2xvYmFsKTtcblx0fSk7XG5cblx0dmFyIHV0ZjgkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiB1dGY4LFxuXHRcdF9fbW9kdWxlRXhwb3J0czogdXRmOFxuXHR9KTtcblxuXHR2YXIgYmFzZTY0QXJyYXlidWZmZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCAgLypcblx0ICAgKiBiYXNlNjQtYXJyYXlidWZmZXJcblx0ICAgKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG5cdCAgICpcblx0ICAgKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG5cdCAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXHQgICAqL1xuXHQgIChmdW5jdGlvbiAoKSB7XG5cblx0ICAgIHZhciBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuXG5cdCAgICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG5cdCAgICB2YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcblx0ICAgIH1cblxuXHQgICAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAoYXJyYXlidWZmZXIpIHtcblx0ICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuXHQgICAgICAgICAgaSxcblx0ICAgICAgICAgIGxlbiA9IGJ5dGVzLmxlbmd0aCxcblx0ICAgICAgICAgIGJhc2U2NCA9IFwiXCI7XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG5cdCAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuXHQgICAgICAgIGJhc2U2NCArPSBjaGFyc1soYnl0ZXNbaV0gJiAzKSA8PCA0IHwgYnl0ZXNbaSArIDFdID4+IDRdO1xuXHQgICAgICAgIGJhc2U2NCArPSBjaGFyc1soYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpICsgMl0gPj4gNl07XG5cdCAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChsZW4gJSAzID09PSAyKSB7XG5cdCAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcblx0ICAgICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG5cdCAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gYmFzZTY0O1xuXHQgICAgfTtcblxuXHQgICAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYmFzZTY0KSB7XG5cdCAgICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcblx0ICAgICAgICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsXG5cdCAgICAgICAgICBpLFxuXHQgICAgICAgICAgcCA9IDAsXG5cdCAgICAgICAgICBlbmNvZGVkMSxcblx0ICAgICAgICAgIGVuY29kZWQyLFxuXHQgICAgICAgICAgZW5jb2RlZDMsXG5cdCAgICAgICAgICBlbmNvZGVkNDtcblxuXHQgICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcblx0ICAgICAgICBidWZmZXJMZW5ndGgtLTtcblx0ICAgICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcblx0ICAgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuXHQgICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cdCAgICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuXHQgICAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAxKV07XG5cdCAgICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDIpXTtcblx0ICAgICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpICsgMyldO1xuXG5cdCAgICAgICAgYnl0ZXNbcCsrXSA9IGVuY29kZWQxIDw8IDIgfCBlbmNvZGVkMiA+PiA0O1xuXHQgICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDIgJiAxNSkgPDwgNCB8IGVuY29kZWQzID4+IDI7XG5cdCAgICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMyAmIDMpIDw8IDYgfCBlbmNvZGVkNCAmIDYzO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuXHQgICAgfTtcblx0ICB9KSgpO1xuXHR9KTtcblx0dmFyIGJhc2U2NEFycmF5YnVmZmVyXzEgPSBiYXNlNjRBcnJheWJ1ZmZlci5lbmNvZGU7XG5cdHZhciBiYXNlNjRBcnJheWJ1ZmZlcl8yID0gYmFzZTY0QXJyYXlidWZmZXIuZGVjb2RlO1xuXG5cdHZhciBiYXNlNjRBcnJheWJ1ZmZlciQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IGJhc2U2NEFycmF5YnVmZmVyLFxuXHRcdF9fbW9kdWxlRXhwb3J0czogYmFzZTY0QXJyYXlidWZmZXIsXG5cdFx0ZW5jb2RlOiBiYXNlNjRBcnJheWJ1ZmZlcl8xLFxuXHRcdGRlY29kZTogYmFzZTY0QXJyYXlidWZmZXJfMlxuXHR9KTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3Rcblx0ICovXG5cblx0dmFyIEJsb2JCdWlsZGVyID0gY29tbW9uanNHbG9iYWwuQmxvYkJ1aWxkZXIgfHwgY29tbW9uanNHbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgY29tbW9uanNHbG9iYWwuTVNCbG9iQnVpbGRlciB8fCBjb21tb25qc0dsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcblx0ICovXG5cblx0dmFyIGJsb2JTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcblx0ICAgIHJldHVybiBhLnNpemUgPT09IDI7XG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fSgpO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3Ncblx0ICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cblx0ICovXG5cblx0dmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgZnVuY3Rpb24gKCkge1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwgMl0pXSk7XG5cdCAgICByZXR1cm4gYi5zaXplID09PSAyO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH0oKTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG5cdCAqL1xuXG5cdHZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmQgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cblx0LyoqXG5cdCAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcblx0ICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG5cdCAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBjaHVuayA9IGFyeVtpXTtcblx0ICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHQgICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG5cdCAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxuXHQgICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcblx0ICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcblx0ICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcblx0ICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGFyeVtpXSA9IGJ1Zjtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdCAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG5cdCAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcblx0ICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuXHQgIH1cblxuXHQgIHJldHVybiBvcHRpb25zLnR5cGUgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG5cdH1cblx0ZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuXHQgIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblx0ICByZXR1cm4gbmV3IEJsb2IoYXJ5LCBvcHRpb25zIHx8IHt9KTtcblx0fVxuXHR2YXIgYmxvYiA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoYmxvYlN1cHBvcnRlZCkge1xuXHQgICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGNvbW1vbmpzR2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG5cdCAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xuXHQgICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXHR9KCk7XG5cblx0dmFyIGJsb2IkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBibG9iLFxuXHRcdF9fbW9kdWxlRXhwb3J0czogYmxvYlxuXHR9KTtcblxuXHR2YXIga2V5cyQyID0gKCBrZXlzJDEgJiYga2V5cyApIHx8IGtleXMkMTtcblxuXHR2YXIgaGFzQmluYXJ5JDEgPSAoIGhhc0JpbmFyeTIkMSAmJiBoYXNCaW5hcnkyICkgfHwgaGFzQmluYXJ5MiQxO1xuXG5cdHZhciBzbGljZUJ1ZmZlciA9ICggYXJyYXlidWZmZXJfc2xpY2UkMSAmJiBhcnJheWJ1ZmZlcl9zbGljZSApIHx8IGFycmF5YnVmZmVyX3NsaWNlJDE7XG5cblx0dmFyIGFmdGVyJDIgPSAoIGFmdGVyJDEgJiYgYWZ0ZXJfMSApIHx8IGFmdGVyJDE7XG5cblx0dmFyIHV0ZjgkMiA9ICggdXRmOCQxICYmIHV0ZjggKSB8fCB1dGY4JDE7XG5cblx0dmFyIHJlcXVpcmUkJDAkMyA9ICggYmFzZTY0QXJyYXlidWZmZXIkMSAmJiBiYXNlNjRBcnJheWJ1ZmZlciApIHx8IGJhc2U2NEFycmF5YnVmZmVyJDE7XG5cblx0dmFyIEJsb2IkMSA9ICggYmxvYiQxICYmIGJsb2IgKSB8fCBibG9iJDE7XG5cblx0dmFyIGJyb3dzZXIkMiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0ICAvKipcblx0ICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgICAqL1xuXG5cdCAgdmFyIGJhc2U2NGVuY29kZXI7XG5cdCAgaWYgKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLkFycmF5QnVmZmVyKSB7XG5cdCAgICBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSQkMCQzO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2Vcblx0ICAgKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuXHQgICAqXG5cdCAgICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cblx0ICAgKi9cblxuXHQgIHZhciBpc0FuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0ICAvKipcblx0ICAgKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG5cdCAgICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcblx0ICAgKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuXHQgICAqIEB0eXBlIGJvb2xlYW5cblx0ICAgKi9cblx0ICB2YXIgaXNQaGFudG9tSlMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuXHQgIC8qKlxuXHQgICAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cblx0ICAgKiBAdHlwZSBib29sZWFuXG5cdCAgICovXG5cdCAgdmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cblx0ICAvKipcblx0ICAgKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG5cdCAgICovXG5cblx0ICBleHBvcnRzLnByb3RvY29sID0gMztcblxuXHQgIC8qKlxuXHQgICAqIFBhY2tldCB0eXBlcy5cblx0ICAgKi9cblxuXHQgIHZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuXHQgICAgb3BlbjogMCAvLyBub24td3Ncblx0ICAgICwgY2xvc2U6IDEgLy8gbm9uLXdzXG5cdCAgICAsIHBpbmc6IDIsXG5cdCAgICBwb25nOiAzLFxuXHQgICAgbWVzc2FnZTogNCxcblx0ICAgIHVwZ3JhZGU6IDUsXG5cdCAgICBub29wOiA2XG5cdCAgfTtcblxuXHQgIHZhciBwYWNrZXRzbGlzdCA9IGtleXMkMihwYWNrZXRzKTtcblxuXHQgIC8qKlxuXHQgICAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuXHQgICAqL1xuXG5cdCAgdmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuXHQgICAqL1xuXG5cdCAgLyoqXG5cdCAgICogRW5jb2RlcyBhIHBhY2tldC5cblx0ICAgKlxuXHQgICAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cblx0ICAgKlxuXHQgICAqIEV4YW1wbGU6XG5cdCAgICpcblx0ICAgKiAgICAgNWhlbGxvIHdvcmxkXG5cdCAgICogICAgIDNcblx0ICAgKiAgICAgNFxuXHQgICAqXG5cdCAgICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuXHQgICAqXG5cdCAgICogQGFwaSBwcml2YXRlXG5cdCAgICovXG5cblx0ICBleHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuXHQgICAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuXHQgICAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuXHQgICAgICB1dGY4ZW5jb2RlID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG5cdCAgICBpZiAoY29tbW9uanNHbG9iYWwuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdCAgICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG5cdCAgICB9IGVsc2UgaWYgKEJsb2IkMSAmJiBkYXRhIGluc3RhbmNlb2YgY29tbW9uanNHbG9iYWwuQmxvYikge1xuXHQgICAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG5cdCAgICB9XG5cblx0ICAgIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuXHQgICAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcblx0ICAgICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICAgIH1cblxuXHQgICAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG5cdCAgICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG5cdCAgICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG5cdCAgICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuXHQgICAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4JDIuZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSksIHsgc3RyaWN0OiBmYWxzZSB9KSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuXHQgICAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuXHQgICAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcblx0ICAgIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICAgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuXHQgICAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuXHQgICAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG5cdCAgICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHJlc3VsdEJ1ZmZlcltpICsgMV0gPSBjb250ZW50QXJyYXlbaV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgICAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuXHQgICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdCAgICBmci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuXHQgICAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG5cdCAgICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG5cdCAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcblx0ICAgICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuXHQgICAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cdCAgICB2YXIgYmxvYiA9IG5ldyBCbG9iJDEoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cblx0ICAgIHJldHVybiBjYWxsYmFjayhibG9iKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcblx0ICAgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2Vcblx0ICAgKi9cblxuXHQgIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgY2FsbGJhY2spIHtcblx0ICAgIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcblx0ICAgIGlmIChCbG9iJDEgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBjb21tb25qc0dsb2JhbC5CbG9iKSB7XG5cdCAgICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdCAgICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG5cdCAgICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG5cdCAgICAgIH07XG5cdCAgICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGI2NGRhdGE7XG5cdCAgICB0cnkge1xuXHQgICAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuXHQgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG5cdCAgICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcblx0ICAgICAgfVxuXHQgICAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG5cdCAgICB9XG5cdCAgICBtZXNzYWdlICs9IGNvbW1vbmpzR2xvYmFsLmJ0b2EoYjY0ZGF0YSk7XG5cdCAgICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG5cdCAgfTtcblxuXHQgIC8qKlxuXHQgICAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuXHQgICAqXG5cdCAgICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG5cdCAgICogQGFwaSBwcml2YXRlXG5cdCAgICovXG5cblx0ICBleHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG5cdCAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHJldHVybiBlcnI7XG5cdCAgICB9XG5cdCAgICAvLyBTdHJpbmcgZGF0YVxuXHQgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuXHQgICAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT09ICdiJykge1xuXHQgICAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodXRmOGRlY29kZSkge1xuXHQgICAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG5cdCAgICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICByZXR1cm4gZXJyO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG5cdCAgICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcblx0ICAgICAgICByZXR1cm4gZXJyO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuXHQgICAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcblx0ICAgIHZhciB0eXBlID0gYXNBcnJheVswXTtcblx0ICAgIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG5cdCAgICBpZiAoQmxvYiQxICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuXHQgICAgICByZXN0ID0gbmV3IEJsb2IkMShbcmVzdF0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIGRhdGEgPSB1dGY4JDIuZGVjb2RlKGRhdGEsIHsgc3RyaWN0OiBmYWxzZSB9KTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGRhdGE7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuXHQgICAqXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2Vcblx0ICAgKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcblx0ICAgKi9cblxuXHQgIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24gKG1zZywgYmluYXJ5VHlwZSkge1xuXHQgICAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcblx0ICAgIGlmICghYmFzZTY0ZW5jb2Rlcikge1xuXHQgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG5cdCAgICB9XG5cblx0ICAgIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cblx0ICAgIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYiQxKSB7XG5cdCAgICAgIGRhdGEgPSBuZXcgQmxvYiQxKFtkYXRhXSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG5cdCAgICpcblx0ICAgKiAgICAgPGxlbmd0aD46ZGF0YVxuXHQgICAqXG5cdCAgICogRXhhbXBsZTpcblx0ICAgKlxuXHQgICAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcblx0ICAgKlxuXHQgICAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG5cdCAgICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG5cdCAgICogQGFwaSBwcml2YXRlXG5cdCAgICovXG5cblx0ICBleHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG5cdCAgICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG5cdCAgICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5JDEocGFja2V0cyk7XG5cblx0ICAgIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuXHQgICAgICBpZiAoQmxvYiQxICYmICFkb250U2VuZEJsb2JzKSB7XG5cdCAgICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghcGFja2V0cy5sZW5ndGgpIHtcblx0ICAgICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuXHQgICAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcblx0ICAgICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCBmYWxzZSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0ICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcblx0ICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIC8qKlxuXHQgICAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcblx0ICAgIHZhciBuZXh0ID0gYWZ0ZXIkMihhcnkubGVuZ3RoLCBkb25lKTtcblxuXHQgICAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbiBlYWNoV2l0aEluZGV4KGksIGVsLCBjYikge1xuXHQgICAgICBlYWNoKGVsLCBmdW5jdGlvbiAoZXJyb3IsIG1zZykge1xuXHQgICAgICAgIHJlc3VsdFtpXSA9IG1zZztcblx0ICAgICAgICBjYihlcnJvciwgcmVzdWx0KTtcblx0ICAgICAgfSk7XG5cdCAgICB9O1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLypcblx0ICAgKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcblx0ICAgKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG5cdCAgICogQGFwaSBwdWJsaWNcblx0ICAgKi9cblxuXHQgIGV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuXHQgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuXHQgICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuXHQgICAgICBiaW5hcnlUeXBlID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgdmFyIHBhY2tldDtcblx0ICAgIGlmIChkYXRhID09PSAnJykge1xuXHQgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbGVuZ3RoID0gJycsXG5cdCAgICAgICAgbixcblx0ICAgICAgICBtc2c7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG5cdCAgICAgIGlmIChjaHIgIT09ICc6Jykge1xuXHQgICAgICAgIGxlbmd0aCArPSBjaHI7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobGVuZ3RoID09PSAnJyB8fCBsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpIHtcblx0ICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cblx0ICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG5cdCAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuXHQgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcblx0ICAgICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIGZhbHNlKTtcblxuXHQgICAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG5cdCAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG5cdCAgICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIGFkdmFuY2UgY3Vyc29yXG5cdCAgICAgIGkgKz0gbjtcblx0ICAgICAgbGVuZ3RoID0gJyc7XG5cdCAgICB9XG5cblx0ICAgIGlmIChsZW5ndGggIT09ICcnKSB7XG5cdCAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcblx0ICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8qKlxuXHQgICAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cblx0ICAgKlxuXHQgICAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcblx0ICAgKiAyNTU+PGRhdGE+XG5cdCAgICpcblx0ICAgKiBFeGFtcGxlOlxuXHQgICAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG5cdCAgICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChwYWNrZXRzLCBjYWxsYmFjaykge1xuXHQgICAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuXHQgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG5cdCAgICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24gKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcblx0ICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHApIHtcblx0ICAgICAgICB2YXIgbGVuO1xuXHQgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG5cdCAgICAgIH0sIDApO1xuXG5cdCAgICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuXHQgICAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuXHQgICAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG5cdCAgICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuXHQgICAgICAgIHZhciBhYiA9IHA7XG5cdCAgICAgICAgaWYgKGlzU3RyaW5nKSB7XG5cdCAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoaXNTdHJpbmcpIHtcblx0ICAgICAgICAgIC8vIG5vdCB0cnVlIGJpbmFyeVxuXHQgICAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAvLyB0cnVlIGJpbmFyeVxuXHQgICAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cblx0ICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIC8qKlxuXHQgICAqIEVuY29kZSBhcyBCbG9iXG5cdCAgICovXG5cblx0ICBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbiAocGFja2V0cywgY2FsbGJhY2spIHtcblx0ICAgIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuXHQgICAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChlbmNvZGVkKSB7XG5cdCAgICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcblx0ICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcblx0ICAgICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuXHQgICAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGxlbiA9IGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGVuY29kZWQuYnl0ZUxlbmd0aCA6IGVuY29kZWQuc2l6ZTtcblxuXHQgICAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcblx0ICAgICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cblx0ICAgICAgICBpZiAoQmxvYiQxKSB7XG5cdCAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iJDEoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG5cdCAgICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuXHQgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IkMShyZXN1bHRzKSk7XG5cdCAgICB9KTtcblx0ICB9O1xuXG5cdCAgLypcblx0ICAgKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcblx0ICAgKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG5cdCAgICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2Rcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcblx0ICAgIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG5cdCAgICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG5cdCAgICB2YXIgYnVmZmVycyA9IFtdO1xuXG5cdCAgICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuXHQgICAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG5cdCAgICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcblx0ICAgICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAxOzsgaSsrKSB7XG5cdCAgICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PT0gMjU1KSBicmVhaztcblxuXHQgICAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcblx0ICAgICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuXHQgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG5cdCAgICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cblx0ICAgICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG5cdCAgICAgIGlmIChpc1N0cmluZykge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuXHQgICAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcblx0ICAgICAgICAgIG1zZyA9ICcnO1xuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgYnVmZmVycy5wdXNoKG1zZyk7XG5cdCAgICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcblx0ICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyLCBpKSB7XG5cdCAgICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcblx0ICAgIH0pO1xuXHQgIH07XG5cdH0pO1xuXHR2YXIgYnJvd3Nlcl8xJDEgPSBicm93c2VyJDIucHJvdG9jb2w7XG5cdHZhciBicm93c2VyXzIkMSA9IGJyb3dzZXIkMi5wYWNrZXRzO1xuXHR2YXIgYnJvd3Nlcl8zJDEgPSBicm93c2VyJDIuZW5jb2RlUGFja2V0O1xuXHR2YXIgYnJvd3Nlcl80JDEgPSBicm93c2VyJDIuZW5jb2RlQmFzZTY0UGFja2V0O1xuXHR2YXIgYnJvd3Nlcl81JDEgPSBicm93c2VyJDIuZGVjb2RlUGFja2V0O1xuXHR2YXIgYnJvd3Nlcl82JDEgPSBicm93c2VyJDIuZGVjb2RlQmFzZTY0UGFja2V0O1xuXHR2YXIgYnJvd3Nlcl83JDEgPSBicm93c2VyJDIuZW5jb2RlUGF5bG9hZDtcblx0dmFyIGJyb3dzZXJfOCA9IGJyb3dzZXIkMi5kZWNvZGVQYXlsb2FkO1xuXHR2YXIgYnJvd3Nlcl85ID0gYnJvd3NlciQyLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyO1xuXHR2YXIgYnJvd3Nlcl8xMCA9IGJyb3dzZXIkMi5lbmNvZGVQYXlsb2FkQXNCbG9iO1xuXHR2YXIgYnJvd3Nlcl8xMSA9IGJyb3dzZXIkMi5kZWNvZGVQYXlsb2FkQXNCaW5hcnk7XG5cblx0dmFyIGJyb3dzZXIkMyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBicm93c2VyJDIsXG5cdFx0X19tb2R1bGVFeHBvcnRzOiBicm93c2VyJDIsXG5cdFx0cHJvdG9jb2w6IGJyb3dzZXJfMSQxLFxuXHRcdHBhY2tldHM6IGJyb3dzZXJfMiQxLFxuXHRcdGVuY29kZVBhY2tldDogYnJvd3Nlcl8zJDEsXG5cdFx0ZW5jb2RlQmFzZTY0UGFja2V0OiBicm93c2VyXzQkMSxcblx0XHRkZWNvZGVQYWNrZXQ6IGJyb3dzZXJfNSQxLFxuXHRcdGRlY29kZUJhc2U2NFBhY2tldDogYnJvd3Nlcl82JDEsXG5cdFx0ZW5jb2RlUGF5bG9hZDogYnJvd3Nlcl83JDEsXG5cdFx0ZGVjb2RlUGF5bG9hZDogYnJvd3Nlcl84LFxuXHRcdGVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyOiBicm93c2VyXzksXG5cdFx0ZW5jb2RlUGF5bG9hZEFzQmxvYjogYnJvd3Nlcl8xMCxcblx0XHRkZWNvZGVQYXlsb2FkQXNCaW5hcnk6IGJyb3dzZXJfMTFcblx0fSk7XG5cblx0dmFyIHBhcnNlciA9ICggYnJvd3NlciQzICYmIGJyb3dzZXIkMiApIHx8IGJyb3dzZXIkMztcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHR2YXIgdHJhbnNwb3J0ID0gVHJhbnNwb3J0O1xuXG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gVHJhbnNwb3J0KG9wdHMpIHtcblx0ICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG5cdCAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG5cdCAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuXHQgIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG5cdCAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG5cdCAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG5cdCAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG5cdCAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcblx0ICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuXHQgIHRoaXMua2V5ID0gb3B0cy5rZXk7XG5cdCAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuXHQgIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcblx0ICB0aGlzLmNhID0gb3B0cy5jYTtcblx0ICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG5cdCAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0ICB0aGlzLmZvcmNlTm9kZSA9IG9wdHMuZm9yY2VOb2RlO1xuXG5cdCAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXHQgIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG5cdH1cblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogRW1pdHMgYW4gZXJyb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuXHQgIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcblx0ICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG5cdCAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblx0ICAgIHRoaXMuZG9PcGVuKCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIHRoaXMuZG9DbG9zZSgpO1xuXHQgICAgdGhpcy5vbkNsb3NlKCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG5cdCAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gb3BlblxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXHQgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXHQgIHRoaXMuZW1pdCgnb3BlbicpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2l0aCBkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuXHQgIHRoaXMub25QYWNrZXQocGFja2V0KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMuZW1pdCgnY2xvc2UnKTtcblx0fTtcblxuXHR2YXIgdHJhbnNwb3J0JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogdHJhbnNwb3J0LFxuXHRcdF9fbW9kdWxlRXhwb3J0czogdHJhbnNwb3J0XG5cdH0pO1xuXG5cdC8qKlxyXG5cdCAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcclxuXHQgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH1cclxuXHQgKiBAYXBpIHByaXZhdGVcclxuXHQgKi9cblxuXHR2YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG9iaikge1xuXHQgIHZhciBzdHIgPSAnJztcblxuXHQgIGZvciAodmFyIGkgaW4gb2JqKSB7XG5cdCAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdCAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuXHQgICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHN0cjtcblx0fTtcblxuXHQvKipcclxuXHQgKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBxc1xyXG5cdCAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAqL1xuXG5cdHZhciBkZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocXMpIHtcblx0ICB2YXIgcXJ5ID0ge307XG5cdCAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHQgICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuXHQgICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG5cdCAgfVxuXHQgIHJldHVybiBxcnk7XG5cdH07XG5cblx0dmFyIHBhcnNlcXMgPSB7XG5cdCAgZW5jb2RlOiBlbmNvZGUsXG5cdCAgZGVjb2RlOiBkZWNvZGVcblx0fTtcblxuXHR2YXIgcGFyc2VxcyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IHBhcnNlcXMsXG5cdFx0X19tb2R1bGVFeHBvcnRzOiBwYXJzZXFzLFxuXHRcdGVuY29kZTogZW5jb2RlLFxuXHRcdGRlY29kZTogZGVjb2RlXG5cdH0pO1xuXG5cdHZhciBjb21wb25lbnRJbmhlcml0ID0gZnVuY3Rpb24gY29tcG9uZW50SW5oZXJpdChhLCBiKSB7XG5cdCAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7fTtcblx0ICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcblx0ICBhLnByb3RvdHlwZSA9IG5ldyBmbigpO1xuXHQgIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcblx0fTtcblxuXHR2YXIgY29tcG9uZW50SW5oZXJpdCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IGNvbXBvbmVudEluaGVyaXQsXG5cdFx0X19tb2R1bGVFeHBvcnRzOiBjb21wb25lbnRJbmhlcml0XG5cdH0pO1xuXG5cdHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJyksXG5cdCAgICBsZW5ndGggPSA2NCxcblx0ICAgIG1hcCA9IHt9LFxuXHQgICAgc2VlZCA9IDAsXG5cdCAgICBpID0gMCxcblx0ICAgIHByZXY7XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUkMShudW0pIHtcblx0ICB2YXIgZW5jb2RlZCA9ICcnO1xuXG5cdCAgZG8ge1xuXHQgICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuXHQgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuXHQgIH0gd2hpbGUgKG51bSA+IDApO1xuXG5cdCAgcmV0dXJuIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZSQxKHN0cikge1xuXHQgIHZhciBkZWNvZGVkID0gMDtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcblx0ICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuXHQgIH1cblxuXHQgIHJldHVybiBkZWNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24geWVhc3QoKSB7XG5cdCAgdmFyIG5vdyA9IGVuY29kZSQxKCtuZXcgRGF0ZSgpKTtcblxuXHQgIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcblx0ICByZXR1cm4gbm93ICsgJy4nICsgZW5jb2RlJDEoc2VlZCsrKTtcblx0fVxuXG5cdC8vXG5cdC8vIE1hcCBlYWNoIGNoYXJhY3RlciB0byBpdHMgaW5kZXguXG5cdC8vXG5cdGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblx0fSAvL1xuXHQvLyBFeHBvc2UgdGhlIGB5ZWFzdGAsIGBlbmNvZGVgIGFuZCBgZGVjb2RlYCBmdW5jdGlvbnMuXG5cdC8vXG5cdHllYXN0LmVuY29kZSA9IGVuY29kZSQxO1xuXHR5ZWFzdC5kZWNvZGUgPSBkZWNvZGUkMTtcblx0dmFyIHllYXN0XzEgPSB5ZWFzdDtcblxuXHR2YXIgeWVhc3QkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiB5ZWFzdF8xLFxuXHRcdF9fbW9kdWxlRXhwb3J0czogeWVhc3RfMVxuXHR9KTtcblxuXHR2YXIgVHJhbnNwb3J0JDEgPSAoIHRyYW5zcG9ydCQxICYmIHRyYW5zcG9ydCApIHx8IHRyYW5zcG9ydCQxO1xuXG5cdHZhciBwYXJzZXFzJDIgPSAoIHBhcnNlcXMkMSAmJiBwYXJzZXFzICkgfHwgcGFyc2VxcyQxO1xuXG5cdHZhciBpbmhlcml0ID0gKCBjb21wb25lbnRJbmhlcml0JDEgJiYgY29tcG9uZW50SW5oZXJpdCApIHx8IGNvbXBvbmVudEluaGVyaXQkMTtcblxuXHR2YXIgeWVhc3QkMiA9ICggeWVhc3QkMSAmJiB5ZWFzdF8xICkgfHwgeWVhc3QkMTtcblxuXHR2YXIgcmVxdWlyZSQkMSA9ICggeG1saHR0cHJlcXVlc3QkMSAmJiB4bWxodHRwcmVxdWVzdCApIHx8IHhtbGh0dHByZXF1ZXN0JDE7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBkZWJ1ZyQzID0gcmVxdWlyZSQkMCQyKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdHZhciBwb2xsaW5nID0gUG9sbGluZztcblxuXHQvKipcblx0ICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG5cdCAqL1xuXG5cdHZhciBoYXNYSFIyID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUkJDE7XG5cdCAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuXHQgIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG5cdH0oKTtcblxuXHQvKipcblx0ICogUG9sbGluZyBpbnRlcmZhY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBQb2xsaW5nKG9wdHMpIHtcblx0ICB2YXIgZm9yY2VCYXNlNjQgPSBvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQ7XG5cdCAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG5cdCAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXHQgIFRyYW5zcG9ydCQxLmNhbGwodGhpcywgb3B0cyk7XG5cdH1cblxuXHQvKipcblx0ICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG5cdCAqL1xuXG5cdGluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0JDEpO1xuXG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgbmFtZS5cblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuXHQvKipcblx0ICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuXHQgKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLnBvbGwoKTtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIHBvbGxpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAob25QYXVzZSkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuXHQgIGZ1bmN0aW9uIHBhdXNlKCkge1xuXHQgICAgZGVidWckMygncGF1c2VkJyk7XG5cdCAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcblx0ICAgIG9uUGF1c2UoKTtcblx0ICB9XG5cblx0ICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG5cdCAgICB2YXIgdG90YWwgPSAwO1xuXG5cdCAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG5cdCAgICAgIGRlYnVnJDMoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcblx0ICAgICAgdG90YWwrKztcblx0ICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZGVidWckMygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcblx0ICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcblx0ICAgICAgZGVidWckMygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuXHQgICAgICB0b3RhbCsrO1xuXHQgICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGRlYnVnJDMoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG5cdCAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgcGF1c2UoKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRQb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuXHQgIGRlYnVnJDMoJ3BvbGxpbmcnKTtcblx0ICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuXHQgIHRoaXMuZG9Qb2xsKCk7XG5cdCAgdGhpcy5lbWl0KCdwb2xsJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgZGVidWckMygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuXHQgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG5cdCAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG5cdCAgICBpZiAoJ29wZW5pbmcnID09PSBzZWxmLnJlYWR5U3RhdGUpIHtcblx0ICAgICAgc2VsZi5vbk9wZW4oKTtcblx0ICAgIH1cblxuXHQgICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuXHQgICAgaWYgKCdjbG9zZScgPT09IHBhY2tldC50eXBlKSB7XG5cdCAgICAgIHNlbGYub25DbG9zZSgpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2Vcblx0ICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcblx0ICB9O1xuXG5cdCAgLy8gZGVjb2RlIHBheWxvYWRcblx0ICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cblx0ICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuXHQgIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuXHQgICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG5cdCAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG5cdCAgICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgICAgdGhpcy5wb2xsKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZWJ1ZyQzKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgZnVuY3Rpb24gY2xvc2UoKSB7XG5cdCAgICBkZWJ1ZyQzKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuXHQgICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcblx0ICB9XG5cblx0ICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIGRlYnVnJDMoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuXHQgICAgY2xvc2UoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcblx0ICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG5cdCAgICBkZWJ1ZyQzKCd0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2UnKTtcblx0ICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRQb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblx0ICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uIGNhbGxiYWNrZm4oKSB7XG5cdCAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcblx0ICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcblx0ICB9O1xuXG5cdCAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcblx0ICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXHQgIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG5cdCAgdmFyIHBvcnQgPSAnJztcblxuXHQgIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG5cdCAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG5cdCAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0JDIoKTtcblx0ICB9XG5cblx0ICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuXHQgICAgcXVlcnkuYjY0ID0gMTtcblx0ICB9XG5cblx0ICBxdWVyeSA9IHBhcnNlcXMkMi5lbmNvZGUocXVlcnkpO1xuXG5cdCAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcblx0ICBpZiAodGhpcy5wb3J0ICYmICgnaHR0cHMnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MyB8fCAnaHR0cCcgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSB7XG5cdCAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuXHQgIH1cblxuXHQgIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuXHQgIGlmIChxdWVyeS5sZW5ndGgpIHtcblx0ICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG5cdCAgfVxuXG5cdCAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG5cdCAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG5cdH07XG5cblx0dmFyIHBvbGxpbmckMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBwb2xsaW5nLFxuXHRcdF9fbW9kdWxlRXhwb3J0czogcG9sbGluZ1xuXHR9KTtcblxuXHR2YXIgUG9sbGluZyQxID0gKCBwb2xsaW5nJDEgJiYgcG9sbGluZyApIHx8IHBvbGxpbmckMTtcblxuXHQvKipcblx0ICogTW9kdWxlIHJlcXVpcmVtZW50cy5cblx0ICovXG5cblx0dmFyIGRlYnVnJDQgPSByZXF1aXJlJCQwJDIoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdHZhciBwb2xsaW5nWGhyID0gWEhSO1xuXHR2YXIgUmVxdWVzdF8xID0gUmVxdWVzdDtcblxuXHQvKipcblx0ICogRW1wdHkgZnVuY3Rpb25cblx0ICovXG5cblx0ZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG5cdC8qKlxuXHQgKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gWEhSKG9wdHMpIHtcblx0ICBQb2xsaW5nJDEuY2FsbCh0aGlzLCBvcHRzKTtcblx0ICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcblx0ICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG5cdCAgaWYgKGNvbW1vbmpzR2xvYmFsLmxvY2F0aW9uKSB7XG5cdCAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG5cdCAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cblx0ICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcblx0ICAgIGlmICghcG9ydCkge1xuXHQgICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGNvbW1vbmpzR2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT09IG9wdHMucG9ydDtcblx0ICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cblx0ICovXG5cblx0aW5oZXJpdChYSFIsIFBvbGxpbmckMSk7XG5cblx0LyoqXG5cdCAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcblx0ICovXG5cblx0WEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRYSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cykge1xuXHQgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHQgIG9wdHMudXJpID0gdGhpcy51cmkoKTtcblx0ICBvcHRzLnhkID0gdGhpcy54ZDtcblx0ICBvcHRzLnhzID0gdGhpcy54cztcblx0ICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcblx0ICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcblx0ICBvcHRzLmVuYWJsZXNYRFIgPSB0aGlzLmVuYWJsZXNYRFI7XG5cblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuXHQgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG5cdCAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuXHQgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcblx0ICBvcHRzLmNhID0gdGhpcy5jYTtcblx0ICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG5cdCAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0ICBvcHRzLnJlcXVlc3RUaW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcblxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuXHQgIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcblx0fTtcblxuXHQvKipcblx0ICogU2VuZHMgZGF0YS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRYSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcblx0ICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuXHQgIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG5cdCAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuXHQgIH0pO1xuXHQgIHRoaXMuc2VuZFhociA9IHJlcTtcblx0fTtcblxuXHQvKipcblx0ICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuXHQgIGRlYnVnJDQoJ3hociBwb2xsJyk7XG5cdCAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgc2VsZi5vbkRhdGEoZGF0YSk7XG5cdCAgfSk7XG5cdCAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuXHQgIH0pO1xuXHQgIHRoaXMucG9sbFhociA9IHJlcTtcblx0fTtcblxuXHQvKipcblx0ICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBSZXF1ZXN0KG9wdHMpIHtcblx0ICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuXHQgIHRoaXMudXJpID0gb3B0cy51cmk7XG5cdCAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcblx0ICB0aGlzLnhzID0gISFvcHRzLnhzO1xuXHQgIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcblx0ICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT09IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG5cdCAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG5cdCAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG5cdCAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG5cdCAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXHQgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeDtcblx0ICB0aGlzLmtleSA9IG9wdHMua2V5O1xuXHQgIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG5cdCAgdGhpcy5jYSA9IG9wdHMuY2E7XG5cdCAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cblx0ICB0aGlzLmNyZWF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgb3B0cy5wZnggPSB0aGlzLnBmeDtcblx0ICBvcHRzLmtleSA9IHRoaXMua2V5O1xuXHQgIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcblx0ICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG5cdCAgb3B0cy5jYSA9IHRoaXMuY2E7XG5cdCAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuXHQgIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgcmVxdWlyZSQkMShvcHRzKTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICB0cnkge1xuXHQgICAgZGVidWckNCgneGhyIG9wZW4gJXM6ICVzJywgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcblx0ICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG5cdCAgICB0cnkge1xuXHQgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcblx0ICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmV4dHJhSGVhZGVycykge1xuXHQgICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG5cdCAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cblx0ICAgIGlmICgnUE9TVCcgPT09IHRoaXMubWV0aG9kKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcblx0ICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgfVxuXG5cdCAgICB0cnkge1xuXHQgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJyovKicpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblxuXHQgICAgLy8gaWU2IGNoZWNrXG5cdCAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG5cdCAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5yZXF1ZXN0VGltZW91dCkge1xuXHQgICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG5cdCAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgc2VsZi5vbkxvYWQoKTtcblx0ICAgICAgfTtcblx0ICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDIpIHtcblx0ICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG5cdCAgICAgICAgICAgIGlmIChzZWxmLnN1cHBvcnRzQmluYXJ5ICYmIGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuXHQgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoNCAhPT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcblx0ICAgICAgICBpZiAoMjAwID09PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT09IHhoci5zdGF0dXMpIHtcblx0ICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuXHQgICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuXHQgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcblx0ICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZGVidWckNCgneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuXHQgICAgeGhyLnNlbmQodGhpcy5kYXRhKTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG5cdCAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cblx0ICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuXHQgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHNlbGYub25FcnJvcihlKTtcblx0ICAgIH0sIDApO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIGlmIChjb21tb25qc0dsb2JhbC5kb2N1bWVudCkge1xuXHQgICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuXHQgICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XSA9IHRoaXM7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcblx0ICB0aGlzLm9uU3VjY2VzcygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlcnJvci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG5cdCAgdGhpcy5jbGVhbnVwKHRydWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbnMgdXAgaG91c2UuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKGZyb21FcnJvcikge1xuXHQgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIC8vIHhtbGh0dHByZXF1ZXN0XG5cdCAgaWYgKHRoaXMuaGFzWERSKCkpIHtcblx0ICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG5cdCAgfVxuXG5cdCAgaWYgKGZyb21FcnJvcikge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgdGhpcy54aHIuYWJvcnQoKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgfVxuXG5cdCAgaWYgKGNvbW1vbmpzR2xvYmFsLmRvY3VtZW50KSB7XG5cdCAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcblx0ICB9XG5cblx0ICB0aGlzLnhociA9IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGxvYWQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIGRhdGE7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBjb250ZW50VHlwZTtcblx0ICAgIHRyeSB7XG5cdCAgICAgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcblx0ICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlIHx8IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG5cdCAgICB9XG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgdGhpcy5vbkVycm9yKGUpO1xuXHQgIH1cblx0ICBpZiAobnVsbCAhPSBkYXRhKSB7XG5cdCAgICB0aGlzLm9uRGF0YShkYXRhKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjb21tb25qc0dsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFib3J0cyB0aGUgcmVxdWVzdC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5jbGVhbnVwKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcblx0ICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuXHQgKiBlbWl0dGVkLlxuXHQgKi9cblxuXHRSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuXHRSZXF1ZXN0LnJlcXVlc3RzID0ge307XG5cblx0aWYgKGNvbW1vbmpzR2xvYmFsLmRvY3VtZW50KSB7XG5cdCAgaWYgKGNvbW1vbmpzR2xvYmFsLmF0dGFjaEV2ZW50KSB7XG5cdCAgICBjb21tb25qc0dsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcblx0ICB9IGVsc2UgaWYgKGNvbW1vbmpzR2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0ICAgIGNvbW1vbmpzR2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuXHQgIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuXHQgICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0ICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRwb2xsaW5nWGhyLlJlcXVlc3QgPSBSZXF1ZXN0XzE7XG5cblx0dmFyIHBvbGxpbmdYaHIkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBwb2xsaW5nWGhyLFxuXHRcdF9fbW9kdWxlRXhwb3J0czogcG9sbGluZ1hocixcblx0XHRSZXF1ZXN0OiBSZXF1ZXN0XzFcblx0fSk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0dmFyIHBvbGxpbmdKc29ucCA9IEpTT05QUG9sbGluZztcblxuXHQvKipcblx0ICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG5cdCAqL1xuXG5cdHZhciByTmV3bGluZSA9IC9cXG4vZztcblx0dmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG5cdC8qKlxuXHQgKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuXHQgKi9cblxuXHR2YXIgY2FsbGJhY2tzO1xuXG5cdC8qKlxuXHQgKiBOb29wLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBlbXB0eSQxKCkge31cblxuXHQvKipcblx0ICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEpTT05QUG9sbGluZyhvcHRzKSB7XG5cdCAgUG9sbGluZyQxLmNhbGwodGhpcywgb3B0cyk7XG5cblx0ICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuXHQgIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG5cdCAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cblx0ICBpZiAoIWNhbGxiYWNrcykge1xuXHQgICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2Vcblx0ICAgIGlmICghY29tbW9uanNHbG9iYWwuX19fZWlvKSBjb21tb25qc0dsb2JhbC5fX19laW8gPSBbXTtcblx0ICAgIGNhbGxiYWNrcyA9IGNvbW1vbmpzR2xvYmFsLl9fX2Vpbztcblx0ICB9XG5cblx0ICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG5cdCAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cblx0ICAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcblx0ICAgIHNlbGYub25EYXRhKG1zZyk7XG5cdCAgfSk7XG5cblx0ICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG5cdCAgdGhpcy5xdWVyeS5qID0gdGhpcy5pbmRleDtcblxuXHQgIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcblx0ICBpZiAoY29tbW9uanNHbG9iYWwuZG9jdW1lbnQgJiYgY29tbW9uanNHbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHQgICAgY29tbW9uanNHbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eSQxO1xuXHQgICAgfSwgZmFsc2UpO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG5cdCAqL1xuXG5cdGluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nJDEpO1xuXG5cdC8qXG5cdCAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3Ncblx0ICovXG5cblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdEpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5zY3JpcHQpIHtcblx0ICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuXHQgICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLmZvcm0pIHtcblx0ICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG5cdCAgICB0aGlzLmZvcm0gPSBudWxsO1xuXHQgICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuXHQgIH1cblxuXHQgIFBvbGxpbmckMS5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuXHQgIGlmICh0aGlzLnNjcmlwdCkge1xuXHQgICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG5cdCAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG5cdCAgfVxuXG5cdCAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcblx0ICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcblx0ICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLCBlKTtcblx0ICB9O1xuXG5cdCAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuXHQgIGlmIChpbnNlcnRBdCkge1xuXHQgICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdCAgfVxuXHQgIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG5cdCAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0ICBpZiAoaXNVQWdlY2tvKSB7XG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHQgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdCAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcblx0ICAgIH0sIDEwMCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICBpZiAoIXRoaXMuZm9ybSkge1xuXHQgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG5cdCAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG5cdCAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG5cdCAgICB2YXIgaWZyYW1lO1xuXG5cdCAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG5cdCAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0ICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuXHQgICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuXHQgICAgZm9ybS50YXJnZXQgPSBpZDtcblx0ICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuXHQgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG5cdCAgICBhcmVhLm5hbWUgPSAnZCc7XG5cdCAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuXHQgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuXHQgICAgdGhpcy5mb3JtID0gZm9ybTtcblx0ICAgIHRoaXMuYXJlYSA9IGFyZWE7XG5cdCAgfVxuXG5cdCAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cblx0ICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcblx0ICAgIGluaXRJZnJhbWUoKTtcblx0ICAgIGZuKCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaW5pdElmcmFtZSgpIHtcblx0ICAgIGlmIChzZWxmLmlmcmFtZSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0cnkge1xuXHQgICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcblx0ICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJyArIHNlbGYuaWZyYW1lSWQgKyAnXCI+Jztcblx0ICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdCAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcblx0ICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuXHQgICAgfVxuXG5cdCAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG5cdCAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0ICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuXHQgIH1cblxuXHQgIGluaXRJZnJhbWUoKTtcblxuXHQgIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuXHQgIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcblx0ICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcblx0ICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG5cdCAgdHJ5IHtcblx0ICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcblx0ICB9IGNhdGNoIChlKSB7fVxuXG5cdCAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG5cdCAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG5cdCAgICAgICAgY29tcGxldGUoKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBwb2xsaW5nSnNvbnAkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBwb2xsaW5nSnNvbnAsXG5cdFx0X19tb2R1bGVFeHBvcnRzOiBwb2xsaW5nSnNvbnBcblx0fSk7XG5cblx0dmFyIGVtcHR5JDIgPSB7fTtcblxuXHR2YXIgZW1wdHkkMyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBlbXB0eSQyXG5cdH0pO1xuXG5cdHZhciByZXF1aXJlJCQxJDEgPSAoIGVtcHR5JDMgJiYgZW1wdHkkMiApIHx8IGVtcHR5JDM7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBkZWJ1ZyQ1ID0gcmVxdWlyZSQkMCQyKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xuXHR2YXIgQnJvd3NlcldlYlNvY2tldCA9IGNvbW1vbmpzR2xvYmFsLldlYlNvY2tldCB8fCBjb21tb25qc0dsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5cdHZhciBOb2RlV2ViU29ja2V0O1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICB0cnkge1xuXHQgICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUkJDEkMTtcblx0ICB9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcblx0ICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcblx0ICogaW50ZXJmYWNlIGV4cG9zZWQgYnkgYHdzYCBmb3IgTm9kZS1saWtlIGVudmlyb25tZW50LlxuXHQgKi9cblxuXHR2YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcblx0aWYgKCFXZWJTb2NrZXQgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHR2YXIgd2Vic29ja2V0ID0gV1M7XG5cblx0LyoqXG5cdCAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFdTKG9wdHMpIHtcblx0ICB2YXIgZm9yY2VCYXNlNjQgPSBvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQ7XG5cdCAgaWYgKGZvcmNlQmFzZTY0KSB7XG5cdCAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXHQgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuXHQgIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG5cdCAgdGhpcy5wcm90b2NvbHMgPSBvcHRzLnByb3RvY29scztcblx0ICBpZiAoIXRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG5cdCAgICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuXHQgIH1cblx0ICBUcmFuc3BvcnQkMS5jYWxsKHRoaXMsIG9wdHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuXHQgKi9cblxuXHRpbmhlcml0KFdTLCBUcmFuc3BvcnQkMSk7XG5cblx0LyoqXG5cdCAqIFRyYW5zcG9ydCBuYW1lLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG5cdC8qXG5cdCAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcblx0ICovXG5cblx0V1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuXHQvKipcblx0ICogT3BlbnMgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0V1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoIXRoaXMuY2hlY2soKSkge1xuXHQgICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgdXJpID0gdGhpcy51cmkoKTtcblx0ICB2YXIgcHJvdG9jb2xzID0gdGhpcy5wcm90b2NvbHM7XG5cdCAgdmFyIG9wdHMgPSB7XG5cdCAgICBhZ2VudDogdGhpcy5hZ2VudCxcblx0ICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlXG5cdCAgfTtcblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIG9wdHMucGZ4ID0gdGhpcy5wZng7XG5cdCAgb3B0cy5rZXkgPSB0aGlzLmtleTtcblx0ICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG5cdCAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuXHQgIG9wdHMuY2EgPSB0aGlzLmNhO1xuXHQgIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcblx0ICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXHQgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuXHQgICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cdCAgfVxuXHQgIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuXHQgICAgb3B0cy5sb2NhbEFkZHJlc3MgPSB0aGlzLmxvY2FsQWRkcmVzcztcblx0ICB9XG5cblx0ICB0cnkge1xuXHQgICAgdGhpcy53cyA9IHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID8gcHJvdG9jb2xzID8gbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scykgOiBuZXcgV2ViU29ja2V0KHVyaSkgOiBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcblx0ICB9IGNhdGNoIChlcnIpIHtcblx0ICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICB9XG5cblx0ICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuXHQgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cdCAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnbm9kZWJ1ZmZlcic7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgfVxuXG5cdCAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBzZWxmLm9uT3BlbigpO1xuXHQgIH07XG5cdCAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgc2VsZi5vbkNsb3NlKCk7XG5cdCAgfTtcblx0ICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuXHQgICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG5cdCAgfTtcblx0ICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgc2VsZi5vbkVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBlKTtcblx0ICB9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHBhY2tldHMuXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cblx0ICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuXHQgIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcblx0ICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAoZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICBpZiAoIXNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG5cdCAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuXHQgICAgICAgICAgdmFyIG9wdHMgPSB7fTtcblx0ICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuXHQgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG5cdCAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PT0gdHlwZW9mIGRhdGEgPyBjb21tb25qc0dsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuXHQgICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcblx0ICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG5cdCAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG5cdCAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3Jcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgaWYgKHNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFR5cGVFcnJvciBpcyB0aHJvd24gd2hlbiBwYXNzaW5nIHRoZSBzZWNvbmQgYXJndW1lbnQgb24gU2FmYXJpXG5cdCAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhLCBvcHRzKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICBkZWJ1ZyQ1KCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSkocGFja2V0c1tpXSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZG9uZSgpIHtcblx0ICAgIHNlbGYuZW1pdCgnZmx1c2gnKTtcblxuXHQgICAgLy8gZmFrZSBkcmFpblxuXHQgICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuXHQgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuXHQgICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG5cdCAgICB9LCAwKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGNsb3NlXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBUcmFuc3BvcnQkMS5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0V1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgdGhpcy53cy5jbG9zZSgpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblx0ICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG5cdCAgdmFyIHBvcnQgPSAnJztcblxuXHQgIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG5cdCAgaWYgKHRoaXMucG9ydCAmJiAoJ3dzcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzIHx8ICd3cycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSB7XG5cdCAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuXHQgIH1cblxuXHQgIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG5cdCAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcblx0ICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QkMigpO1xuXHQgIH1cblxuXHQgIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuXHQgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuXHQgICAgcXVlcnkuYjY0ID0gMTtcblx0ICB9XG5cblx0ICBxdWVyeSA9IHBhcnNlcXMkMi5lbmNvZGUocXVlcnkpO1xuXG5cdCAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG5cdCAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuXHQgICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcblx0ICB9XG5cblx0ICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcblx0ICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcblx0fTtcblxuXHQvKipcblx0ICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG5cdH07XG5cblx0dmFyIHdlYnNvY2tldCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IHdlYnNvY2tldCxcblx0XHRfX21vZHVsZUV4cG9ydHM6IHdlYnNvY2tldFxuXHR9KTtcblxuXHR2YXIgWEhSJDEgPSAoIHBvbGxpbmdYaHIkMSAmJiBwb2xsaW5nWGhyICkgfHwgcG9sbGluZ1hociQxO1xuXG5cdHZhciBKU09OUCA9ICggcG9sbGluZ0pzb25wJDEgJiYgcG9sbGluZ0pzb25wICkgfHwgcG9sbGluZ0pzb25wJDE7XG5cblx0dmFyIHdlYnNvY2tldCQyID0gKCB3ZWJzb2NrZXQkMSAmJiB3ZWJzb2NrZXQgKSB8fCB3ZWJzb2NrZXQkMTtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llc1xuXHQgKi9cblxuXHQvKipcblx0ICogRXhwb3J0IHRyYW5zcG9ydHMuXG5cdCAqL1xuXG5cdHZhciBwb2xsaW5nXzEgPSBwb2xsaW5nJDI7XG5cdHZhciB3ZWJzb2NrZXRfMSA9IHdlYnNvY2tldCQyO1xuXG5cdC8qKlxuXHQgKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cblx0ICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBwb2xsaW5nJDIob3B0cykge1xuXHQgIHZhciB4aHI7XG5cdCAgdmFyIHhkID0gZmFsc2U7XG5cdCAgdmFyIHhzID0gZmFsc2U7XG5cdCAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cblx0ICBpZiAoY29tbW9uanNHbG9iYWwubG9jYXRpb24pIHtcblx0ICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcblx0ICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuXHQgICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuXHQgICAgaWYgKCFwb3J0KSB7XG5cdCAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuXHQgICAgfVxuXG5cdCAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT09IG9wdHMucG9ydDtcblx0ICAgIHhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuXHQgIH1cblxuXHQgIG9wdHMueGRvbWFpbiA9IHhkO1xuXHQgIG9wdHMueHNjaGVtZSA9IHhzO1xuXHQgIHhociA9IG5ldyByZXF1aXJlJCQxKG9wdHMpO1xuXG5cdCAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuXHQgICAgcmV0dXJuIG5ldyBYSFIkMShvcHRzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuXHQgICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcblx0ICB9XG5cdH1cblxuXHR2YXIgdHJhbnNwb3J0cyA9IHtcblx0ICBwb2xsaW5nOiBwb2xsaW5nXzEsXG5cdCAgd2Vic29ja2V0OiB3ZWJzb2NrZXRfMVxuXHR9O1xuXG5cdHZhciB0cmFuc3BvcnRzJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogdHJhbnNwb3J0cyxcblx0XHRfX21vZHVsZUV4cG9ydHM6IHRyYW5zcG9ydHMsXG5cdFx0cG9sbGluZzogcG9sbGluZ18xLFxuXHRcdHdlYnNvY2tldDogd2Vic29ja2V0XzFcblx0fSk7XG5cblx0dmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5cdHZhciBpbmRleG9mID0gZnVuY3Rpb24gaW5kZXhvZihhcnIsIG9iaikge1xuXHQgIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuXHQgICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcblx0ICB9XG5cdCAgcmV0dXJuIC0xO1xuXHR9O1xuXG5cdHZhciBpbmRleG9mJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogaW5kZXhvZixcblx0XHRfX21vZHVsZUV4cG9ydHM6IGluZGV4b2Zcblx0fSk7XG5cblx0dmFyIHRyYW5zcG9ydHMkMiA9ICggdHJhbnNwb3J0cyQxICYmIHRyYW5zcG9ydHMgKSB8fCB0cmFuc3BvcnRzJDE7XG5cblx0dmFyIGluZGV4ID0gKCBpbmRleG9mJDEgJiYgaW5kZXhvZiApIHx8IGluZGV4b2YkMTtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIGRlYnVnJDYgPSByZXF1aXJlJCQwJDIoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHR2YXIgc29ja2V0ID0gU29ja2V0O1xuXG5cdC8qKlxuXHQgKiBTb2NrZXQgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gU29ja2V0KHVyaSwgb3B0cykge1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cblx0ICBpZiAodXJpICYmICdvYmplY3QnID09PSAodHlwZW9mIHVyaSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodXJpKSkpIHtcblx0ICAgIG9wdHMgPSB1cmk7XG5cdCAgICB1cmkgPSBudWxsO1xuXHQgIH1cblxuXHQgIGlmICh1cmkpIHtcblx0ICAgIHVyaSA9IHBhcnNldXJpJDIodXJpKTtcblx0ICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcblx0ICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PT0gJ3dzcyc7XG5cdCAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcblx0ICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG5cdCAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcblx0ICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaSQyKG9wdHMuaG9zdCkuaG9zdDtcblx0ICB9XG5cblx0ICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZSA6IGNvbW1vbmpzR2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcblxuXHQgIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcblx0ICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcblx0ICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuXHQgIH1cblxuXHQgIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuXHQgIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8IChjb21tb25qc0dsb2JhbC5sb2NhdGlvbiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuXHQgIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoY29tbW9uanNHbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydCA/IGxvY2F0aW9uLnBvcnQgOiB0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKTtcblx0ICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcblx0ICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2VxcyQyLmRlY29kZSh0aGlzLnF1ZXJ5KTtcblx0ICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuXHQgIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuXHQgIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuXHQgIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblx0ICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuXHQgIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuXHQgIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0Jztcblx0ICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcblx0ICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuXHQgIHRoaXMudHJhbnNwb3J0T3B0aW9ucyA9IG9wdHMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcblx0ICB0aGlzLndyaXRlQnVmZmVyID0gW107XG5cdCAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblx0ICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuXHQgIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG5cdCAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcblx0ICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuXHQgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBmYWxzZSAhPT0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30gOiBmYWxzZTtcblxuXHQgIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG5cdCAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuXHQgICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuXHQgIH1cblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcblx0ICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG5cdCAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG5cdCAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG5cdCAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcblx0ICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcblx0ICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cdCAgdGhpcy5mb3JjZU5vZGUgPSAhIW9wdHMuZm9yY2VOb2RlO1xuXG5cdCAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICB2YXIgZnJlZUdsb2JhbCA9IF90eXBlb2YoY29tbW9uanNHbG9iYWwpID09PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbDtcblx0ICBpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwpIHtcblx0ICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuXHQgICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcblx0ICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBzZXQgb24gaGFuZHNoYWtlXG5cdCAgdGhpcy5pZCA9IG51bGw7XG5cdCAgdGhpcy51cGdyYWRlcyA9IG51bGw7XG5cdCAgdGhpcy5waW5nSW50ZXJ2YWwgPSBudWxsO1xuXHQgIHRoaXMucGluZ1RpbWVvdXQgPSBudWxsO1xuXG5cdCAgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuXHQgIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSBudWxsO1xuXHQgIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG5cblx0ICB0aGlzLm9wZW4oKTtcblx0fVxuXG5cdFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogUHJvdG9jb2wgdmVyc2lvbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG5cdC8qKlxuXHQgKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcblx0ICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG5cdCAqL1xuXG5cdFNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5cdFNvY2tldC5UcmFuc3BvcnQgPSBUcmFuc3BvcnQkMTtcblx0U29ja2V0LnRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzJDI7XG5cdFNvY2tldC5wYXJzZXIgPSBwYXJzZXI7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcblx0ICogQHJldHVybiB7VHJhbnNwb3J0fVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgIGRlYnVnJDYoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcblx0ICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuXHQgIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuXHQgIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuXHQgIC8vIHRyYW5zcG9ydCBuYW1lXG5cdCAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuXHQgIC8vIHBlci10cmFuc3BvcnQgb3B0aW9uc1xuXHQgIHZhciBvcHRpb25zID0gdGhpcy50cmFuc3BvcnRPcHRpb25zW25hbWVdIHx8IHt9O1xuXG5cdCAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG5cdCAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cblx0ICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHMkMltuYW1lXSh7XG5cdCAgICBxdWVyeTogcXVlcnksXG5cdCAgICBzb2NrZXQ6IHRoaXMsXG5cdCAgICBhZ2VudDogb3B0aW9ucy5hZ2VudCB8fCB0aGlzLmFnZW50LFxuXHQgICAgaG9zdG5hbWU6IG9wdGlvbnMuaG9zdG5hbWUgfHwgdGhpcy5ob3N0bmFtZSxcblx0ICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCB0aGlzLnBvcnQsXG5cdCAgICBzZWN1cmU6IG9wdGlvbnMuc2VjdXJlIHx8IHRoaXMuc2VjdXJlLFxuXHQgICAgcGF0aDogb3B0aW9ucy5wYXRoIHx8IHRoaXMucGF0aCxcblx0ICAgIGZvcmNlSlNPTlA6IG9wdGlvbnMuZm9yY2VKU09OUCB8fCB0aGlzLmZvcmNlSlNPTlAsXG5cdCAgICBqc29ucDogb3B0aW9ucy5qc29ucCB8fCB0aGlzLmpzb25wLFxuXHQgICAgZm9yY2VCYXNlNjQ6IG9wdGlvbnMuZm9yY2VCYXNlNjQgfHwgdGhpcy5mb3JjZUJhc2U2NCxcblx0ICAgIGVuYWJsZXNYRFI6IG9wdGlvbnMuZW5hYmxlc1hEUiB8fCB0aGlzLmVuYWJsZXNYRFIsXG5cdCAgICB0aW1lc3RhbXBSZXF1ZXN0czogb3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyB8fCB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuXHQgICAgdGltZXN0YW1wUGFyYW06IG9wdGlvbnMudGltZXN0YW1wUGFyYW0gfHwgdGhpcy50aW1lc3RhbXBQYXJhbSxcblx0ICAgIHBvbGljeVBvcnQ6IG9wdGlvbnMucG9saWN5UG9ydCB8fCB0aGlzLnBvbGljeVBvcnQsXG5cdCAgICBwZng6IG9wdGlvbnMucGZ4IHx8IHRoaXMucGZ4LFxuXHQgICAga2V5OiBvcHRpb25zLmtleSB8fCB0aGlzLmtleSxcblx0ICAgIHBhc3NwaHJhc2U6IG9wdGlvbnMucGFzc3BocmFzZSB8fCB0aGlzLnBhc3NwaHJhc2UsXG5cdCAgICBjZXJ0OiBvcHRpb25zLmNlcnQgfHwgdGhpcy5jZXJ0LFxuXHQgICAgY2E6IG9wdGlvbnMuY2EgfHwgdGhpcy5jYSxcblx0ICAgIGNpcGhlcnM6IG9wdGlvbnMuY2lwaGVycyB8fCB0aGlzLmNpcGhlcnMsXG5cdCAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIHx8IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuXHQgICAgcGVyTWVzc2FnZURlZmxhdGU6IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgfHwgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcblx0ICAgIGV4dHJhSGVhZGVyczogb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgdGhpcy5leHRyYUhlYWRlcnMsXG5cdCAgICBmb3JjZU5vZGU6IG9wdGlvbnMuZm9yY2VOb2RlIHx8IHRoaXMuZm9yY2VOb2RlLFxuXHQgICAgbG9jYWxBZGRyZXNzOiBvcHRpb25zLmxvY2FsQWRkcmVzcyB8fCB0aGlzLmxvY2FsQWRkcmVzcyxcblx0ICAgIHJlcXVlc3RUaW1lb3V0OiBvcHRpb25zLnJlcXVlc3RUaW1lb3V0IHx8IHRoaXMucmVxdWVzdFRpbWVvdXQsXG5cdCAgICBwcm90b2NvbHM6IG9wdGlvbnMucHJvdG9jb2xzIHx8IHZvaWQgMFxuXHQgIH0pO1xuXG5cdCAgcmV0dXJuIHRyYW5zcG9ydDtcblx0fTtcblxuXHRmdW5jdGlvbiBjbG9uZShvYmopIHtcblx0ICB2YXIgbyA9IHt9O1xuXHQgIGZvciAodmFyIGkgaW4gb2JqKSB7XG5cdCAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdCAgICAgIG9baV0gPSBvYmpbaV07XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBvO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRTb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHRyYW5zcG9ydDtcblx0ICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG5cdCAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0Jztcblx0ICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcblx0ICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcblx0ICAgIH0sIDApO1xuXHQgICAgcmV0dXJuO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG5cdCAgfVxuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuXHQgIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcblx0ICB0cnkge1xuXHQgICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcblx0ICAgIHRoaXMub3BlbigpO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIHRyYW5zcG9ydC5vcGVuKCk7XG5cdCAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcblx0ICBkZWJ1ZyQ2KCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICBpZiAodGhpcy50cmFuc3BvcnQpIHtcblx0ICAgIGRlYnVnJDYoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuXHQgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdCAgfVxuXG5cdCAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuXHQgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG5cdCAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcblx0ICB0cmFuc3BvcnQub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuXHQgICAgc2VsZi5vbkRyYWluKCk7XG5cdCAgfSkub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcblx0ICB9KS5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgc2VsZi5vbkVycm9yKGUpO1xuXHQgIH0pLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcblx0ICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG5cdCAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb2JlcyBhIHRyYW5zcG9ydC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICBkZWJ1ZyQ2KCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcblx0ICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KTtcblx0ICB2YXIgZmFpbGVkID0gZmFsc2U7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG5cdCAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuKCkge1xuXHQgICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG5cdCAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcblx0ICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcblx0ICAgIH1cblx0ICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuXHQgICAgZGVidWckNigncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcblx0ICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG5cdCAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuXHQgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cdCAgICAgIGlmICgncG9uZycgPT09IG1zZy50eXBlICYmICdwcm9iZScgPT09IG1zZy5kYXRhKSB7XG5cdCAgICAgICAgZGVidWckNigncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG5cdCAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuXHQgICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcblx0ICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuXHQgICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdHJhbnNwb3J0Lm5hbWU7XG5cblx0ICAgICAgICBkZWJ1ZyQ2KCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuXHQgICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcblx0ICAgICAgICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG5cdCAgICAgICAgICBkZWJ1ZyQ2KCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuXHQgICAgICAgICAgY2xlYW51cCgpO1xuXG5cdCAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuXHQgICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcblx0ICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG5cdCAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuXHQgICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcblx0ICAgICAgICAgIHNlbGYuZmx1c2goKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBkZWJ1ZyQ2KCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuXHQgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG5cdCAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXHQgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuXHQgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG5cdCAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcblx0ICAgIGZhaWxlZCA9IHRydWU7XG5cblx0ICAgIGNsZWFudXAoKTtcblxuXHQgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG5cdCAgICB0cmFuc3BvcnQgPSBudWxsO1xuXHQgIH1cblxuXHQgIC8vIEhhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2Jpbmdcblx0ICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuXHQgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG5cdCAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuXHQgICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cblx0ICAgIGRlYnVnJDYoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuXHQgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpIHtcblx0ICAgIG9uZXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcblx0ICB9XG5cblx0ICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2Jpbmdcblx0ICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuXHQgICAgb25lcnJvcignc29ja2V0IGNsb3NlZCcpO1xuXHQgIH1cblxuXHQgIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG5cdCAgZnVuY3Rpb24gb251cGdyYWRlKHRvKSB7XG5cdCAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT09IHRyYW5zcG9ydC5uYW1lKSB7XG5cdCAgICAgIGRlYnVnJDYoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcblx0ICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuXHQgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdCAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuXHQgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXHQgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXHQgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblx0ICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cdCAgfVxuXG5cdCAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuXHQgIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuXHQgIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG5cdCAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXHQgIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuXHQgIHRyYW5zcG9ydC5vcGVuKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIGRlYnVnJDYoJ3NvY2tldCBvcGVuJyk7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcblx0ICB0aGlzLmVtaXQoJ29wZW4nKTtcblx0ICB0aGlzLmZsdXNoKCk7XG5cblx0ICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG5cdCAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuXHQgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcblx0ICAgIGRlYnVnJDYoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIGRlYnVnJDYoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG5cdCAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cblx0ICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcblx0ICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cblx0ICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcblx0ICAgICAgY2FzZSAnb3Blbic6XG5cdCAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShKU09OLnBhcnNlKHBhY2tldC5kYXRhKSk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSAncG9uZyc6XG5cdCAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG5cdCAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSAnZXJyb3InOlxuXHQgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuXHQgICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG5cdCAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSAnbWVzc2FnZSc6XG5cdCAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuXHQgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgZGVidWckNigncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcblx0ICB0aGlzLmlkID0gZGF0YS5zaWQ7XG5cdCAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG5cdCAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG5cdCAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcblx0ICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcblx0ICB0aGlzLm9uT3BlbigpO1xuXHQgIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcblx0ICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHQgIHRoaXMuc2V0UGluZygpO1xuXG5cdCAgLy8gUHJvbG9uZyBsaXZlbmVzcyBvZiBzb2NrZXQgb24gaGVhcnRiZWF0XG5cdCAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG5cdCAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcblx0ICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHQgICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcblx0ICB9LCB0aW1lb3V0IHx8IHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG5cdCAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcblx0ICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICBkZWJ1ZyQ2KCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcblx0ICAgIHNlbGYucGluZygpO1xuXHQgICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcblx0ICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG5cdH07XG5cblx0LyoqXG5cdCogU2VuZHMgYSBwaW5nIHBhY2tldC5cblx0KlxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24gKCkge1xuXHQgICAgc2VsZi5lbWl0KCdwaW5nJyk7XG5cdCAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuXHQgIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcblx0ICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3Zlcixcblx0ICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuXHQgIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cblx0ICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcblx0ICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5mbHVzaCgpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogRmx1c2ggd3JpdGUgYnVmZmVycy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiYgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdCAgICBkZWJ1ZyQ2KCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcblx0ICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG5cdCAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG5cdCAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcblx0ICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuXHQgICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogU2VuZHMgYSBtZXNzYWdlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuXHQgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS53cml0ZSA9IFNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG5cdCAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcblx0ICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRhdGEpIHtcblx0ICAgIGZuID0gZGF0YTtcblx0ICAgIGRhdGEgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zKSB7XG5cdCAgICBmbiA9IG9wdGlvbnM7XG5cdCAgICBvcHRpb25zID0gbnVsbDtcblx0ICB9XG5cblx0ICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0aW9ucy5jb21wcmVzcztcblxuXHQgIHZhciBwYWNrZXQgPSB7XG5cdCAgICB0eXBlOiB0eXBlLFxuXHQgICAgZGF0YTogZGF0YSxcblx0ICAgIG9wdGlvbnM6IG9wdGlvbnNcblx0ICB9O1xuXHQgIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcblx0ICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcblx0ICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG5cdCAgdGhpcy5mbHVzaCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NpbmcnO1xuXG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuXHQgICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuXHQgICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY2xvc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuXHQgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY2xvc2UoKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBjbG9zZSgpIHtcblx0ICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG5cdCAgICBkZWJ1ZyQ2KCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG5cdCAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSgpIHtcblx0ICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuXHQgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICAgIGNsb3NlKCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG5cdCAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuXHQgICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgZGVidWckNignc29ja2V0IGVycm9yICVqJywgZXJyKTtcblx0ICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cdCAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG5cdCAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG5cdCAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICBkZWJ1ZyQ2KCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICAgIC8vIGNsZWFyIHRpbWVyc1xuXHQgICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuXHQgICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cblx0ICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuXHQgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG5cdCAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuXHQgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuXHQgICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cblx0ICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG5cdCAgICAvLyBzZXQgcmVhZHkgc3RhdGVcblx0ICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG5cdCAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG5cdCAgICB0aGlzLmlkID0gbnVsbDtcblxuXHQgICAgLy8gZW1pdCBjbG9zZSBldmVudFxuXHQgICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cblx0ICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuXHQgICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG5cdCAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG5cdCAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICpcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuXHQgIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0ICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG5cdCAgfVxuXHQgIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xuXHR9O1xuXG5cdHZhciBzb2NrZXQkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBzb2NrZXQsXG5cdFx0X19tb2R1bGVFeHBvcnRzOiBzb2NrZXRcblx0fSk7XG5cblx0dmFyIHJlcXVpcmUkJDAkNCA9ICggc29ja2V0JDEgJiYgc29ja2V0ICkgfHwgc29ja2V0JDE7XG5cblx0dmFyIGxpYiA9IHJlcXVpcmUkJDAkNDtcblxuXHQvKipcblx0ICogRXhwb3J0cyBwYXJzZXJcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICpcblx0ICovXG5cdHZhciBwYXJzZXIkMSA9IHBhcnNlcjtcblx0bGliLnBhcnNlciA9IHBhcnNlciQxO1xuXG5cdHZhciBsaWIkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRkZWZhdWx0OiBsaWIsXG5cdFx0X19tb2R1bGVFeHBvcnRzOiBsaWIsXG5cdFx0cGFyc2VyOiBwYXJzZXIkMVxuXHR9KTtcblxuXHR2YXIgdG9BcnJheV8xID0gdG9BcnJheSQxO1xuXG5cdGZ1bmN0aW9uIHRvQXJyYXkkMShsaXN0LCBpbmRleCkge1xuXHQgICAgdmFyIGFycmF5ID0gW107XG5cblx0ICAgIGluZGV4ID0gaW5kZXggfHwgMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgYXJyYXlbaSAtIGluZGV4XSA9IGxpc3RbaV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBhcnJheTtcblx0fVxuXG5cdHZhciB0b0FycmF5JDIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogdG9BcnJheV8xLFxuXHRcdF9fbW9kdWxlRXhwb3J0czogdG9BcnJheV8xXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0dmFyIG9uXzEgPSBvbjtcblxuXHQvKipcblx0ICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuXHQgIG9iai5vbihldiwgZm4pO1xuXHQgIHJldHVybiB7XG5cdCAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cblx0dmFyIG9uJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogb25fMSxcblx0XHRfX21vZHVsZUV4cG9ydHM6IG9uXzFcblx0fSk7XG5cblx0LyoqXG5cdCAqIFNsaWNlIHJlZmVyZW5jZS5cblx0ICovXG5cblx0dmFyIHNsaWNlID0gW10uc2xpY2U7XG5cblx0LyoqXG5cdCAqIEJpbmQgYG9iamAgdG8gYGZuYC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHR2YXIgY29tcG9uZW50QmluZCA9IGZ1bmN0aW9uIGNvbXBvbmVudEJpbmQob2JqLCBmbikge1xuXHQgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcblx0ICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcblx0ICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgY29tcG9uZW50QmluZCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IGNvbXBvbmVudEJpbmQsXG5cdFx0X19tb2R1bGVFeHBvcnRzOiBjb21wb25lbnRCaW5kXG5cdH0pO1xuXG5cdHZhciBwYXJzZXIkMiA9ICggc29ja2V0X2lvUGFyc2VyJDEgJiYgc29ja2V0X2lvUGFyc2VyICkgfHwgc29ja2V0X2lvUGFyc2VyJDE7XG5cblx0dmFyIHRvQXJyYXkkMyA9ICggdG9BcnJheSQyICYmIHRvQXJyYXlfMSApIHx8IHRvQXJyYXkkMjtcblxuXHR2YXIgb24kMiA9ICggb24kMSAmJiBvbl8xICkgfHwgb24kMTtcblxuXHR2YXIgYmluZCA9ICggY29tcG9uZW50QmluZCQxICYmIGNvbXBvbmVudEJpbmQgKSB8fCBjb21wb25lbnRCaW5kJDE7XG5cblx0dmFyIHNvY2tldCQyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQgIC8qKlxuXHQgICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAgICovXG5cblx0ICB2YXIgZGVidWcgPSByZXF1aXJlJCQwJDIoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG5cblx0ICAvKipcblx0ICAgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICAgKi9cblxuXHQgIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuXHQgIC8qKlxuXHQgICAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuXHQgICAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuXHQgICAqXG5cdCAgICogQGFwaSBwcml2YXRlXG5cdCAgICovXG5cblx0ICB2YXIgZXZlbnRzID0ge1xuXHQgICAgY29ubmVjdDogMSxcblx0ICAgIGNvbm5lY3RfZXJyb3I6IDEsXG5cdCAgICBjb25uZWN0X3RpbWVvdXQ6IDEsXG5cdCAgICBjb25uZWN0aW5nOiAxLFxuXHQgICAgZGlzY29ubmVjdDogMSxcblx0ICAgIGVycm9yOiAxLFxuXHQgICAgcmVjb25uZWN0OiAxLFxuXHQgICAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG5cdCAgICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuXHQgICAgcmVjb25uZWN0X2Vycm9yOiAxLFxuXHQgICAgcmVjb25uZWN0aW5nOiAxLFxuXHQgICAgcGluZzogMSxcblx0ICAgIHBvbmc6IDFcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG5cdCAgICovXG5cblx0ICB2YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cblx0ICAvKipcblx0ICAgKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBTb2NrZXQoaW8sIG5zcCwgb3B0cykge1xuXHQgICAgdGhpcy5pbyA9IGlvO1xuXHQgICAgdGhpcy5uc3AgPSBuc3A7XG5cdCAgICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcblx0ICAgIHRoaXMuaWRzID0gMDtcblx0ICAgIHRoaXMuYWNrcyA9IHt9O1xuXHQgICAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cdCAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcblx0ICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cdCAgICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG5cdCAgICB0aGlzLmZsYWdzID0ge307XG5cdCAgICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG5cdCAgICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAgICovXG5cblx0ICBFbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG5cdCAgLyoqXG5cdCAgICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG5cdCAgICpcblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIFNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG5cdCAgICB2YXIgaW8gPSB0aGlzLmlvO1xuXHQgICAgdGhpcy5zdWJzID0gW29uJDIoaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLCBvbiQyKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksIG9uJDIoaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSldO1xuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBTb2NrZXQucHJvdG90eXBlLm9wZW4gPSBTb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG5cdCAgICB0aGlzLnN1YkV2ZW50cygpO1xuXHQgICAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG5cdCAgICBpZiAoJ29wZW4nID09PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG5cdCAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cblx0ICAgKlxuXHQgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBTb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgYXJncyA9IHRvQXJyYXkkMyhhcmd1bWVudHMpO1xuXHQgICAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG5cdCAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogT3ZlcnJpZGUgYGVtaXRgLlxuXHQgICAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcblx0ICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2KSB7XG5cdCAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuXHQgICAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgYXJncyA9IHRvQXJyYXkkMyhhcmd1bWVudHMpO1xuXHQgICAgdmFyIHBhY2tldCA9IHtcblx0ICAgICAgdHlwZTogKHRoaXMuZmxhZ3MuYmluYXJ5ICE9PSB1bmRlZmluZWQgPyB0aGlzLmZsYWdzLmJpbmFyeSA6IGhhc0JpbmFyeSQxKGFyZ3MpKSA/IHBhcnNlciQyLkJJTkFSWV9FVkVOVCA6IHBhcnNlciQyLkVWRU5ULFxuXHQgICAgICBkYXRhOiBhcmdzXG5cdCAgICB9O1xuXG5cdCAgICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuXHQgICAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSAhdGhpcy5mbGFncyB8fCBmYWxzZSAhPT0gdGhpcy5mbGFncy5jb21wcmVzcztcblxuXHQgICAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG5cdCAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuXHQgICAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuXHQgICAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcblx0ICAgICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdCAgICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmZsYWdzID0ge307XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBTZW5kcyBhIHBhY2tldC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIFNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuXHQgICAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cblx0ICAgIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuXHQgICAgaWYgKCcvJyAhPT0gdGhpcy5uc3ApIHtcblx0ICAgICAgaWYgKHRoaXMucXVlcnkpIHtcblx0ICAgICAgICB2YXIgcXVlcnkgPSBfdHlwZW9mKHRoaXMucXVlcnkpID09PSAnb2JqZWN0JyA/IHBhcnNlcXMkMi5lbmNvZGUodGhpcy5xdWVyeSkgOiB0aGlzLnF1ZXJ5O1xuXHQgICAgICAgIGRlYnVnKCdzZW5kaW5nIGNvbm5lY3QgcGFja2V0IHdpdGggcXVlcnkgJXMnLCBxdWVyeSk7XG5cdCAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIkMi5DT05ORUNULCBxdWVyeTogcXVlcnkgfSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIkMi5DT05ORUNUIH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8qKlxuXHQgICAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuXHQgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcblx0ICAgIGRlbGV0ZSB0aGlzLmlkO1xuXHQgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIFNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgICB2YXIgc2FtZU5hbWVzcGFjZSA9IHBhY2tldC5uc3AgPT09IHRoaXMubnNwO1xuXHQgICAgdmFyIHJvb3ROYW1lc3BhY2VFcnJvciA9IHBhY2tldC50eXBlID09PSBwYXJzZXIkMi5FUlJPUiAmJiBwYWNrZXQubnNwID09PSAnLyc7XG5cblx0ICAgIGlmICghc2FtZU5hbWVzcGFjZSAmJiAhcm9vdE5hbWVzcGFjZUVycm9yKSByZXR1cm47XG5cblx0ICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcblx0ICAgICAgY2FzZSBwYXJzZXIkMi5DT05ORUNUOlxuXHQgICAgICAgIHRoaXMub25jb25uZWN0KCk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBwYXJzZXIkMi5FVkVOVDpcblx0ICAgICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIHBhcnNlciQyLkJJTkFSWV9FVkVOVDpcblx0ICAgICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIHBhcnNlciQyLkFDSzpcblx0ICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBwYXJzZXIkMi5CSU5BUllfQUNLOlxuXHQgICAgICAgIHRoaXMub25hY2socGFja2V0KTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIHBhcnNlciQyLkRJU0NPTk5FQ1Q6XG5cdCAgICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIHBhcnNlciQyLkVSUk9SOlxuXHQgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8qKlxuXHQgICAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgICAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcblx0ICAgIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG5cdCAgICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcblx0ICAgICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcblx0ICAgICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcblx0ICAgICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuXHQgICAqXG5cdCAgICogQGFwaSBwcml2YXRlXG5cdCAgICovXG5cblx0ICBTb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgdmFyIHNlbnQgPSBmYWxzZTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuXHQgICAgICBpZiAoc2VudCkgcmV0dXJuO1xuXHQgICAgICBzZW50ID0gdHJ1ZTtcblx0ICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5JDMoYXJndW1lbnRzKTtcblx0ICAgICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cblx0ICAgICAgc2VsZi5wYWNrZXQoe1xuXHQgICAgICAgIHR5cGU6IGhhc0JpbmFyeSQxKGFyZ3MpID8gcGFyc2VyJDIuQklOQVJZX0FDSyA6IHBhcnNlciQyLkFDSyxcblx0ICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgZGF0YTogYXJnc1xuXHQgICAgICB9KTtcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8qKlxuXHQgICAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICAgIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcblx0ICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYWNrKSB7XG5cdCAgICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG5cdCAgICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG5cdCAgICAgIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG5cdCAgICpcblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIFNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuXHQgICAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuXHQgICAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaTtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuXHQgICAgfVxuXHQgICAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcblx0ICAgIHRoaXMuZGVzdHJveSgpO1xuXHQgICAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuXHQgICAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG5cdCAgICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG5cdCAgICpcblx0ICAgKiBAYXBpIHByaXZhdGUuXG5cdCAgICovXG5cblx0ICBTb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5zdWJzKSB7XG5cdCAgICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5zdWJzID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuXHQgICAqXG5cdCAgICogQHJldHVybiB7U29ja2V0fSBzZWxmXG5cdCAgICogQGFwaSBwdWJsaWNcblx0ICAgKi9cblxuXHQgIFNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBTb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcblx0ICAgICAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuXHQgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlciQyLkRJU0NPTk5FQ1QgfSk7XG5cdCAgICB9XG5cblx0ICAgIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG5cdCAgICB0aGlzLmRlc3Ryb3koKTtcblxuXHQgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdCAgICAgIC8vIGZpcmUgZXZlbnRzXG5cdCAgICAgIHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvKipcblx0ICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuXHQgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBTb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG5cdCAgICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogU2V0cyB0aGUgYmluYXJ5IGZsYWdcblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciB0aGUgZW1pdHRlZCBkYXRhIGNvbnRhaW5zIGJpbmFyeVxuXHQgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBTb2NrZXQucHJvdG90eXBlLmJpbmFyeSA9IGZ1bmN0aW9uIChiaW5hcnkpIHtcblx0ICAgIHRoaXMuZmxhZ3MuYmluYXJ5ID0gYmluYXJ5O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0fSk7XG5cblx0dmFyIHNvY2tldCQzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IHNvY2tldCQyLFxuXHRcdF9fbW9kdWxlRXhwb3J0czogc29ja2V0JDJcblx0fSk7XG5cblx0LyoqXG5cdCAqIEV4cG9zZSBgQmFja29mZmAuXG5cdCAqL1xuXG5cdHZhciBiYWNrbzIgPSBCYWNrb2ZmO1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG5cdCAqXG5cdCAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuXHQgKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cblx0ICogLSBgaml0dGVyYCBbMF1cblx0ICogLSBgZmFjdG9yYCBbMl1cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cdCAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcblx0ICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuXHQgIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcblx0ICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuXHQgIHRoaXMuYXR0ZW1wdHMgPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cblx0ICpcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG5cdCAgaWYgKHRoaXMuaml0dGVyKSB7XG5cdCAgICB2YXIgcmFuZCA9IE1hdGgucmFuZG9tKCk7XG5cdCAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG5cdCAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmF0dGVtcHRzID0gMDtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uIChtaW4pIHtcblx0ICB0aGlzLm1zID0gbWluO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0QmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24gKG1heCkge1xuXHQgIHRoaXMubWF4ID0gbWF4O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGppdHRlclxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbiAoaml0dGVyKSB7XG5cdCAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG5cdH07XG5cblx0dmFyIGJhY2tvMiQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGRlZmF1bHQ6IGJhY2tvMixcblx0XHRfX21vZHVsZUV4cG9ydHM6IGJhY2tvMlxuXHR9KTtcblxuXHR2YXIgZWlvID0gKCBsaWIkMSAmJiBsaWIgKSB8fCBsaWIkMTtcblxuXHR2YXIgU29ja2V0JDEgPSAoIHNvY2tldCQzICYmIHNvY2tldCQyICkgfHwgc29ja2V0JDM7XG5cblx0dmFyIEJhY2tvZmYkMSA9ICggYmFja28yJDEgJiYgYmFja28yICkgfHwgYmFja28yJDE7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBkZWJ1ZyQ3ID0gcmVxdWlyZSQkMCQyKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcblxuXHQvKipcblx0ICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuXHQgKi9cblxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHNcblx0ICovXG5cblx0dmFyIG1hbmFnZXIgPSBNYW5hZ2VyO1xuXG5cdC8qKlxuXHQgKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcblx0ICBpZiAodXJpICYmICdvYmplY3QnID09PSAodHlwZW9mIHVyaSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodXJpKSkpIHtcblx0ICAgIG9wdHMgPSB1cmk7XG5cdCAgICB1cmkgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXHQgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG5cdCAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcblx0ICB0aGlzLm5zcHMgPSB7fTtcblx0ICB0aGlzLnN1YnMgPSBbXTtcblx0ICB0aGlzLm9wdHMgPSBvcHRzO1xuXHQgIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG5cdCAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcblx0ICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG5cdCAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuXHQgIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcblx0ICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZiQxKHtcblx0ICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuXHQgICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG5cdCAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG5cdCAgfSk7XG5cdCAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMudXJpID0gdXJpO1xuXHQgIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuXHQgIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXHQgIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcblx0ICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuXHQgIHZhciBfcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyJDI7XG5cdCAgdGhpcy5lbmNvZGVyID0gbmV3IF9wYXJzZXIuRW5jb2RlcigpO1xuXHQgIHRoaXMuZGVjb2RlciA9IG5ldyBfcGFyc2VyLkRlY29kZXIoKTtcblx0ICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG5cdCAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG5cdCAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG5cdCAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcblx0ICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG5cdCAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG5cdCAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5nZW5lcmF0ZUlkKG5zcCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBnZW5lcmF0ZSBgc29ja2V0LmlkYCBmb3IgdGhlIGdpdmVuIGBuc3BgXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuc3Bcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIChuc3ApIHtcblx0ICByZXR1cm4gKG5zcCA9PT0gJy8nID8gJycgOiBuc3AgKyAnIycpICsgdGhpcy5lbmdpbmUuaWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3Rcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG5cdCAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcblx0ICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG5cdCAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0TWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3Rvcjtcblx0ICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcblx0ICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24gKHYpIHtcblx0ICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG5cdCAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG5cdCAqXG5cdCAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcblx0ICB0aGlzLl90aW1lb3V0ID0gdjtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG5cdCAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuXHQgIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuXHQgICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuXHQgICAgdGhpcy5yZWNvbm5lY3QoKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vcGVuID0gTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuXHQgIGRlYnVnJDcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuXHQgIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cblx0ICBkZWJ1ZyQ3KCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuXHQgIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXHQgIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXG5cdCAgLy8gZW1pdCBgb3BlbmBcblx0ICB2YXIgb3BlblN1YiA9IG9uJDIoc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uICgpIHtcblx0ICAgIHNlbGYub25vcGVuKCk7XG5cdCAgICBmbiAmJiBmbigpO1xuXHQgIH0pO1xuXG5cdCAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcblx0ICB2YXIgZXJyb3JTdWIgPSBvbiQyKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIGRlYnVnJDcoJ2Nvbm5lY3RfZXJyb3InKTtcblx0ICAgIHNlbGYuY2xlYW51cCgpO1xuXHQgICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdCAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcblx0ICAgIGlmIChmbikge1xuXHQgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG5cdCAgICAgIGVyci5kYXRhID0gZGF0YTtcblx0ICAgICAgZm4oZXJyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG5cdCAgICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcblx0ICAgIH1cblx0ICB9KTtcblxuXHQgIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcblx0ICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcblx0ICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcblx0ICAgIGRlYnVnJDcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuXHQgICAgLy8gc2V0IHRpbWVyXG5cdCAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgZGVidWckNygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXHQgICAgICBvcGVuU3ViLmRlc3Ryb3koKTtcblx0ICAgICAgc29ja2V0LmNsb3NlKCk7XG5cdCAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG5cdCAgICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF90aW1lb3V0JywgdGltZW91dCk7XG5cdCAgICB9LCB0aW1lb3V0KTtcblxuXHQgICAgdGhpcy5zdWJzLnB1c2goe1xuXHQgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICBkZWJ1ZyQ3KCdvcGVuJyk7XG5cblx0ICAvLyBjbGVhciBvbGQgc3Vic1xuXHQgIHRoaXMuY2xlYW51cCgpO1xuXG5cdCAgLy8gbWFyayBhcyBvcGVuXG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXHQgIHRoaXMuZW1pdCgnb3BlbicpO1xuXG5cdCAgLy8gYWRkIG5ldyBzdWJzXG5cdCAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uJDIoc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24kMihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbiQyKHNvY2tldCwgJ3BvbmcnLCBiaW5kKHRoaXMsICdvbnBvbmcnKSkpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uJDIoc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbiQyKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24kMih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMubGFzdFBpbmcgPSBuZXcgRGF0ZSgpO1xuXHQgIHRoaXMuZW1pdEFsbCgncGluZycpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSgpIC0gdGhpcy5sYXN0UGluZyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aXRoIGRhdGEuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0ICBkZWJ1ZyQ3KCdlcnJvcicsIGVycik7XG5cdCAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1NvY2tldH1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24gKG5zcCwgb3B0cykge1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcblx0ICBpZiAoIXNvY2tldCkge1xuXHQgICAgc29ja2V0ID0gbmV3IFNvY2tldCQxKHRoaXMsIG5zcCwgb3B0cyk7XG5cdCAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcblx0ICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG5cdCAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHNvY2tldC5pZCA9IHNlbGYuZ2VuZXJhdGVJZChuc3ApO1xuXHQgICAgfSk7XG5cblx0ICAgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG5cdCAgICAgIC8vIG1hbnVhbGx5IGNhbGwgaGVyZSBzaW5jZSBjb25uZWN0aW5nIGV2ZW50IGlzIGZpcmVkIGJlZm9yZSBsaXN0ZW5pbmdcblx0ICAgICAgb25Db25uZWN0aW5nKCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gb25Db25uZWN0aW5nKCkge1xuXHQgICAgaWYgKCF+aW5kZXgoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG5cdCAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHNvY2tldDtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcblx0ICB2YXIgaW5kZXgkJDEgPSBpbmRleCh0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG5cdCAgaWYgKH5pbmRleCQkMSkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCQkMSwgMSk7XG5cdCAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuXHQgIHRoaXMuY2xvc2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogV3JpdGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgZGVidWckNygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuXHQgIGlmICghc2VsZi5lbmNvZGluZykge1xuXHQgICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuXHQgICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG5cdCAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24gKGVuY29kZWRQYWNrZXRzKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuXHQgICAgICB9XG5cdCAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcblx0ICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuXHQgICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcblx0ICogbmV4dCBwYWNrZXQgaW4gbGluZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuXHQgICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuXHQgICAgdGhpcy5wYWNrZXQocGFjayk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZGVidWckNygnY2xlYW51cCcpO1xuXG5cdCAgdmFyIHN1YnNMZW5ndGggPSB0aGlzLnN1YnMubGVuZ3RoO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic0xlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG5cdCAgICBzdWIuZGVzdHJveSgpO1xuXHQgIH1cblxuXHQgIHRoaXMucGFja2V0QnVmZmVyID0gW107XG5cdCAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuXHQgIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG5cdCAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPSBNYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgIGRlYnVnJDcoJ2Rpc2Nvbm5lY3QnKTtcblx0ICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuXHQgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG5cdCAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG5cdCAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG5cdCAgICB0aGlzLmNsZWFudXAoKTtcblx0ICB9XG5cdCAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdCAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgIGRlYnVnJDcoJ29uY2xvc2UnKTtcblxuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHQgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG5cdCAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG5cdCAgICB0aGlzLnJlY29ubmVjdCgpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIGlmICh0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcblx0ICAgIGRlYnVnJDcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcblx0ICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuXHQgICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG5cdCAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcblx0ICAgIGRlYnVnJDcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuXHQgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuXHQgICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuXHQgICAgICBkZWJ1ZyQ3KCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuXHQgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblx0ICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG5cdCAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuXHQgICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cblx0ICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcblx0ICAgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgICBkZWJ1ZyQ3KCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuXHQgICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG5cdCAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZGVidWckNygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcblx0ICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSwgZGVsYXkpO1xuXG5cdCAgICB0aGlzLnN1YnMucHVzaCh7XG5cdCAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdCAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuXHQgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG5cdCAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG5cdCAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcblx0ICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xuXHR9O1xuXG5cdHZhciBtYW5hZ2VyJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogbWFuYWdlcixcblx0XHRfX21vZHVsZUV4cG9ydHM6IG1hbmFnZXJcblx0fSk7XG5cblx0dmFyIHVybCQyID0gKCB1cmwkMSAmJiB1cmxfMSApIHx8IHVybCQxO1xuXG5cdHZhciBNYW5hZ2VyJDEgPSAoIG1hbmFnZXIkMSAmJiBtYW5hZ2VyICkgfHwgbWFuYWdlciQxO1xuXG5cdHZhciBsaWIkMiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0ICAvKipcblx0ICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgICAqL1xuXG5cdCAgdmFyIGRlYnVnID0gcmVxdWlyZSQkMCQyKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cblx0ICAvKipcblx0ICAgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICAgKi9cblxuXHQgIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuXHQgIC8qKlxuXHQgICAqIE1hbmFnZXJzIGNhY2hlLlxuXHQgICAqL1xuXG5cdCAgdmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG5cdCAgLyoqXG5cdCAgICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG5cdCAgICogSWYgdGhlIHVzZXIgc3VtbW9uczpcblx0ICAgKlxuXHQgICAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG5cdCAgICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2Bcblx0ICAgKlxuXHQgICAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG5cdCAgICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG5cdCAgICpcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuXHQgICAgaWYgKCh0eXBlb2YgdXJpID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih1cmkpKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgb3B0cyA9IHVyaTtcblx0ICAgICAgdXJpID0gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuXHQgICAgdmFyIHBhcnNlZCA9IHVybCQyKHVyaSk7XG5cdCAgICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcblx0ICAgIHZhciBpZCA9IHBhcnNlZC5pZDtcblx0ICAgIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG5cdCAgICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuXHQgICAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHwgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4IHx8IHNhbWVOYW1lc3BhY2U7XG5cblx0ICAgIHZhciBpbztcblxuXHQgICAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcblx0ICAgICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuXHQgICAgICBpbyA9IE1hbmFnZXIkMShzb3VyY2UsIG9wdHMpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcblx0ICAgICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG5cdCAgICAgICAgY2FjaGVbaWRdID0gTWFuYWdlciQxKHNvdXJjZSwgb3B0cyk7XG5cdCAgICAgIH1cblx0ICAgICAgaW8gPSBjYWNoZVtpZF07XG5cdCAgICB9XG5cdCAgICBpZiAocGFyc2VkLnF1ZXJ5ICYmICFvcHRzLnF1ZXJ5KSB7XG5cdCAgICAgIG9wdHMucXVlcnkgPSBwYXJzZWQucXVlcnk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBQcm90b2NvbCB2ZXJzaW9uLlxuXHQgICAqXG5cdCAgICogQGFwaSBwdWJsaWNcblx0ICAgKi9cblxuXHQgIGV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIkMi5wcm90b2NvbDtcblxuXHQgIC8qKlxuXHQgICAqIGBjb25uZWN0YC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG5cdCAgLyoqXG5cdCAgICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBleHBvcnRzLk1hbmFnZXIgPSBNYW5hZ2VyJDE7XG5cdCAgZXhwb3J0cy5Tb2NrZXQgPSBTb2NrZXQkMTtcblx0fSk7XG5cdHZhciBsaWJfMSA9IGxpYiQyLm1hbmFnZXJzO1xuXHR2YXIgbGliXzIgPSBsaWIkMi5wcm90b2NvbDtcblx0dmFyIGxpYl8zID0gbGliJDIuY29ubmVjdDtcblx0dmFyIGxpYl80ID0gbGliJDIuTWFuYWdlcjtcblx0dmFyIGxpYl81ID0gbGliJDIuU29ja2V0O1xuXG5cdGZ1bmN0aW9uIGV4dGVuZChZKSB7XG5cdCAgICB2YXIgQ29ubmVjdG9yID0gZnVuY3Rpb24gKF9ZJEFic3RyYWN0Q29ubmVjdG9yKSB7XG5cdCAgICAgICAgaW5oZXJpdHMoQ29ubmVjdG9yLCBfWSRBYnN0cmFjdENvbm5lY3Rvcik7XG5cblx0ICAgICAgICBmdW5jdGlvbiBDb25uZWN0b3IoeSwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb25uZWN0b3IpO1xuXG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBtdXN0IG5vdCBiZSB1bmRlZmluZWQhJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3B0aW9ucy5wcmVmZXJVbnRyYW5zZm9ybWVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgb3B0aW9ucy5nZW5lcmF0ZVVzZXJJZCA9IG9wdGlvbnMuZ2VuZXJhdGVVc2VySWQgfHwgZmFsc2U7XG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLmluaXRTeW5jICE9PSBmYWxzZSkge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5pbml0U3luYyA9IHRydWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb25uZWN0b3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb25uZWN0b3IpKS5jYWxsKHRoaXMsIHksIG9wdGlvbnMpKTtcblxuXHQgICAgICAgICAgICBfdGhpcy5fc2VudFN5bmMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdCAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgfHwgJ2h0dHBzOi8veWpzLmRiaXMucnd0aC1hYWNoZW4uZGU6NTA3Mic7XG5cdCAgICAgICAgICAgIHZhciBzb2NrZXQgPSBvcHRpb25zLnNvY2tldCB8fCBsaWIkMihvcHRpb25zLnVybCwgb3B0aW9ucy5vcHRpb25zKTtcblx0ICAgICAgICAgICAgX3RoaXMuc29ja2V0ID0gc29ja2V0O1xuXHQgICAgICAgICAgICB2YXIgc2VsZiA9IF90aGlzO1xuXG5cdCAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKiogc3RhcnQgbWluaW1hbCB3ZWJydGMgKioqKioqKioqKioqKioqKioqKioqKi9cblx0ICAgICAgICAgICAgdmFyIHNpZ25hbGluZ19zb2NrZXQgPSBzb2NrZXQ7XG5cdCAgICAgICAgICAgIHZhciBERUZBVUxUX0NIQU5ORUwgPSBvcHRpb25zLnJvb207XG5cdCAgICAgICAgICAgIHZhciBJQ0VfU0VSVkVSUyA9IFt7IHVybHM6IFwic3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMlwiIH0sIHsgdXJsczogXCJ0dXJuOnRyeS5yZWZhY3RvcmVkLmFpOjM0NzhcIiwgdXNlcm5hbWU6IFwidGVzdDk5XCIsIGNyZWRlbnRpYWw6IFwidGVzdFwiIH1dO1xuXHQgICAgICAgICAgICB2YXIgZGNzID0ge307XG5cdCAgICAgICAgICAgIF90aGlzLmRjcyA9IGRjcztcblx0ICAgICAgICAgICAgX3RoaXMuc2RjcyA9IGRjcztcblx0ICAgICAgICAgICAgdmFyIHBlZXJzID0ge307XG5cdCAgICAgICAgICAgIHZhciBwZWVyX21lZGlhX2VsZW1lbnRzID0ge307XG5cdCAgICAgICAgICAgIHZhciBzb2NrZXRzO1xuXHQgICAgICAgICAgICBfdGhpcy5zb2NrZXRzID0gc29ja2V0cztcblxuXHQgICAgICAgICAgICBmdW5jdGlvbiByZWNlaXZlRGF0YSh5d2VicnRjLCBwZWVyX2lkKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnVmLCBjb3VudDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBvbm1lc3NhZ2UoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHBhcnNlSW50KGV2ZW50LmRhdGEpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZXZlbnQuZGF0YSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVmLnNldChkYXRhLCBjb3VudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gZGF0YS5ieXRlTGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gYnVmLmJ5dGVMZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeXdlYnJ0Yy5yZWNlaXZlTWVzc2FnZShwZWVyX2lkLCBidWYpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBmdW5jdGlvbiBpbml0KHl3ZWJydGMpIHtcblx0ICAgICAgICAgICAgICAgIHNpZ25hbGluZ19zb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgam9pbl9jaGF0X2NoYW5uZWwoREVGQVVMVF9DSEFOTkVMLCB7ICd3aGF0ZXZlci15b3Utd2FudC1oZXJlJzogJ3N0dWZmJyB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgICAgICBzaWduYWxpbmdfc29ja2V0Lm9uKCdzb2NrZXRzJywgZnVuY3Rpb24gKHNvY2tldHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB5d2VicnRjLnNvY2tldHMgPSBzb2NrZXRzO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIHNpZ25hbGluZ19zb2NrZXQub24oJ2Rpc2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLyogVGVhciBkb3duIGFsbCBvZiBvdXIgcGVlciBjb25uZWN0aW9ucyBhbmQgcmVtb3ZlIGFsbCB0aGVcblx0ICAgICAgICAgICAgICAgICAgICAgKiBtZWRpYSBkaXZzIHdoZW4gd2UgZGlzY29ubmVjdCAqL1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAocGVlcl9pZCBpbiBwZWVyX21lZGlhX2VsZW1lbnRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJfbWVkaWFfZWxlbWVudHNbcGVlcl9pZF0ucmVtb3ZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAocGVlcl9pZCBpbiBwZWVycykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwZWVyc1twZWVyX2lkXS5jbG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHBlZXJzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgcGVlcl9tZWRpYV9lbGVtZW50cyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGpvaW5fY2hhdF9jaGFubmVsKGNoYW5uZWwsIHVzZXJkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2lnbmFsaW5nX3NvY2tldC5lbWl0KCdqb2luJywgeyBcImNoYW5uZWxcIjogY2hhbm5lbCwgXCJ1c2VyZGF0YVwiOiB1c2VyZGF0YSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB5d2VicnRjLnVzZXJJRCA9IHNpZ25hbGluZ19zb2NrZXQuaWQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHNpZ25hbGluZ19zb2NrZXQub24oJ2FkZFBlZXInLCBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBlZXJfaWQgPSBjb25maWcucGVlcl9pZDtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwZWVyX2lkIGluIHBlZXJzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoaXMgY291bGQgaGFwcGVuIGlmIHRoZSB1c2VyIGpvaW5zIG11bHRpcGxlIGNoYW5uZWxzIHdoZXJlIHRoZSBvdGhlciBwZWVyIGlzIGFsc28gaW4uICovXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGVlcl9jb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHsgXCJpY2VTZXJ2ZXJzXCI6IElDRV9TRVJWRVJTIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHBlZXJzW3BlZXJfaWRdID0gcGVlcl9jb25uZWN0aW9uO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFDaGFubmVsID0gcGVlcl9jb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKCdkYXRhJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN5bmNEYXRhQ2hhbm5lbCA9IHBlZXJfY29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbCgnc3luY19kYXRhJyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcblx0ICAgICAgICAgICAgICAgICAgICBzeW5jRGF0YUNoYW5uZWwuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cblx0ICAgICAgICAgICAgICAgICAgICB5d2VicnRjLmRjc1twZWVyX2lkXSA9IGRhdGFDaGFubmVsO1xuXHQgICAgICAgICAgICAgICAgICAgIHl3ZWJydGMuc2Rjc1twZWVyX2lkXSA9IHN5bmNEYXRhQ2hhbm5lbDtcblxuXHQgICAgICAgICAgICAgICAgICAgIHl3ZWJydGMudXNlckpvaW5lZChwZWVyX2lkLCAnbWFzdGVyJyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSByZWNlaXZlRGF0YSh5d2VicnRjLCBwZWVyX2lkKTtcblx0ICAgICAgICAgICAgICAgICAgICBzeW5jRGF0YUNoYW5uZWwub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeXdlYnJ0Yy5yZWNlaXZlYnVmZmVyKHBlZXJfaWQsIGUuZGF0YSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHBlZXJfY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWxpbmdfc29ja2V0LmVtaXQoJ3JlbGF5SUNFQ2FuZGlkYXRlJywge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwZWVyX2lkJzogcGVlcl9pZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWNlX2NhbmRpZGF0ZSc6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NkcE1MaW5lSW5kZXgnOiBldmVudC5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmRpZGF0ZSc6IGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnNob3VsZF9jcmVhdGVfb2ZmZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGVlcl9jb25uZWN0aW9uLmNyZWF0ZU9mZmVyKGZ1bmN0aW9uIChsb2NhbF9kZXNjcmlwdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVlcl9jb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24obG9jYWxfZGVzY3JpcHRpb24sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWxpbmdfc29ja2V0LmVtaXQoJ3JlbGF5U2Vzc2lvbkRlc2NyaXB0aW9uJywgeyAncGVlcl9pZCc6IHBlZXJfaWQsICdzZXNzaW9uX2Rlc2NyaXB0aW9uJzogbG9jYWxfZGVzY3JpcHRpb24gfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxlcnQoXCJPZmZlciBzZXRMb2NhbERlc2NyaXB0aW9uIGZhaWxlZCFcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIHNlbmRpbmcgb2ZmZXI6IFwiLCBlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgICAgICAvKiogXG5cdCAgICAgICAgICAgICAgICAgKiBQZWVycyBleGNoYW5nZSBzZXNzaW9uIGRlc2NyaXB0aW9ucyB3aGljaCBjb250YWlucyBpbmZvcm1hdGlvblxuXHQgICAgICAgICAgICAgICAgICogYWJvdXQgdGhlaXIgYXVkaW8gLyB2aWRlbyBzZXR0aW5ncyBhbmQgdGhhdCBzb3J0IG9mIHN0dWZmLiBGaXJzdFxuXHQgICAgICAgICAgICAgICAgICogdGhlICdvZmZlcmVyJyBzZW5kcyBhIGRlc2NyaXB0aW9uIHRvIHRoZSAnYW5zd2VyZXInICh3aXRoIHR5cGVcblx0ICAgICAgICAgICAgICAgICAqIFwib2ZmZXJcIiksIHRoZW4gdGhlIGFuc3dlcmVyIHNlbmRzIG9uZSBiYWNrICh3aXRoIHR5cGUgXCJhbnN3ZXJcIikuICBcblx0ICAgICAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICAgICAgc2lnbmFsaW5nX3NvY2tldC5vbignc2Vzc2lvbkRlc2NyaXB0aW9uJywgZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwZWVyX2lkID0gY29uZmlnLnBlZXJfaWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBlZXIgPSBwZWVyc1twZWVyX2lkXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHBlZXIub25kYXRhY2hhbm5lbCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUNoYW5uZWwgPSBldmVudC5jaGFubmVsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFDaGFubmVsLmxhYmVsID09ICdzeW5jX2RhdGEnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSByZWNlaXZlRGF0YSh5d2VicnRjLCBwZWVyX2lkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFDaGFubmVsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeXdlYnJ0Yy5yZWNlaXZlYnVmZmVyKHBlZXJfaWQsIGUuZGF0YSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdGVfZGVzY3JpcHRpb24gPSBjb25maWcuc2Vzc2lvbl9kZXNjcmlwdGlvbjtcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihyZW1vdGVfZGVzY3JpcHRpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdHVmZiA9IHBlZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oZGVzYywgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3RlX2Rlc2NyaXB0aW9uLnR5cGUgPT0gXCJvZmZlclwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWVyLmNyZWF0ZUFuc3dlcihmdW5jdGlvbiAobG9jYWxfZGVzY3JpcHRpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWVyLnNldExvY2FsRGVzY3JpcHRpb24obG9jYWxfZGVzY3JpcHRpb24sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsaW5nX3NvY2tldC5lbWl0KCdyZWxheVNlc3Npb25EZXNjcmlwdGlvbicsIHsgJ3BlZXJfaWQnOiBwZWVyX2lkLCAnc2Vzc2lvbl9kZXNjcmlwdGlvbic6IGxvY2FsX2Rlc2NyaXB0aW9uIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxlcnQoXCJBbnN3ZXIgc2V0TG9jYWxEZXNjcmlwdGlvbiBmYWlsZWQhXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBjcmVhdGluZyBhbnN3ZXI6IFwiLCBlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNldFJlbW90ZURlc2NyaXB0aW9uIGVycm9yOiBcIiwgZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIHNpZ25hbGluZ19zb2NrZXQub24oJ2ljZUNhbmRpZGF0ZScsIGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGVlciA9IHBlZXJzW2NvbmZpZy5wZWVyX2lkXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWNlX2NhbmRpZGF0ZSA9IGNvbmZpZy5pY2VfY2FuZGlkYXRlO1xuXHQgICAgICAgICAgICAgICAgICAgIHBlZXIuYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoaWNlX2NhbmRpZGF0ZSkpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIHNpZ25hbGluZ19zb2NrZXQub24oJ3JlbW92ZVBlZXInLCBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBlZXJfaWQgPSBjb25maWcucGVlcl9pZDtcblx0ICAgICAgICAgICAgICAgICAgICB5d2VicnRjLnVzZXJMZWZ0KHBlZXJfaWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwZWVyX2lkIGluIHBlZXJfbWVkaWFfZWxlbWVudHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGVlcl9tZWRpYV9lbGVtZW50c1twZWVyX2lkXS5yZW1vdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBlZXJfaWQgaW4gcGVlcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGVlcnNbcGVlcl9pZF0uY2xvc2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGVlcnNbcGVlcl9pZF07XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBlZXJfbWVkaWFfZWxlbWVudHNbY29uZmlnLnBlZXJfaWRdO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaW5pdChzZWxmKTtcblx0ICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKiBlbmQgbWluaW1hbF93ZWJydGMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGNyZWF0ZUNsYXNzKENvbm5lY3RvciwgW3tcblx0ICAgICAgICAgICAga2V5OiAnZGlzY29ubmVjdCcsXG5cdCAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0KCkge31cblx0ICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuXHQgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHt9XG5cdCAgICAgICAgfSwge1xuXHQgICAgICAgICAgICBrZXk6ICdyZWNvbm5lY3QnLFxuXHQgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb25uZWN0KCkge31cblx0ICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgIGtleTogJ3NlbmQnLFxuXHQgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZCh1aWQsIG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCckJCQkJCQkJCQkJCQkJCQkIHN5bmNpbmcuLi4uLi4gJCQkJCQkJCQkJCQkJCQkJCQnKTtcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNlbmQyKGRhdGFDaGFubmVsLCBkYXRhMikge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhQ2hhbm5lbC5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIENIVU5LX0xFTiA9IDY0MDAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gZGF0YTIuYnl0ZUxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBsZW4gLyBDSFVOS19MRU4gfCAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbC5zZW5kKGxlbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwaG90byBhbmQgc2VuZCBpbiBjaHVua3Mgb2YgYWJvdXQgNjRLQlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaSAqIENIVU5LX0xFTixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoaSArIDEpICogQ0hVTktfTEVOO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUNoYW5uZWwuc2VuZChkYXRhMi5zdWJhcnJheShzdGFydCwgZW5kKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCB0aGUgcmVtaW5kZXIsIGlmIGFueVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuICUgQ0hVTktfTEVOKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbC5zZW5kKGRhdGEyLnN1YmFycmF5KG4gKiBDSFVOS19MRU4pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoc2VuZDIsIDUwMCwgZGF0YUNoYW5uZWwsIGRhdGEyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzZW5kMih0aGlzLnNkY3NbdWlkXSwgbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSwge1xuXHQgICAgICAgICAgICBrZXk6ICdicm9hZGNhc3QnLFxuXHQgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYnJvYWRjYXN0KG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHBlZXJfaWQgaW4gdGhpcy5kY3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VuZDIgPSBmdW5jdGlvbiBzZW5kMihkYXRhQ2hhbm5lbCwgZGF0YTIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFDaGFubmVsLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIENIVU5LX0xFTiA9IDY0MDAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGRhdGEyLmJ5dGVMZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGxlbiAvIENIVU5LX0xFTiB8IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbC5zZW5kKGxlbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcGhvdG8gYW5kIHNlbmQgaW4gY2h1bmtzIG9mIGFib3V0IDY0S0Jcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaSAqIENIVU5LX0xFTixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gKGkgKyAxKSAqIENIVU5LX0xFTjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbC5zZW5kKGRhdGEyLnN1YmFycmF5KHN0YXJ0LCBlbmQpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgdGhlIHJlbWluZGVyLCBpZiBhbnlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4gJSBDSFVOS19MRU4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbC5zZW5kKGRhdGEyLnN1YmFycmF5KG4gKiBDSFVOS19MRU4pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycicsIHBlZXJfaWQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQyKHRoaXMuZGNzW3BlZXJfaWRdLCBuZXcgVWludDhBcnJheShtZXNzYWdlKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgIGtleTogJ2lzRGlzY29ubmVjdGVkJyxcblx0ICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGlzY29ubmVjdGVkKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3RlZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1dKTtcblx0ICAgICAgICByZXR1cm4gQ29ubmVjdG9yO1xuXHQgICAgfShZLkFic3RyYWN0Q29ubmVjdG9yKTtcblxuXHQgICAgQ29ubmVjdG9yLmlvID0gbGliJDI7XG5cdCAgICBZWyd3ZWJydGMnXSA9IENvbm5lY3Rvcjtcblx0fVxuXG5cdGlmICh0eXBlb2YgWSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIGV4dGVuZChZKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHR9XG5cblx0cmV0dXJuIGV4dGVuZDtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXktd2VicnRjLmpzLm1hcFxuIiwiXG4vKipcbiAqIHlqcyAtIEEgZnJhbWV3b3JrIGZvciByZWFsLXRpbWUgcDJwIHNoYXJlZCBlZGl0aW5nIG9uIGFueSBkYXRhXG4gKiBAdmVyc2lvbiB2MTMuMC4wLTYyXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwuWSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9O1xuXG4gIHZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuXG4gICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gICAgfVxuXG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICB9O1xuXG4gIHZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbiAgfTtcblxuICB2YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgICAgdmFyIF9hcnIgPSBbXTtcbiAgICAgIHZhciBfbiA9IHRydWU7XG4gICAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgIF9lID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9hcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7XG4gICAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gcm90YXRlKHRyZWUsIHBhcmVudCwgbmV3UGFyZW50LCBuKSB7XG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJlZS5yb290ID0gbmV3UGFyZW50O1xuICAgICAgbmV3UGFyZW50Ll9wYXJlbnQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocGFyZW50LmxlZnQgPT09IG4pIHtcbiAgICAgIHBhcmVudC5sZWZ0ID0gbmV3UGFyZW50O1xuICAgIH0gZWxzZSBpZiAocGFyZW50LnJpZ2h0ID09PSBuKSB7XG4gICAgICBwYXJlbnQucmlnaHQgPSBuZXdQYXJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVsZW1lbnRzIGFyZSB3cm9uZ2x5IGNvbm5lY3RlZCEnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBIGNyZWF0ZWQgbm9kZSBpcyBhbHdheXMgcmVkIVxuICAgIGZ1bmN0aW9uIE4odmFsKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOKTtcblxuICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICB0aGlzLmNvbG9yID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2xlZnQgPSBudWxsO1xuICAgICAgdGhpcy5fcmlnaHQgPSBudWxsO1xuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhOLCBbe1xuICAgICAga2V5OiAnaXNSZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzUmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc0JsYWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JsYWNrKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sb3I7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncmVkZGVuJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWRkZW4oKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSB0cnVlO3JldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2JsYWNrZW4nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJsYWNrZW4oKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBmYWxzZTtyZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyb3RhdGVMZWZ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVMZWZ0KHRyZWUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgbmV3UGFyZW50ID0gdGhpcy5yaWdodDtcbiAgICAgICAgdmFyIG5ld1JpZ2h0ID0gdGhpcy5yaWdodC5sZWZ0O1xuICAgICAgICBuZXdQYXJlbnQubGVmdCA9IHRoaXM7XG4gICAgICAgIHRoaXMucmlnaHQgPSBuZXdSaWdodDtcbiAgICAgICAgcm90YXRlKHRyZWUsIHBhcmVudCwgbmV3UGFyZW50LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICduZXh0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHNlYXJjaCB0aGUgbW9zdCBsZWZ0IG5vZGUgaW4gdGhlIHJpZ2h0IHRyZWVcbiAgICAgICAgICB2YXIgbyA9IHRoaXMucmlnaHQ7XG4gICAgICAgICAgd2hpbGUgKG8ubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG8ubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHAgPSB0aGlzO1xuICAgICAgICAgIHdoaWxlIChwLnBhcmVudCAhPT0gbnVsbCAmJiBwICE9PSBwLnBhcmVudC5sZWZ0KSB7XG4gICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3ByZXYnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBzZWFyY2ggdGhlIG1vc3QgcmlnaHQgbm9kZSBpbiB0aGUgbGVmdCB0cmVlXG4gICAgICAgICAgdmFyIG8gPSB0aGlzLmxlZnQ7XG4gICAgICAgICAgd2hpbGUgKG8ucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG8gPSBvLnJpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcCA9IHRoaXM7XG4gICAgICAgICAgd2hpbGUgKHAucGFyZW50ICE9PSBudWxsICYmIHAgIT09IHAucGFyZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JvdGF0ZVJpZ2h0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVSaWdodCh0cmVlKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IHRoaXMubGVmdDtcbiAgICAgICAgdmFyIG5ld0xlZnQgPSB0aGlzLmxlZnQucmlnaHQ7XG4gICAgICAgIG5ld1BhcmVudC5yaWdodCA9IHRoaXM7XG4gICAgICAgIHRoaXMubGVmdCA9IG5ld0xlZnQ7XG4gICAgICAgIHJvdGF0ZSh0cmVlLCBwYXJlbnQsIG5ld1BhcmVudCwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VW5jbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVuY2xlKCkge1xuICAgICAgICAvLyB3ZSBjYW4gYXNzdW1lIHRoYXQgZ3JhbmRwYXJlbnQgZXhpc3RzIHdoZW4gdGhpcyBpcyBjYWxsZWQhXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCA9PT0gdGhpcy5wYXJlbnQucGFyZW50LmxlZnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucGFyZW50LnJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wYXJlbnQubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dyYW5kcGFyZW50JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3BhcmVudCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzaWJsaW5nJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcyA9PT0gdGhpcy5wYXJlbnQubGVmdCA/IHRoaXMucGFyZW50LnJpZ2h0IDogdGhpcy5wYXJlbnQubGVmdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdsZWZ0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShuKSB7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgbi5fcGFyZW50ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZWZ0ID0gbjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyaWdodCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG4pIHtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICBuLl9wYXJlbnQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gbjtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIE47XG4gIH0oKTtcblxuICAvKlxuICAgKiBUaGlzIGlzIGEgUmVkIEJsYWNrIFRyZWUgaW1wbGVtZW50YXRpb25cbiAgICovXG5cblxuICB2YXIgVHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlKCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZSk7XG5cbiAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoVHJlZSwgW3tcbiAgICAgIGtleTogJ2ZpbmROZXh0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTmV4dChpZCkge1xuICAgICAgICB2YXIgbmV4dElEID0gaWQuY2xvbmUoKTtcbiAgICAgICAgbmV4dElELmNsb2NrICs9IDE7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRXaXRoTG93ZXJCb3VuZChuZXh0SUQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmRQcmV2JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kUHJldihpZCkge1xuICAgICAgICB2YXIgcHJldklEID0gaWQuY2xvbmUoKTtcbiAgICAgICAgcHJldklELmNsb2NrIC09IDE7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRXaXRoVXBwZXJCb3VuZChwcmV2SUQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmROb2RlV2l0aExvd2VyQm91bmQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmROb2RlV2l0aExvd2VyQm91bmQoZnJvbSkge1xuICAgICAgICB2YXIgbyA9IHRoaXMucm9vdDtcbiAgICAgICAgaWYgKG8gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IG51bGwgfHwgZnJvbS5sZXNzVGhhbihvLnZhbC5faWQpICYmIG8ubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBvIGlzIGluY2x1ZGVkIGluIHRoZSBib3VuZFxuICAgICAgICAgICAgICAvLyB0cnkgdG8gZmluZCBhbiBlbGVtZW50IHRoYXQgaXMgY2xvc2VyIHRvIHRoZSBib3VuZFxuICAgICAgICAgICAgICBvID0gby5sZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcm9tICE9PSBudWxsICYmIG8udmFsLl9pZC5sZXNzVGhhbihmcm9tKSkge1xuICAgICAgICAgICAgICAvLyBvIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kLCBtYXliZSBvbmUgb2YgdGhlIHJpZ2h0IGVsZW1lbnRzIGlzLi5cbiAgICAgICAgICAgICAgaWYgKG8ucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvID0gby5yaWdodDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyByaWdodCBlbGVtZW50LiBTZWFyY2ggZm9yIHRoZSBuZXh0IGJpZ2dlciBlbGVtZW50LFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIG8ubmV4dCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaW5kTm9kZVdpdGhVcHBlckJvdW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTm9kZVdpdGhVcHBlckJvdW5kKHRvKSB7XG4gICAgICAgIGlmICh0byA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBkZWZpbmUgZnJvbSEnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbyA9IHRoaXMucm9vdDtcbiAgICAgICAgaWYgKG8gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCh0byA9PT0gbnVsbCB8fCBvLnZhbC5faWQubGVzc1RoYW4odG8pKSAmJiBvLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIG8gaXMgaW5jbHVkZWQgaW4gdGhlIGJvdW5kXG4gICAgICAgICAgICAgIC8vIHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgdGhhdCBpcyBjbG9zZXIgdG8gdGhlIGJvdW5kXG4gICAgICAgICAgICAgIG8gPSBvLnJpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0byAhPT0gbnVsbCAmJiB0by5sZXNzVGhhbihvLnZhbC5faWQpKSB7XG4gICAgICAgICAgICAgIC8vIG8gaXMgbm90IHdpdGhpbiB0aGUgYm91bmQsIG1heWJlIG9uZSBvZiB0aGUgbGVmdCBlbGVtZW50cyBpcy4uXG4gICAgICAgICAgICAgIGlmIChvLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvID0gby5sZWZ0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIGxlZnQgZWxlbWVudC4gU2VhcmNoIGZvciB0aGUgcHJldiBzbWFsbGVyIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgYmUgd2l0aGluIHRoZSBib3VuZHNcbiAgICAgICAgICAgICAgICByZXR1cm4gby5wcmV2KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmRTbWFsbGVzdE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRTbWFsbGVzdE5vZGUoKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5yb290O1xuICAgICAgICB3aGlsZSAobyAhPSBudWxsICYmIG8ubGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgbyA9IG8ubGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaW5kV2l0aExvd2VyQm91bmQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRXaXRoTG93ZXJCb3VuZChmcm9tKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5maW5kTm9kZVdpdGhMb3dlckJvdW5kKGZyb20pO1xuICAgICAgICByZXR1cm4gbiA9PSBudWxsID8gbnVsbCA6IG4udmFsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmRXaXRoVXBwZXJCb3VuZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFdpdGhVcHBlckJvdW5kKHRvKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5maW5kTm9kZVdpdGhVcHBlckJvdW5kKHRvKTtcbiAgICAgICAgcmV0dXJuIG4gPT0gbnVsbCA/IG51bGwgOiBuLnZhbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpdGVyYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpdGVyYXRlKGZyb20sIHRvLCBmKSB7XG4gICAgICAgIHZhciBvO1xuICAgICAgICBpZiAoZnJvbSA9PT0gbnVsbCkge1xuICAgICAgICAgIG8gPSB0aGlzLmZpbmRTbWFsbGVzdE5vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvID0gdGhpcy5maW5kTm9kZVdpdGhMb3dlckJvdW5kKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmICh0byA9PT0gbnVsbCB8fCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVubW9kaWZpZWQtbG9vcC1jb25kaXRpb25cbiAgICAgICAgby52YWwuX2lkLmxlc3NUaGFuKHRvKSB8fCBvLnZhbC5faWQuZXF1YWxzKHRvKSkpIHtcbiAgICAgICAgICBmKG8udmFsKTtcbiAgICAgICAgICBvID0gby5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kKGlkKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5maW5kTm9kZShpZCk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG4udmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZmluZE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmROb2RlKGlkKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5yb290O1xuICAgICAgICBpZiAobyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAobyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZC5sZXNzVGhhbihvLnZhbC5faWQpKSB7XG4gICAgICAgICAgICAgIG8gPSBvLmxlZnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG8udmFsLl9pZC5sZXNzVGhhbihpZCkpIHtcbiAgICAgICAgICAgICAgbyA9IG8ucmlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZWxldGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoaWQpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmZpbmROb2RlKGlkKTtcbiAgICAgICAgaWYgKGQgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBkb2VzIG5vdCBleGlzdCEnKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICBpZiAoZC5sZWZ0ICE9PSBudWxsICYmIGQucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBzd2l0Y2ggZCB3aXRoIHRoZSBncmVhdGVzIGVsZW1lbnQgaW4gdGhlIGxlZnQgc3VidHJlZS5cbiAgICAgICAgICAvLyBvIHNob3VsZCBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlxuICAgICAgICAgIHZhciBvID0gZC5sZWZ0O1xuICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICB3aGlsZSAoby5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG8ucmlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN3aXRjaFxuICAgICAgICAgIGQudmFsID0gby52YWw7XG4gICAgICAgICAgZCA9IG87XG4gICAgICAgIH1cbiAgICAgICAgLy8gZCBoYXMgYXQgbW9zdCBvbmUgY2hpbGRcbiAgICAgICAgLy8gbGV0IG4gYmUgdGhlIG5vZGUgdGhhdCByZXBsYWNlcyBkXG4gICAgICAgIHZhciBpc0Zha2VDaGlsZDtcbiAgICAgICAgdmFyIGNoaWxkID0gZC5sZWZ0IHx8IGQucmlnaHQ7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlzRmFrZUNoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBjaGlsZCA9IG5ldyBOKG51bGwpO1xuICAgICAgICAgIGNoaWxkLmJsYWNrZW4oKTtcbiAgICAgICAgICBkLnJpZ2h0ID0gY2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNGYWtlQ2hpbGQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmICghaXNGYWtlQ2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IGNoaWxkO1xuICAgICAgICAgICAgY2hpbGQuYmxhY2tlbigpO1xuICAgICAgICAgICAgY2hpbGQuX3BhcmVudCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChkLnBhcmVudC5sZWZ0ID09PSBkKSB7XG4gICAgICAgICAgZC5wYXJlbnQubGVmdCA9IGNoaWxkO1xuICAgICAgICB9IGVsc2UgaWYgKGQucGFyZW50LnJpZ2h0ID09PSBkKSB7XG4gICAgICAgICAgZC5wYXJlbnQucmlnaHQgPSBjaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcG9zc2libGUhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuaXNCbGFjaygpKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmlzUmVkKCkpIHtcbiAgICAgICAgICAgIGNoaWxkLmJsYWNrZW4oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZml4RGVsZXRlKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290LmJsYWNrZW4oKTtcbiAgICAgICAgaWYgKGlzRmFrZUNoaWxkKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLnBhcmVudC5sZWZ0ID09PSBjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50LmxlZnQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQucGFyZW50LnJpZ2h0ID09PSBjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50LnJpZ2h0ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlICMzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpeERlbGV0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeERlbGV0ZShuKSB7XG4gICAgICAgIGZ1bmN0aW9uIGlzQmxhY2sobm9kZSkge1xuICAgICAgICAgIHJldHVybiBub2RlICE9PSBudWxsID8gbm9kZS5pc0JsYWNrKCkgOiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzUmVkKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZSAhPT0gbnVsbCA/IG5vZGUuaXNSZWQoKSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIHRoaXMgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBmaXJzdCBpdGVyYXRpb24gb2YgZml4RGVsZXRlLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBkIHdhcyBhbHJlYWR5IHJlcGxhY2VkIGJ5IHRoZSBjaGlsZFxuICAgICAgICAvLyBkIGlzIG5vdCB0aGUgcm9vdFxuICAgICAgICAvLyBkIGFuZCBjaGlsZCBhcmUgYmxhY2tcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBuLnNpYmxpbmc7XG4gICAgICAgIGlmIChpc1JlZChzaWJsaW5nKSkge1xuICAgICAgICAgIC8vIG1ha2Ugc2libGluZyB0aGUgZ3JhbmRmYXRoZXJcbiAgICAgICAgICBuLnBhcmVudC5yZWRkZW4oKTtcbiAgICAgICAgICBzaWJsaW5nLmJsYWNrZW4oKTtcbiAgICAgICAgICBpZiAobiA9PT0gbi5wYXJlbnQubGVmdCkge1xuICAgICAgICAgICAgbi5wYXJlbnQucm90YXRlTGVmdCh0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IG4ucGFyZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICBuLnBhcmVudC5yb3RhdGVSaWdodCh0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlICMyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpYmxpbmcgPSBuLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFyZW50LCBzaWJsaW5nLCBhbmQgY2hpbGRyZW4gb2YgbiBhcmUgYmxhY2tcbiAgICAgICAgaWYgKG4ucGFyZW50LmlzQmxhY2soKSAmJiBzaWJsaW5nLmlzQmxhY2soKSAmJiBpc0JsYWNrKHNpYmxpbmcubGVmdCkgJiYgaXNCbGFjayhzaWJsaW5nLnJpZ2h0KSkge1xuICAgICAgICAgIHNpYmxpbmcucmVkZGVuKCk7XG4gICAgICAgICAgdGhpcy5fZml4RGVsZXRlKG4ucGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChuLnBhcmVudC5pc1JlZCgpICYmIHNpYmxpbmcuaXNCbGFjaygpICYmIGlzQmxhY2soc2libGluZy5sZWZ0KSAmJiBpc0JsYWNrKHNpYmxpbmcucmlnaHQpKSB7XG4gICAgICAgICAgc2libGluZy5yZWRkZW4oKTtcbiAgICAgICAgICBuLnBhcmVudC5ibGFja2VuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG4gPT09IG4ucGFyZW50LmxlZnQgJiYgc2libGluZy5pc0JsYWNrKCkgJiYgaXNSZWQoc2libGluZy5sZWZ0KSAmJiBpc0JsYWNrKHNpYmxpbmcucmlnaHQpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLnJlZGRlbigpO1xuICAgICAgICAgICAgc2libGluZy5sZWZ0LmJsYWNrZW4oKTtcbiAgICAgICAgICAgIHNpYmxpbmcucm90YXRlUmlnaHQodGhpcyk7XG4gICAgICAgICAgICBzaWJsaW5nID0gbi5zaWJsaW5nO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gbi5wYXJlbnQucmlnaHQgJiYgc2libGluZy5pc0JsYWNrKCkgJiYgaXNSZWQoc2libGluZy5yaWdodCkgJiYgaXNCbGFjayhzaWJsaW5nLmxlZnQpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLnJlZGRlbigpO1xuICAgICAgICAgICAgc2libGluZy5yaWdodC5ibGFja2VuKCk7XG4gICAgICAgICAgICBzaWJsaW5nLnJvdGF0ZUxlZnQodGhpcyk7XG4gICAgICAgICAgICBzaWJsaW5nID0gbi5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWJsaW5nLmNvbG9yID0gbi5wYXJlbnQuY29sb3I7XG4gICAgICAgICAgbi5wYXJlbnQuYmxhY2tlbigpO1xuICAgICAgICAgIGlmIChuID09PSBuLnBhcmVudC5sZWZ0KSB7XG4gICAgICAgICAgICBzaWJsaW5nLnJpZ2h0LmJsYWNrZW4oKTtcbiAgICAgICAgICAgIG4ucGFyZW50LnJvdGF0ZUxlZnQodGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcubGVmdC5ibGFja2VuKCk7XG4gICAgICAgICAgICBuLnBhcmVudC5yb3RhdGVSaWdodCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdwdXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1dCh2KSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE4odik7XG4gICAgICAgIGlmICh0aGlzLnJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgcCA9IHRoaXMucm9vdDsgLy8gcCBhYmJyZXYuIHBhcmVudFxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS52YWwuX2lkLmxlc3NUaGFuKHAudmFsLl9pZCkpIHtcbiAgICAgICAgICAgICAgaWYgKHAubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHAubGVmdCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHAubGVmdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwLnZhbC5faWQubGVzc1RoYW4obm9kZS52YWwuX2lkKSkge1xuICAgICAgICAgICAgICBpZiAocC5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHAucmlnaHQgPSBub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBwLnJpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnZhbCA9IG5vZGUudmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZml4SW5zZXJ0KG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucm9vdCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgdGhpcy5yb290LmJsYWNrZW4oKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpeEluc2VydCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeEluc2VydChuKSB7XG4gICAgICAgIGlmIChuLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIG4uYmxhY2tlbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChuLnBhcmVudC5pc0JsYWNrKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVuY2xlID0gbi5nZXRVbmNsZSgpO1xuICAgICAgICBpZiAodW5jbGUgIT09IG51bGwgJiYgdW5jbGUuaXNSZWQoKSkge1xuICAgICAgICAgIC8vIE5vdGU6IHBhcmVudDogcmVkLCB1bmNsZTogcmVkXG4gICAgICAgICAgbi5wYXJlbnQuYmxhY2tlbigpO1xuICAgICAgICAgIHVuY2xlLmJsYWNrZW4oKTtcbiAgICAgICAgICBuLmdyYW5kcGFyZW50LnJlZGRlbigpO1xuICAgICAgICAgIHRoaXMuX2ZpeEluc2VydChuLmdyYW5kcGFyZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3RlOiBwYXJlbnQ6IHJlZCwgdW5jbGU6IGJsYWNrIG9yIG51bGxcbiAgICAgICAgICAvLyBOb3cgd2UgdHJhbnNmb3JtIHRoZSB0cmVlIGluIHN1Y2ggYSB3YXkgdGhhdFxuICAgICAgICAgIC8vIGVpdGhlciBvZiB0aGVzZSBob2xkczpcbiAgICAgICAgICAvLyAgIDEpIGdyYW5kcGFyZW50LmxlZnQuaXNSZWRcbiAgICAgICAgICAvLyAgICAgYW5kIGdyYW5kcGFyZW50LmxlZnQubGVmdC5pc1JlZFxuICAgICAgICAgIC8vICAgMikgZ3JhbmRwYXJlbnQucmlnaHQuaXNSZWRcbiAgICAgICAgICAvLyAgICAgYW5kIGdyYW5kcGFyZW50LnJpZ2h0LnJpZ2h0LmlzUmVkXG4gICAgICAgICAgaWYgKG4gPT09IG4ucGFyZW50LnJpZ2h0ICYmIG4ucGFyZW50ID09PSBuLmdyYW5kcGFyZW50LmxlZnQpIHtcbiAgICAgICAgICAgIG4ucGFyZW50LnJvdGF0ZUxlZnQodGhpcyk7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSByb3RhdGVkIGFuZCB3YW50IHRvIHVzZSB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIGNhc2VzLCB3ZSBuZWVkIHRvIHNldCBuIGluIHN1Y2ggYSB3YXkgdGhhdFxuICAgICAgICAgICAgLy8gbi5wYXJlbnQuaXNSZWQgYWdhaW5cbiAgICAgICAgICAgIG4gPSBuLmxlZnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChuID09PSBuLnBhcmVudC5sZWZ0ICYmIG4ucGFyZW50ID09PSBuLmdyYW5kcGFyZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICBuLnBhcmVudC5yb3RhdGVSaWdodCh0aGlzKTtcbiAgICAgICAgICAgIC8vIHNlZSBhYm92ZVxuICAgICAgICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhc2UgMSkgb3IgMikgaG9sZCBmcm9tIGhlcmUgb24uXG4gICAgICAgICAgLy8gTm93IHRyYXZlcnNlIGdyYW5kcGFyZW50LCBtYWtlIHBhcmVudCBhIGJsYWNrIG5vZGVcbiAgICAgICAgICAvLyBvbiB0aGUgaGlnaGVzdCBsZXZlbCB3aGljaCBob2xkcyB0d28gcmVkIG5vZGVzLlxuICAgICAgICAgIG4ucGFyZW50LmJsYWNrZW4oKTtcbiAgICAgICAgICBuLmdyYW5kcGFyZW50LnJlZGRlbigpO1xuICAgICAgICAgIGlmIChuID09PSBuLnBhcmVudC5sZWZ0KSB7XG4gICAgICAgICAgICAvLyBDYXNlIDFcbiAgICAgICAgICAgIG4uZ3JhbmRwYXJlbnQucm90YXRlUmlnaHQodGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhc2UgMlxuICAgICAgICAgICAgbi5ncmFuZHBhcmVudC5yb3RhdGVMZWZ0KHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gVHJlZTtcbiAgfSgpO1xuXG4gIHZhciBJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJRCh1c2VyLCBjbG9jaykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSUQpO1xuXG4gICAgICB0aGlzLnVzZXIgPSB1c2VyOyAvLyBUT0RPOiByZW5hbWUgdG8gY2xpZW50XG4gICAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoSUQsIFt7XG4gICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJRCh0aGlzLnVzZXIsIHRoaXMuY2xvY2spO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlcXVhbHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkICE9PSBudWxsICYmIGlkLnVzZXIgPT09IHRoaXMudXNlciAmJiBpZC5jbG9jayA9PT0gdGhpcy5jbG9jaztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGVzc1RoYW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsZXNzVGhhbihpZCkge1xuICAgICAgICBpZiAoaWQuY29uc3RydWN0b3IgPT09IElEKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudXNlciA8IGlkLnVzZXIgfHwgdGhpcy51c2VyID09PSBpZC51c2VyICYmIHRoaXMuY2xvY2sgPCBpZC5jbG9jaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIElEO1xuICB9KCk7XG5cbiAgdmFyIERTTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEU05vZGUoaWQsIGxlbiwgZ2MpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERTTm9kZSk7XG5cbiAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICAgIHRoaXMuZ2MgPSBnYztcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhEU05vZGUsIFt7XG4gICAgICBrZXk6ICdjbG9uZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRFNOb2RlKHRoaXMuX2lkLCB0aGlzLmxlbiwgdGhpcy5nYyk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBEU05vZGU7XG4gIH0oKTtcblxuICB2YXIgRGVsZXRlU3RvcmUgPSBmdW5jdGlvbiAoX1RyZWUpIHtcbiAgICBpbmhlcml0cyhEZWxldGVTdG9yZSwgX1RyZWUpO1xuXG4gICAgZnVuY3Rpb24gRGVsZXRlU3RvcmUoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEZWxldGVTdG9yZSk7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRGVsZXRlU3RvcmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEZWxldGVTdG9yZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKERlbGV0ZVN0b3JlLCBbe1xuICAgICAga2V5OiAnbG9nVGFibGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ1RhYmxlKCkge1xuICAgICAgICB2YXIgZGVsZXRlcyA9IFtdO1xuICAgICAgICB0aGlzLml0ZXJhdGUobnVsbCwgbnVsbCwgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICBkZWxldGVzLnB1c2goe1xuICAgICAgICAgICAgdXNlcjogbi5faWQudXNlcixcbiAgICAgICAgICAgIGNsb2NrOiBuLl9pZC5jbG9jayxcbiAgICAgICAgICAgIGxlbjogbi5sZW4sXG4gICAgICAgICAgICBnYzogbi5nY1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS50YWJsZShkZWxldGVzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc0RlbGV0ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGVsZXRlZChpZCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuZmluZFdpdGhVcHBlckJvdW5kKGlkKTtcbiAgICAgICAgcmV0dXJuIG4gIT09IG51bGwgJiYgbi5faWQudXNlciA9PT0gaWQudXNlciAmJiBpZC5jbG9jayA8IG4uX2lkLmNsb2NrICsgbi5sZW47XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFyaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFyayhpZCwgbGVuZ3RoLCBnYykge1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIC8vIFN0ZXAgMS4gVW5tYXJrIHJhbmdlXG4gICAgICAgIHZhciBsZWZ0RCA9IHRoaXMuZmluZFdpdGhVcHBlckJvdW5kKG5ldyBJRChpZC51c2VyLCBpZC5jbG9jayAtIDEpKTtcbiAgICAgICAgLy8gUmVzaXplIGxlZnQgRFNOb2RlIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAobGVmdEQgIT09IG51bGwgJiYgbGVmdEQuX2lkLnVzZXIgPT09IGlkLnVzZXIpIHtcbiAgICAgICAgICBpZiAobGVmdEQuX2lkLmNsb2NrIDwgaWQuY2xvY2sgJiYgaWQuY2xvY2sgPCBsZWZ0RC5faWQuY2xvY2sgKyBsZWZ0RC5sZW4pIHtcbiAgICAgICAgICAgIC8vIG5vZGUgaXMgb3ZlcmxhcHBpbmcuIG5lZWQgdG8gcmVzaXplXG4gICAgICAgICAgICBpZiAoaWQuY2xvY2sgKyBsZW5ndGggPCBsZWZ0RC5faWQuY2xvY2sgKyBsZWZ0RC5sZW4pIHtcbiAgICAgICAgICAgICAgLy8gb3ZlcmxhcHMgbmV3IG1hcmsgcmFuZ2UgYW5kIHNvbWUgbW9yZVxuICAgICAgICAgICAgICAvLyBjcmVhdGUgYW5vdGhlciBEU05vZGUgdG8gdGhlIHJpZ2h0IG9mIG5ldyBtYXJrXG4gICAgICAgICAgICAgIHRoaXMucHV0KG5ldyBEU05vZGUobmV3IElEKGlkLnVzZXIsIGlkLmNsb2NrICsgbGVuZ3RoKSwgbGVmdEQuX2lkLmNsb2NrICsgbGVmdEQubGVuIC0gaWQuY2xvY2sgLSBsZW5ndGgsIGxlZnRELmdjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXNpemUgbGVmdCBEU05vZGVcbiAgICAgICAgICAgIGxlZnRELmxlbiA9IGlkLmNsb2NrIC0gbGVmdEQuX2lkLmNsb2NrO1xuICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlIHRoZXJlIGlzIG5vIG92ZXJsYXBwaW5nXG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzaXplIHJpZ2h0IERTTm9kZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIHVwcGVyID0gbmV3IElEKGlkLnVzZXIsIGlkLmNsb2NrICsgbGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciByaWdodEQgPSB0aGlzLmZpbmRXaXRoVXBwZXJCb3VuZCh1cHBlcik7XG4gICAgICAgIGlmIChyaWdodEQgIT09IG51bGwgJiYgcmlnaHRELl9pZC51c2VyID09PSBpZC51c2VyKSB7XG4gICAgICAgICAgaWYgKHJpZ2h0RC5faWQuY2xvY2sgPCBpZC5jbG9jayArIGxlbmd0aCAmJiBpZC5jbG9jayA8PSByaWdodEQuX2lkLmNsb2NrICYmIGlkLmNsb2NrICsgbGVuZ3RoIDwgcmlnaHRELl9pZC5jbG9jayArIHJpZ2h0RC5sZW4pIHtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgY29uc2lkZXIgdGhlIGNhc2Ugd2hlcmUgd2UgcmVzaXplIHRoZSBub2RlXG4gICAgICAgICAgICB2YXIgZCA9IGlkLmNsb2NrICsgbGVuZ3RoIC0gcmlnaHRELl9pZC5jbG9jaztcbiAgICAgICAgICAgIHJpZ2h0RC5faWQgPSBuZXcgSUQocmlnaHRELl9pZC51c2VyLCByaWdodEQuX2lkLmNsb2NrICsgZCk7XG4gICAgICAgICAgICByaWdodEQubGVuIC09IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyB3ZSBvbmx5IGhhdmUgdG8gZGVsZXRlIGFsbCBpbm5lciBtYXJrc1xuICAgICAgICB2YXIgZGVsZXRlTm9kZUlkcyA9IFtdO1xuICAgICAgICB0aGlzLml0ZXJhdGUoaWQsIHVwcGVyLCBmdW5jdGlvbiAobSkge1xuICAgICAgICAgIGRlbGV0ZU5vZGVJZHMucHVzaChtLl9pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gZGVsZXRlTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMuZGVsZXRlKGRlbGV0ZU5vZGVJZHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdNYXJrID0gbmV3IERTTm9kZShpZCwgbGVuZ3RoLCBnYyk7XG4gICAgICAgIC8vIFN0ZXAgMi4gQ2hlY2sgaWYgd2UgY2FuIGV4dGVuZCBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgIGlmIChsZWZ0RCAhPT0gbnVsbCAmJiBsZWZ0RC5faWQudXNlciA9PT0gaWQudXNlciAmJiBsZWZ0RC5faWQuY2xvY2sgKyBsZWZ0RC5sZW4gPT09IGlkLmNsb2NrICYmIGxlZnRELmdjID09PSBnYykge1xuICAgICAgICAgIC8vIFdlIGNhbiBleHRlbmQgbGVmdFxuICAgICAgICAgIGxlZnRELmxlbiArPSBsZW5ndGg7XG4gICAgICAgICAgbmV3TWFyayA9IGxlZnREO1xuICAgICAgICB9XG4gICAgICAgIHZhciByaWdodE5leHQgPSB0aGlzLmZpbmQobmV3IElEKGlkLnVzZXIsIGlkLmNsb2NrICsgbGVuZ3RoKSk7XG4gICAgICAgIGlmIChyaWdodE5leHQgIT09IG51bGwgJiYgcmlnaHROZXh0Ll9pZC51c2VyID09PSBpZC51c2VyICYmIGlkLmNsb2NrICsgbGVuZ3RoID09PSByaWdodE5leHQuX2lkLmNsb2NrICYmIGdjID09PSByaWdodE5leHQuZ2MpIHtcbiAgICAgICAgICAvLyBXZSBjYW4gbWVyZ2UgbmV3TWFyayBhbmQgcmlnaHROZXh0XG4gICAgICAgICAgbmV3TWFyay5sZW4gKz0gcmlnaHROZXh0LmxlbjtcbiAgICAgICAgICB0aGlzLmRlbGV0ZShyaWdodE5leHQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdEQgIT09IG5ld01hcmspIHtcbiAgICAgICAgICAvLyBvbmx5IHB1dCBpZiB3ZSBkaWRuJ3QgZXh0ZW5kIGxlZnRcbiAgICAgICAgICB0aGlzLnB1dChuZXdNYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVE9ETzogZXhjaGFuZ2UgbWFya0RlbGV0ZWQgZm9yIG1hcmsoKVxuXG4gICAgfSwge1xuICAgICAga2V5OiAnbWFya0RlbGV0ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtEZWxldGVkKGlkLCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5tYXJrKGlkLCBsZW5ndGgsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIERlbGV0ZVN0b3JlO1xuICB9KFRyZWUpO1xuXG4gIC8qKlxuICAgKiBBIEJpbmFyeURlY29kZXIgaGFuZGxlcyB0aGUgZGVjb2Rpbmcgb2YgYW4gQXJyYXlCdWZmZXIuXG4gICAqL1xuXG4gIHZhciBCaW5hcnlEZWNvZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheXxCdWZmZXJ9IGJ1ZmZlciBUaGUgYmluYXJ5IGRhdGEgdGhhdCB0aGlzIGluc3RhbmNlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQmluYXJ5RGVjb2RlcihidWZmZXIpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJpbmFyeURlY29kZXIpO1xuXG4gICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdGhpcy51aW50OGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYnVmZmVyIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIHRoaXMudWludDhhcnIgPSBidWZmZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFuIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkhJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmUgdGhpcyBkZWNvZGVyIGluc3RhbmNlLlxuICAgICAqIE9wdGlvbmFsbHkgc2V0IGEgbmV3IHBvc2l0aW9uIHBhcmFtZXRlci5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoQmluYXJ5RGVjb2RlciwgW3tcbiAgICAgIGtleTogJ2Nsb25lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIG5ld1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5wb3M7XG5cbiAgICAgICAgdmFyIGRlY29kZXIgPSBuZXcgQmluYXJ5RGVjb2Rlcih0aGlzLnVpbnQ4YXJyKTtcbiAgICAgICAgZGVjb2Rlci5wb3MgPSBuZXdQb3M7XG4gICAgICAgIHJldHVybiBkZWNvZGVyO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE51bWJlciBvZiBieXRlcy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2tpcDgnLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogU2tpcCBvbmUgYnl0ZSwganVtcCB0byB0aGUgbmV4dCBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNraXA4KCkge1xuICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWQgb25lIGJ5dGUgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVhZFVpbnQ4JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVWludDgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQ4YXJyW3RoaXMucG9zKytdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWQgNCBieXRlcyBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVhZFVpbnQzMicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFVpbnQzMigpIHtcbiAgICAgICAgdmFyIHVpbnQgPSB0aGlzLnVpbnQ4YXJyW3RoaXMucG9zXSArICh0aGlzLnVpbnQ4YXJyW3RoaXMucG9zICsgMV0gPDwgOCkgKyAodGhpcy51aW50OGFyclt0aGlzLnBvcyArIDJdIDw8IDE2KSArICh0aGlzLnVpbnQ4YXJyW3RoaXMucG9zICsgM10gPDwgMjQpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdWludDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMb29rIGFoZWFkIHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uLlxuICAgICAgICogdG8gdGhlIG5leHQgYnl0ZSBhbmQgcmVhZCBpdCBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncGVla1VpbnQ4JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwZWVrVWludDgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQ4YXJyW3RoaXMucG9zXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWFkIHVuc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAgICAgICAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gICAgICAgKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0ZS5cbiAgICAgICAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnl0ZXMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWFkVmFyVWludCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFZhclVpbnQoKSB7XG4gICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICB2YXIgbGVuID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgciA9IHRoaXMudWludDhhcnJbdGhpcy5wb3MrK107XG4gICAgICAgICAgbnVtID0gbnVtIHwgKHIgJiAxMjcpIDw8IGxlbjtcbiAgICAgICAgICBsZW4gKz0gNztcbiAgICAgICAgICBpZiAociA8IDEgPDwgNykge1xuICAgICAgICAgICAgcmV0dXJuIG51bSA+Pj4gMDsgLy8gcmV0dXJuIHVuc2lnbmVkIG51bWJlciFcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlbiA+IDM1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXIgb3V0IG9mIHJhbmdlIScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWQgc3RyaW5nIG9mIHZhcmlhYmxlIGxlbmd0aFxuICAgICAgICogKiB2YXJVaW50IGlzIHVzZWQgdG8gc3RvcmUgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmcuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlYWRWYXJTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRWYXJTdHJpbmcoKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgYnl0ZXNbaV0gPSB0aGlzLnVpbnQ4YXJyW3RoaXMucG9zKytdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmNvZGVkU3RyaW5nID0gYnl0ZXMubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGIpO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyU3RyaW5nIHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3BlZWtWYXJTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBlZWtWYXJTdHJpbmcoKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdmFyIHMgPSB0aGlzLnJlYWRWYXJTdHJpbmcoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWQgSUQuXG4gICAgICAgKiAqIElmIGZpcnN0IHZhclVpbnQgcmVhZCBpcyAweEZGRkZGRiBhIFJvb3RJRCBpcyByZXR1cm5lZC5cbiAgICAgICAqICogT3RoZXJ3aXNlIGFuIElEIGlzIHJldHVybmVkLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4gSURcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVhZElEJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkSUQoKSB7XG4gICAgICAgIHZhciB1c2VyID0gdGhpcy5yZWFkVmFyVWludCgpO1xuICAgICAgICBpZiAodXNlciA9PT0gUm9vdEZha2VVc2VySUQpIHtcbiAgICAgICAgICAvLyByZWFkIHByb3BlcnR5IG5hbWUgYW5kIHR5cGUgaWRcbiAgICAgICAgICB2YXIgcmlkID0gbmV3IFJvb3RJRCh0aGlzLnJlYWRWYXJTdHJpbmcoKSwgbnVsbCk7XG4gICAgICAgICAgcmlkLnR5cGUgPSB0aGlzLnJlYWRWYXJVaW50KCk7XG4gICAgICAgICAgcmV0dXJuIHJpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IElEKHVzZXIsIHRoaXMucmVhZFZhclVpbnQoKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbGVuZ3RoJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50OGFyci5sZW5ndGg7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBCaW5hcnlEZWNvZGVyO1xuICB9KCk7XG5cbiAgLy8gVE9ETyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBiYXNlIGNsYXNzIGFzIEl0ZW1cblxuICB2YXIgR0MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR0MoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBHQyk7XG5cbiAgICAgIHRoaXMuX2lkID0gbnVsbDtcbiAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoR0MsIFt7XG4gICAgICBrZXk6ICdfaW50ZWdyYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW50ZWdyYXRlKHkpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5faWQ7XG4gICAgICAgIHZhciB1c2VyU3RhdGUgPSB5LnNzLmdldFN0YXRlKGlkLnVzZXIpO1xuICAgICAgICBpZiAoaWQuY2xvY2sgPT09IHVzZXJTdGF0ZSkge1xuICAgICAgICAgIHkuc3Muc2V0U3RhdGUoaWQudXNlciwgaWQuY2xvY2sgKyB0aGlzLl9sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHkuZHMubWFyayh0aGlzLl9pZCwgdGhpcy5fbGVuZ3RoLCB0cnVlKTtcbiAgICAgICAgdmFyIG4gPSB5Lm9zLnB1dCh0aGlzKTtcbiAgICAgICAgdmFyIHByZXYgPSBuLnByZXYoKS52YWw7XG4gICAgICAgIGlmIChwcmV2ICE9PSBudWxsICYmIHByZXYuY29uc3RydWN0b3IgPT09IEdDICYmIHByZXYuX2lkLnVzZXIgPT09IG4udmFsLl9pZC51c2VyICYmIHByZXYuX2lkLmNsb2NrICsgcHJldi5fbGVuZ3RoID09PSBuLnZhbC5faWQuY2xvY2spIHtcbiAgICAgICAgICAvLyBUT0RPOiBkbyBtZXJnaW5nIGZvciBhbGwgaXRlbXMhXG4gICAgICAgICAgcHJldi5fbGVuZ3RoICs9IG4udmFsLl9sZW5ndGg7XG4gICAgICAgICAgeS5vcy5kZWxldGUobi52YWwuX2lkKTtcbiAgICAgICAgICBuID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobi52YWwpIHtcbiAgICAgICAgICBuID0gbi52YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQgPSB5Lm9zLmZpbmROZXh0KG4uX2lkKTtcbiAgICAgICAgaWYgKG5leHQgIT09IG51bGwgJiYgbmV4dC5jb25zdHJ1Y3RvciA9PT0gR0MgJiYgbmV4dC5faWQudXNlciA9PT0gbi5faWQudXNlciAmJiBuZXh0Ll9pZC5jbG9jayA9PT0gbi5faWQuY2xvY2sgKyBuLl9sZW5ndGgpIHtcbiAgICAgICAgICBuLl9sZW5ndGggKz0gbmV4dC5fbGVuZ3RoO1xuICAgICAgICAgIHkub3MuZGVsZXRlKG5leHQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQudXNlciAhPT0gUm9vdEZha2VVc2VySUQpIHtcbiAgICAgICAgICBpZiAoeS5jb25uZWN0b3IgIT09IG51bGwgJiYgKHkuY29ubmVjdG9yLl9mb3J3YXJkQXBwbGllZFN0cnVjdHMgfHwgaWQudXNlciA9PT0geS51c2VySUQpKSB7XG4gICAgICAgICAgICB5LmNvbm5lY3Rvci5icm9hZGNhc3RTdHJ1Y3QodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5LnBlcnNpc3RlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB5LnBlcnNpc3RlbmNlLnNhdmVTdHJ1Y3QoeSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAgICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0JpbmFyeUVuY29kZXJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190b0JpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvQmluYXJ5KGVuY29kZXIpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVVpbnQ4KGdldFN0cnVjdFJlZmVyZW5jZSh0aGlzLmNvbnN0cnVjdG9yKSk7XG4gICAgICAgIGVuY29kZXIud3JpdGVJRCh0aGlzLl9pZCk7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJVaW50KHRoaXMuX2xlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVhZCB0aGUgbmV4dCBJdGVtIGluIGEgRGVjb2RlciBhbmQgZmlsbCB0aGlzIEl0ZW0gd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gZGF0YSBpcyByZWNlaXZlZCBmcm9tIGEgcmVtb3RlIHBlZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2UgdGhhdCB0aGlzIEl0ZW0gYmVsb25ncyB0by5cbiAgICAgICAqIEBwYXJhbSB7QmluYXJ5RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBvYmplY3QgdG8gcmVhZCBkYXRhIGZyb20uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZnJvbUJpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zyb21CaW5hcnkoeSwgZGVjb2Rlcikge1xuICAgICAgICB2YXIgaWQgPSBkZWNvZGVyLnJlYWRJRCgpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHZhciBtaXNzaW5nID0gW107XG4gICAgICAgIGlmICh5LnNzLmdldFN0YXRlKGlkLnVzZXIpIDwgaWQuY2xvY2spIHtcbiAgICAgICAgICBtaXNzaW5nLnB1c2gobmV3IElEKGlkLnVzZXIsIGlkLmNsb2NrIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zcGxpdEF0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3BsaXRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2Nsb25lUGFydGlhbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Nsb25lUGFydGlhbChkaWZmKSB7XG4gICAgICAgIHZhciBnYyA9IG5ldyBHQygpO1xuICAgICAgICBnYy5faWQgPSBuZXcgSUQodGhpcy5faWQudXNlciwgdGhpcy5faWQuY2xvY2sgKyBkaWZmKTtcbiAgICAgICAgZ2MuX2xlbmd0aCA9IHRoaXMuX2xlbmd0aCAtIGRpZmY7XG4gICAgICAgIHJldHVybiBnYztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGVsZXRlZCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBHQztcbiAgfSgpO1xuXG4gIHZhciBNaXNzaW5nRW50cnkgPSBmdW5jdGlvbiBNaXNzaW5nRW50cnkoZGVjb2RlciwgbWlzc2luZywgc3RydWN0KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWlzc2luZ0VudHJ5KTtcblxuICAgIHRoaXMuZGVjb2RlciA9IGRlY29kZXI7XG4gICAgdGhpcy5taXNzaW5nID0gbWlzc2luZy5sZW5ndGg7XG4gICAgdGhpcy5zdHJ1Y3QgPSBzdHJ1Y3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEludGVncmF0ZSByZW1vdGUgc3RydWN0XG4gICAqIFdoZW4gYSByZW1vdGUgc3RydWN0IGlzIGludGVncmF0ZWQsIG90aGVyIHN0cnVjdHMgbWlnaHQgYmUgcmVhZHkgdG8gcmVhZHkgdG9cbiAgICogaW50ZWdyYXRlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIF9pbnRlZ3JhdGVSZW1vdGVTdHJ1Y3RIZWxwZXIoeSwgc3RydWN0KSB7XG4gICAgdmFyIGlkID0gc3RydWN0Ll9pZDtcbiAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RydWN0Ll9pbnRlZ3JhdGUoeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh5LnNzLmdldFN0YXRlKGlkLnVzZXIpID4gaWQuY2xvY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF5LmdjRW5hYmxlZCB8fCBzdHJ1Y3QuY29uc3RydWN0b3IgPT09IEdDIHx8IHN0cnVjdC5fcGFyZW50LmNvbnN0cnVjdG9yICE9PSBHQyAmJiBzdHJ1Y3QuX3BhcmVudC5fZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gSXMgZWl0aGVyIGEgR0Mgb3IgSXRlbSB3aXRoIGFuIHVuZGVsZXRlZCBwYXJlbnRcbiAgICAgICAgLy8gc2F2ZSB0byBpbnRlZ3JhdGVcbiAgICAgICAgc3RydWN0Ll9pbnRlZ3JhdGUoeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJcyBhbiBJdGVtLiBwYXJlbnQgd2FzIGRlbGV0ZWQuXG4gICAgICAgIHN0cnVjdC5fZ2MoeSk7XG4gICAgICB9XG4gICAgICB2YXIgbXN1ID0geS5fbWlzc2luZ1N0cnVjdHMuZ2V0KGlkLnVzZXIpO1xuICAgICAgaWYgKG1zdSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjbG9jayA9IGlkLmNsb2NrO1xuICAgICAgICB2YXIgZmluYWxDbG9jayA9IGNsb2NrICsgc3RydWN0Ll9sZW5ndGg7XG4gICAgICAgIGZvciAoOyBjbG9jayA8IGZpbmFsQ2xvY2s7IGNsb2NrKyspIHtcbiAgICAgICAgICB2YXIgbWlzc2luZ1N0cnVjdHMgPSBtc3UuZ2V0KGNsb2NrKTtcbiAgICAgICAgICBpZiAobWlzc2luZ1N0cnVjdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWlzc2luZ1N0cnVjdHMuZm9yRWFjaChmdW5jdGlvbiAobWlzc2luZ0RlZikge1xuICAgICAgICAgICAgICBtaXNzaW5nRGVmLm1pc3NpbmctLTtcbiAgICAgICAgICAgICAgaWYgKG1pc3NpbmdEZWYubWlzc2luZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWNvZGVyID0gbWlzc2luZ0RlZi5kZWNvZGVyO1xuICAgICAgICAgICAgICAgIHZhciBvbGRQb3MgPSBkZWNvZGVyLnBvcztcbiAgICAgICAgICAgICAgICB2YXIgbWlzc2luZyA9IG1pc3NpbmdEZWYuc3RydWN0Ll9mcm9tQmluYXJ5KHksIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIGRlY29kZXIucG9zID0gb2xkUG9zO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgeS5fcmVhZHlUb0ludGVncmF0ZS5wdXNoKG1pc3NpbmdEZWYuc3RydWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbXN1LmRlbGV0ZShjbG9jayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5U3RydWN0cyh5LCBkZWNvZGVyLCBzdHJCdWlsZGVyKSB7XG4gICAgdmFyIGxlbiA9IGRlY29kZXIucmVhZFVpbnQzMigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciByZWZlcmVuY2UgPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICB2YXIgQ29uc3RyID0gZ2V0U3RydWN0KHJlZmVyZW5jZSk7XG4gICAgICB2YXIgc3RydWN0ID0gbmV3IENvbnN0cigpO1xuICAgICAgdmFyIG1pc3NpbmcgPSBzdHJ1Y3QuX2Zyb21CaW5hcnkoeSwgZGVjb2Rlcik7XG4gICAgICB2YXIgbG9nTWVzc2FnZSA9ICcgICcgKyBzdHJ1Y3QuX2xvZ1N0cmluZygpO1xuICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICBsb2dNZXNzYWdlICs9ICcgLi4gbWlzc2luZzogJyArIG1pc3NpbmcubWFwKGxvZ0lEKS5qb2luKCcsICcpO1xuICAgICAgfVxuICAgICAgc3RyQnVpbGRlci5wdXNoKGxvZ01lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVncmF0ZVJlbW90ZVN0cnVjdHMoeSwgZGVjb2Rlcikge1xuICAgIHZhciBsZW4gPSBkZWNvZGVyLnJlYWRVaW50MzIoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgdmFyIENvbnN0ciA9IGdldFN0cnVjdChyZWZlcmVuY2UpO1xuICAgICAgdmFyIHN0cnVjdCA9IG5ldyBDb25zdHIoKTtcbiAgICAgIHZhciBkZWNvZGVyUG9zID0gZGVjb2Rlci5wb3M7XG4gICAgICB2YXIgbWlzc2luZyA9IHN0cnVjdC5fZnJvbUJpbmFyeSh5LCBkZWNvZGVyKTtcbiAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB3aGlsZSAoc3RydWN0ICE9IG51bGwpIHtcbiAgICAgICAgICBfaW50ZWdyYXRlUmVtb3RlU3RydWN0SGVscGVyKHksIHN0cnVjdCk7XG4gICAgICAgICAgc3RydWN0ID0geS5fcmVhZHlUb0ludGVncmF0ZS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2RlY29kZXIgPSBuZXcgQmluYXJ5RGVjb2RlcihkZWNvZGVyLnVpbnQ4YXJyKTtcbiAgICAgICAgX2RlY29kZXIucG9zID0gZGVjb2RlclBvcztcbiAgICAgICAgdmFyIG1pc3NpbmdFbnRyeSA9IG5ldyBNaXNzaW5nRW50cnkoX2RlY29kZXIsIG1pc3NpbmcsIHN0cnVjdCk7XG4gICAgICAgIHZhciBtaXNzaW5nU3RydWN0cyA9IHkuX21pc3NpbmdTdHJ1Y3RzO1xuICAgICAgICBmb3IgKHZhciBfaSA9IG1pc3NpbmcubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgICAgICAgIHZhciBtID0gbWlzc2luZ1tfaV07XG4gICAgICAgICAgaWYgKCFtaXNzaW5nU3RydWN0cy5oYXMobS51c2VyKSkge1xuICAgICAgICAgICAgbWlzc2luZ1N0cnVjdHMuc2V0KG0udXNlciwgbmV3IE1hcCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1zdSA9IG1pc3NpbmdTdHJ1Y3RzLmdldChtLnVzZXIpO1xuICAgICAgICAgIGlmICghbXN1LmhhcyhtLmNsb2NrKSkge1xuICAgICAgICAgICAgbXN1LnNldChtLmNsb2NrLCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtQXJyYXkgPSBtc3UgPSBtc3UuZ2V0KG0uY2xvY2spO1xuICAgICAgICAgIG1BcnJheS5wdXNoKG1pc3NpbmdFbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYml0czcgPSAxMjc7XG4gIHZhciBiaXRzOCA9IDI1NTtcblxuICAvKipcbiAgICogQSBCaW5hcnlFbmNvZGVyIGhhbmRsZXMgdGhlIGVuY29kaW5nIHRvIGFuIEFycmF5QnVmZmVyLlxuICAgKi9cblxuICB2YXIgQmluYXJ5RW5jb2RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5hcnlFbmNvZGVyKCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQmluYXJ5RW5jb2Rlcik7XG5cbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBjaGFpbmVkIFVpbnQ4QXJyYXkgYnVmZmVycyBpbnN0ZWFkIG9mIEFycmF5IGJ1ZmZlclxuICAgICAgLy8gVE9ETzogUmV3cml0ZSBhbGwgbWV0aG9kcyBhcyBmdW5jdGlvbnMhXG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBsZW5ndGggb2YgdGhlIGVuY29kZWQgZGF0YS5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoQmluYXJ5RW5jb2RlciwgW3tcbiAgICAgIGtleTogJ2NyZWF0ZUJ1ZmZlcicsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYW4gQXJyYXlCdWZmZXIuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7VWludDhBcnJheX0gQSBVaW50OEFycmF5IHRoYXQgcmVwcmVzZW50cyB0aGUgd3JpdHRlbiBkYXRhLlxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHRoaXMuZGF0YSkuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIG9uZSBieXRlIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnd3JpdGVVaW50OCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVaW50OChudW0pIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2gobnVtICYgYml0czgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIG9uZSBieXRlIGFzIGFuIHVuc2lnbmVkIEludGVnZXIgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRVaW50OCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VWludDgocG9zLCBudW0pIHtcbiAgICAgICAgdGhpcy5kYXRhW3Bvc10gPSBudW0gJiBiaXRzODtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd3cml0ZVVpbnQxNicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVaW50MTYobnVtKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKG51bSAmIGJpdHM4LCBudW0gPj4+IDggJiBiaXRzOCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUaGUgbG9jYXRpb24gd2hlcmUgdGhlIGRhdGEgd2lsbCBiZSB3cml0dGVuLlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0VWludDE2JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVaW50MTYocG9zLCBudW0pIHtcbiAgICAgICAgdGhpcy5kYXRhW3Bvc10gPSBudW0gJiBiaXRzODtcbiAgICAgICAgdGhpcy5kYXRhW3BvcyArIDFdID0gbnVtID4+PiA4ICYgYml0czg7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXJcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd3cml0ZVVpbnQzMicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVaW50MzIobnVtKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2gobnVtICYgYml0czgpO1xuICAgICAgICAgIG51bSA+Pj49IDg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldFVpbnQzMicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VWludDMyKHBvcywgbnVtKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kYXRhW3BvcyArIGldID0gbnVtICYgYml0czg7XG4gICAgICAgICAgbnVtID4+Pj0gODtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHVuc2lnbmVkIGludGVnZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnd3JpdGVWYXJVaW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZVZhclVpbnQobnVtKSB7XG4gICAgICAgIHdoaWxlIChudW0gPj0gMTI4KSB7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2goMTI4IHwgYml0czcgJiBudW0pO1xuICAgICAgICAgIG51bSA+Pj49IDc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhLnB1c2goYml0czcgJiBudW0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd3cml0ZVZhclN0cmluZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVWYXJTdHJpbmcoc3RyKSB7XG4gICAgICAgIHZhciBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBlbmNvZGVkU3RyaW5nLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gYy5jb2RlUG9pbnRBdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy53cml0ZVZhclVpbnQobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKGJ5dGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIGFuIElEIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SUR9IGlkIFRoZSBJRCB0aGF0IGlzIHRvIGJlIHdyaXR0ZW4uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3dyaXRlSUQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlSUQoaWQpIHtcbiAgICAgICAgdmFyIHVzZXIgPSBpZC51c2VyO1xuICAgICAgICB0aGlzLndyaXRlVmFyVWludCh1c2VyKTtcbiAgICAgICAgaWYgKHVzZXIgIT09IFJvb3RGYWtlVXNlcklEKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVZhclVpbnQoaWQuY2xvY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud3JpdGVWYXJTdHJpbmcoaWQubmFtZSk7XG4gICAgICAgICAgdGhpcy53cml0ZVZhclVpbnQoaWQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdsZW5ndGgnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjdXJyZW50IHdyaXRlIHBvaW50ZXIgKHRoZSBzYW1lIGFzIHtAbGluayBsZW5ndGh9KS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncG9zJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEJpbmFyeUVuY29kZXI7XG4gIH0oKTtcblxuICBmdW5jdGlvbiByZWFkU3RhdGVTZXQoZGVjb2Rlcikge1xuICAgIHZhciBzcyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgc3NMZW5ndGggPSBkZWNvZGVyLnJlYWRVaW50MzIoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB1c2VyID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgdmFyIGNsb2NrID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgc3Muc2V0KHVzZXIsIGNsb2NrKTtcbiAgICB9XG4gICAgcmV0dXJuIHNzO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVTdGF0ZVNldCh5LCBlbmNvZGVyKSB7XG4gICAgdmFyIGxlblBvc2l0aW9uID0gZW5jb2Rlci5wb3M7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgZW5jb2Rlci53cml0ZVVpbnQzMigwKTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHkuc3Muc3RhdGVbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IHNsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgICAgdXNlciA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgY2xvY2sgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICBlbmNvZGVyLndyaXRlVmFyVWludCh1c2VyKTtcbiAgICAgICAgZW5jb2Rlci53cml0ZVZhclVpbnQoY2xvY2spO1xuICAgICAgICBsZW4rKztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbmNvZGVyLnNldFVpbnQzMihsZW5Qb3NpdGlvbiwgbGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlRGVsZXRlU2V0KHksIGVuY29kZXIpIHtcbiAgICB2YXIgY3VycmVudFVzZXIgPSBudWxsO1xuICAgIHZhciBjdXJyZW50TGVuZ3RoID0gdm9pZCAwO1xuICAgIHZhciBsYXN0TGVuUG9zID0gdm9pZCAwO1xuXG4gICAgdmFyIG51bWJlck9mVXNlcnMgPSAwO1xuICAgIHZhciBsYXRlckRTTGVuUHVzID0gZW5jb2Rlci5wb3M7XG4gICAgZW5jb2Rlci53cml0ZVVpbnQzMigwKTtcblxuICAgIHkuZHMuaXRlcmF0ZShudWxsLCBudWxsLCBmdW5jdGlvbiAobikge1xuICAgICAgdmFyIHVzZXIgPSBuLl9pZC51c2VyO1xuICAgICAgdmFyIGNsb2NrID0gbi5faWQuY2xvY2s7XG4gICAgICB2YXIgbGVuID0gbi5sZW47XG4gICAgICB2YXIgZ2MgPSBuLmdjO1xuICAgICAgaWYgKGN1cnJlbnRVc2VyICE9PSB1c2VyKSB7XG4gICAgICAgIG51bWJlck9mVXNlcnMrKztcbiAgICAgICAgLy8gYSBuZXcgdXNlciB3YXMgZm91bmRcbiAgICAgICAgaWYgKGN1cnJlbnRVc2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gaGFwcGVucyBvbiBmaXJzdCBpdGVyYXRpb25cbiAgICAgICAgICBlbmNvZGVyLnNldFVpbnQzMihsYXN0TGVuUG9zLCBjdXJyZW50TGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VXNlciA9IHVzZXI7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJVaW50KHVzZXIpO1xuICAgICAgICAvLyBwc2V1ZG8tZmlsbCBwb3NcbiAgICAgICAgbGFzdExlblBvcyA9IGVuY29kZXIucG9zO1xuICAgICAgICBlbmNvZGVyLndyaXRlVWludDMyKDApO1xuICAgICAgICBjdXJyZW50TGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGVuY29kZXIud3JpdGVWYXJVaW50KGNsb2NrKTtcbiAgICAgIGVuY29kZXIud3JpdGVWYXJVaW50KGxlbik7XG4gICAgICBlbmNvZGVyLndyaXRlVWludDgoZ2MgPyAxIDogMCk7XG4gICAgICBjdXJyZW50TGVuZ3RoKys7XG4gICAgfSk7XG4gICAgaWYgKGN1cnJlbnRVc2VyICE9PSBudWxsKSB7XG4gICAgICAvLyBoYXBwZW5zIG9uIGZpcnN0IGl0ZXJhdGlvblxuICAgICAgZW5jb2Rlci5zZXRVaW50MzIobGFzdExlblBvcywgY3VycmVudExlbmd0aCk7XG4gICAgfVxuICAgIGVuY29kZXIuc2V0VWludDMyKGxhdGVyRFNMZW5QdXMsIG51bWJlck9mVXNlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZERlbGV0ZVNldCh5LCBkZWNvZGVyKSB7XG4gICAgdmFyIGRzTGVuZ3RoID0gZGVjb2Rlci5yZWFkVWludDMyKCk7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICB2YXIgdXNlciA9IGRlY29kZXIucmVhZFZhclVpbnQoKTtcbiAgICAgIHZhciBkdiA9IFtdO1xuICAgICAgdmFyIGR2TGVuZ3RoID0gZGVjb2Rlci5yZWFkVWludDMyKCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGR2TGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGZyb20gPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHZhciBsZW4gPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHZhciBnYyA9IGRlY29kZXIucmVhZFVpbnQ4KCkgPT09IDE7XG4gICAgICAgIGR2LnB1c2goW2Zyb20sIGxlbiwgZ2NdKTtcbiAgICAgIH1cbiAgICAgIGlmIChkdkxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgIHZhciBkID0gZHZbcG9zXTtcbiAgICAgICAgdmFyIGRlbGV0aW9ucyA9IFtdO1xuICAgICAgICB5LmRzLml0ZXJhdGUobmV3IElEKHVzZXIsIDApLCBuZXcgSUQodXNlciwgTnVtYmVyLk1BWF9WQUxVRSksIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgLy8gY2FzZXM6XG4gICAgICAgICAgLy8gMS4gZCBkZWxldGVzIHNvbWV0aGluZyB0byB0aGUgcmlnaHQgb2YgblxuICAgICAgICAgIC8vICA9PiBnbyB0byBuZXh0IG4gKGJyZWFrKVxuICAgICAgICAgIC8vIDIuIGQgZGVsZXRlcyBzb21ldGhpbmcgdG8gdGhlIGxlZnQgb2YgblxuICAgICAgICAgIC8vICA9PiBjcmVhdGUgZGVsZXRpb25zXG4gICAgICAgICAgLy8gID0+IHJlc2V0IGQgYWNjb3JkaW5nbHlcbiAgICAgICAgICAvLyAgKik9PiBpZiBkIGRvZXNuJ3QgZGVsZXRlIGFueXRoaW5nIGFueW1vcmUsIGdvIHRvIG5leHQgZCAoY29udGludWUpXG4gICAgICAgICAgLy8gMy4gbm90IDIpIGFuZCBkIGRlbGV0ZXMgc29tZXRoaW5nIHRoYXQgYWxzbyBuIGRlbGV0ZXNcbiAgICAgICAgICAvLyAgPT4gcmVzZXQgZCBzbyB0aGF0IGl0IGRvZXNuJ3QgY29udGFpbiBuJ3MgZGVsZXRpb25cbiAgICAgICAgICAvLyAgKik9PiBpZiBkIGRvZXMgbm90IGRlbGV0ZSBhbnl0aGluZyBhbnltb3JlLCBnbyB0byBuZXh0IGQgKGNvbnRpbnVlKVxuICAgICAgICAgIHdoaWxlIChkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gMDsgLy8gZGVzY3JpYmUgdGhlIGRpZmYgb2YgbGVuZ3RoIGluIDEpIGFuZCAyKVxuICAgICAgICAgICAgaWYgKG4uX2lkLmNsb2NrICsgbi5sZW4gPD0gZFswXSkge1xuICAgICAgICAgICAgICAvLyAxKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZFswXSA8IG4uX2lkLmNsb2NrKSB7XG4gICAgICAgICAgICAgIC8vIDIpXG4gICAgICAgICAgICAgIC8vIGRlbGV0ZSBtYXhpbXVtIHRoZSBsZW4gb2YgZFxuICAgICAgICAgICAgICAvLyBlbHNlIGRlbGV0ZSBhcyBtdWNoIGFzIHBvc3NpYmxlXG4gICAgICAgICAgICAgIGRpZmYgPSBNYXRoLm1pbihuLl9pZC5jbG9jayAtIGRbMF0sIGRbMV0pO1xuICAgICAgICAgICAgICAvLyBkZWxldGVJdGVtUmFuZ2UoeSwgdXNlciwgZFswXSwgZGlmZiwgdHJ1ZSlcbiAgICAgICAgICAgICAgZGVsZXRpb25zLnB1c2goW3VzZXIsIGRbMF0sIGRpZmZdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIDMpXG4gICAgICAgICAgICAgIGRpZmYgPSBuLl9pZC5jbG9jayArIG4ubGVuIC0gZFswXTsgLy8gbmV2ZXIgbnVsbCAoc2VlIDEpXG4gICAgICAgICAgICAgIGlmIChkWzJdICYmICFuLmdjKSB7XG4gICAgICAgICAgICAgICAgLy8gZCBtYXJrcyBhcyBnYydkIGJ1dCBuIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgLy8gdGhlbiBkZWxldGUgZWl0aGVyIHdheVxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZUl0ZW1SYW5nZSh5LCB1c2VyLCBkWzBdLCBNYXRoLm1pbihkaWZmLCBkWzFdKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICBkZWxldGlvbnMucHVzaChbdXNlciwgZFswXSwgTWF0aC5taW4oZGlmZiwgZFsxXSldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRbMV0gPD0gZGlmZikge1xuICAgICAgICAgICAgICAvLyBkIGRvZXNuJ3QgZGVsZXRlIGFueXRoaW5nIGFueW1vcmVcbiAgICAgICAgICAgICAgZCA9IGR2WysrcG9zXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRbMF0gPSBkWzBdICsgZGlmZjsgLy8gcmVzZXQgcG9zXG4gICAgICAgICAgICAgIGRbMV0gPSBkWzFdIC0gZGlmZjsgLy8gcmVzZXQgbGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogSXQgd291bGQgYmUgbW9yZSBwZXJmb3JtYW50IHRvIGFwcGx5IHRoZSBkZWxldGVzIGluIHRoZSBhYm92ZSBsb29wXG4gICAgICAgIC8vIEFkYXB0IHRoZSBUcmVlIGltcGxlbWVudGF0aW9uIHRvIHN1cHBvcnQgZGVsZXRlIHdoaWxlIGl0ZXJhdGluZ1xuICAgICAgICBmb3IgKHZhciBfaSA9IGRlbGV0aW9ucy5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgICAgICAgdmFyIGRlbCA9IGRlbGV0aW9uc1tfaV07XG4gICAgICAgICAgZGVsZXRlSXRlbVJhbmdlKHksIGRlbFswXSwgZGVsWzFdLCBkZWxbMl0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciB0aGUgcmVzdC4uIGp1c3QgYXBwbHkgaXRcbiAgICAgICAgZm9yICg7IHBvcyA8IGR2Lmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgICBkID0gZHZbcG9zXTtcbiAgICAgICAgICBkZWxldGVJdGVtUmFuZ2UoeSwgdXNlciwgZFswXSwgZFsxXSwgdHJ1ZSk7XG4gICAgICAgICAgLy8gZGVsZXRpb25zLnB1c2goW3VzZXIsIGRbMF0sIGRbMV0sIGRbMl1dKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHNMZW5ndGg7IGkrKykge1xuICAgICAgX2xvb3AoaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5U3luY1N0ZXAxKHksIGRlY29kZXIsIHN0ckJ1aWxkZXIpIHtcbiAgICB2YXIgYXV0aCA9IGRlY29kZXIucmVhZFZhclN0cmluZygpO1xuICAgIHZhciBwcm90b2NvbFZlcnNpb24gPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgc3RyQnVpbGRlci5wdXNoKCcgIC0gYXV0aDogXCInICsgYXV0aCArICdcIicpO1xuICAgIHN0ckJ1aWxkZXIucHVzaCgnICAtIHByb3RvY29sVmVyc2lvbjogJyArIHByb3RvY29sVmVyc2lvbik7XG4gICAgLy8gd3JpdGUgU1NcbiAgICB2YXIgc3NCdWlsZGVyID0gW107XG4gICAgdmFyIGxlbiA9IGRlY29kZXIucmVhZFVpbnQzMigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB1c2VyID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgdmFyIGNsb2NrID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgc3NCdWlsZGVyLnB1c2goJygnICsgdXNlciArICc6JyArIGNsb2NrICsgJyknKTtcbiAgICB9XG4gICAgc3RyQnVpbGRlci5wdXNoKCcgID09IFNTOiAnICsgc3NCdWlsZGVyLmpvaW4oJywnKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZW5kU3luY1N0ZXAxKGNvbm5lY3Rvciwgc3luY1VzZXIpIHtcbiAgICB2YXIgZW5jb2RlciA9IG5ldyBCaW5hcnlFbmNvZGVyKCk7XG4gICAgZW5jb2Rlci53cml0ZVZhclN0cmluZyhjb25uZWN0b3IueS5yb29tKTtcbiAgICBlbmNvZGVyLndyaXRlVmFyU3RyaW5nKCdzeW5jIHN0ZXAgMScpO1xuICAgIGVuY29kZXIud3JpdGVWYXJTdHJpbmcoY29ubmVjdG9yLmF1dGhJbmZvIHx8ICcnKTtcbiAgICBlbmNvZGVyLndyaXRlVmFyVWludChjb25uZWN0b3IucHJvdG9jb2xWZXJzaW9uKTtcbiAgICB3cml0ZVN0YXRlU2V0KGNvbm5lY3Rvci55LCBlbmNvZGVyKTtcbiAgICBjb25uZWN0b3Iuc2VuZChzeW5jVXNlciwgZW5jb2Rlci5jcmVhdGVCdWZmZXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogV3JpdGUgYWxsIEl0ZW1zIHRoYXQgYXJlIG5vdCBub3QgaW5jbHVkZWQgaW4gc3MgdG9cbiAgICogdGhlIGVuY29kZXIgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVTdHJ1Y3RzKHksIGVuY29kZXIsIHNzKSB7XG4gICAgdmFyIGxlblBvcyA9IGVuY29kZXIucG9zO1xuICAgIGVuY29kZXIud3JpdGVVaW50MzIoMCk7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB5LnNzLnN0YXRlLmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgdmFyIHVzZXIgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICB2YXIgY2xvY2sgPSBzcy5nZXQodXNlcikgfHwgMDtcbiAgICAgICAgaWYgKHVzZXIgIT09IFJvb3RGYWtlVXNlcklEKSB7XG4gICAgICAgICAgdmFyIG1pbkJvdW5kID0gbmV3IElEKHVzZXIsIGNsb2NrKTtcbiAgICAgICAgICB2YXIgb3ZlcmxhcHBpbmdMZWZ0ID0geS5vcy5maW5kUHJldihtaW5Cb3VuZCk7XG4gICAgICAgICAgdmFyIHJpZ2h0SUQgPSBvdmVybGFwcGluZ0xlZnQgPT09IG51bGwgPyBudWxsIDogb3ZlcmxhcHBpbmdMZWZ0Ll9pZDtcbiAgICAgICAgICBpZiAocmlnaHRJRCAhPT0gbnVsbCAmJiByaWdodElELnVzZXIgPT09IHVzZXIgJiYgcmlnaHRJRC5jbG9jayArIG92ZXJsYXBwaW5nTGVmdC5fbGVuZ3RoID4gY2xvY2spIHtcbiAgICAgICAgICAgIHZhciBzdHJ1Y3QgPSBvdmVybGFwcGluZ0xlZnQuX2Nsb25lUGFydGlhbChjbG9jayAtIHJpZ2h0SUQuY2xvY2spO1xuICAgICAgICAgICAgc3RydWN0Ll90b0JpbmFyeShlbmNvZGVyKTtcbiAgICAgICAgICAgIGxlbisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5Lm9zLml0ZXJhdGUobWluQm91bmQsIG5ldyBJRCh1c2VyLCBOdW1iZXIuTUFYX1ZBTFVFKSwgZnVuY3Rpb24gKHN0cnVjdCkge1xuICAgICAgICAgICAgc3RydWN0Ll90b0JpbmFyeShlbmNvZGVyKTtcbiAgICAgICAgICAgIGxlbisrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZW5jb2Rlci5zZXRVaW50MzIobGVuUG9zLCBsZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFN5bmNTdGVwMShkZWNvZGVyLCBlbmNvZGVyLCB5LCBzZW5kZXJDb25uLCBzZW5kZXIpIHtcbiAgICB2YXIgcHJvdG9jb2xWZXJzaW9uID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgIC8vIGNoZWNrIHByb3RvY29sIHZlcnNpb25cbiAgICBpZiAocHJvdG9jb2xWZXJzaW9uICE9PSB5LmNvbm5lY3Rvci5wcm90b2NvbFZlcnNpb24pIHtcbiAgICAgIGNvbnNvbGUud2FybignWW91IHRyaWVkIHRvIHN5bmMgd2l0aCBhIFlqcyBpbnN0YW5jZSB0aGF0IGhhcyBhIGRpZmZlcmVudCBwcm90b2NvbCB2ZXJzaW9uXFxuICAgICAgKFlvdTogJyArIHByb3RvY29sVmVyc2lvbiArICcsIENsaWVudDogJyArIHByb3RvY29sVmVyc2lvbiArICcpLlxcbiAgICAgICcpO1xuICAgICAgeS5kZXN0cm95KCk7XG4gICAgfVxuICAgIC8vIHdyaXRlIHN5bmMgc3RlcCAyXG4gICAgZW5jb2Rlci53cml0ZVZhclN0cmluZygnc3luYyBzdGVwIDInKTtcbiAgICBlbmNvZGVyLndyaXRlVmFyU3RyaW5nKHkuY29ubmVjdG9yLmF1dGhJbmZvIHx8ICcnKTtcbiAgICB2YXIgc3MgPSByZWFkU3RhdGVTZXQoZGVjb2Rlcik7XG4gICAgd3JpdGVTdHJ1Y3RzKHksIGVuY29kZXIsIHNzKTtcbiAgICB3cml0ZURlbGV0ZVNldCh5LCBlbmNvZGVyKTtcbiAgICB5LmNvbm5lY3Rvci5zZW5kKHNlbmRlckNvbm4udWlkLCBlbmNvZGVyLmNyZWF0ZUJ1ZmZlcigpKTtcbiAgICBzZW5kZXJDb25uLnJlY2VpdmVkU3luY1N0ZXAyID0gdHJ1ZTtcbiAgICBpZiAoeS5jb25uZWN0b3Iucm9sZSA9PT0gJ3NsYXZlJykge1xuICAgICAgc2VuZFN5bmNTdGVwMSh5LmNvbm5lY3Rvciwgc2VuZGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlTeW5jU3RlcDIoeSwgZGVjb2Rlciwgc3RyQnVpbGRlcikge1xuICAgIHN0ckJ1aWxkZXIucHVzaCgnICAgICAtIGF1dGg6ICcgKyBkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKSk7XG4gICAgc3RyQnVpbGRlci5wdXNoKCcgID09IE9TOicpO1xuICAgIHN0cmluZ2lmeVN0cnVjdHMoeSwgZGVjb2Rlciwgc3RyQnVpbGRlcik7XG4gICAgLy8gd3JpdGUgRFMgdG8gc3RyaW5nXG4gICAgc3RyQnVpbGRlci5wdXNoKCcgID09IERTOicpO1xuICAgIHZhciBsZW4gPSBkZWNvZGVyLnJlYWRVaW50MzIoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdXNlciA9IGRlY29kZXIucmVhZFZhclVpbnQoKTtcbiAgICAgIHN0ckJ1aWxkZXIucHVzaCgnICAgIFVzZXI6ICcgKyB1c2VyICsgJzogJyk7XG4gICAgICB2YXIgbGVuMiA9IGRlY29kZXIucmVhZFVpbnQzMigpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgdmFyIGZyb20gPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHZhciB0byA9IGRlY29kZXIucmVhZFZhclVpbnQoKTtcbiAgICAgICAgdmFyIGdjID0gZGVjb2Rlci5yZWFkVWludDgoKSA9PT0gMTtcbiAgICAgICAgc3RyQnVpbGRlci5wdXNoKCdbJyArIGZyb20gKyAnLCAnICsgdG8gKyAnLCAnICsgZ2MgKyAnXScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRTeW5jU3RlcDIoZGVjb2RlciwgZW5jb2RlciwgeSwgc2VuZGVyQ29ubiwgc2VuZGVyKSB7XG4gICAgaW50ZWdyYXRlUmVtb3RlU3RydWN0cyh5LCBkZWNvZGVyKTtcbiAgICByZWFkRGVsZXRlU2V0KHksIGRlY29kZXIpO1xuICAgIHkuY29ubmVjdG9yLl9zZXRTeW5jZWRXaXRoKHNlbmRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXNzYWdlVG9TdHJpbmcoX3JlZikge1xuICAgIHZhciBfcmVmMiA9IHNsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIHkgPSBfcmVmMlswXSxcbiAgICAgICAgYnVmZmVyID0gX3JlZjJbMV07XG5cbiAgICB2YXIgZGVjb2RlciA9IG5ldyBCaW5hcnlEZWNvZGVyKGJ1ZmZlcik7XG4gICAgZGVjb2Rlci5yZWFkVmFyU3RyaW5nKCk7IC8vIHJlYWQgcm9vbW5hbWVcbiAgICB2YXIgdHlwZSA9IGRlY29kZXIucmVhZFZhclN0cmluZygpO1xuICAgIHZhciBzdHJCdWlsZGVyID0gW107XG4gICAgc3RyQnVpbGRlci5wdXNoKCdcXG4gPT09ICcgKyB0eXBlICsgJyA9PT0nKTtcbiAgICBpZiAodHlwZSA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgIHN0cmluZ2lmeVN0cnVjdHMoeSwgZGVjb2Rlciwgc3RyQnVpbGRlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3luYyBzdGVwIDEnKSB7XG4gICAgICBzdHJpbmdpZnlTeW5jU3RlcDEoeSwgZGVjb2Rlciwgc3RyQnVpbGRlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3luYyBzdGVwIDInKSB7XG4gICAgICBzdHJpbmdpZnlTeW5jU3RlcDIoeSwgZGVjb2Rlciwgc3RyQnVpbGRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ckJ1aWxkZXIucHVzaCgnLS0gVW5rbm93biBtZXNzYWdlIHR5cGUgLSBwcm9iYWJseSBhbiBlbmNvZGluZyBpc3N1ZSEhIScpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyQnVpbGRlci5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lc3NhZ2VUb1Jvb21uYW1lKGJ1ZmZlcikge1xuICAgIHZhciBkZWNvZGVyID0gbmV3IEJpbmFyeURlY29kZXIoYnVmZmVyKTtcbiAgICBkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKTsgLy8gcm9vbW5hbWVcbiAgICByZXR1cm4gZGVjb2Rlci5yZWFkVmFyU3RyaW5nKCk7IC8vIG1lc3NhZ2VUeXBlXG4gIH1cblxuICBmdW5jdGlvbiBsb2dJRChpZCkge1xuICAgIGlmIChpZCAhPT0gbnVsbCAmJiBpZC5faWQgIT0gbnVsbCkge1xuICAgICAgaWQgPSBpZC5faWQ7XG4gICAgfVxuICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcoKSc7XG4gICAgfSBlbHNlIGlmIChpZCBpbnN0YW5jZW9mIElEKSB7XG4gICAgICByZXR1cm4gJygnICsgaWQudXNlciArICcsJyArIGlkLmNsb2NrICsgJyknO1xuICAgIH0gZWxzZSBpZiAoaWQgaW5zdGFuY2VvZiBSb290SUQpIHtcbiAgICAgIHJldHVybiAnKCcgKyBpZC5uYW1lICsgJywnICsgaWQudHlwZSArICcpJztcbiAgICB9IGVsc2UgaWYgKGlkLmNvbnN0cnVjdG9yID09PSBZKSB7XG4gICAgICByZXR1cm4gJ3knO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgaXMgbm90IGEgdmFsaWQgSUQhJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB1dGlsaXR5IHRvIGNvbnZlcnQgYW4gaXRlbSB0byBhIHJlYWRhYmxlIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGl0ZW0gY2xhc3MgKFlUZXh0LCBJdGVtU3RyaW5nLCAuLikuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSBUaGUgaXRlbSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFthcHBlbmRdIEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gYXBwZW5kIHRvIHRoZSByZXR1cm5lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgcmVhZGFibGUgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgaXRlbSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBsb2dJdGVtSGVscGVyKG5hbWUsIGl0ZW0sIGFwcGVuZCkge1xuICAgIHZhciBsZWZ0ID0gaXRlbS5fbGVmdCAhPT0gbnVsbCA/IGl0ZW0uX2xlZnQuX2xhc3RJZCA6IG51bGw7XG4gICAgdmFyIG9yaWdpbiA9IGl0ZW0uX29yaWdpbiAhPT0gbnVsbCA/IGl0ZW0uX29yaWdpbi5fbGFzdElkIDogbnVsbDtcbiAgICByZXR1cm4gbmFtZSArICcoaWQ6JyArIGxvZ0lEKGl0ZW0uX2lkKSArICcsbGVmdDonICsgbG9nSUQobGVmdCkgKyAnLG9yaWdpbjonICsgbG9nSUQob3JpZ2luKSArICcscmlnaHQ6JyArIGxvZ0lEKGl0ZW0uX3JpZ2h0KSArICcscGFyZW50OicgKyBsb2dJRChpdGVtLl9wYXJlbnQpICsgJyxwYXJlbnRTdWI6JyArIGl0ZW0uX3BhcmVudFN1YiArIChhcHBlbmQgIT09IHVuZGVmaW5lZCA/ICcgLSAnICsgYXBwZW5kIDogJycpICsgJyknO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIERlbGV0ZSBhbGwgaXRlbXMgaW4gYW4gSUQtcmFuZ2VcbiAgICogVE9ETzogaW1wbGVtZW50IGdldEl0ZW1DbGVhblN0YXJ0Tm9kZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlIChvbmx5IG9uZSBsb29rdXApXG4gICAqL1xuICBmdW5jdGlvbiBkZWxldGVJdGVtUmFuZ2UoeSwgdXNlciwgY2xvY2ssIHJhbmdlLCBnY0NoaWxkcmVuKSB7XG4gICAgdmFyIGNyZWF0ZURlbGV0ZSA9IHkuY29ubmVjdG9yICE9PSBudWxsICYmIHkuY29ubmVjdG9yLl9mb3J3YXJkQXBwbGllZFN0cnVjdHM7XG4gICAgdmFyIGl0ZW0gPSB5Lm9zLmdldEl0ZW1DbGVhblN0YXJ0KG5ldyBJRCh1c2VyLCBjbG9jaykpO1xuICAgIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgICBpZiAoIWl0ZW0uX2RlbGV0ZWQpIHtcbiAgICAgICAgaXRlbS5fc3BsaXRBdCh5LCByYW5nZSk7XG4gICAgICAgIGl0ZW0uX2RlbGV0ZSh5LCBjcmVhdGVEZWxldGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZW1MZW4gPSBpdGVtLl9sZW5ndGg7XG4gICAgICByYW5nZSAtPSBpdGVtTGVuO1xuICAgICAgY2xvY2sgKz0gaXRlbUxlbjtcbiAgICAgIGlmIChyYW5nZSA+IDApIHtcbiAgICAgICAgdmFyIG5vZGUgPSB5Lm9zLmZpbmROb2RlKG5ldyBJRCh1c2VyLCBjbG9jaykpO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBub2RlLnZhbCAhPT0gbnVsbCAmJiByYW5nZSA+IDAgJiYgbm9kZS52YWwuX2lkLmVxdWFscyhuZXcgSUQodXNlciwgY2xvY2spKSkge1xuICAgICAgICAgIHZhciBub2RlVmFsID0gbm9kZS52YWw7XG4gICAgICAgICAgaWYgKCFub2RlVmFsLl9kZWxldGVkKSB7XG4gICAgICAgICAgICBub2RlVmFsLl9zcGxpdEF0KHksIHJhbmdlKTtcbiAgICAgICAgICAgIG5vZGVWYWwuX2RlbGV0ZSh5LCBjcmVhdGVEZWxldGUsIGdjQ2hpbGRyZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbm9kZUxlbiA9IG5vZGVWYWwuX2xlbmd0aDtcbiAgICAgICAgICByYW5nZSAtPSBub2RlTGVuO1xuICAgICAgICAgIGNsb2NrICs9IG5vZGVMZW47XG4gICAgICAgICAgbm9kZSA9IG5vZGUubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEEgRGVsZXRlIGNoYW5nZSBpcyBub3QgYSByZWFsIEl0ZW0sIGJ1dCBpdCBwcm92aWRlcyB0aGUgc2FtZSBpbnRlcmZhY2UgYXMgYW5cbiAgICogSXRlbS4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGl0IHdpbGwgbm90IGJlIHNhdmVkIGluIHRoZSBJdGVtU3RvcmVcbiAgICogKE9wZXJhdGlvblN0b3JlKSwgYnV0IGluc3RlYWQgaXQgaXMgc2FmZWQgaW4gdGhlIERlbGV0ZVN0b3JlLlxuICAgKi9cblxuICB2YXIgRGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGV0ZSgpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERlbGV0ZSk7XG5cbiAgICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9sZW5ndGggPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogUmVhZCB0aGUgbmV4dCBJdGVtIGluIGEgRGVjb2RlciBhbmQgZmlsbCB0aGlzIEl0ZW0gd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBkYXRhIGlzIHJlY2VpdmVkIGZyb20gYSByZW1vdGUgcGVlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WX0geSBUaGUgWWpzIGluc3RhbmNlIHRoYXQgdGhpcyBJdGVtIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtCaW5hcnlEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIG9iamVjdCB0byByZWFkIGRhdGEgZnJvbS5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoRGVsZXRlLCBbe1xuICAgICAga2V5OiAnX2Zyb21CaW5hcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mcm9tQmluYXJ5KHksIGRlY29kZXIpIHtcbiAgICAgICAgLy8gVE9ETzogc2V0IHRhcmdldCwgYW5kIGFkZCBpdCB0byBtaXNzaW5nIGlmIG5vdCBmb3VuZFxuICAgICAgICAvLyBUaGVyZSBpcyBhbiBlZGdlIGNhc2UgaW4gcDJwIG5ldHdvcmtzIVxuICAgICAgICB2YXIgdGFyZ2V0SUQgPSBkZWNvZGVyLnJlYWRJRCgpO1xuICAgICAgICB0aGlzLl90YXJnZXRJRCA9IHRhcmdldElEO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIGlmICh5Lm9zLmdldEl0ZW0odGFyZ2V0SUQpID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFt0YXJnZXRJRF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgICAgICogQmluYXJ5RW5jb2Rlci5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtCaW5hcnlFbmNvZGVyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190b0JpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvQmluYXJ5KGVuY29kZXIpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVVpbnQ4KGdldFN0cnVjdFJlZmVyZW5jZSh0aGlzLmNvbnN0cnVjdG9yKSk7XG4gICAgICAgIGVuY29kZXIud3JpdGVJRCh0aGlzLl90YXJnZXRJRCk7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJVaW50KHRoaXMuX2xlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEludGVncmF0ZXMgdGhpcyBJdGVtIGludG8gdGhlIHNoYXJlZCBzdHJ1Y3R1cmUuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgYWN0dWFsbHkgYXBwbGllcyB0aGUgY2hhbmdlIHRvIHRoZSBZanMgaW5zdGFuY2UuIEluIHRoZSBjYXNlIG9mXG4gICAgICAgKiBEZWxldGUgaXQgbWFya3MgdGhlIGRlbGV0ZSB0YXJnZXQgYXMgZGVsZXRlZC5cbiAgICAgICAqXG4gICAgICAgKiAqIElmIGNyZWF0ZWQgcmVtb3RlbHkgKGEgcmVtb3RlIHVzZXIgZGVsZXRlZCBzb21ldGhpbmcpLFxuICAgICAgICogICB0aGlzIERlbGV0ZSBpcyBhcHBsaWVkIHRvIGFsbCBzdHJ1Y3RzIGluIGlkLXJhbmdlLlxuICAgICAgICogKiBJZiBjcmVhdGVkIGxva2FsbHkgKGUuZy4gd2hlbiB5LWFycmF5IGRlbGV0ZXMgYSByYW5nZSBvZiBlbGVtZW50cyksXG4gICAgICAgKiAgIHRoaXMgc3RydWN0IGlzIGJyb2FkY2FzdGVkIG9ubHkgKGl0IGlzIGFscmVhZHkgZXhlY3V0ZWQpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19pbnRlZ3JhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnRlZ3JhdGUoeSkge1xuICAgICAgICB2YXIgbG9jYWxseUNyZWF0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICAgIGlmICghbG9jYWxseUNyZWF0ZWQpIHtcbiAgICAgICAgICAvLyBmcm9tIHJlbW90ZVxuICAgICAgICAgIHZhciBpZCA9IHRoaXMuX3RhcmdldElEO1xuICAgICAgICAgIGRlbGV0ZUl0ZW1SYW5nZSh5LCBpZC51c2VyLCBpZC5jbG9jaywgdGhpcy5fbGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoeS5jb25uZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBmcm9tIGxvY2FsXG4gICAgICAgICAgeS5jb25uZWN0b3IuYnJvYWRjYXN0U3RydWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5LnBlcnNpc3RlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgeS5wZXJzaXN0ZW5jZS5zYXZlU3RydWN0KHksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIHRoaXMgWVhtbCBUeXBlIHRvIGEgcmVhZGFibGUgZm9ybWF0LlxuICAgICAgICogVXNlZnVsIGZvciBsb2dnaW5nIGFzIGFsbCBJdGVtcyBhbmQgRGVsZXRlIGltcGxlbWVudCB0aGlzIG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbG9nU3RyaW5nJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9nU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ0RlbGV0ZSAtIHRhcmdldDogJyArIGxvZ0lEKHRoaXMuX3RhcmdldElEKSArICcsIGxlbjogJyArIHRoaXMuX2xlbmd0aDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIERlbGV0ZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBIHRyYW5zYWN0aW9uIGlzIGNyZWF0ZWQgZm9yIGV2ZXJ5IGNoYW5nZSBvbiB0aGUgWWpzIG1vZGVsLiBJdCBpcyBwb3NzaWJsZVxuICAgKiB0byBidW5kbGUgY2hhbmdlcyBvbiB0aGUgWWpzIG1vZGVsIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHRvXG4gICAqIG1pbmltaXplIHRoZSBudW1iZXIgb24gbWVzc2FnZXMgc2VudCBhbmQgdGhlIG51bWJlciBvZiBvYnNlcnZlciBjYWxscy5cbiAgICogSWYgcG9zc2libGUgdGhlIHVzZXIgb2YgdGhpcyBsaWJyYXJ5IHNob3VsZCBidW5kbGUgYXMgbWFueSBjaGFuZ2VzIGFzXG4gICAqIHBvc3NpYmxlLiBIZXJlIGlzIGFuIGV4YW1wbGUgdG8gaWxsdXN0cmF0ZSB0aGUgYWR2YW50YWdlcyBvZiBidW5kbGluZzpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgbWFwID0geS5kZWZpbmUoJ21hcCcsIFlNYXApXG4gICAqIC8vIExvZyBjb250ZW50IHdoZW4gY2hhbmdlIGlzIHRyaWdnZXJlZFxuICAgKiBtYXAub2JzZXJ2ZShmdW5jdGlvbiAoKSB7XG4gICAqICAgY29uc29sZS5sb2coJ2NoYW5nZSB0cmlnZ2VyZWQnKVxuICAgKiB9KVxuICAgKiAvLyBFYWNoIGNoYW5nZSBvbiB0aGUgbWFwIHR5cGUgdHJpZ2dlcnMgYSBsb2cgbWVzc2FnZTpcbiAgICogbWFwLnNldCgnYScsIDApIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gICAqIG1hcC5zZXQoJ2InLCAwKSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICAgKiAvLyBXaGVuIHB1dCBpbiBhIHRyYW5zYWN0aW9uLCBpdCB3aWxsIHRyaWdnZXIgdGhlIGxvZyBhZnRlciB0aGUgdHJhbnNhY3Rpb246XG4gICAqIHkudHJhbnNhY3QoZnVuY3Rpb24gKCkge1xuICAgKiAgIG1hcC5zZXQoJ2EnLCAxKVxuICAgKiAgIG1hcC5zZXQoJ2InLCAxKVxuICAgKiB9KSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICAgKlxuICAgKi9cbiAgdmFyIFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gVHJhbnNhY3Rpb24oeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zYWN0aW9uKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZfSBUaGUgWWpzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHRoaXMueSA9IHk7XG4gICAgLyoqXG4gICAgICogQWxsIG5ldyB0eXBlcyB0aGF0IGFyZSBhZGRlZCBkdXJpbmcgYSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMubmV3VHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogQWxsIHR5cGVzIHRoYXQgd2VyZSBkaXJlY3RseSBtb2RpZmllZCAocHJvcGVydHkgYWRkZWQgb3IgY2hpbGRcbiAgICAgKiBpbnNlcnRlZC9kZWxldGVkKS4gTmV3IHR5cGVzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhpcyBTZXQuXG4gICAgICogTWFwcyBmcm9tIHR5cGUgdG8gcGFyZW50U3VicyAoYGl0ZW0uX3BhcmVudFN1YiA9IG51bGxgIGZvciBZQXJyYXkpXG4gICAgICogQHR5cGUge1NldDxZVHlwZSxTdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlZFR5cGVzID0gbmV3IE1hcCgpO1xuICAgIC8vIFRPRE86IHJlbmFtZSBkZWxldGVkVHlwZXNcbiAgICAvKipcbiAgICAgKiBTZXQgb2YgYWxsIGRlbGV0ZWQgVHlwZXMgYW5kIFN0cnVjdHMuXG4gICAgICogQHR5cGUge1NldDxJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZWRTdHJ1Y3RzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBvbGQgc3RhdGUgc2V0IG9mIHRoZSBZanMgaW5zdGFuY2UuIElmIGEgc3RhdGUgd2FzIG1vZGlmaWVkLFxuICAgICAqIHRoZSBvcmlnaW5hbCB2YWx1ZSBpcyBzYXZlZCBoZXJlLlxuICAgICAqIEB0eXBlIHtNYXA8TnVtYmVyLE51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVTdGF0ZSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGV2ZW50cyBmb3IgdGhlIHR5cGVzIHRoYXQgb2JzZXJ2ZSBhbHNvIGNoaWxkIGVsZW1lbnRzLlxuICAgICAqIEl0IGlzIG1haW5seSB1c2VkIGJ5IGBvYnNlcnZlRGVlcGAuXG4gICAgICogQHR5cGUge01hcDxZVHlwZSxBcnJheTxZRXZlbnQ+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZWRQYXJlbnRUeXBlcyA9IG5ldyBNYXAoKTtcbiAgfTtcbiAgZnVuY3Rpb24gdHJhbnNhY3Rpb25UeXBlQ2hhbmdlZCh5LCB0eXBlLCBzdWIpIHtcbiAgICBpZiAodHlwZSAhPT0geSAmJiAhdHlwZS5fZGVsZXRlZCAmJiAheS5fdHJhbnNhY3Rpb24ubmV3VHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICB2YXIgY2hhbmdlZFR5cGVzID0geS5fdHJhbnNhY3Rpb24uY2hhbmdlZFR5cGVzO1xuICAgICAgdmFyIHN1YnMgPSBjaGFuZ2VkVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgaWYgKHN1YnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBjcmVhdGUgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXRcbiAgICAgICAgc3VicyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY2hhbmdlZFR5cGVzLnNldCh0eXBlLCBzdWJzKTtcbiAgICAgIH1cbiAgICAgIHN1YnMuYWRkKHN1Yik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEhlbHBlciB1dGlsaXR5IHRvIHNwbGl0IGFuIEl0ZW0gKHNlZSB7QGxpbmsgSXRlbSNfc3BsaXRBdH0pXG4gICAqIC0gY29waWVzIGFsbCBwcm9wZXJ0aWVzIGZyb20gYSB0byBiXG4gICAqIC0gY29ubmVjdHMgYSB0byBiXG4gICAqIC0gYXNzaWducyB0aGUgY29ycmVjdCBfaWRcbiAgICogLSBzYXZlcyBiIHRvIG9zXG4gICAqL1xuICBmdW5jdGlvbiBzcGxpdEhlbHBlcih5LCBhLCBiLCBkaWZmKSB7XG4gICAgdmFyIGFJRCA9IGEuX2lkO1xuICAgIGIuX2lkID0gbmV3IElEKGFJRC51c2VyLCBhSUQuY2xvY2sgKyBkaWZmKTtcbiAgICBiLl9vcmlnaW4gPSBhO1xuICAgIGIuX2xlZnQgPSBhO1xuICAgIGIuX3JpZ2h0ID0gYS5fcmlnaHQ7XG4gICAgaWYgKGIuX3JpZ2h0ICE9PSBudWxsKSB7XG4gICAgICBiLl9yaWdodC5fbGVmdCA9IGI7XG4gICAgfVxuICAgIGIuX3JpZ2h0X29yaWdpbiA9IGEuX3JpZ2h0X29yaWdpbjtcbiAgICAvLyBkbyBub3Qgc2V0IGEuX3JpZ2h0X29yaWdpbiwgYXMgdGhpcyB3aWxsIGxlYWQgdG8gcHJvYmxlbXMgd2hlbiBzeW5jaW5nXG4gICAgYS5fcmlnaHQgPSBiO1xuICAgIGIuX3BhcmVudCA9IGEuX3BhcmVudDtcbiAgICBiLl9wYXJlbnRTdWIgPSBhLl9wYXJlbnRTdWI7XG4gICAgYi5fZGVsZXRlZCA9IGEuX2RlbGV0ZWQ7XG4gICAgLy8gbm93IHNlYXJjaCBhbGwgcmVsZXZhbnQgaXRlbXMgdG8gdGhlIHJpZ2h0IGFuZCB1cGRhdGUgb3JpZ2luXG4gICAgLy8gaWYgb3JpZ2luIGlzIG5vdCBpdCBmb3VuZE9yaWdpbnMsIHdlIGRvbid0IGhhdmUgdG8gc2VhcmNoIGFueSBsb25nZXJcbiAgICB2YXIgZm91bmRPcmlnaW5zID0gbmV3IFNldCgpO1xuICAgIGZvdW5kT3JpZ2lucy5hZGQoYSk7XG4gICAgdmFyIG8gPSBiLl9yaWdodDtcbiAgICB3aGlsZSAobyAhPT0gbnVsbCAmJiBmb3VuZE9yaWdpbnMuaGFzKG8uX29yaWdpbikpIHtcbiAgICAgIGlmIChvLl9vcmlnaW4gPT09IGEpIHtcbiAgICAgICAgby5fb3JpZ2luID0gYjtcbiAgICAgIH1cbiAgICAgIGZvdW5kT3JpZ2lucy5hZGQobyk7XG4gICAgICBvID0gby5fcmlnaHQ7XG4gICAgfVxuICAgIHkub3MucHV0KGIpO1xuICAgIGlmICh5Ll90cmFuc2FjdGlvbi5uZXdUeXBlcy5oYXMoYSkpIHtcbiAgICAgIHkuX3RyYW5zYWN0aW9uLm5ld1R5cGVzLmFkZChiKTtcbiAgICB9IGVsc2UgaWYgKHkuX3RyYW5zYWN0aW9uLmRlbGV0ZWRTdHJ1Y3RzLmhhcyhhKSkge1xuICAgICAgeS5fdHJhbnNhY3Rpb24uZGVsZXRlZFN0cnVjdHMuYWRkKGIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYW55IGNvbnRlbnQuXG4gICAqL1xuXG4gIHZhciBJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEl0ZW0oKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJdGVtKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdW5pcWUgaWRlbnRpZmllciBvZiB0aGlzIHR5cGUuXG4gICAgICAgKiBAdHlwZSB7SUR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX2lkID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgbGVmdCBvZiB0aGlzIGl0ZW0uXG4gICAgICAgKiBAdHlwZSB7SXRlbX1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fb3JpZ2luID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAgICogQHR5cGUge0l0ZW19XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX2xlZnQgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaXRlbSB0aGF0IGlzIGN1cnJlbnRseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAgICogQHR5cGUge0l0ZW19XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX3JpZ2h0ID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAgICogQHR5cGUge0l0ZW19XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX3JpZ2h0X29yaWdpbiA9IG51bGw7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBwYXJlbnQgdHlwZS5cbiAgICAgICAqIEB0eXBlIHtZfFlUeXBlfVxuICAgICAgICovXG4gICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgcGFyZW50IHJlZmVycyB0byB0aGlzIGl0ZW0gd2l0aCBzb21lIGtpbmQgb2Yga2V5IChlLmcuIFlNYXAsIHRoZVxuICAgICAgICoga2V5IGlzIHNwZWNpZmllZCBoZXJlLiBUaGUga2V5IGlzIHRoZW4gdXNlZCB0byByZWZlciB0byB0aGUgbGlzdCBpbiB3aGljaFxuICAgICAgICogdG8gaW5zZXJ0IHRoaXMgaXRlbS4gSWYgYHBhcmVudFN1YiA9IG51bGxgIHR5cGUuX3N0YXJ0IGlzIHRoZSBsaXN0IGluXG4gICAgICAgKiB3aGljaCB0byBpbnNlcnQgdG8uIE90aGVyd2lzZSBpdCBpcyBgcGFyZW50Ll9zdGFydGAuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICB0aGlzLl9wYXJlbnRTdWIgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoaXMgaXRlbSB3YXMgZGVsZXRlZCBvciBub3QuXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGlzIHR5cGUncyBlZmZlY3QgaXMgcmV1bmRvbmUgdGhpcyB0eXBlIHJlZmVycyB0byB0aGUgdHlwZSB0aGF0IHVuZGlkXG4gICAgICAgKiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgICAqIEB0eXBlIHtJdGVtfVxuICAgICAgICovXG4gICAgICB0aGlzLl9yZWRvbmUgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoSXRlbSwgW3tcbiAgICAgIGtleTogJ19jb3B5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVkb2VzIHRoZSBlZmZlY3Qgb2YgdGhpcyBvcGVyYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlZG8nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWRvKHksIHJlZG9pdGVtcykge1xuICAgICAgICBpZiAodGhpcy5fcmVkb25lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RydWN0ID0gdGhpcy5fY29weSgpO1xuICAgICAgICB2YXIgbGVmdCA9IHRoaXMuX2xlZnQ7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXM7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHBhcmVudCBpcyByZWRvbmVcbiAgICAgICAgaWYgKHBhcmVudC5fZGVsZXRlZCA9PT0gdHJ1ZSAmJiBwYXJlbnQuX3JlZG9uZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIHRyeSB0byB1bmRvIHBhcmVudCBpZiBpdCB3aWxsIGJlIHVuZG9uZSBhbnl3YXlcbiAgICAgICAgICBpZiAoIXJlZG9pdGVtcy5oYXMocGFyZW50KSB8fCAhcGFyZW50Ll9yZWRvKHksIHJlZG9pdGVtcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudC5fcmVkb25lICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9yZWRvbmU7XG4gICAgICAgICAgLy8gZmluZCBuZXh0IGNsb25lZCBpdGVtc1xuICAgICAgICAgIHdoaWxlIChsZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGVmdC5fcmVkb25lICE9PSBudWxsICYmIGxlZnQuX3JlZG9uZS5fcGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuX3JlZG9uZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdC5fbGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmlnaHQuX3JlZG9uZSAhPT0gbnVsbCAmJiByaWdodC5fcmVkb25lLl9wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0Ll9yZWRvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByaWdodCA9IHJpZ2h0Ll9yaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RydWN0Ll9vcmlnaW4gPSBsZWZ0O1xuICAgICAgICBzdHJ1Y3QuX2xlZnQgPSBsZWZ0O1xuICAgICAgICBzdHJ1Y3QuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHN0cnVjdC5fcmlnaHRfb3JpZ2luID0gcmlnaHQ7XG4gICAgICAgIHN0cnVjdC5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICBzdHJ1Y3QuX3BhcmVudFN1YiA9IHRoaXMuX3BhcmVudFN1YjtcbiAgICAgICAgc3RydWN0Ll9pbnRlZ3JhdGUoeSk7XG4gICAgICAgIHRoaXMuX3JlZG9uZSA9IHN0cnVjdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29tcHV0ZXMgdGhlIGxhc3QgY29udGVudCBhZGRyZXNzIG9mIHRoaXMgSXRlbS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc3BsaXRBdCcsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBTcGxpdHMgdGhpcyBJdGVtIHNvIHRoYXQgYW5vdGhlciBJdGVtcyBjYW4gYmUgaW5zZXJ0ZWQgaW4tYmV0d2Vlbi5cbiAgICAgICAqIFRoaXMgbXVzdCBiZSBvdmVyd3JpdHRlbiBpZiBfbGVuZ3RoID4gMVxuICAgICAgICogUmV0dXJucyByaWdodCBwYXJ0IGFmdGVyIHNwbGl0XG4gICAgICAgKiAqIGRpZmYgPT09IDAgPT4gdGhpc1xuICAgICAgICogKiBkaWZmID09PSBsZW5ndGggPT4gdGhpcy5fcmlnaHRcbiAgICAgICAqICogb3RoZXJ3aXNlID0+IHNwbGl0IF9jb250ZW50IGFuZCByZXR1cm4gcmlnaHQgcGFydCBvZiBzcGxpdFxuICAgICAgICogKHNlZSB7QGxpbmsgSXRlbUpTT059L3tAbGluayBJdGVtU3RyaW5nfSBmb3IgaW1wbGVtZW50YXRpb24pXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zcGxpdEF0KHksIGRpZmYpIHtcbiAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWFyayB0aGlzIEl0ZW0gYXMgZGVsZXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGVEZWxldGUgV2hldGhlciB0byBwcm9wYWdhdGUgYSBtZXNzYWdlIHRoYXQgdGhpc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHlwZSB3YXMgZGVsZXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGVsZXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKHkpIHtcbiAgICAgICAgdmFyIGNyZWF0ZURlbGV0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9kZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICB5LmRzLm1hcmsodGhpcy5faWQsIHRoaXMuX2xlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgIHZhciBkZWwgPSBuZXcgRGVsZXRlKCk7XG4gICAgICAgICAgZGVsLl90YXJnZXRJRCA9IHRoaXMuX2lkO1xuICAgICAgICAgIGRlbC5fbGVuZ3RoID0gdGhpcy5fbGVuZ3RoO1xuICAgICAgICAgIGlmIChjcmVhdGVEZWxldGUpIHtcbiAgICAgICAgICAgIC8vIGJyb2FkY2FzdCBhbmQgcGVyc2lzdHMgRGVsZXRlXG4gICAgICAgICAgICBkZWwuX2ludGVncmF0ZSh5LCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHkucGVyc2lzdGVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcGVyc2lzdCBEZWxldGVcbiAgICAgICAgICAgIHkucGVyc2lzdGVuY2Uuc2F2ZVN0cnVjdCh5LCBkZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc2FjdGlvblR5cGVDaGFuZ2VkKHksIHRoaXMuX3BhcmVudCwgdGhpcy5fcGFyZW50U3ViKTtcbiAgICAgICAgICB5Ll90cmFuc2FjdGlvbi5kZWxldGVkU3RydWN0cy5hZGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2NDaGlsZHJlbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2djQ2hpbGRyZW4oeSkge31cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2MnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nYyh5KSB7XG4gICAgICAgIHZhciBnYyA9IG5ldyBHQygpO1xuICAgICAgICBnYy5faWQgPSB0aGlzLl9pZDtcbiAgICAgICAgZ2MuX2xlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICAgICAgeS5vcy5kZWxldGUodGhpcy5faWQpO1xuICAgICAgICBnYy5faW50ZWdyYXRlKHkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSB0aGlzIEl0ZW0gcmVjZWl2ZXMgYW55IGNoaWxkcmVuLlxuICAgICAgICogSXQgY2FuIGJlIG92ZXJ3cml0dGVuIHRvIGFwcGx5IHBlbmRpbmcgY2hhbmdlcyBiZWZvcmUgYXBwbHlpbmcgcmVtb3RlIGNoYW5nZXNcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYmVmb3JlQ2hhbmdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmVmb3JlQ2hhbmdlKCkge31cbiAgICAgIC8vIG5vcFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogSW50ZWdyYXRlcyB0aGlzIEl0ZW0gaW50byB0aGUgc2hhcmVkIHN0cnVjdHVyZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBhY3R1YWxseSBhcHBsaWVzIHRoZSBjaGFuZ2UgdG8gdGhlIFlqcyBpbnN0YW5jZS4gSW4gY2FzZSBvZlxuICAgICAgICogSXRlbSBpdCBjb25uZWN0cyBfbGVmdCBhbmQgX3JpZ2h0IHRvIHRoaXMgSXRlbSBhbmQgY2FsbHMgdGhlXG4gICAgICAgKiB7QGxpbmsgSXRlbSNiZWZvcmVDaGFuZ2V9IG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiAqIEludGVncmF0ZSB0aGUgc3RydWN0IHNvIHRoYXQgb3RoZXIgdHlwZXMvc3RydWN0cyBjYW4gc2VlIGl0XG4gICAgICAgKiAqIEFkZCB0aGlzIHN0cnVjdCB0byB5Lm9zXG4gICAgICAgKiAqIENoZWNrIGlmIHRoaXMgaXMgc3RydWN0IGRlbGV0ZWRcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaW50ZWdyYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW50ZWdyYXRlKHkpIHtcbiAgICAgICAgeS5fdHJhbnNhY3Rpb24ubmV3VHlwZXMuYWRkKHRoaXMpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICB2YXIgc2VsZklEID0gdGhpcy5faWQ7XG4gICAgICAgIHZhciB1c2VyID0gc2VsZklEID09PSBudWxsID8geS51c2VySUQgOiBzZWxmSUQudXNlcjtcbiAgICAgICAgdmFyIHVzZXJTdGF0ZSA9IHkuc3MuZ2V0U3RhdGUodXNlcik7XG4gICAgICAgIGlmIChzZWxmSUQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9pZCA9IHkuc3MuZ2V0TmV4dElEKHRoaXMuX2xlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZklELnVzZXIgPT09IFJvb3RGYWtlVXNlcklEKSA7IGVsc2UgaWYgKHNlbGZJRC5jbG9jayA8IHVzZXJTdGF0ZSkge1xuICAgICAgICAgIC8vIGFscmVhZHkgYXBwbGllZC4uXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGZJRC5jbG9jayA9PT0gdXNlclN0YXRlKSB7XG4gICAgICAgICAgeS5zcy5zZXRTdGF0ZShzZWxmSUQudXNlciwgdXNlclN0YXRlICsgdGhpcy5fbGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtaXNzaW5nIGNvbnRlbnQgZnJvbSB1c2VyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFwcGx5IHlldCEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5fZGVsZXRlZCAmJiAheS5fdHJhbnNhY3Rpb24uY2hhbmdlZFR5cGVzLmhhcyhwYXJlbnQpICYmICF5Ll90cmFuc2FjdGlvbi5uZXdUeXBlcy5oYXMocGFyZW50KSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgcGFyZW50IGlzIHVwZGF0ZWRcbiAgICAgICAgICAvLyBvciB0aGlzIHR5cGVzIGlzIG5ld1xuICAgICAgICAgIHRoaXMuX3BhcmVudC5fYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAjICR0aGlzIGhhcyB0byBmaW5kIGEgdW5pcXVlIHBvc2l0aW9uIGJldHdlZW4gb3JpZ2luIGFuZCB0aGUgbmV4dCBrbm93biBjaGFyYWN0ZXJcbiAgICAgICAgIyBjYXNlIDE6ICRvcmlnaW4gZXF1YWxzICRvLm9yaWdpbjogdGhlICRjcmVhdG9yIHBhcmFtZXRlciBkZWNpZGVzIGlmIGxlZnQgb3IgcmlnaHRcbiAgICAgICAgIyAgICAgICAgIGxldCAkT0w9IFtvMSxvMixvMyxvNF0sIHdoZXJlYnkgJHRoaXMgaXMgdG8gYmUgaW5zZXJ0ZWQgYmV0d2VlbiBvMSBhbmQgbzRcbiAgICAgICAgIyAgICAgICAgIG8yLG8zIGFuZCBvNCBvcmlnaW4gaXMgMSAodGhlIHBvc2l0aW9uIG9mIG8yKVxuICAgICAgICAjICAgICAgICAgdGhlcmUgaXMgdGhlIGNhc2UgdGhhdCAkdGhpcy5jcmVhdG9yIDwgbzIuY3JlYXRvciwgYnV0IG8zLmNyZWF0b3IgPCAkdGhpcy5jcmVhdG9yXG4gICAgICAgICMgICAgICAgICB0aGVuIG8yIGtub3dzIG8zLiBTaW5jZSBvbiBhbm90aGVyIGNsaWVudCAkT0wgY291bGQgYmUgW28xLG8zLG80XSB0aGUgcHJvYmxlbSBpcyBjb21wbGV4XG4gICAgICAgICMgICAgICAgICB0aGVyZWZvcmUgJHRoaXMgd291bGQgYmUgYWx3YXlzIHRvIHRoZSByaWdodCBvZiBvM1xuICAgICAgICAjIGNhc2UgMjogJG9yaWdpbiA8ICRvLm9yaWdpblxuICAgICAgICAjICAgICAgICAgaWYgY3VycmVudCAkdGhpcyBpbnNlcnRfcG9zaXRpb24gPiAkbyBvcmlnaW46ICR0aGlzIGluc1xuICAgICAgICAjICAgICAgICAgZWxzZSAkaW5zZXJ0X3Bvc2l0aW9uIHdpbGwgbm90IGNoYW5nZVxuICAgICAgICAjICAgICAgICAgKG1heWJlIHdlIGVuY291bnRlciBjYXNlIDEgbGF0ZXIsIHRoZW4gdGhpcyB3aWxsIGJlIHRvIHRoZSByaWdodCBvZiAkbylcbiAgICAgICAgIyBjYXNlIDM6ICRvcmlnaW4gPiAkby5vcmlnaW5cbiAgICAgICAgIyAgICAgICAgICR0aGlzIGluc2VydF9wb3NpdGlvbiBpcyB0byB0aGUgbGVmdCBvZiAkbyAoZm9yZXZlciEpXG4gICAgICAgICovXG4gICAgICAgIC8vIGhhbmRsZSBjb25mbGljdHNcbiAgICAgICAgdmFyIG8gPSB2b2lkIDA7XG4gICAgICAgIC8vIHNldCBvIHRvIHRoZSBmaXJzdCBjb25mbGljdGluZyBpdGVtXG4gICAgICAgIGlmICh0aGlzLl9sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbyA9IHRoaXMuX2xlZnQuX3JpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3BhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgIG8gPSB0aGlzLl9wYXJlbnQuX21hcC5nZXQodGhpcy5fcGFyZW50U3ViKSB8fCBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8gPSB0aGlzLl9wYXJlbnQuX3N0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25mbGljdGluZ0l0ZW1zID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgaXRlbXNCZWZvcmVPcmlnaW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIExldCBjIGluIGNvbmZsaWN0aW5nSXRlbXMsIGIgaW4gaXRlbXNCZWZvcmVPcmlnaW5cbiAgICAgICAgLy8gKioqe29yaWdpbn1iYmJie3RoaXN9e2MsYn17YyxifXtvfSoqKlxuICAgICAgICAvLyBOb3RlIHRoYXQgY29uZmxpY3RpbmdJdGVtcyBpcyBhIHN1YnNldCBvZiBpdGVtc0JlZm9yZU9yaWdpblxuICAgICAgICB3aGlsZSAobyAhPT0gbnVsbCAmJiBvICE9PSB0aGlzLl9yaWdodCkge1xuICAgICAgICAgIGl0ZW1zQmVmb3JlT3JpZ2luLmFkZChvKTtcbiAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmFkZChvKTtcbiAgICAgICAgICBpZiAodGhpcy5fb3JpZ2luID09PSBvLl9vcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIGNhc2UgMVxuICAgICAgICAgICAgaWYgKG8uX2lkLnVzZXIgPCB0aGlzLl9pZC51c2VyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xlZnQgPSBvO1xuICAgICAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtc0JlZm9yZU9yaWdpbi5oYXMoby5fb3JpZ2luKSkge1xuICAgICAgICAgICAgLy8gY2FzZSAyXG4gICAgICAgICAgICBpZiAoIWNvbmZsaWN0aW5nSXRlbXMuaGFzKG8uX29yaWdpbikpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGVmdCA9IG87XG4gICAgICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbXMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE86IHRyeSB0byB1c2UgcmlnaHRfb3JpZ2luIGluc3RlYWQuXG4gICAgICAgICAgLy8gVGhlbiB5b3UgY291bGQgYmFzaWNhbGx5IG9taXQgY29uZmxpY3RpbmdJdGVtcyFcbiAgICAgICAgICAvLyBOb3RlOiB5b3UgcHJvYmFibHkgY2FuJ3QgdXNlIHJpZ2h0X29yaWdpbiBpbiBldmVyeSBjYXNlLi4gb25seSB3aGVuIHNldHRpbmcgX2xlZnRcbiAgICAgICAgICBvID0gby5fcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjb25uZWN0IGxlZnQvcmlnaHQgKyB1cGRhdGUgcGFyZW50IG1hcC9zdGFydCBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIHBhcmVudFN1YiA9IHRoaXMuX3BhcmVudFN1YjtcbiAgICAgICAgaWYgKHRoaXMuX2xlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgcmlnaHQgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBtYXAgPSBwYXJlbnQuX21hcDtcbiAgICAgICAgICAgIHJpZ2h0ID0gcG1hcC5nZXQocGFyZW50U3ViKSB8fCBudWxsO1xuICAgICAgICAgICAgcG1hcC5zZXQocGFyZW50U3ViLCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBwYXJlbnQuX3N0YXJ0O1xuICAgICAgICAgICAgcGFyZW50Ll9zdGFydCA9IHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgaWYgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByaWdodC5fbGVmdCA9IHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fbGVmdDtcbiAgICAgICAgICB2YXIgX3JpZ2h0ID0gbGVmdC5fcmlnaHQ7XG4gICAgICAgICAgdGhpcy5fcmlnaHQgPSBfcmlnaHQ7XG4gICAgICAgICAgbGVmdC5fcmlnaHQgPSB0aGlzO1xuICAgICAgICAgIGlmIChfcmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9yaWdodC5fbGVmdCA9IHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQuX2RlbGV0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9kZWxldGUoeSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHkub3MucHV0KHRoaXMpO1xuICAgICAgICB0cmFuc2FjdGlvblR5cGVDaGFuZ2VkKHksIHBhcmVudCwgcGFyZW50U3ViKTtcbiAgICAgICAgaWYgKHRoaXMuX2lkLnVzZXIgIT09IFJvb3RGYWtlVXNlcklEKSB7XG4gICAgICAgICAgaWYgKHkuY29ubmVjdG9yICE9PSBudWxsICYmICh5LmNvbm5lY3Rvci5fZm9yd2FyZEFwcGxpZWRTdHJ1Y3RzIHx8IHRoaXMuX2lkLnVzZXIgPT09IHkudXNlcklEKSkge1xuICAgICAgICAgICAgeS5jb25uZWN0b3IuYnJvYWRjYXN0U3RydWN0KHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeS5wZXJzaXN0ZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgeS5wZXJzaXN0ZW5jZS5zYXZlU3RydWN0KHksIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgICAgICogQmluYXJ5RW5jb2Rlci5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtCaW5hcnlFbmNvZGVyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3RvQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9CaW5hcnkoZW5jb2Rlcikge1xuICAgICAgICBlbmNvZGVyLndyaXRlVWludDgoZ2V0U3RydWN0UmVmZXJlbmNlKHRoaXMuY29uc3RydWN0b3IpKTtcbiAgICAgICAgdmFyIGluZm8gPSAwO1xuICAgICAgICBpZiAodGhpcy5fb3JpZ2luICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5mbyArPSAxOyAvLyBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgICAvKiBubyBsb25nZXIgc2VuZCBfbGVmdFxuICAgICAgICBpZiAodGhpcy5fbGVmdCAhPT0gdGhpcy5fb3JpZ2luKSB7XG4gICAgICAgICAgaW5mbyArPSAwYjEwIC8vIGRvIG5vdCBjb3B5IG9yaWdpbiB0byBsZWZ0XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuX3JpZ2h0X29yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGluZm8gKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5mbyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZXIud3JpdGVVaW50OChpbmZvKTtcbiAgICAgICAgZW5jb2Rlci53cml0ZUlEKHRoaXMuX2lkKTtcbiAgICAgICAgaWYgKGluZm8gJiAxKSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZUlEKHRoaXMuX29yaWdpbi5fbGFzdElkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgLyogc2VlIGFib3ZlXG4gICAgICAgIGlmIChpbmZvICYgMGIxMCkge1xuICAgICAgICAgIGVuY29kZXIud3JpdGVJRCh0aGlzLl9sZWZ0Ll9sYXN0SWQpXG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKGluZm8gJiA0KSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZUlEKHRoaXMuX3JpZ2h0X29yaWdpbi5faWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaW5mbyAmIDUpID09PSAwKSB7XG4gICAgICAgICAgLy8gbmVpdGhlciBvcmlnaW4gbm9yIHJpZ2h0IGlzIGRlZmluZWRcbiAgICAgICAgICBlbmNvZGVyLndyaXRlSUQodGhpcy5fcGFyZW50Ll9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8gJiA4KSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVZhclN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLl9wYXJlbnRTdWIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWQgdGhlIG5leHQgSXRlbSBpbiBhIERlY29kZXIgYW5kIGZpbGwgdGhpcyBJdGVtIHdpdGggdGhlIHJlYWQgZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGRhdGEgaXMgcmVjZWl2ZWQgZnJvbSBhIHJlbW90ZSBwZWVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7WX0geSBUaGUgWWpzIGluc3RhbmNlIHRoYXQgdGhpcyBJdGVtIGJlbG9uZ3MgdG8uXG4gICAgICAgKiBAcGFyYW0ge0JpbmFyeURlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgb2JqZWN0IHRvIHJlYWQgZGF0YSBmcm9tLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19mcm9tQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZnJvbUJpbmFyeSh5LCBkZWNvZGVyKSB7XG4gICAgICAgIHZhciBtaXNzaW5nID0gW107XG4gICAgICAgIHZhciBpbmZvID0gZGVjb2Rlci5yZWFkVWludDgoKTtcbiAgICAgICAgdmFyIGlkID0gZGVjb2Rlci5yZWFkSUQoKTtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgLy8gcmVhZCBvcmlnaW5cbiAgICAgICAgaWYgKGluZm8gJiAxKSB7XG4gICAgICAgICAgLy8gb3JpZ2luICE9IG51bGxcbiAgICAgICAgICB2YXIgb3JpZ2luSUQgPSBkZWNvZGVyLnJlYWRJRCgpO1xuICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcXVlcnkgZm9yIGxlZnQgYWdhaW4gYmVjYXVzZSBpdCBtaWdodCBoYXZlIGJlZW4gc3BsaXQvbWVyZ2VkLi5cbiAgICAgICAgICB2YXIgb3JpZ2luID0geS5vcy5nZXRJdGVtQ2xlYW5FbmQob3JpZ2luSUQpO1xuICAgICAgICAgIGlmIChvcmlnaW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChvcmlnaW5JRCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgICAgIHRoaXMuX2xlZnQgPSB0aGlzLl9vcmlnaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWQgcmlnaHRcbiAgICAgICAgaWYgKGluZm8gJiA0KSB7XG4gICAgICAgICAgLy8gcmlnaHQgIT0gbnVsbFxuICAgICAgICAgIHZhciByaWdodElEID0gZGVjb2Rlci5yZWFkSUQoKTtcbiAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHF1ZXJ5IGZvciByaWdodCBhZ2FpbiBiZWNhdXNlIGl0IG1pZ2h0IGhhdmUgYmVlbiBzcGxpdC9tZXJnZWQuLlxuICAgICAgICAgIHZhciByaWdodCA9IHkub3MuZ2V0SXRlbUNsZWFuU3RhcnQocmlnaHRJRCk7XG4gICAgICAgICAgaWYgKHJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBtaXNzaW5nLnB1c2gocmlnaHRJRCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9yaWdodF9vcmlnaW4gPSByaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZCBwYXJlbnRcbiAgICAgICAgaWYgKChpbmZvICYgNSkgPT09IDApIHtcbiAgICAgICAgICAvLyBuZWl0aGVyIG9yaWdpbiBub3IgcmlnaHQgaXMgZGVmaW5lZFxuICAgICAgICAgIHZhciBwYXJlbnRJRCA9IGRlY29kZXIucmVhZElEKCk7XG4gICAgICAgICAgLy8gcGFyZW50IGRvZXMgbm90IGNoYW5nZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byBzZWFyY2ggZm9yIGl0IGFnYWluXG4gICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChwYXJlbnRJRC5jb25zdHJ1Y3RvciA9PT0gUm9vdElEKSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHkub3MuZ2V0KHBhcmVudElEKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHkub3MuZ2V0SXRlbShwYXJlbnRJRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIG1pc3NpbmcucHVzaChwYXJlbnRJRCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0aGlzLl9vcmlnaW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcmlnaW4uY29uc3RydWN0b3IgPT09IEdDKSB7XG4gICAgICAgICAgICAgIC8vIGlmIG9yaWdpbiBpcyBhIGdjLCBzZXQgcGFyZW50IGFsc28gZ2MnZFxuICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9vcmlnaW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9vcmlnaW4uX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3JpZ2h0X29yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaWYgb3JpZ2luIGlzIGEgZ2MsIHNldCBwYXJlbnQgYWxzbyBnYydkXG4gICAgICAgICAgICBpZiAodGhpcy5fcmlnaHRfb3JpZ2luLmNvbnN0cnVjdG9yID09PSBHQykge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9yaWdodF9vcmlnaW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9yaWdodF9vcmlnaW4uX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8gJiA4KSB7XG4gICAgICAgICAgLy8gVE9ETzogbWF5YmUgcHV0IHRoaXMgaW4gcmVhZCBwYXJlbnQgY29uZGl0aW9uICh5b3UgY2FuIGFsc28gcmVhZCBwYXJlbnRzdWIgZnJvbSBsZWZ0L3JpZ2h0KVxuICAgICAgICAgIHRoaXMuX3BhcmVudFN1YiA9IEpTT04ucGFyc2UoZGVjb2Rlci5yZWFkVmFyU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5LnNzLmdldFN0YXRlKGlkLnVzZXIpIDwgaWQuY2xvY2spIHtcbiAgICAgICAgICBtaXNzaW5nLnB1c2gobmV3IElEKGlkLnVzZXIsIGlkLmNsb2NrIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sYXN0SWQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSUQodGhpcy5faWQudXNlciwgdGhpcy5faWQuY2xvY2sgKyB0aGlzLl9sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgSXRlbS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbGVuZ3RoJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTaG91bGQgcmV0dXJuIGZhbHNlIGlmIHRoaXMgSXRlbSBpcyBzb21lIGtpbmQgb2YgbWV0YSBpbmZvcm1hdGlvblxuICAgICAgICogKGUuZy4gZm9ybWF0IGluZm9ybWF0aW9uKS5cbiAgICAgICAqXG4gICAgICAgKiAqIFdoZXRoZXIgdGhpcyBJdGVtIHNob3VsZCBiZSBhZGRyZXNzYWJsZSB2aWEgYHlhcnJheS5nZXQoaSlgXG4gICAgICAgKiAqIFdoZXRoZXIgdGhpcyBJdGVtIHNob3VsZCBiZSBjb3VudGVkIHdoZW4gY29tcHV0aW5nIHlhcnJheS5sZW5ndGhcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY291bnRhYmxlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEl0ZW07XG4gIH0oKTtcblxuICAvKipcbiAgICogR2VuZXJhbCBldmVudCBoYW5kbGVyIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgdmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEhhbmRsZXIoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudEhhbmRsZXIpO1xuXG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gcHJldmVudCBtZW1vcnkgbGVha3MsIGNhbGwgdGhpcyBtZXRob2Qgd2hlbiB0aGUgZXZlbnRMaXN0ZW5lcnMgd29uJ3QgYmVcbiAgICAgKiB1c2VkIGFueW1vcmUuXG4gICAgICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKEV2ZW50SGFuZGxlciwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGlzIGNhbGxlZCB3aGVuXG4gICAgICAgKiB7QGxpbmsgRXZlbnRIYW5kbGVyI2NhbGxFdmVudExpc3RlbmVyc30gaXMgY2FsbGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihmKSB7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMucHVzaChmKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGV2ZW50IGhhbmRsZXIgdGhhdCB3YXMgYWRkZWQgd2l0aFxuICAgICAgICogICAgICAgICAgICAgICAgICAgICB7QGxpbmsgRXZlbnRIYW5kbGVyI2FkZEV2ZW50TGlzdGVuZXJ9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihmKSB7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoZykge1xuICAgICAgICAgIHJldHVybiBmICE9PSBnO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVBbGxFdmVudExpc3RlbmVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCBhbGwgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZCB2aWFcbiAgICAgICAqIHtAbGluayBFdmVudEhhbmRsZXIjYWRkRXZlbnRMaXN0ZW5lcn0uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIG9iamVjdCAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoaXM/XG4gICAgICAgKiBAcGFyYW0ge1lFdmVudH0gZXZlbnQgQW4gZXZlbnQgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2Ugb24gYSB0eXBlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2FsbEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbEV2ZW50TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBldmVudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGYgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgZihldmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgWW91ciBvYnNlcnZlciB0aHJldyBhbiBlcnJvci4gVGhpcyBlcnJvciB3YXMgY2F1Z2h0IHNvIHRoYXQgWWpzXG4gICAgICAgICAgICAgIGNhbiBlbnN1cmUgZGF0YSBjb25zaXN0ZW5jeSEgSW4gb3JkZXIgdG8gZGVidWcgdGhpcyBlcnJvciB5b3VcbiAgICAgICAgICAgICAgaGF2ZSB0byBjaGVjayBcIlBhdXNlIE9uIENhdWdodCBFeGNlcHRpb25zXCIgaW4gZGV2ZWxvcGVyIHRvb2xzLlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBFdmVudEhhbmRsZXI7XG4gIH0oKTtcblxuICAvLyByZXN0cnVjdHVyZSBjaGlsZHJlbiBhcyBpZiB0aGV5IHdlcmUgaW5zZXJ0ZWQgb25lIGFmdGVyIGFub3RoZXJcbiAgZnVuY3Rpb24gaW50ZWdyYXRlQ2hpbGRyZW4oeSwgc3RhcnQpIHtcbiAgICB2YXIgcmlnaHQgPSB2b2lkIDA7XG4gICAgZG8ge1xuICAgICAgcmlnaHQgPSBzdGFydC5fcmlnaHQ7XG4gICAgICBzdGFydC5fcmlnaHQgPSBudWxsO1xuICAgICAgc3RhcnQuX3JpZ2h0X29yaWdpbiA9IG51bGw7XG4gICAgICBzdGFydC5fb3JpZ2luID0gc3RhcnQuX2xlZnQ7XG4gICAgICBzdGFydC5faW50ZWdyYXRlKHkpO1xuICAgICAgc3RhcnQgPSByaWdodDtcbiAgICB9IHdoaWxlIChyaWdodCAhPT0gbnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBnY0NoaWxkcmVuKHksIGl0ZW0pIHtcbiAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgaXRlbS5fZGVsZXRlKHksIGZhbHNlLCB0cnVlKTtcbiAgICAgIGl0ZW0uX2djKHkpO1xuICAgICAgaXRlbSA9IGl0ZW0uX3JpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBYnN0cmFjdCBZanMgVHlwZSBjbGFzc1xuICAgKi9cblxuICB2YXIgVHlwZSA9IGZ1bmN0aW9uIChfSXRlbSkge1xuICAgIGluaGVyaXRzKFR5cGUsIF9JdGVtKTtcblxuICAgIGZ1bmN0aW9uIFR5cGUoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlKTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGUpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgX3RoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgIF90aGlzLl9zdGFydCA9IG51bGw7XG4gICAgICBfdGhpcy5feSA9IG51bGw7XG4gICAgICBfdGhpcy5fZXZlbnRIYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuICAgICAgX3RoaXMuX2RlZXBFdmVudEhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyKCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgcGF0aCBmcm9tIHRoaXMgdHlwZSB0byB0aGUgc3BlY2lmaWVkIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogSXQgc2hvdWxkIGJlIGFjY2Vzc2libGUgdmlhIGB0aGlzLmdldChyZXN1bHRbMF0pLmdldChyZXN1bHRbMV0pLi5gXG4gICAgICogY29uc3QgcGF0aCA9IHR5cGUuZ2V0UGF0aFRvKGNoaWxkKVxuICAgICAqIC8vIGFzc3VtaW5nIGB0eXBlIGluc3RhbmNlb2YgWUFycmF5YFxuICAgICAqIGNvbnNvbGUubG9nKHBhdGgpIC8vIG1pZ2h0IGxvb2sgbGlrZSA9PiBbMiwgJ2tleTEnXVxuICAgICAqIGNoaWxkID09PSB0eXBlLmdldChwYXRoWzBdKS5nZXQocGF0aFsxXSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WVR5cGV9IHR5cGUgVHlwZSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBQYXRoIHRvIHRoZSB0YXJnZXRcbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoVHlwZSwgW3tcbiAgICAgIGtleTogJ2dldFBhdGhUbycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aFRvKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHRoaXMpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSBbXTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLl95O1xuICAgICAgICB3aGlsZSAodHlwZSAhPT0gdGhpcyAmJiB0eXBlICE9PSB5KSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHR5cGUuX3BhcmVudDtcbiAgICAgICAgICBpZiAodHlwZS5fcGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXRoLnVuc2hpZnQodHlwZS5fcGFyZW50U3ViKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyZW50IGlzIGFycmF5LWlzaFxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHBhcmVudFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBzbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICBwYXRoLnVuc2hpZnQoaSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHlwZSBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIG5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQ2FsbCBldmVudCBsaXN0ZW5lcnMgd2l0aCBhbiBldmVudC4gVGhpcyB3aWxsIGFsc28gYWRkIGFuIGV2ZW50IHRvIGFsbFxuICAgICAgICogcGFyZW50cyAoZm9yIGAub2JzZXJ2ZURlZXBgIGhhbmRsZXJzKS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NhbGxFdmVudEhhbmRsZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxsRXZlbnRIYW5kbGVyKHRyYW5zYWN0aW9uLCBldmVudCkge1xuICAgICAgICB2YXIgY2hhbmdlZFBhcmVudFR5cGVzID0gdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzO1xuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXIuY2FsbEV2ZW50TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBldmVudCk7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHR5cGUgIT09IHRoaXMuX3kpIHtcbiAgICAgICAgICB2YXIgZXZlbnRzID0gY2hhbmdlZFBhcmVudFR5cGVzLmdldCh0eXBlKTtcbiAgICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgY2hhbmdlZFBhcmVudFR5cGVzLnNldCh0eXBlLCBldmVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudHMucHVzaChldmVudCk7XG4gICAgICAgICAgdHlwZSA9IHR5cGUuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHRyYW5zYWN0IGlmIHRoZSB5IGluc3RhbmNlIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqXG4gICAgICAgKiBUT0RPOiBDdXJyZW50bHkgZXZlbnQgaGFuZGxlcnMgYXJlIG5vdCB0aHJvd24gd2hlbiBhIHR5cGUgaXMgbm90IHJlZ2lzdGVyZWRcbiAgICAgICAqICAgICAgIHdpdGggYSBZanMgaW5zdGFuY2UuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190cmFuc2FjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zYWN0KGYpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLl95O1xuICAgICAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICAgIHkudHJhbnNhY3QoZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZih5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE9ic2VydmUgYWxsIGV2ZW50cyB0aGF0IGFyZSBjcmVhdGVkIG9uIHRoaXMgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29ic2VydmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9ic2VydmUoZikge1xuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXIuYWRkRXZlbnRMaXN0ZW5lcihmKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPYnNlcnZlIGFsbCBldmVudHMgdGhhdCBhcmUgY3JlYXRlZCBieSB0aGlzIHR5cGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29ic2VydmVEZWVwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvYnNlcnZlRGVlcChmKSB7XG4gICAgICAgIHRoaXMuX2RlZXBFdmVudEhhbmRsZXIuYWRkRXZlbnRMaXN0ZW5lcihmKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVbnJlZ2lzdGVyIGFuIG9ic2VydmVyIGZ1bmN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndW5vYnNlcnZlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bm9ic2VydmUoZikge1xuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihmKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVbnJlZ2lzdGVyIGFuIG9ic2VydmVyIGZ1bmN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndW5vYnNlcnZlRGVlcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5vYnNlcnZlRGVlcChmKSB7XG4gICAgICAgIHRoaXMuX2RlZXBFdmVudEhhbmRsZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihmKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgICAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICAgICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7WX0geSBUaGUgWWpzIGluc3RhbmNlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19pbnRlZ3JhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnRlZ3JhdGUoeSkge1xuICAgICAgICBnZXQoVHlwZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUeXBlLnByb3RvdHlwZSksICdfaW50ZWdyYXRlJywgdGhpcykuY2FsbCh0aGlzLCB5KTtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIC8vIHdoZW4gaW50ZWdyYXRpbmcgY2hpbGRyZW4gd2UgbXVzdCBtYWtlIHN1cmUgdG9cbiAgICAgICAgLy8gaW50ZWdyYXRlIHN0YXJ0XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuX3N0YXJ0O1xuICAgICAgICBpZiAoc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9zdGFydCA9IG51bGw7XG4gICAgICAgICAgaW50ZWdyYXRlQ2hpbGRyZW4oeSwgc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludGVncmF0ZSBtYXAgY2hpbGRyZW5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gbWFwLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgICAgLy8gVE9ETyBtYWtlIHN1cmUgdGhhdCByaWdodCBlbGVtZW50cyBhcmUgZGVsZXRlZCFcbiAgICAgICAgICAgIGludGVncmF0ZUNoaWxkcmVuKHksIHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2djQ2hpbGRyZW4nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nY0NoaWxkcmVuKHkpIHtcbiAgICAgICAgZ2NDaGlsZHJlbih5LCB0aGlzLl9zdGFydCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFwLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBnY0NoaWxkcmVuKHksIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nYycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2djKHkpIHtcbiAgICAgICAgdGhpcy5fZ2NDaGlsZHJlbih5KTtcbiAgICAgICAgZ2V0KFR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHlwZS5wcm90b3R5cGUpLCAnX2djJywgdGhpcykuY2FsbCh0aGlzLCB5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogTWFyayB0aGlzIEl0ZW0gYXMgZGVsZXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGVEZWxldGUgV2hldGhlciB0byBwcm9wYWdhdGUgYSBtZXNzYWdlIHRoYXQgdGhpc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHlwZSB3YXMgZGVsZXRlZC5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2djQ2hpbGRyZW49eS5faGFzVW5kb01hbmFnZXI9PT1mYWxzZV0gV2hldGhlciB0byBnYXJiYWdlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyB0eXBlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGVsZXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKHksIGNyZWF0ZURlbGV0ZSwgZ2NDaGlsZHJlbikge1xuICAgICAgICBpZiAoZ2NDaGlsZHJlbiA9PT0gdW5kZWZpbmVkIHx8ICF5LmdjRW5hYmxlZCkge1xuICAgICAgICAgIGdjQ2hpbGRyZW4gPSB5Ll9oYXNVbmRvTWFuYWdlciA9PT0gZmFsc2UgJiYgeS5nY0VuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0KFR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHlwZS5wcm90b3R5cGUpLCAnX2RlbGV0ZScsIHRoaXMpLmNhbGwodGhpcywgeSwgY3JlYXRlRGVsZXRlLCBnY0NoaWxkcmVuKTtcbiAgICAgICAgeS5fdHJhbnNhY3Rpb24uY2hhbmdlZFR5cGVzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgLy8gZGVsZXRlIG1hcCB0eXBlc1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gdGhpcy5fbWFwLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEl0ZW0gJiYgIXZhbHVlLl9kZWxldGVkKSB7XG4gICAgICAgICAgICAgIHZhbHVlLl9kZWxldGUoeSwgZmFsc2UsIGdjQ2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBkZWxldGUgYXJyYXkgdHlwZXNcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzLl9zdGFydDtcbiAgICAgICAgd2hpbGUgKHQgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIXQuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHQuX2RlbGV0ZSh5LCBmYWxzZSwgZ2NDaGlsZHJlbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHQgPSB0Ll9yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2NDaGlsZHJlbikge1xuICAgICAgICAgIHRoaXMuX2djQ2hpbGRyZW4oeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFR5cGU7XG4gIH0oSXRlbSk7XG5cbiAgdmFyIEl0ZW1KU09OID0gZnVuY3Rpb24gKF9JdGVtKSB7XG4gICAgaW5oZXJpdHMoSXRlbUpTT04sIF9JdGVtKTtcblxuICAgIGZ1bmN0aW9uIEl0ZW1KU09OKCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSXRlbUpTT04pO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJdGVtSlNPTi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1KU09OKSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgIF90aGlzLl9jb250ZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhJdGVtSlNPTiwgW3tcbiAgICAgIGtleTogJ19jb3B5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29weSgpIHtcbiAgICAgICAgdmFyIHN0cnVjdCA9IGdldChJdGVtSlNPTi5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGVtSlNPTi5wcm90b3R5cGUpLCAnX2NvcHknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICBzdHJ1Y3QuX2NvbnRlbnQgPSB0aGlzLl9jb250ZW50O1xuICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19mcm9tQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZnJvbUJpbmFyeSh5LCBkZWNvZGVyKSB7XG4gICAgICAgIHZhciBtaXNzaW5nID0gZ2V0KEl0ZW1KU09OLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1KU09OLnByb3RvdHlwZSksICdfZnJvbUJpbmFyeScsIHRoaXMpLmNhbGwodGhpcywgeSwgZGVjb2Rlcik7XG4gICAgICAgIHZhciBsZW4gPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBjdG50ID0gZGVjb2Rlci5yZWFkVmFyU3RyaW5nKCk7XG4gICAgICAgICAgdmFyIHBhcnNlZCA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoY3RudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShjdG50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY29udGVudFtpXSA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlzc2luZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdG9CaW5hcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90b0JpbmFyeShlbmNvZGVyKSB7XG4gICAgICAgIGdldChJdGVtSlNPTi5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGVtSlNPTi5wcm90b3R5cGUpLCAnX3RvQmluYXJ5JywgdGhpcykuY2FsbCh0aGlzLCBlbmNvZGVyKTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICBlbmNvZGVyLndyaXRlVmFyVWludChsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVuY29kZWQgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9jb250ZW50W2ldO1xuICAgICAgICAgIGlmIChjb250ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuY29kZWQgPSAndW5kZWZpbmVkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RlZCA9IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmNvZGVyLndyaXRlVmFyU3RyaW5nKGVuY29kZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aGlzIFlYbWwgVHlwZSB0byBhIHJlYWRhYmxlIGZvcm1hdC5cbiAgICAgICAqIFVzZWZ1bCBmb3IgbG9nZ2luZyBhcyBhbGwgSXRlbXMgYW5kIERlbGV0ZSBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2xvZ1N0cmluZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGxvZ0l0ZW1IZWxwZXIoJ0l0ZW1KU09OJywgdGhpcywgJ2NvbnRlbnQ6JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuX2NvbnRlbnQpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc3BsaXRBdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NwbGl0QXQoeSwgZGlmZikge1xuICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpdGVtID0gbmV3IEl0ZW1KU09OKCk7XG4gICAgICAgIGl0ZW0uX2NvbnRlbnQgPSB0aGlzLl9jb250ZW50LnNwbGljZShkaWZmKTtcbiAgICAgICAgc3BsaXRIZWxwZXIoeSwgdGhpcywgaXRlbSwgZGlmZik7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sZW5ndGgnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEl0ZW1KU09OO1xuICB9KEl0ZW0pO1xuXG4gIHZhciBJdGVtU3RyaW5nID0gZnVuY3Rpb24gKF9JdGVtKSB7XG4gICAgaW5oZXJpdHMoSXRlbVN0cmluZywgX0l0ZW0pO1xuXG4gICAgZnVuY3Rpb24gSXRlbVN0cmluZygpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEl0ZW1TdHJpbmcpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJdGVtU3RyaW5nLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRlbVN0cmluZykpLmNhbGwodGhpcykpO1xuXG4gICAgICBfdGhpcy5fY29udGVudCA9IG51bGw7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoSXRlbVN0cmluZywgW3tcbiAgICAgIGtleTogJ19jb3B5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29weSgpIHtcbiAgICAgICAgdmFyIHN0cnVjdCA9IGdldChJdGVtU3RyaW5nLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1TdHJpbmcucHJvdG90eXBlKSwgJ19jb3B5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgc3RydWN0Ll9jb250ZW50ID0gdGhpcy5fY29udGVudDtcbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZnJvbUJpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zyb21CaW5hcnkoeSwgZGVjb2Rlcikge1xuICAgICAgICB2YXIgbWlzc2luZyA9IGdldChJdGVtU3RyaW5nLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1TdHJpbmcucHJvdG90eXBlKSwgJ19mcm9tQmluYXJ5JywgdGhpcykuY2FsbCh0aGlzLCB5LCBkZWNvZGVyKTtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGRlY29kZXIucmVhZFZhclN0cmluZygpO1xuICAgICAgICByZXR1cm4gbWlzc2luZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdG9CaW5hcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90b0JpbmFyeShlbmNvZGVyKSB7XG4gICAgICAgIGdldChJdGVtU3RyaW5nLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1TdHJpbmcucHJvdG90eXBlKSwgJ190b0JpbmFyeScsIHRoaXMpLmNhbGwodGhpcywgZW5jb2Rlcik7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJTdHJpbmcodGhpcy5fY29udGVudCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aGlzIFlYbWwgVHlwZSB0byBhIHJlYWRhYmxlIGZvcm1hdC5cbiAgICAgICAqIFVzZWZ1bCBmb3IgbG9nZ2luZyBhcyBhbGwgSXRlbXMgYW5kIERlbGV0ZSBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2xvZ1N0cmluZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGxvZ0l0ZW1IZWxwZXIoJ0l0ZW1TdHJpbmcnLCB0aGlzLCAnY29udGVudDpcIicgKyB0aGlzLl9jb250ZW50ICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3NwbGl0QXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zcGxpdEF0KHksIGRpZmYpIHtcbiAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbSA9IG5ldyBJdGVtU3RyaW5nKCk7XG4gICAgICAgIGl0ZW0uX2NvbnRlbnQgPSB0aGlzLl9jb250ZW50LnNsaWNlKGRpZmYpO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zbGljZSgwLCBkaWZmKTtcbiAgICAgICAgc3BsaXRIZWxwZXIoeSwgdGhpcywgaXRlbSwgZGlmZik7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sZW5ndGgnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEl0ZW1TdHJpbmc7XG4gIH0oSXRlbSk7XG5cbiAgLyoqXG4gICAqIFlFdmVudCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZVHlwZS5cbiAgICovXG4gIHZhciBZRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtZVHlwZX0gdGFyZ2V0IFRoZSBjaGFuZ2VkIHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gWUV2ZW50KHRhcmdldCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWUV2ZW50KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdHlwZSBvbiB3aGljaCB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkIG9uLlxuICAgICAgICogQHR5cGUge1lUeXBlfVxuICAgICAgICovXG4gICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGN1cnJlbnQgdGFyZ2V0IG9uIHdoaWNoIHRoZSBvYnNlcnZlIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAgICAgICAqIEB0eXBlIHtZVHlwZX1cbiAgICAgICAqL1xuICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBwYXRoIGZyb20gYHlgIHRvIHRoZSBjaGFuZ2VkIHR5cGUuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnR5IGhvbGRzOlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBsZXQgdHlwZSA9IHlcbiAgICAgKiAgIGV2ZW50LnBhdGguZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICogICAgIHR5cGUgPSB0eXBlLmdldChkaXIpXG4gICAgICogICB9KVxuICAgICAqICAgdHlwZSA9PT0gZXZlbnQudGFyZ2V0IC8vID0+IHRydWVcbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoWUV2ZW50LCBbe1xuICAgICAga2V5OiBcInBhdGhcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VGFyZ2V0LmdldFBhdGhUbyh0aGlzLnRhcmdldCk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBZRXZlbnQ7XG4gIH0oKTtcblxuICAvKipcbiAgICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZQXJyYXlcbiAgICpcbiAgICogQHBhcmFtIHtZQXJyYXl9IHlhcnJheSBUaGUgY2hhbmdlZCB0eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3RlIFdoZXRoZXIgdGhlIGNoYW5nZWQgd2FzIGNhdXNlZCBieSBhIHJlbW90ZSBwZWVyXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICovXG4gIHZhciBZQXJyYXlFdmVudCA9IGZ1bmN0aW9uIChfWUV2ZW50KSB7XG4gICAgaW5oZXJpdHMoWUFycmF5RXZlbnQsIF9ZRXZlbnQpO1xuXG4gICAgZnVuY3Rpb24gWUFycmF5RXZlbnQoeWFycmF5LCByZW1vdGUsIHRyYW5zYWN0aW9uKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBZQXJyYXlFdmVudCk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFlBcnJheUV2ZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWUFycmF5RXZlbnQpKS5jYWxsKHRoaXMsIHlhcnJheSkpO1xuXG4gICAgICBfdGhpcy5yZW1vdGUgPSByZW1vdGU7XG4gICAgICBfdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgIF90aGlzLl9hZGRlZEVsZW1lbnRzID0gbnVsbDtcbiAgICAgIF90aGlzLl9yZW1vdmVkRWxlbWVudHMgPSBudWxsO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoaWxkIGVsZW1lbnRzIHRoYXQgd2VyZSBhZGRlZCBpbiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2V0fVxuICAgICAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhZQXJyYXlFdmVudCwgW3tcbiAgICAgIGtleTogJ2FkZGVkRWxlbWVudHMnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hZGRlZEVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuX3RyYW5zYWN0aW9uO1xuICAgICAgICAgIHZhciBhZGRlZEVsZW1lbnRzID0gbmV3IFNldCgpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLm5ld1R5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlLl9wYXJlbnQgPT09IHRhcmdldCAmJiAhdHJhbnNhY3Rpb24uZGVsZXRlZFN0cnVjdHMuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgIGFkZGVkRWxlbWVudHMuYWRkKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX2FkZGVkRWxlbWVudHMgPSBhZGRlZEVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRlZEVsZW1lbnRzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoaWxkIGVsZW1lbnRzIHRoYXQgd2VyZSByZW1vdmVkIGluIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7U2V0fVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW1vdmVkRWxlbWVudHMnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmVkRWxlbWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy5fdHJhbnNhY3Rpb247XG4gICAgICAgICAgdmFyIHJlbW92ZWRFbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5kZWxldGVkU3RydWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJ1Y3QpIHtcbiAgICAgICAgICAgIGlmIChzdHJ1Y3QuX3BhcmVudCA9PT0gdGFyZ2V0ICYmICF0cmFuc2FjdGlvbi5uZXdUeXBlcy5oYXMoc3RydWN0KSkge1xuICAgICAgICAgICAgICByZW1vdmVkRWxlbWVudHMuYWRkKHN0cnVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlZEVsZW1lbnRzID0gcmVtb3ZlZEVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVkRWxlbWVudHM7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBZQXJyYXlFdmVudDtcbiAgfShZRXZlbnQpO1xuXG4gIC8qKlxuICAgKiBBIHNoYXJlZCBBcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAgICovXG5cbiAgdmFyIFlBcnJheSA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICAgIGluaGVyaXRzKFlBcnJheSwgX1R5cGUpO1xuXG4gICAgZnVuY3Rpb24gWUFycmF5KCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWUFycmF5KTtcbiAgICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChZQXJyYXkuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZQXJyYXkpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhZQXJyYXksIFt7XG4gICAgICBrZXk6ICdfY2FsbE9ic2VydmVyJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQ3JlYXRlcyBZQXJyYXkgRXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMsIHJlbW90ZSkge1xuICAgICAgICB0aGlzLl9jYWxsRXZlbnRIYW5kbGVyKHRyYW5zYWN0aW9uLCBuZXcgWUFycmF5RXZlbnQodGhpcywgcmVtb3RlLCB0cmFuc2FjdGlvbikpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGktdGggZWxlbWVudCBmcm9tIGEgWUFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybiBmcm9tIHRoZSBZQXJyYXlcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQkJDEoaW5kZXgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9zdGFydDtcbiAgICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIW4uX2RlbGV0ZWQgJiYgbi5fY291bnRhYmxlKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBuLl9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKG4uY29uc3RydWN0b3IgPT09IEl0ZW1KU09OIHx8IG4uY29uc3RydWN0b3IgPT09IEl0ZW1TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5fY29udGVudFtpbmRleF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4IC09IG4uX2xlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbiA9IG4uX3JpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3RvQXJyYXknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm1zIHRoaXMgU2hhcmVkIFR5cGUgdG8gYSBKU09OIG9iamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9KU09OJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgICAgICAgaWYgKGMudG9KU09OICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjLnRvSlNPTigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYW4gQXJyYXkgd2l0aCB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBldmVyeVxuICAgICAgICogZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIEZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gZWxlbWVudCBvZiB0aGUgbmV3IEFycmF5XG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnQgYmVpbmcgdGhlIHJlc3VsdCBvZiB0aGVcbiAgICAgICAqICAgICAgICAgICAgICAgICBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdtYXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChmKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgcmVzLnB1c2goZihjLCBpLCBfdGhpczMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIG92ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZm9yRWFjaCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChmKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBuID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFuLl9kZWxldGVkICYmIG4uX2NvdW50YWJsZSkge1xuICAgICAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgICAgICAgIGYobiwgaW5kZXgrKywgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgY29udGVudCA9IG4uX2NvbnRlbnQ7XG4gICAgICAgICAgICAgIHZhciBjb250ZW50TGVuID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBmKGNvbnRlbnRbaV0sIGluZGV4LCB0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gbi5fcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgWUFycmF5LlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2l0ZW0gIT09IG51bGwgJiYgKHRoaXMuX2l0ZW0uX2RlbGV0ZWQgfHwgdGhpcy5faXRlbS5fbGVuZ3RoIDw9IHRoaXMuX2l0ZW1FbGVtZW50KSkge1xuICAgICAgICAgICAgICAvLyBpdGVtIGlzIGRlbGV0ZWQgb3IgaXRlbUVsZW1lbnQgZG9lcyBub3QgZXhpc3QgKGlzIGRlbGV0ZWQpXG4gICAgICAgICAgICAgIHRoaXMuX2l0ZW0gPSB0aGlzLl9pdGVtLl9yaWdodDtcbiAgICAgICAgICAgICAgdGhpcy5faXRlbUVsZW1lbnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtIGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5faXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLl9pdGVtLl9jb250ZW50W3RoaXMuX2l0ZW1FbGVtZW50KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGNvbnRlbnQsXG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgX2l0ZW06IHRoaXMuX3N0YXJ0LFxuICAgICAgICAgIF9pdGVtRWxlbWVudDogMCxcbiAgICAgICAgICBfY291bnQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGVzIGVsZW1lbnRzIHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZyBlbGVtZW50c1xuICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBsZW5ndGggVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlbGV0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShpbmRleCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuXG4gICAgICAgIHRoaXMuX3kudHJhbnNhY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpdGVtID0gX3RoaXM0Ll9zdGFydDtcbiAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgIHdoaWxlIChpdGVtICE9PSBudWxsICYmIGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghaXRlbS5fZGVsZXRlZCAmJiBpdGVtLl9jb3VudGFibGUpIHtcbiAgICAgICAgICAgICAgaWYgKGNvdW50IDw9IGluZGV4ICYmIGluZGV4IDwgY291bnQgKyBpdGVtLl9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZkRlbCA9IGluZGV4IC0gY291bnQ7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0uX3NwbGl0QXQoX3RoaXM0Ll95LCBkaWZmRGVsKTtcbiAgICAgICAgICAgICAgICBpdGVtLl9zcGxpdEF0KF90aGlzNC5feSwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZW5ndGggLT0gaXRlbS5fbGVuZ3RoO1xuICAgICAgICAgICAgICAgIGl0ZW0uX2RlbGV0ZShfdGhpczQuX3kpO1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IGRpZmZEZWw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gaXRlbS5fbGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5fcmlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbGV0ZSBleGNlZWRzIHRoZSByYW5nZSBvZiB0aGUgWUFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogSW5zZXJ0cyBjb250ZW50IGFmdGVyIGFuIGVsZW1lbnQgY29udGFpbmVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SXRlbX0gbGVmdCBUaGUgZWxlbWVudCBjb250YWluZXIgdG8gdXNlIGFzIGEgcmVmZXJlbmNlLlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gY29udGVudCBUaGUgQXJyYXkgb2YgY29udGVudCB0byBpbnNlcnQgKHNlZSB7QHNlZSBpbnNlcnR9KVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpbnNlcnRBZnRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIobGVmdCwgY29udGVudCkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICB0aGlzLl90cmFuc2FjdChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgIHZhciByaWdodCA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAobGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmlnaHQgPSBfdGhpczUuX3N0YXJ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByaWdodCA9IGxlZnQuX3JpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJldkpzb25JbnMgPSBudWxsO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjb250ZW50W2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGMgPSBuZXcgYygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgICAgICAgICBpZiAocHJldkpzb25JbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcHJldkpzb25JbnMuX2ludGVncmF0ZSh5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVmdCA9IHByZXZKc29uSW5zO1xuICAgICAgICAgICAgICAgIHByZXZKc29uSW5zID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjLl9vcmlnaW4gPSBsZWZ0O1xuICAgICAgICAgICAgICBjLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgICAgYy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgICAgYy5fcmlnaHRfb3JpZ2luID0gcmlnaHQ7XG4gICAgICAgICAgICAgIGMuX3BhcmVudCA9IF90aGlzNTtcbiAgICAgICAgICAgICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjLl9pbnRlZ3JhdGUoeSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzNS5fc3RhcnQgPSBjO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZnQuX3JpZ2h0ID0gYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZWZ0ID0gYztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2SnNvbklucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZXZKc29uSW5zID0gbmV3IEl0ZW1KU09OKCk7XG4gICAgICAgICAgICAgICAgcHJldkpzb25JbnMuX29yaWdpbiA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgcHJldkpzb25JbnMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIHByZXZKc29uSW5zLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIHByZXZKc29uSW5zLl9yaWdodF9vcmlnaW4gPSByaWdodDtcbiAgICAgICAgICAgICAgICBwcmV2SnNvbklucy5fcGFyZW50ID0gX3RoaXM1O1xuICAgICAgICAgICAgICAgIHByZXZKc29uSW5zLl9jb250ZW50ID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJldkpzb25JbnMuX2NvbnRlbnQucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZKc29uSW5zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2SnNvbklucy5faW50ZWdyYXRlKHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2SnNvbklucy5fbGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBfdGhpczUuX3N0YXJ0ID0gcHJldkpzb25JbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0cyBuZXcgY29udGVudCBhdCBhbiBpbmRleC5cbiAgICAgICAqXG4gICAgICAgKiBJbXBvcnRhbnQ6IFRoaXMgZnVuY3Rpb24gZXhwZWN0cyBhbiBhcnJheSBvZiBjb250ZW50LiBOb3QganVzdCBhIGNvbnRlbnRcbiAgICAgICAqIG9iamVjdC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBcIndlaXJkbmVzc1wiIGlzIHRoYXQgaW5zZXJ0aW5nIHNldmVyYWwgZWxlbWVudHNcbiAgICAgICAqIGlzIHZlcnkgZWZmaWNpZW50IHdoZW4gaXQgaXMgZG9uZSBhcyBhIHNpbmdsZSBvcGVyYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAgICAgKiAgeWFycmF5Lmluc2VydCgwLCBbJ2EnXSlcbiAgICAgICAqICAvLyBJbnNlcnQgbnVtYmVycyAxLCAyIGF0IHBvc2l0aW9uIDFcbiAgICAgICAqICB5YXJyYXkuaW5zZXJ0KDIsIFsxLCAyXSlcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdC5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRlbnQgVGhlIGFycmF5IG9mIGNvbnRlbnRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaW5zZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnQoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNhY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBsZWZ0ID0gbnVsbDtcbiAgICAgICAgICB2YXIgcmlnaHQgPSBfdGhpczYuX3N0YXJ0O1xuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgdmFyIHkgPSBfdGhpczYuX3k7XG4gICAgICAgICAgd2hpbGUgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmlnaHRMZW4gPSByaWdodC5fZGVsZXRlZCA/IDAgOiByaWdodC5fbGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChjb3VudCA8PSBpbmRleCAmJiBpbmRleCA8PSBjb3VudCArIHJpZ2h0TGVuKSB7XG4gICAgICAgICAgICAgIHZhciBzcGxpdERpZmYgPSBpbmRleCAtIGNvdW50O1xuICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0Ll9zcGxpdEF0KHksIHNwbGl0RGlmZik7XG4gICAgICAgICAgICAgIGxlZnQgPSByaWdodC5fbGVmdDtcbiAgICAgICAgICAgICAgY291bnQgKz0gc3BsaXREaWZmO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmlnaHQuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgY291bnQgKz0gcmlnaHQuX2xlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuX3JpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXggPiBjb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBleGNlZWRzIGFycmF5IHJhbmdlIScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczYuaW5zZXJ0QWZ0ZXIobGVmdCwgY29udGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gYXBwZW5kLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdwdXNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9zdGFydDtcbiAgICAgICAgdmFyIGxhc3RVbmRlbGV0ZWQgPSBudWxsO1xuICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghbi5fZGVsZXRlZCkge1xuICAgICAgICAgICAgbGFzdFVuZGVsZXRlZCA9IG47XG4gICAgICAgICAgfVxuICAgICAgICAgIG4gPSBuLl9yaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluc2VydEFmdGVyKGxhc3RVbmRlbGV0ZWQsIGNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aGlzIFlYbWwgVHlwZSB0byBhIHJlYWRhYmxlIGZvcm1hdC5cbiAgICAgICAqIFVzZWZ1bCBmb3IgbG9nZ2luZyBhcyBhbGwgSXRlbXMgYW5kIERlbGV0ZSBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2xvZ1N0cmluZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGxvZ0l0ZW1IZWxwZXIoJ1lBcnJheScsIHRoaXMsICdzdGFydDonICsgbG9nSUQodGhpcy5fc3RhcnQpICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbGVuZ3RoJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9zdGFydDtcbiAgICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIW4uX2RlbGV0ZWQgJiYgbi5fY291bnRhYmxlKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gbi5fbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gbi5fcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFlBcnJheTtcbiAgfShUeXBlKTtcblxuICAvKipcbiAgICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZTWFwLlxuICAgKlxuICAgKiBAcGFyYW0ge1lNYXB9IHltYXAgVGhlIFlBcnJheSB0aGF0IGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7U2V0PGFueT59IHN1YnMgVGhlIGtleXMgdGhhdCBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbW90ZSBXaGV0aGVyIHRoZSBjaGFuZ2Ugd2FzIGNyZWF0ZWQgYnkgYSByZW1vdGUgcGVlci5cbiAgICovXG4gIHZhciBZTWFwRXZlbnQgPSBmdW5jdGlvbiAoX1lFdmVudCkge1xuICAgIGluaGVyaXRzKFlNYXBFdmVudCwgX1lFdmVudCk7XG5cbiAgICBmdW5jdGlvbiBZTWFwRXZlbnQoeW1hcCwgc3VicywgcmVtb3RlKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBZTWFwRXZlbnQpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChZTWFwRXZlbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZTWFwRXZlbnQpKS5jYWxsKHRoaXMsIHltYXApKTtcblxuICAgICAgX3RoaXMua2V5c0NoYW5nZWQgPSBzdWJzO1xuICAgICAgX3RoaXMucmVtb3RlID0gcmVtb3RlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBZTWFwRXZlbnQ7XG4gIH0oWUV2ZW50KTtcblxuICAvKipcbiAgICogQSBzaGFyZWQgTWFwIGltcGxlbWVudGF0aW9uLlxuICAgKi9cblxuICB2YXIgWU1hcCA9IGZ1bmN0aW9uIChfVHlwZSkge1xuICAgIGluaGVyaXRzKFlNYXAsIF9UeXBlKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQ3JlYXRlcyBZTWFwIEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gWU1hcCgpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFlNYXApO1xuXG4gICAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoWU1hcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlNYXApKS5jYWxsKHRoaXMpKTtcblxuICAgICAgY29uc29sZS5sb2coX3RoaXMyKTtcbiAgICAgIGNvbnNvbGUubG9nKCdycnJycnJycnJycnJycnJycnJycnInKTtcbiAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoWU1hcCwgW3tcbiAgICAgIGtleTogJ19jYWxsT2JzZXJ2ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMsIHJlbW90ZSkge1xuICAgICAgICB0aGlzLl9jYWxsRXZlbnRIYW5kbGVyKHRyYW5zYWN0aW9uLCBuZXcgWU1hcEV2ZW50KHRoaXMsIHBhcmVudFN1YnMsIHJlbW90ZSkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybXMgdGhpcyBTaGFyZWQgVHlwZSB0byBhIEpTT04gb2JqZWN0LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9KU09OJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5fbWFwW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgaXRlbSA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICBpZiAoIWl0ZW0uX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHJlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9KU09OICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJlcyA9IGl0ZW0udG9KU09OKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlcyA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gaXRlbS5fY29udGVudFswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtYXBba2V5XSA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFlNYXAgVHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAna2V5cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIHJldHVybiBlaXRoZXIgSXRlcmF0b3Igb3IgU2V0IVxuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdGhpcy5fbWFwW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgIGtleSA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF9zdGVwMiR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZS5fZGVsZXRlZCkge1xuICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhpcyBZTWFwLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZW5jb2RhYmxlfSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlbGV0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNhY3QoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICB2YXIgYyA9IF90aGlzMy5fbWFwLmdldChrZXkpO1xuICAgICAgICAgIGlmICh5ICE9PSBudWxsICYmIGMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYy5fZGVsZXRlKHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZW5jb2RhYmxlfSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQgdG8gdGhpcyBZTWFwLlxuICAgICAgICogQHBhcmFtIHtlbmNvZGFibGUgfCBZVHlwZX0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGlzXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBZTWFwLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldCQkMShrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zYWN0KGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgdmFyIG9sZCA9IF90aGlzNC5fbWFwLmdldChrZXkpIHx8IG51bGw7XG4gICAgICAgICAgaWYgKG9sZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG9sZC5jb25zdHJ1Y3RvciA9PT0gSXRlbUpTT04gJiYgIW9sZC5fZGVsZXRlZCAmJiBvbGQuX2NvbnRlbnRbMF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIC8vIFRyeWluZyB0byBvdmVyd3JpdGUgd2l0aCBzYW1lIHZhbHVlXG4gICAgICAgICAgICAgIC8vIGJyZWFrIGhlcmVcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgb2xkLl9kZWxldGUoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2ID0gdm9pZCAwO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHYgPSBuZXcgdmFsdWUoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICAgICAgICB2YWx1ZSA9IHY7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEl0ZW0pIHtcbiAgICAgICAgICAgIHYgPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IG5ldyBJdGVtSlNPTigpO1xuICAgICAgICAgICAgdi5fY29udGVudCA9IFt2YWx1ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHYuX3JpZ2h0ID0gb2xkO1xuICAgICAgICAgIHYuX3JpZ2h0X29yaWdpbiA9IG9sZDtcbiAgICAgICAgICB2Ll9wYXJlbnQgPSBfdGhpczQ7XG4gICAgICAgICAgdi5fcGFyZW50U3ViID0ga2V5O1xuICAgICAgICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2Ll9pbnRlZ3JhdGUoeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzNC5fbWFwLnNldChrZXksIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGlzIFlNYXAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtlbmNvZGFibGV9IGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQkJDEoa2V5KSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHYuX2RlbGV0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2Ll9jb250ZW50W3YuX2NvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VuY29kYWJsZX0ga2V5IFRoZSBrZXkgdG8gdGVzdC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaGFzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHYuX2RlbGV0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gdGhpcyBZWG1sIFR5cGUgdG8gYSByZWFkYWJsZSBmb3JtYXQuXG4gICAgICAgKiBVc2VmdWwgZm9yIGxvZ2dpbmcgYXMgYWxsIEl0ZW1zIGFuZCBEZWxldGUgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sb2dTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2dTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBsb2dJdGVtSGVscGVyKCdZTWFwJywgdGhpcywgJ21hcFNpemU6JyArIHRoaXMuX21hcC5zaXplKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFlNYXA7XG4gIH0oVHlwZSk7XG5cbiAgdmFyIEl0ZW1FbWJlZCA9IGZ1bmN0aW9uIChfSXRlbSkge1xuICAgIGluaGVyaXRzKEl0ZW1FbWJlZCwgX0l0ZW0pO1xuXG4gICAgZnVuY3Rpb24gSXRlbUVtYmVkKCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSXRlbUVtYmVkKTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSXRlbUVtYmVkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRlbUVtYmVkKSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgIF90aGlzLmVtYmVkID0gbnVsbDtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhJdGVtRW1iZWQsIFt7XG4gICAgICBrZXk6ICdfY29weScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvcHkodW5kZWxldGVDaGlsZHJlbiwgY29weVBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBzdHJ1Y3QgPSBnZXQoSXRlbUVtYmVkLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1FbWJlZC5wcm90b3R5cGUpLCAnX2NvcHknLCB0aGlzKS5jYWxsKHRoaXMsIHVuZGVsZXRlQ2hpbGRyZW4sIGNvcHlQb3NpdGlvbik7XG4gICAgICAgIHN0cnVjdC5lbWJlZCA9IHRoaXMuZW1iZWQ7XG4gICAgICAgIHJldHVybiBzdHJ1Y3Q7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2Zyb21CaW5hcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mcm9tQmluYXJ5KHksIGRlY29kZXIpIHtcbiAgICAgICAgdmFyIG1pc3NpbmcgPSBnZXQoSXRlbUVtYmVkLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1FbWJlZC5wcm90b3R5cGUpLCAnX2Zyb21CaW5hcnknLCB0aGlzKS5jYWxsKHRoaXMsIHksIGRlY29kZXIpO1xuICAgICAgICB0aGlzLmVtYmVkID0gSlNPTi5wYXJzZShkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ190b0JpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvQmluYXJ5KGVuY29kZXIpIHtcbiAgICAgICAgZ2V0KEl0ZW1FbWJlZC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGVtRW1iZWQucHJvdG90eXBlKSwgJ190b0JpbmFyeScsIHRoaXMpLmNhbGwodGhpcywgZW5jb2Rlcik7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJTdHJpbmcoSlNPTi5zdHJpbmdpZnkodGhpcy5lbWJlZCkpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gdGhpcyBZWG1sIFR5cGUgdG8gYSByZWFkYWJsZSBmb3JtYXQuXG4gICAgICAgKiBVc2VmdWwgZm9yIGxvZ2dpbmcgYXMgYWxsIEl0ZW1zIGFuZCBEZWxldGUgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sb2dTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2dTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBsb2dJdGVtSGVscGVyKCdJdGVtRW1iZWQnLCB0aGlzLCAnZW1iZWQ6JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZW1iZWQpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbGVuZ3RoJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEl0ZW1FbWJlZDtcbiAgfShJdGVtKTtcblxuICB2YXIgSXRlbUZvcm1hdCA9IGZ1bmN0aW9uIChfSXRlbSkge1xuICAgIGluaGVyaXRzKEl0ZW1Gb3JtYXQsIF9JdGVtKTtcblxuICAgIGZ1bmN0aW9uIEl0ZW1Gb3JtYXQoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJdGVtRm9ybWF0KTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSXRlbUZvcm1hdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1Gb3JtYXQpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgX3RoaXMua2V5ID0gbnVsbDtcbiAgICAgIF90aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhJdGVtRm9ybWF0LCBbe1xuICAgICAga2V5OiAnX2NvcHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb3B5KHVuZGVsZXRlQ2hpbGRyZW4sIGNvcHlQb3NpdGlvbikge1xuICAgICAgICB2YXIgc3RydWN0ID0gZ2V0KEl0ZW1Gb3JtYXQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRlbUZvcm1hdC5wcm90b3R5cGUpLCAnX2NvcHknLCB0aGlzKS5jYWxsKHRoaXMsIHVuZGVsZXRlQ2hpbGRyZW4sIGNvcHlQb3NpdGlvbik7XG4gICAgICAgIHN0cnVjdC5rZXkgPSB0aGlzLmtleTtcbiAgICAgICAgc3RydWN0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZnJvbUJpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zyb21CaW5hcnkoeSwgZGVjb2Rlcikge1xuICAgICAgICB2YXIgbWlzc2luZyA9IGdldChJdGVtRm9ybWF0LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1Gb3JtYXQucHJvdG90eXBlKSwgJ19mcm9tQmluYXJ5JywgdGhpcykuY2FsbCh0aGlzLCB5LCBkZWNvZGVyKTtcbiAgICAgICAgdGhpcy5rZXkgPSBkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IEpTT04ucGFyc2UoZGVjb2Rlci5yZWFkVmFyU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gbWlzc2luZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdG9CaW5hcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90b0JpbmFyeShlbmNvZGVyKSB7XG4gICAgICAgIGdldChJdGVtRm9ybWF0LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1Gb3JtYXQucHJvdG90eXBlKSwgJ190b0JpbmFyeScsIHRoaXMpLmNhbGwodGhpcywgZW5jb2Rlcik7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJTdHJpbmcodGhpcy5rZXkpO1xuICAgICAgICBlbmNvZGVyLndyaXRlVmFyU3RyaW5nKEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIHRoaXMgWVhtbCBUeXBlIHRvIGEgcmVhZGFibGUgZm9ybWF0LlxuICAgICAgICogVXNlZnVsIGZvciBsb2dnaW5nIGFzIGFsbCBJdGVtcyBhbmQgRGVsZXRlIGltcGxlbWVudCB0aGlzIG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbG9nU3RyaW5nJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9nU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gbG9nSXRlbUhlbHBlcignSXRlbUZvcm1hdCcsIHRoaXMsICdrZXk6JyArIEpTT04uc3RyaW5naWZ5KHRoaXMua2V5KSArICcsdmFsdWU6JyArIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbGVuZ3RoJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY291bnRhYmxlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBJdGVtRm9ybWF0O1xuICB9KEl0ZW0pO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaW50ZWdyYXRlSXRlbShpdGVtLCBwYXJlbnQsIHksIGxlZnQsIHJpZ2h0KSB7XG4gICAgaXRlbS5fb3JpZ2luID0gbGVmdDtcbiAgICBpdGVtLl9sZWZ0ID0gbGVmdDtcbiAgICBpdGVtLl9yaWdodCA9IHJpZ2h0O1xuICAgIGl0ZW0uX3JpZ2h0X29yaWdpbiA9IHJpZ2h0O1xuICAgIGl0ZW0uX3BhcmVudCA9IHBhcmVudDtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgaXRlbS5faW50ZWdyYXRlKHkpO1xuICAgIH0gZWxzZSBpZiAobGVmdCA9PT0gbnVsbCkge1xuICAgICAgcGFyZW50Ll9zdGFydCA9IGl0ZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQuX3JpZ2h0ID0gaXRlbTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmROZXh0UG9zaXRpb24oY3VycmVudEF0dHJpYnV0ZXMsIHBhcmVudCwgbGVmdCwgcmlnaHQsIGNvdW50KSB7XG4gICAgd2hpbGUgKHJpZ2h0ICE9PSBudWxsICYmIGNvdW50ID4gMCkge1xuICAgICAgc3dpdGNoIChyaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIEl0ZW1FbWJlZDpcbiAgICAgICAgY2FzZSBJdGVtU3RyaW5nOlxuICAgICAgICAgIHZhciByaWdodExlbiA9IHJpZ2h0Ll9kZWxldGVkID8gMCA6IHJpZ2h0Ll9sZW5ndGggLSAxO1xuICAgICAgICAgIGlmIChjb3VudCA8PSByaWdodExlbikge1xuICAgICAgICAgICAgcmlnaHQgPSByaWdodC5fc3BsaXRBdChwYXJlbnQuX3ksIGNvdW50KTtcbiAgICAgICAgICAgIGxlZnQgPSByaWdodC5fbGVmdDtcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHQsIGN1cnJlbnRBdHRyaWJ1dGVzXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJpZ2h0Ll9kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY291bnQgLT0gcmlnaHQuX2xlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSXRlbUZvcm1hdDpcbiAgICAgICAgICBpZiAocmlnaHQuX2RlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgcmlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gcmlnaHQuX3JpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gW2xlZnQsIHJpZ2h0LCBjdXJyZW50QXR0cmlidXRlc107XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRQb3NpdGlvbihwYXJlbnQsIGluZGV4KSB7XG4gICAgdmFyIGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgIHZhciBsZWZ0ID0gbnVsbDtcbiAgICB2YXIgcmlnaHQgPSBwYXJlbnQuX3N0YXJ0O1xuICAgIHJldHVybiBmaW5kTmV4dFBvc2l0aW9uKGN1cnJlbnRBdHRyaWJ1dGVzLCBwYXJlbnQsIGxlZnQsIHJpZ2h0LCBpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogTmVnYXRlIGFwcGxpZWQgZm9ybWF0c1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXMoeSwgcGFyZW50LCBsZWZ0LCByaWdodCwgbmVnYXRlZEF0dHJpYnV0ZXMpIHtcbiAgICAvLyBjaGVjayBpZiB3ZSByZWFsbHkgbmVlZCB0byByZW1vdmUgYXR0cmlidXRlc1xuICAgIHdoaWxlIChyaWdodCAhPT0gbnVsbCAmJiAocmlnaHQuX2RlbGV0ZWQgPT09IHRydWUgfHwgcmlnaHQuY29uc3RydWN0b3IgPT09IEl0ZW1Gb3JtYXQgJiYgbmVnYXRlZEF0dHJpYnV0ZXMuZ2V0KHJpZ2h0LmtleSkgPT09IHJpZ2h0LnZhbHVlKSkge1xuICAgICAgaWYgKHJpZ2h0Ll9kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5kZWxldGUocmlnaHQua2V5KTtcbiAgICAgIH1cbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gcmlnaHQuX3JpZ2h0O1xuICAgIH1cbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG5lZ2F0ZWRBdHRyaWJ1dGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBzbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgdmFsID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgICAgdmFyIGZvcm1hdCA9IG5ldyBJdGVtRm9ybWF0KCk7XG4gICAgICAgIGZvcm1hdC5rZXkgPSBrZXk7XG4gICAgICAgIGZvcm1hdC52YWx1ZSA9IHZhbDtcbiAgICAgICAgaW50ZWdyYXRlSXRlbShmb3JtYXQsIHBhcmVudCwgeSwgbGVmdCwgcmlnaHQpO1xuICAgICAgICBsZWZ0ID0gZm9ybWF0O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgaXRlbSkge1xuICAgIHZhciB2YWx1ZSA9IGl0ZW0udmFsdWU7XG4gICAgdmFyIGtleSA9IGl0ZW0ua2V5O1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpIHtcbiAgICAvLyBnbyByaWdodCB3aGlsZSBhdHRyaWJ1dGVzW3JpZ2h0LmtleV0gPT09IHJpZ2h0LnZhbHVlIChvciByaWdodCBpcyBkZWxldGVkKVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAocmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHJpZ2h0Ll9kZWxldGVkID09PSB0cnVlKSA7IGVsc2UgaWYgKHJpZ2h0LmNvbnN0cnVjdG9yID09PSBJdGVtRm9ybWF0ICYmIChhdHRyaWJ1dGVzW3JpZ2h0LmtleV0gfHwgbnVsbCkgPT09IHJpZ2h0LnZhbHVlKSB7XG4gICAgICAgIC8vIGZvdW5kIGEgZm9ybWF0LCB1cGRhdGUgY3VycmVudEF0dHJpYnV0ZXMgYW5kIGNvbnRpbnVlXG4gICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCByaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gcmlnaHQuX3JpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0QXR0cmlidXRlcyh5LCBwYXJlbnQsIGxlZnQsIHJpZ2h0LCBhdHRyaWJ1dGVzLCBjdXJyZW50QXR0cmlidXRlcykge1xuICAgIHZhciBuZWdhdGVkQXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICAvLyBpbnNlcnQgZm9ybWF0LXN0YXJ0IGl0ZW1zXG4gICAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIHZhciB2YWwgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICB2YXIgY3VycmVudFZhbCA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpO1xuICAgICAgaWYgKGN1cnJlbnRWYWwgIT09IHZhbCkge1xuICAgICAgICAvLyBzYXZlIG5lZ2F0ZWQgYXR0cmlidXRlIChzZXQgbnVsbCBpZiBjdXJyZW50VmFsIHVuZGVmaW5lZClcbiAgICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuc2V0KGtleSwgY3VycmVudFZhbCB8fCBudWxsKTtcbiAgICAgICAgdmFyIGZvcm1hdCA9IG5ldyBJdGVtRm9ybWF0KCk7XG4gICAgICAgIGZvcm1hdC5rZXkgPSBrZXk7XG4gICAgICAgIGZvcm1hdC52YWx1ZSA9IHZhbDtcbiAgICAgICAgaW50ZWdyYXRlSXRlbShmb3JtYXQsIHBhcmVudCwgeSwgbGVmdCwgcmlnaHQpO1xuICAgICAgICBsZWZ0ID0gZm9ybWF0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2xlZnQsIHJpZ2h0LCBuZWdhdGVkQXR0cmlidXRlc107XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydFRleHQoeSwgdGV4dCwgcGFyZW50LCBsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBjdXJyZW50QXR0cmlidXRlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDEpLFxuICAgICAgICAgICAga2V5ID0gX3N0ZXAyJHZhbHVlWzBdO1xuXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9taW5pbWl6ZUF0dHJpYnV0ZUNoYSA9IG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgdmFyIF9taW5pbWl6ZUF0dHJpYnV0ZUNoYTIgPSBzbGljZWRUb0FycmF5KF9taW5pbWl6ZUF0dHJpYnV0ZUNoYSwgMik7XG5cbiAgICBsZWZ0ID0gX21pbmltaXplQXR0cmlidXRlQ2hhMlswXTtcbiAgICByaWdodCA9IF9taW5pbWl6ZUF0dHJpYnV0ZUNoYTJbMV07XG5cbiAgICB2YXIgbmVnYXRlZEF0dHJpYnV0ZXMgPSB2b2lkIDA7XG5cbiAgICAvLyBpbnNlcnQgY29udGVudFxuICAgIHZhciBfaW5zZXJ0QXR0cmlidXRlcyA9IGluc2VydEF0dHJpYnV0ZXMoeSwgcGFyZW50LCBsZWZ0LCByaWdodCwgYXR0cmlidXRlcywgY3VycmVudEF0dHJpYnV0ZXMpO1xuXG4gICAgdmFyIF9pbnNlcnRBdHRyaWJ1dGVzMiA9IHNsaWNlZFRvQXJyYXkoX2luc2VydEF0dHJpYnV0ZXMsIDMpO1xuXG4gICAgbGVmdCA9IF9pbnNlcnRBdHRyaWJ1dGVzMlswXTtcbiAgICByaWdodCA9IF9pbnNlcnRBdHRyaWJ1dGVzMlsxXTtcbiAgICBuZWdhdGVkQXR0cmlidXRlcyA9IF9pbnNlcnRBdHRyaWJ1dGVzMlsyXTtcbiAgICB2YXIgaXRlbSA9IHZvaWQgMDtcbiAgICBpZiAodGV4dC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICBpdGVtID0gbmV3IEl0ZW1TdHJpbmcoKTtcbiAgICAgIGl0ZW0uX2NvbnRlbnQgPSB0ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtID0gbmV3IEl0ZW1FbWJlZCgpO1xuICAgICAgaXRlbS5lbWJlZCA9IHRleHQ7XG4gICAgfVxuICAgIGludGVncmF0ZUl0ZW0oaXRlbSwgcGFyZW50LCB5LCBsZWZ0LCByaWdodCk7XG4gICAgbGVmdCA9IGl0ZW07XG4gICAgcmV0dXJuIGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzKHksIHBhcmVudCwgbGVmdCwgcmlnaHQsIG5lZ2F0ZWRBdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZm9ybWF0VGV4dCh5LCBsZW5ndGgsIHBhcmVudCwgbGVmdCwgcmlnaHQsIGN1cnJlbnRBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIF9taW5pbWl6ZUF0dHJpYnV0ZUNoYTMgPSBtaW5pbWl6ZUF0dHJpYnV0ZUNoYW5nZXMobGVmdCwgcmlnaHQsIGN1cnJlbnRBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcblxuICAgIHZhciBfbWluaW1pemVBdHRyaWJ1dGVDaGE0ID0gc2xpY2VkVG9BcnJheShfbWluaW1pemVBdHRyaWJ1dGVDaGEzLCAyKTtcblxuICAgIGxlZnQgPSBfbWluaW1pemVBdHRyaWJ1dGVDaGE0WzBdO1xuICAgIHJpZ2h0ID0gX21pbmltaXplQXR0cmlidXRlQ2hhNFsxXTtcblxuICAgIHZhciBuZWdhdGVkQXR0cmlidXRlcyA9IHZvaWQgMDtcblxuICAgIC8vIGl0ZXJhdGUgdW50aWwgZmlyc3Qgbm9uLWZvcm1hdCBvciBudWxsIGlzIGZvdW5kXG4gICAgLy8gZGVsZXRlIGFsbCBmb3JtYXRzIHdpdGggYXR0cmlidXRlc1tmb3JtYXQua2V5XSAhPSBudWxsXG4gICAgdmFyIF9pbnNlcnRBdHRyaWJ1dGVzMyA9IGluc2VydEF0dHJpYnV0ZXMoeSwgcGFyZW50LCBsZWZ0LCByaWdodCwgYXR0cmlidXRlcywgY3VycmVudEF0dHJpYnV0ZXMpO1xuXG4gICAgdmFyIF9pbnNlcnRBdHRyaWJ1dGVzNCA9IHNsaWNlZFRvQXJyYXkoX2luc2VydEF0dHJpYnV0ZXMzLCAzKTtcblxuICAgIGxlZnQgPSBfaW5zZXJ0QXR0cmlidXRlczRbMF07XG4gICAgcmlnaHQgPSBfaW5zZXJ0QXR0cmlidXRlczRbMV07XG4gICAgbmVnYXRlZEF0dHJpYnV0ZXMgPSBfaW5zZXJ0QXR0cmlidXRlczRbMl07XG4gICAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgcmlnaHQgIT09IG51bGwpIHtcbiAgICAgIGlmIChyaWdodC5fZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3dpdGNoIChyaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIGNhc2UgSXRlbUZvcm1hdDpcbiAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tyaWdodC5rZXldO1xuICAgICAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoYXR0ciA9PT0gcmlnaHQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5kZWxldGUocmlnaHQua2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5zZXQocmlnaHQua2V5LCByaWdodC52YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmlnaHQuX2RlbGV0ZSh5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCByaWdodCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEl0ZW1FbWJlZDpcbiAgICAgICAgICBjYXNlIEl0ZW1TdHJpbmc6XG4gICAgICAgICAgICByaWdodC5fc3BsaXRBdCh5LCBsZW5ndGgpO1xuICAgICAgICAgICAgbGVuZ3RoIC09IHJpZ2h0Ll9sZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgcmlnaHQgPSByaWdodC5fcmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBpbnNlcnROZWdhdGVkQXR0cmlidXRlcyh5LCBwYXJlbnQsIGxlZnQsIHJpZ2h0LCBuZWdhdGVkQXR0cmlidXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGRlbGV0ZVRleHQoeSwgbGVuZ3RoLCBwYXJlbnQsIGxlZnQsIHJpZ2h0LCBjdXJyZW50QXR0cmlidXRlcykge1xuICAgIHdoaWxlIChsZW5ndGggPiAwICYmIHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICBpZiAocmlnaHQuX2RlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHN3aXRjaCAocmlnaHQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICBjYXNlIEl0ZW1Gb3JtYXQ6XG4gICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgcmlnaHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBJdGVtRW1iZWQ6XG4gICAgICAgICAgY2FzZSBJdGVtU3RyaW5nOlxuICAgICAgICAgICAgcmlnaHQuX3NwbGl0QXQoeSwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGxlbmd0aCAtPSByaWdodC5fbGVuZ3RoO1xuICAgICAgICAgICAgcmlnaHQuX2RlbGV0ZSh5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICByaWdodCA9IHJpZ2h0Ll9yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gIH1cblxuICAvLyBUT0RPOiBJbiB0aGUgcXVpbGwgZGVsdGEgcmVwcmVzZW50YXRpb24gd2Ugc2hvdWxkIGFsc28gdXNlIHRoZSBmb3JtYXQge29wczpbLi5dfVxuICAvKipcbiAgICogVGhlIFF1aWxsIERlbHRhIGZvcm1hdCByZXByZXNlbnRzIGNoYW5nZXMgb24gYSB0ZXh0IGRvY3VtZW50IHdpdGhcbiAgICogZm9ybWF0dGluZyBpbmZvcm1hdGlvbi4gRm9yIG1vciBpbmZvcm1hdGlvbiB2aXNpdCB7QGxpbmsgaHR0cHM6Ly9xdWlsbGpzLmNvbS9kb2NzL2RlbHRhL3xRdWlsbCBEZWx0YX1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICB7XG4gICAqICAgICBvcHM6IFtcbiAgICogICAgICAgeyBpbnNlcnQ6ICdHYW5kYWxmJywgYXR0cmlidXRlczogeyBib2xkOiB0cnVlIH0gfSxcbiAgICogICAgICAgeyBpbnNlcnQ6ICcgdGhlICcgfSxcbiAgICogICAgICAgeyBpbnNlcnQ6ICdHcmV5JywgYXR0cmlidXRlczogeyBjb2xvcjogJyNjY2NjY2MnIH0gfVxuICAgKiAgICAgXVxuICAgKiAgIH1cbiAgICpcbiAgICogQHR5cGVkZWYge0FycmF5PE9iamVjdD59IERlbHRhXG4gICAqL1xuXG4gIC8qKlxuICAgICogQXR0cmlidXRlcyB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byBhIHNlbGVjdGlvbiBvZiB0ZXh0LlxuICAgICpcbiAgICAqIEBleGFtcGxlXG4gICAgKiAgIHtcbiAgICAqICAgICBib2xkOiB0cnVlLFxuICAgICogICAgIGZvbnQtc2l6ZTogJzQwcHgnXG4gICAgKiAgIH1cbiAgICAqXG4gICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0QXR0cmlidXRlc1xuICAgICovXG5cbiAgLyoqXG4gICAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmFyIFlUZXh0RXZlbnQgPSBmdW5jdGlvbiAoX1lBcnJheUV2ZW50KSB7XG4gICAgaW5oZXJpdHMoWVRleHRFdmVudCwgX1lBcnJheUV2ZW50KTtcblxuICAgIGZ1bmN0aW9uIFlUZXh0RXZlbnQoeXRleHQsIHJlbW90ZSwgdHJhbnNhY3Rpb24pIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFlUZXh0RXZlbnQpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChZVGV4dEV2ZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVRleHRFdmVudCkpLmNhbGwodGhpcywgeXRleHQsIHJlbW90ZSwgdHJhbnNhY3Rpb24pKTtcblxuICAgICAgX3RoaXMuX2RlbHRhID0gbnVsbDtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gVE9ETzogU2hvdWxkIHB1dCB0aGlzIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24uIHRvRGVsdGEgc2hvdWxkbid0IGJlIGluY2x1ZGVkXG4gICAgLy8gICAgICAgaW4gZXZlcnkgWWpzIGRpc3RyaWJ1dGlvblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGNoYW5nZXMgaW4gdGhlIGRlbHRhIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0RlbHRhfSBBIHtAbGluayBodHRwczovL3F1aWxsanMuY29tL2RvY3MvZGVsdGEvfFF1aWxsIERlbHRhfSkgdGhhdFxuICAgICAqICAgICAgICAgICAgICAgICByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG9uIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoWVRleHRFdmVudCwgW3tcbiAgICAgIGtleTogJ2RlbHRhJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5fZGVsdGEgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgeSA9IHRoaXMudGFyZ2V0Ll95O1xuICAgICAgICAgIHkudHJhbnNhY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBfdGhpczIudGFyZ2V0Ll9zdGFydDtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IFtdO1xuICAgICAgICAgICAgdmFyIGFkZGVkID0gX3RoaXMyLmFkZGVkRWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IF90aGlzMi5yZW1vdmVkRWxlbWVudHM7XG4gICAgICAgICAgICBfdGhpczIuX2RlbHRhID0gZGVsdGE7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307IC8vIGNvdW50cyBhZGRlZCBvciByZW1vdmVkIG5ldyBhdHRyaWJ1dGVzIGZvciByZXRhaW5cbiAgICAgICAgICAgIHZhciBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTsgLy8gc2F2ZXMgYWxsIGN1cnJlbnQgYXR0cmlidXRlcyBmb3IgaW5zZXJ0XG4gICAgICAgICAgICB2YXIgb2xkQXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHZhciBpbnNlcnQgPSAnJztcbiAgICAgICAgICAgIHZhciByZXRhaW4gPSAwO1xuICAgICAgICAgICAgdmFyIGRlbGV0ZUxlbiA9IDA7XG4gICAgICAgICAgICB2YXIgYWRkT3AgPSBmdW5jdGlvbiBhZGRPcCgpIHtcbiAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvcCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICAgICAgb3AgPSB7IGRlbGV0ZTogZGVsZXRlTGVuIH07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgICAgICAgICAgICAgICAgb3AgPSB7IGluc2VydDogaW5zZXJ0IH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBjdXJyZW50QXR0cmlidXRlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3N0ZXAzJHZhbHVlID0gc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gX3N0ZXAzJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfc3RlcDMkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3JldGFpbic6XG4gICAgICAgICAgICAgICAgICAgIG9wID0geyByZXRhaW46IHJldGFpbiB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlc1trZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXRhaW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsdGEucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgSXRlbUVtYmVkOlxuICAgICAgICAgICAgICAgICAgaWYgKGFkZGVkLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnaW5zZXJ0JztcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gaXRlbS5lbWJlZDtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVtb3ZlZC5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiArPSAxO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLl9kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ3JldGFpbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0YWluICs9IDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEl0ZW1TdHJpbmc6XG4gICAgICAgICAgICAgICAgICBpZiAoYWRkZWQuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnaW5zZXJ0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgKz0gaXRlbS5fY29udGVudDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVtb3ZlZC5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiArPSBpdGVtLl9sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uX2RlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSAncmV0YWluJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXRhaW4gKz0gaXRlbS5fbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBJdGVtRm9ybWF0OlxuICAgICAgICAgICAgICAgICAgaWYgKGFkZGVkLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyVmFsID0gY3VycmVudEF0dHJpYnV0ZXMuZ2V0KGl0ZW0ua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVmFsICE9PSBpdGVtLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnZhbHVlID09PSAob2xkQXR0cmlidXRlcy5nZXQoaXRlbS5rZXkpIHx8IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1tpdGVtLmtleV07XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbaXRlbS5rZXldID0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbS5fZGVsZXRlKHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlbW92ZWQuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGl0ZW0ua2V5LCBpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jdXJWYWwgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoaXRlbS5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfY3VyVmFsICE9PSBpdGVtLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbaXRlbS5rZXldID0gX2N1clZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLl9kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzLnNldChpdGVtLmtleSwgaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tpdGVtLmtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ciAhPT0gaXRlbS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbaXRlbS5rZXldID0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2l0ZW0ua2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5fZGVsZXRlKHkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uX2RlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgaXRlbSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpdGVtID0gaXRlbS5fcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgd2hpbGUgKF90aGlzMi5fZGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgbGFzdE9wID0gX3RoaXMyLl9kZWx0YVtfdGhpczIuX2RlbHRhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBpZiAobGFzdE9wLnJldGFpbiAhPT0gdW5kZWZpbmVkICYmIGxhc3RPcC5hdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXRhaW4gZGVsdGEncyBpZiB0aGV5IGRvbid0IGFzc2lnbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgX3RoaXMyLl9kZWx0YS5wb3AoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWx0YTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFlUZXh0RXZlbnQ7XG4gIH0oWUFycmF5RXZlbnQpO1xuXG4gIC8qKlxuICAgKiBUeXBlIHRoYXQgcmVwcmVzZW50cyB0ZXh0IHdpdGggZm9ybWF0dGluZyBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogVGhpcyB0eXBlIHJlcGxhY2VzIHktcmljaHRleHQgYXMgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhYmxlIHRvIGhhbmRsZVxuICAgKiBibG9jayBmb3JtYXRzIChmb3JtYXQgaW5mb3JtYXRpb24gb24gYSBwYXJhZ3JhcGgpLCBlbWJlZHMgKGNvbXBsZXggZWxlbWVudHNcbiAgICogbGlrZSBwaWN0dXJlcyBhbmQgdmlkZW9zKSwgYW5kIHRleHQgZm9ybWF0cyAoKipib2xkKiosICppdGFsaWMqKS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgWVRleHQuXG4gICAqL1xuXG5cbiAgdmFyIFlUZXh0ID0gZnVuY3Rpb24gKF9ZQXJyYXkpIHtcbiAgICBpbmhlcml0cyhZVGV4dCwgX1lBcnJheSk7XG5cbiAgICBmdW5jdGlvbiBZVGV4dChzdHJpbmcpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFlUZXh0KTtcblxuICAgICAgdmFyIF90aGlzMyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFlUZXh0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVRleHQpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBzdGFydCA9IG5ldyBJdGVtU3RyaW5nKCk7XG4gICAgICAgIHN0YXJ0Ll9wYXJlbnQgPSBfdGhpczM7XG4gICAgICAgIHN0YXJ0Ll9jb250ZW50ID0gc3RyaW5nO1xuICAgICAgICBfdGhpczMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXMzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQ3JlYXRlcyBZTWFwIEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAgICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKFlUZXh0LCBbe1xuICAgICAga2V5OiAnX2NhbGxPYnNlcnZlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgcGFyZW50U3VicywgcmVtb3RlKSB7XG4gICAgICAgIHRoaXMuX2NhbGxFdmVudEhhbmRsZXIodHJhbnNhY3Rpb24sIG5ldyBZVGV4dEV2ZW50KHRoaXMsIHJlbW90ZSwgdHJhbnNhY3Rpb24pKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIHZhciBuID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFuLl9kZWxldGVkICYmIG4uX2NvdW50YWJsZSkge1xuICAgICAgICAgICAgc3RyICs9IG4uX2NvbnRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG4gPSBuLl9yaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFwcGx5IGEge0BsaW5rIERlbHRhfSBvbiB0aGlzIHNoYXJlZCBZVGV4dCB0eXBlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RGVsdGF9IGRlbHRhIFRoZSBjaGFuZ2VzIHRvIGFwcGx5IG9uIHRoaXMgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FwcGx5RGVsdGEnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5RGVsdGEoZGVsdGEpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNhY3QoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IG51bGw7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gX3RoaXM0Ll9zdGFydDtcbiAgICAgICAgICB2YXIgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9wID0gZGVsdGFbaV07XG4gICAgICAgICAgICBpZiAob3AuaW5zZXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnNlcnRUZXh0ID0gaW5zZXJ0VGV4dCh5LCBvcC5pbnNlcnQsIF90aGlzNCwgbGVmdCwgcmlnaHQsIGN1cnJlbnRBdHRyaWJ1dGVzLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KTtcblxuICAgICAgICAgICAgICB2YXIgX2luc2VydFRleHQyID0gc2xpY2VkVG9BcnJheShfaW5zZXJ0VGV4dCwgMik7XG5cbiAgICAgICAgICAgICAgbGVmdCA9IF9pbnNlcnRUZXh0MlswXTtcbiAgICAgICAgICAgICAgcmlnaHQgPSBfaW5zZXJ0VGV4dDJbMV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wLnJldGFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBfZm9ybWF0VGV4dCA9IGZvcm1hdFRleHQoeSwgb3AucmV0YWluLCBfdGhpczQsIGxlZnQsIHJpZ2h0LCBjdXJyZW50QXR0cmlidXRlcywgb3AuYXR0cmlidXRlcyB8fCB7fSk7XG5cbiAgICAgICAgICAgICAgdmFyIF9mb3JtYXRUZXh0MiA9IHNsaWNlZFRvQXJyYXkoX2Zvcm1hdFRleHQsIDIpO1xuXG4gICAgICAgICAgICAgIGxlZnQgPSBfZm9ybWF0VGV4dDJbMF07XG4gICAgICAgICAgICAgIHJpZ2h0ID0gX2Zvcm1hdFRleHQyWzFdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcC5kZWxldGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgX2RlbGV0ZVRleHQgPSBkZWxldGVUZXh0KHksIG9wLmRlbGV0ZSwgX3RoaXM0LCBsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAgIHZhciBfZGVsZXRlVGV4dDIgPSBzbGljZWRUb0FycmF5KF9kZWxldGVUZXh0LCAyKTtcblxuICAgICAgICAgICAgICBsZWZ0ID0gX2RlbGV0ZVRleHQyWzBdO1xuICAgICAgICAgICAgICByaWdodCA9IF9kZWxldGVUZXh0MlsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIERlbHRhIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWVRleHQgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtEZWx0YX0gVGhlIERlbHRhIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3RvRGVsdGEnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRGVsdGEoKSB7XG4gICAgICAgIHZhciBvcHMgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIHZhciBuID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIGZ1bmN0aW9uIHBhY2tTdHIoKSB7XG4gICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBwYWNrIHN0ciB3aXRoIGF0dHJpYnV0ZXMgdG8gb3BzXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGFkZEF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gY3VycmVudEF0dHJpYnV0ZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gc2xpY2VkVG9BcnJheShfc3RlcDQudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBfc3RlcDQkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3N0ZXA0JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgICAgYWRkQXR0cmlidXRlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBlcnI7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9wID0geyBpbnNlcnQ6IHN0ciB9O1xuICAgICAgICAgICAgaWYgKGFkZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHMucHVzaChvcCk7XG4gICAgICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIW4uX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobi5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICBjYXNlIEl0ZW1TdHJpbmc6XG4gICAgICAgICAgICAgICAgc3RyICs9IG4uX2NvbnRlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSXRlbUZvcm1hdDpcbiAgICAgICAgICAgICAgICBwYWNrU3RyKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VycmVudEF0dHJpYnV0ZXMsIG4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gbi5fcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFja1N0cigpO1xuICAgICAgICByZXR1cm4gb3BzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCB0ZXh0IGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgaW5zZXJ0aW5nLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gaW5zZXJ0IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAgICAgKiBAcGFyYW0ge1RleHRBdHRyaWJ1dGVzfSBhdHRyaWJ1dGVzIE9wdGlvbmFsbHkgZGVmaW5lIHNvbWUgZm9ybWF0dGluZ1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvcm1hdGlvbiB0byBhcHBseSBvbiB0aGUgaW5zZXJ0ZWRcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2luc2VydCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0KGluZGV4LCB0ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgICBpZiAodGV4dC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2FjdChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgIHZhciBfZmluZFBvc2l0aW9uID0gZmluZFBvc2l0aW9uKF90aGlzNSwgaW5kZXgpLFxuICAgICAgICAgICAgICBfZmluZFBvc2l0aW9uMiA9IHNsaWNlZFRvQXJyYXkoX2ZpbmRQb3NpdGlvbiwgMyksXG4gICAgICAgICAgICAgIGxlZnQgPSBfZmluZFBvc2l0aW9uMlswXSxcbiAgICAgICAgICAgICAgcmlnaHQgPSBfZmluZFBvc2l0aW9uMlsxXSxcbiAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMgPSBfZmluZFBvc2l0aW9uMlsyXTtcblxuICAgICAgICAgIGluc2VydFRleHQoeSwgdGV4dCwgX3RoaXM1LCBsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbnNlcnRzIGFuIGVtYmVkIGF0IGEgaW5kZXguXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IHRoZSBlbWJlZCBhdC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbWJlZCBUaGUgT2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZW1iZWQuXG4gICAgICAgKiBAcGFyYW0ge1RleHRBdHRyaWJ1dGVzfSBhdHRyaWJ1dGVzIEF0dHJpYnV0ZSBpbmZvcm1hdGlvbiB0byBhcHBseSBvbiB0aGVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1iZWRcbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2luc2VydEVtYmVkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRFbWJlZChpbmRleCwgZW1iZWQpIHtcbiAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICAgIGlmIChlbWJlZC5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbWJlZCBtdXN0IGJlIGFuIE9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0KGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgdmFyIF9maW5kUG9zaXRpb24zID0gZmluZFBvc2l0aW9uKF90aGlzNiwgaW5kZXgpLFxuICAgICAgICAgICAgICBfZmluZFBvc2l0aW9uNCA9IHNsaWNlZFRvQXJyYXkoX2ZpbmRQb3NpdGlvbjMsIDMpLFxuICAgICAgICAgICAgICBsZWZ0ID0gX2ZpbmRQb3NpdGlvbjRbMF0sXG4gICAgICAgICAgICAgIHJpZ2h0ID0gX2ZpbmRQb3NpdGlvbjRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzID0gX2ZpbmRQb3NpdGlvbjRbMl07XG5cbiAgICAgICAgICBpbnNlcnRUZXh0KHksIGVtYmVkLCBfdGhpczYsIGxlZnQsIHJpZ2h0LCBjdXJyZW50QXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlbGV0ZXMgdGV4dCBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcuXG4gICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVsZXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2FjdChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgIHZhciBfZmluZFBvc2l0aW9uNSA9IGZpbmRQb3NpdGlvbihfdGhpczcsIGluZGV4KSxcbiAgICAgICAgICAgICAgX2ZpbmRQb3NpdGlvbjYgPSBzbGljZWRUb0FycmF5KF9maW5kUG9zaXRpb241LCAzKSxcbiAgICAgICAgICAgICAgbGVmdCA9IF9maW5kUG9zaXRpb242WzBdLFxuICAgICAgICAgICAgICByaWdodCA9IF9maW5kUG9zaXRpb242WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcyA9IF9maW5kUG9zaXRpb242WzJdO1xuXG4gICAgICAgICAgZGVsZXRlVGV4dCh5LCBsZW5ndGgsIF90aGlzNywgbGVmdCwgcmlnaHQsIGN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQXNzaWducyBwcm9wZXJ0aWVzIHRvIGEgcmFuZ2Ugb2YgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB3aGVyZSB0byBzdGFydCBmb3JtYXR0aW5nLlxuICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBsZW5ndGggVGhlIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvLlxuICAgICAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gYXR0cmlidXRlcyBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmb3JtYXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChpbmRleCwgbGVuZ3RoLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zYWN0KGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgdmFyIF9maW5kUG9zaXRpb243ID0gZmluZFBvc2l0aW9uKF90aGlzOCwgaW5kZXgpLFxuICAgICAgICAgICAgICBfZmluZFBvc2l0aW9uOCA9IHNsaWNlZFRvQXJyYXkoX2ZpbmRQb3NpdGlvbjcsIDMpLFxuICAgICAgICAgICAgICBsZWZ0ID0gX2ZpbmRQb3NpdGlvbjhbMF0sXG4gICAgICAgICAgICAgIHJpZ2h0ID0gX2ZpbmRQb3NpdGlvbjhbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzID0gX2ZpbmRQb3NpdGlvbjhbMl07XG5cbiAgICAgICAgICBpZiAocmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9ybWF0VGV4dCh5LCBsZW5ndGgsIF90aGlzOCwgbGVmdCwgcmlnaHQsIGN1cnJlbnRBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBEZS1kdXBsaWNhdGUgY29kZS4gVGhlIGZvbGxvd2luZyBjb2RlIGlzIGluIGV2ZXJ5IHR5cGUuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aGlzIFlUZXh0IHRvIGEgcmVhZGFibGUgZm9ybWF0LlxuICAgICAgICogVXNlZnVsIGZvciBsb2dnaW5nIGFzIGFsbCBJdGVtcyBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2xvZ1N0cmluZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGxvZ0l0ZW1IZWxwZXIoJ1lUZXh0JywgdGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBZVGV4dDtcbiAgfShZQXJyYXkpO1xuXG4gIC8qKlxuICAgKiBZb3UgY2FuIG1hbmFnZSBiaW5kaW5nIHRvIGEgY3VzdG9tIHR5cGUgd2l0aCBZWG1sSG9vay5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cblxuICB2YXIgWVhtbEhvb2sgPSBmdW5jdGlvbiAoX1lNYXApIHtcbiAgICBpbmhlcml0cyhZWG1sSG9vaywgX1lNYXApO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhvb2tOYW1lIG5vZGVOYW1lIG9mIHRoZSBEb20gTm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBZWG1sSG9vayhob29rTmFtZSkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWVhtbEhvb2spO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChZWG1sSG9vay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxIb29rKSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgIF90aGlzLmhvb2tOYW1lID0gbnVsbDtcbiAgICAgIGlmIChob29rTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF90aGlzLmhvb2tOYW1lID0gaG9va05hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBJdGVtIHdpdGggdGhlIHNhbWUgZWZmZWN0IGFzIHRoaXMgSXRlbSAod2l0aG91dCBwb3NpdGlvbiBlZmZlY3QpXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhZWG1sSG9vaywgW3tcbiAgICAgIGtleTogJ19jb3B5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29weSgpIHtcbiAgICAgICAgdmFyIHN0cnVjdCA9IGdldChZWG1sSG9vay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZWG1sSG9vay5wcm90b3R5cGUpLCAnX2NvcHknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICBzdHJ1Y3QuaG9va05hbWUgPSB0aGlzLmhvb2tOYW1lO1xuICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAgICAgKiBAcGFyYW0ge09iamVjdDxrZXk6aG9va0RlZmluaXRpb24+fSBbaG9va3NdIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAgICAgKiBAcGFyYW0ge0RvbUJpbmRpbmd9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZVxuICAgICAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3RvRG9tJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0RvbSgpIHtcblxuICAgICAgICB2YXIgaG9va3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICB2YXIgYmluZGluZyA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgICB2YXIgaG9vayA9IGhvb2tzW3RoaXMuaG9va05hbWVdO1xuICAgICAgICB2YXIgZG9tID0gdm9pZCAwO1xuICAgICAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZG9tID0gaG9vay5jcmVhdGVEb20odGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmhvb2tOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLXlqcy1ob29rJywgdGhpcy5ob29rTmFtZSk7XG4gICAgICAgIGNyZWF0ZUFzc29jaWF0aW9uKGJpbmRpbmcsIGRvbSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVhZCB0aGUgbmV4dCBJdGVtIGluIGEgRGVjb2RlciBhbmQgZmlsbCB0aGlzIEl0ZW0gd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gZGF0YSBpcyByZWNlaXZlZCBmcm9tIGEgcmVtb3RlIHBlZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2UgdGhhdCB0aGlzIEl0ZW0gYmVsb25ncyB0by5cbiAgICAgICAqIEBwYXJhbSB7QmluYXJ5RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBvYmplY3QgdG8gcmVhZCBkYXRhIGZyb20uXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2Zyb21CaW5hcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mcm9tQmluYXJ5KHksIGRlY29kZXIpIHtcbiAgICAgICAgdmFyIG1pc3NpbmcgPSBnZXQoWVhtbEhvb2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbEhvb2sucHJvdG90eXBlKSwgJ19mcm9tQmluYXJ5JywgdGhpcykuY2FsbCh0aGlzLCB5LCBkZWNvZGVyKTtcbiAgICAgICAgdGhpcy5ob29rTmFtZSA9IGRlY29kZXIucmVhZFZhclN0cmluZygpO1xuICAgICAgICByZXR1cm4gbWlzc2luZztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICAgICAqIEJpbmFyeUVuY29kZXIuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7QmluYXJ5RW5jb2Rlcn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190b0JpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvQmluYXJ5KGVuY29kZXIpIHtcbiAgICAgICAgZ2V0KFlYbWxIb29rLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxIb29rLnByb3RvdHlwZSksICdfdG9CaW5hcnknLCB0aGlzKS5jYWxsKHRoaXMsIGVuY29kZXIpO1xuICAgICAgICBlbmNvZGVyLndyaXRlVmFyU3RyaW5nKHRoaXMuaG9va05hbWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICAgICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAgICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19pbnRlZ3JhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnRlZ3JhdGUoeSkge1xuICAgICAgICBpZiAodGhpcy5ob29rTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaG9va05hbWUgbXVzdCBiZSBkZWZpbmVkIScpO1xuICAgICAgICB9XG4gICAgICAgIGdldChZWG1sSG9vay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZWG1sSG9vay5wcm90b3R5cGUpLCAnX2ludGVncmF0ZScsIHRoaXMpLmNhbGwodGhpcywgeSk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBZWG1sSG9vaztcbiAgfShZTWFwKTtcblxuICAvKipcbiAgICogRGVmaW5lIHRoZSBlbGVtZW50cyB0byB3aGljaCBhIHNldCBvZiBDU1MgcXVlcmllcyBhcHBseS5cbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9DU1NfU2VsZWN0b3JzfENTU19TZWxlY3RvcnN9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgcXVlcnkgPSAnLmNsYXNzU2VsZWN0b3InXG4gICAqICAgcXVlcnkgPSAnbm9kZVNlbGVjdG9yJ1xuICAgKiAgIHF1ZXJ5ID0gJyNpZFNlbGVjdG9yJ1xuICAgKlxuICAgKiBAdHlwZWRlZiB7c3RyaW5nfSBDU1NfU2VsZWN0b3JcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzdWJzZXQgb2YgdGhlIG5vZGVzIG9mIGEgWVhtbEVsZW1lbnQgLyBZWG1sRnJhZ21lbnQgYW5kIGFcbiAgICogcG9zaXRpb24gd2l0aGluIHRoZW0uXG4gICAqXG4gICAqIENhbiBiZSBjcmVhdGVkIHdpdGgge0BsaW5rIFlYbWxGcmFnbWVudCNjcmVhdGVUcmVlV2Fsa2VyfVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIHZhciBZWG1sVHJlZVdhbGtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBZWG1sVHJlZVdhbGtlcihyb290LCBmKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBZWG1sVHJlZVdhbGtlcik7XG5cbiAgICAgIHRoaXMuX2ZpbHRlciA9IGYgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAgIHRoaXMuX2N1cnJlbnROb2RlID0gcm9vdDtcbiAgICAgIHRoaXMuX2ZpcnN0Q2FsbCA9IHRydWU7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoWVhtbFRyZWVXYWxrZXIsIFt7XG4gICAgICBrZXk6IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgbmV4dCBub2RlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fSBUaGUgbmV4dCBub2RlLlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbmV4dCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9jdXJyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0Q2FsbCkge1xuICAgICAgICAgIHRoaXMuX2ZpcnN0Q2FsbCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghbi5fZGVsZXRlZCAmJiB0aGlzLl9maWx0ZXIobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBuLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKCFuLl9kZWxldGVkICYmIChuLmNvbnN0cnVjdG9yID09PSBZWG1sRnJhZ21lbnQuX1lYbWxFbGVtZW50IHx8IG4uY29uc3RydWN0b3IgPT09IFlYbWxGcmFnbWVudCkgJiYgbi5fc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHdhbGsgZG93biBpbiB0aGUgdHJlZVxuICAgICAgICAgICAgbiA9IG4uX3N0YXJ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3YWxrIHJpZ2h0IG9yIHVwIGluIHRoZSB0cmVlXG4gICAgICAgICAgICB3aGlsZSAobiAhPT0gdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgICBpZiAobi5fcmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuID0gbi5fcmlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbiA9IG4uX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuID09PSB0aGlzLl9yb290KSB7XG4gICAgICAgICAgICAgIG4gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobiA9PT0gdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChuICE9PSBudWxsICYmIChuLl9kZWxldGVkIHx8ICF0aGlzLl9maWx0ZXIobikpKTtcbiAgICAgICAgdGhpcy5fY3VycmVudE5vZGUgPSBuO1xuICAgICAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbiwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gWVhtbFRyZWVXYWxrZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogQW4gRXZlbnQgdGhhdCBkZXNjcmliZXMgY2hhbmdlcyBvbiBhIFlYbWwgRWxlbWVudCBvciBZeG1sIEZyYWdtZW50XG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgdmFyIFlYbWxFdmVudCA9IGZ1bmN0aW9uIChfWUV2ZW50KSB7XG4gICAgaW5oZXJpdHMoWVhtbEV2ZW50LCBfWUV2ZW50KTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7WVR5cGV9IHRhcmdldCBUaGUgdGFyZ2V0IG9uIHdoaWNoIHRoZSBldmVudCBpcyBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7U2V0fSBzdWJzIFRoZSBzZXQgb2YgY2hhbmdlZCBhdHRyaWJ1dGVzLiBgbnVsbGAgaXMgaW5jbHVkZWQgaWYgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgY2hpbGQgbGlzdCBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3RlIFdoZXRoZXIgdGhpcyBjaGFuZ2Ugd2FzIGNyZWF0ZWQgYnkgYSByZW1vdGUgcGVlci5cbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiBUaGUgdHJhbnNhY3Rpb24gaW5zdGFuY2Ugd2l0aCB3aWNoIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBZWG1sRXZlbnQodGFyZ2V0LCBzdWJzLCByZW1vdGUsIHRyYW5zYWN0aW9uKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBZWG1sRXZlbnQpO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSBmb3IgdGhlIGNvbXB1dGVkIGNoYW5nZS5cbiAgICAgICAqIEB0eXBlIHtUcmFuc2FjdGlvbn1cbiAgICAgICAqL1xuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoWVhtbEV2ZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbEV2ZW50KSkuY2FsbCh0aGlzLCB0YXJnZXQpKTtcblxuICAgICAgX3RoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdGhlIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgX3RoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb2YgYWxsIGNoYW5nZWQgYXR0cmlidXRlcy5cbiAgICAgICAqIEB0eXBlIHtTZXR9XG4gICAgICAgKi9cbiAgICAgIF90aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkID0gbmV3IFNldCgpO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoaXMgY2hhbmdlIHdhcyBjcmVhdGVkIGJ5IGEgcmVtb3RlIHBlZXIuXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgX3RoaXMucmVtb3RlID0gcmVtb3RlO1xuICAgICAgc3Vicy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgICAgaWYgKHN1YiA9PT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLmNoaWxkTGlzdENoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkLmFkZChzdWIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gWVhtbEV2ZW50O1xuICB9KFlFdmVudCk7XG5cbiAgLyoqXG4gICAqIERvbSBmaWx0ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBjYWxsYmFjayBkb21GaWx0ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIFRoZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0ge01hcH0gYXR0cmlidXRlcyBUaGUgbWFwIG9mIGF0dHJpYnV0ZXMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgRG9tIG5vZGUgaW4gdGhlIFlYbWxFbGVtZW50LlxuICAgKi9cblxuICAvKipcbiAgICogRGVmaW5lIHRoZSBlbGVtZW50cyB0byB3aGljaCBhIHNldCBvZiBDU1MgcXVlcmllcyBhcHBseS5cbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9DU1NfU2VsZWN0b3JzfENTU19TZWxlY3RvcnN9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgcXVlcnkgPSAnLmNsYXNzU2VsZWN0b3InXG4gICAqICAgcXVlcnkgPSAnbm9kZVNlbGVjdG9yJ1xuICAgKiAgIHF1ZXJ5ID0gJyNpZFNlbGVjdG9yJ1xuICAgKlxuICAgKiBAdHlwZWRlZiB7c3RyaW5nfSBDU1NfU2VsZWN0b3JcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBsaXN0IG9mIHtAbGluayBZWG1sRWxlbWVudH0uYW5kIHtAbGluayBZWG1sVGV4dH0gdHlwZXMuXG4gICAqIEEgWXhtbEZyYWdtZW50IGlzIHNpbWlsYXIgdG8gYSB7QGxpbmsgWVhtbEVsZW1lbnR9LCBidXQgaXQgZG9lcyBub3QgaGF2ZSBhXG4gICAqIG5vZGVOYW1lIGFuZCBpdCBkb2VzIG5vdCBoYXZlIGF0dHJpYnV0ZXMuIFRob3VnaCBpdCBjYW4gYmUgYm91bmQgdG8gYSBET01cbiAgICogZWxlbWVudCAtIGluIHRoaXMgY2FzZSB0aGUgYXR0cmlidXRlcyBhbmQgdGhlIG5vZGVOYW1lIGFyZSBub3Qgc2hhcmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIHZhciBZWG1sRnJhZ21lbnQgPSBmdW5jdGlvbiAoX1lBcnJheSkge1xuICAgIGluaGVyaXRzKFlYbWxGcmFnbWVudCwgX1lBcnJheSk7XG5cbiAgICBmdW5jdGlvbiBZWG1sRnJhZ21lbnQoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBZWG1sRnJhZ21lbnQpO1xuICAgICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFlYbWxGcmFnbWVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxGcmFnbWVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKFlYbWxGcmFnbWVudCwgW3tcbiAgICAgIGtleTogJ2NyZWF0ZVRyZWVXYWxrZXInLFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhIHN1YnRyZWUgb2YgY2hpbGROb2Rlcy5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogY29uc3Qgd2Fsa2VyID0gZWxlbS5jcmVhdGVUcmVlV2Fsa2VyKGRvbSA9PiBkb20ubm9kZU5hbWUgPT09ICdkaXYnKVxuICAgICAgICogZm9yIChsZXQgbm9kZSBpbiB3YWxrZXIpIHtcbiAgICAgICAqICAgLy8gYG5vZGVgIGlzIGEgZGl2IG5vZGVcbiAgICAgICAqICAgbm9wKG5vZGUpXG4gICAgICAgKiB9XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGVhY2ggY2hpbGQgZWxlbWVudCBhbmRcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNoaWxkXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHN1YnRyZWUuXG4gICAgICAgKiBAcmV0dXJuIHtUcmVlV2Fsa2VyfSBBIHN1YnRyZWUgYW5kIGEgcG9zaXRpb24gd2l0aGluIGl0LlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRyZWVXYWxrZXIoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgWVhtbFRyZWVXYWxrZXIodGhpcywgZmlsdGVyKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBZWG1sRWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5LlxuICAgICAgICogU2ltaWxhciB0byBET00ncyB7QGxpbmsgcXVlcnlTZWxlY3Rvcn0uXG4gICAgICAgKlxuICAgICAgICogUXVlcnkgc3VwcG9ydDpcbiAgICAgICAqICAgLSB0YWduYW1lXG4gICAgICAgKiBUT0RPOlxuICAgICAgICogICAtIGlkXG4gICAgICAgKiAgIC0gYXR0cmlidXRlXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW4uXG4gICAgICAgKiBAcmV0dXJuIHs/WVhtbEVsZW1lbnR9IFRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgcXVlcnkgb3IgbnVsbC5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3F1ZXJ5U2VsZWN0b3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3IocXVlcnkpIHtcbiAgICAgICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgWVhtbFRyZWVXYWxrZXIodGhpcywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZSA9PT0gcXVlcnk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbGwgWVhtbEVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5LlxuICAgICAgICogU2ltaWxhciB0byBEb20ncyB7QGxpbmsgcXVlcnlTZWxlY3RvckFsbH0uXG4gICAgICAgKlxuICAgICAgICogVE9ETzogRG9lcyBub3QgeWV0IHN1cHBvcnQgYWxsIHF1ZXJpZXMuIEN1cnJlbnRseSBvbmx5IHF1ZXJ5IGJ5IHRhZ05hbWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5PFlYbWxFbGVtZW50Pn0gVGhlIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhpcyBxdWVyeS5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3F1ZXJ5U2VsZWN0b3JBbGwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpIHtcbiAgICAgICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgWVhtbFRyZWVXYWxrZXIodGhpcywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZSA9PT0gcXVlcnk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIFlBcnJheSBFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jYWxsT2JzZXJ2ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMsIHJlbW90ZSkge1xuICAgICAgICB0aGlzLl9jYWxsRXZlbnRIYW5kbGVyKHRyYW5zYWN0aW9uLCBuZXcgWVhtbEV2ZW50KHRoaXMsIHBhcmVudFN1YnMsIHJlbW90ZSwgdHJhbnNhY3Rpb24pKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoaXMgWVhtbEZyYWdtZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbGwgY2hpbGRyZW4uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh4bWwpIHtcbiAgICAgICAgICByZXR1cm4geG1sLnRvU3RyaW5nKCk7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBVbmJpbmQgZnJvbSBEb20gYW5kIG1hcmsgdGhpcyBJdGVtIGFzIGRlbGV0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlRGVsZXRlIFdoZXRoZXIgdG8gcHJvcGFnYXRlIGEgbWVzc2FnZSB0aGF0IHRoaXNcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFR5cGUgd2FzIGRlbGV0ZWQuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnY0NoaWxkcmVuPXkuX2hhc1VuZG9NYW5hZ2VyPT09ZmFsc2VdIFdoZXRoZXIgdG8gZ2FyYmFnZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3QgdGhlIGNoaWxkcmVuIG9mIHRoaXMgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGVsZXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKHksIGNyZWF0ZURlbGV0ZSwgZ2NDaGlsZHJlbikge1xuICAgICAgICBnZXQoWVhtbEZyYWdtZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxGcmFnbWVudC5wcm90b3R5cGUpLCAnX2RlbGV0ZScsIHRoaXMpLmNhbGwodGhpcywgeSwgY3JlYXRlRGVsZXRlLCBnY0NoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgICAgICogQHBhcmFtIHtPYmplY3Q8a2V5Omhvb2tEZWZpbml0aW9uPn0gW2hvb2tzPXt9XSBPcHRpb25hbCBwcm9wZXJ0eSB0byBjdXN0b21pemUgaG93IGhvb2tzXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgICAgICogQHBhcmFtIHtEb21CaW5kaW5nfSBbYmluZGluZ10gWW91IHNob3VsZCBub3Qgc2V0IHRoaXMgcHJvcGVydHkuIFRoaXMgaXNcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGVcbiAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b0RvbScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9Eb20oKSB7XG4gICAgICAgIHZhciBfZG9jdW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGRvY3VtZW50O1xuXG4gICAgICAgIHZhciBob29rcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgIHZhciBiaW5kaW5nID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIHZhciBmcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGNyZWF0ZUFzc29jaWF0aW9uKGJpbmRpbmcsIGZyYWdtZW50LCB0aGlzKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4bWxUeXBlKSB7XG4gICAgICAgICAgZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKHhtbFR5cGUudG9Eb20oX2RvY3VtZW50LCBob29rcywgYmluZGluZyksIG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gdGhpcyBZWG1sIFR5cGUgdG8gYSByZWFkYWJsZSBmb3JtYXQuXG4gICAgICAgKiBVc2VmdWwgZm9yIGxvZ2dpbmcgYXMgYWxsIEl0ZW1zIGFuZCBEZWxldGUgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sb2dTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2dTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBsb2dJdGVtSGVscGVyKCdZWG1sJywgdGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBZWG1sRnJhZ21lbnQ7XG4gIH0oWUFycmF5KTtcblxuICAvKipcbiAgICogQW4gWVhtbEVsZW1lbnQgaW1pdGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGFcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fS5cbiAgICpcbiAgICogKiBBbiBZWG1sRWxlbWVudCBoYXMgYXR0cmlidXRlcyAoa2V5IHZhbHVlIHBhaXJzKVxuICAgKiAqIEFuIFlYbWxFbGVtZW50IGhhcyBjaGlsZEVsZW1lbnRzIHRoYXQgbXVzdCBpbmhlcml0IGZyb20gWVhtbEVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lIE5vZGUgbmFtZVxuICAgKi9cblxuICB2YXIgWVhtbEVsZW1lbnQgPSBmdW5jdGlvbiAoX1lYbWxGcmFnbWVudCkge1xuICAgIGluaGVyaXRzKFlYbWxFbGVtZW50LCBfWVhtbEZyYWdtZW50KTtcblxuICAgIGZ1bmN0aW9uIFlYbWxFbGVtZW50KCkge1xuICAgICAgdmFyIG5vZGVOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnVU5ERUZJTkVEJztcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFlYbWxFbGVtZW50KTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoWVhtbEVsZW1lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZWG1sRWxlbWVudCkpLmNhbGwodGhpcykpO1xuXG4gICAgICBfdGhpcy5ub2RlTmFtZSA9IG5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDcmVhdGVzIGFuIEl0ZW0gd2l0aCB0aGUgc2FtZSBlZmZlY3QgYXMgdGhpcyBJdGVtICh3aXRob3V0IHBvc2l0aW9uIGVmZmVjdClcbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoWVhtbEVsZW1lbnQsIFt7XG4gICAgICBrZXk6ICdfY29weScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvcHkoKSB7XG4gICAgICAgIHZhciBzdHJ1Y3QgPSBnZXQoWVhtbEVsZW1lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbEVsZW1lbnQucHJvdG90eXBlKSwgJ19jb3B5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgc3RydWN0Lm5vZGVOYW1lID0gdGhpcy5ub2RlTmFtZTtcbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogUmVhZCB0aGUgbmV4dCBJdGVtIGluIGEgRGVjb2RlciBhbmQgZmlsbCB0aGlzIEl0ZW0gd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gZGF0YSBpcyByZWNlaXZlZCBmcm9tIGEgcmVtb3RlIHBlZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2UgdGhhdCB0aGlzIEl0ZW0gYmVsb25ncyB0by5cbiAgICAgICAqIEBwYXJhbSB7QmluYXJ5RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBvYmplY3QgdG8gcmVhZCBkYXRhIGZyb20uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19mcm9tQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZnJvbUJpbmFyeSh5LCBkZWNvZGVyKSB7XG4gICAgICAgIHZhciBtaXNzaW5nID0gZ2V0KFlYbWxFbGVtZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxFbGVtZW50LnByb3RvdHlwZSksICdfZnJvbUJpbmFyeScsIHRoaXMpLmNhbGwodGhpcywgeSwgZGVjb2Rlcik7XG4gICAgICAgIHRoaXMubm9kZU5hbWUgPSBkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIG1pc3Npbmc7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAgICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0JpbmFyeUVuY29kZXJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdG9CaW5hcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90b0JpbmFyeShlbmNvZGVyKSB7XG4gICAgICAgIGdldChZWG1sRWxlbWVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZWG1sRWxlbWVudC5wcm90b3R5cGUpLCAnX3RvQmluYXJ5JywgdGhpcykuY2FsbCh0aGlzLCBlbmNvZGVyKTtcbiAgICAgICAgZW5jb2Rlci53cml0ZVZhclN0cmluZyh0aGlzLm5vZGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbnRlZ3JhdGVzIHRoaXMgSXRlbSBpbnRvIHRoZSBzaGFyZWQgc3RydWN0dXJlLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgbWV0aG9kIGFjdHVhbGx5IGFwcGxpZXMgdGhlIGNoYW5nZSB0byB0aGUgWWpzIGluc3RhbmNlLiBJbiBjYXNlIG9mXG4gICAgICAgKiBJdGVtIGl0IGNvbm5lY3RzIF9sZWZ0IGFuZCBfcmlnaHQgdG8gdGhpcyBJdGVtIGFuZCBjYWxscyB0aGVcbiAgICAgICAqIHtAbGluayBJdGVtI2JlZm9yZUNoYW5nZX0gbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqICogQ2hlY2tzIGZvciBub2RlTmFtZVxuICAgICAgICogKiBTZXRzIGRvbUZpbHRlclxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7WX0geSBUaGUgWWpzIGluc3RhbmNlXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2ludGVncmF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ludGVncmF0ZSh5KSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2RlTmFtZSBtdXN0IGJlIGRlZmluZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0KFlYbWxFbGVtZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxFbGVtZW50LnByb3RvdHlwZSksICdfaW50ZWdyYXRlJywgdGhpcykuY2FsbCh0aGlzLCB5KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZWG1sRWxlbWVudC5cbiAgICAgICAqIFRoZSBhdHRyaWJ1dGVzIGFyZSBvcmRlcmVkIGJ5IGF0dHJpYnV0ZS1uYW1lLCBzbyB5b3UgY2FuIGVhc2lseSB1c2UgdGhpc1xuICAgICAgICogbWV0aG9kIHRvIGNvbXBhcmUgWVhtbEVsZW1lbnRzXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIHZhciBzdHJpbmdCdWlsZGVyID0gW107XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICB2YXIga2V5c0xlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNMZW47IGkrKykge1xuICAgICAgICAgIHZhciBfa2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2goX2tleSArICc9XCInICsgYXR0cnNbX2tleV0gKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZU5hbWUgPSB0aGlzLm5vZGVOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBhdHRyc1N0cmluZyA9IHN0cmluZ0J1aWxkZXIubGVuZ3RoID4gMCA/ICcgJyArIHN0cmluZ0J1aWxkZXIuam9pbignICcpIDogJyc7XG4gICAgICAgIHJldHVybiAnPCcgKyBub2RlTmFtZSArIGF0dHJzU3RyaW5nICsgJz4nICsgZ2V0KFlYbWxFbGVtZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxFbGVtZW50LnByb3RvdHlwZSksICd0b1N0cmluZycsIHRoaXMpLmNhbGwodGhpcykgKyAnPC8nICsgbm9kZU5hbWUgKyAnPic7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGlzIFlYbWxFbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHJlbW92ZWQuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW1vdmVBdHRyaWJ1dGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBZTWFwLnByb3RvdHlwZS5kZWxldGUuY2FsbCh0aGlzLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIG9yIHVwZGF0ZXMgYW4gYXR0cmlidXRlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVWYWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0QXR0cmlidXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFlNYXAucHJvdG90eXBlLnNldC5jYWxsKHRoaXMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlkZW50aWZpZXMgdGhlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVkIHZhbHVlLlxuICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcXVlcmllZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRBdHRyaWJ1dGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBZTWFwLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFsbCBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBpbiBhIEpTT04gT2JqZWN0LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBKU09OIE9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgYXR0cmlidXRlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEF0dHJpYnV0ZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5fbWFwW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZS5fZGVsZXRlZCkge1xuICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLl9jb250ZW50WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogb3V0c291cmNlIHRoZSBiaW5kaW5nIHByb3BlcnR5LlxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgICAgICogQHBhcmFtIHtPYmplY3Q8a2V5Omhvb2tEZWZpbml0aW9uPn0gW2hvb2tzPXt9XSBPcHRpb25hbCBwcm9wZXJ0eSB0byBjdXN0b21pemUgaG93IGhvb2tzXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgICAgICogQHBhcmFtIHtEb21CaW5kaW5nfSBbYmluZGluZ10gWW91IHNob3VsZCBub3Qgc2V0IHRoaXMgcHJvcGVydHkuIFRoaXMgaXNcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGUuXG4gICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9Eb20nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRG9tKCkge1xuICAgICAgICB2YXIgX2RvY3VtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBkb2N1bWVudDtcblxuICAgICAgICB2YXIgaG9va3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICB2YXIgYmluZGluZyA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgICB2YXIgZG9tID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlTmFtZSk7XG4gICAgICAgIHZhciBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5eG1sKSB7XG4gICAgICAgICAgZG9tLmFwcGVuZENoaWxkKHl4bWwudG9Eb20oX2RvY3VtZW50LCBob29rcywgYmluZGluZykpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3JlYXRlQXNzb2NpYXRpb24oYmluZGluZywgZG9tLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFlYbWxFbGVtZW50O1xuICB9KFlYbWxGcmFnbWVudCk7XG5cblxuICBZWG1sRnJhZ21lbnQuX1lYbWxFbGVtZW50ID0gWVhtbEVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGBwYXJlbnRgIGlzIGEgcGFyZW50IG9mIGBjaGlsZGAuXG4gICAqXG4gICAqIEBwYXJhbSB7VHlwZX0gcGFyZW50XG4gICAqIEBwYXJhbSB7VHlwZX0gY2hpbGRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBgcGFyZW50YCBpcyBhIHBhcmVudCBvZiBgY2hpbGRgLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmdW5jdGlvbiBpc1BhcmVudE9mKHBhcmVudCwgY2hpbGQpIHtcbiAgICBjaGlsZCA9IGNoaWxkLl9wYXJlbnQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuX3BhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZmlsdGVyIG1ldGhvZCAoZG9lcyBub3RoaW5nKS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lIFRoZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0ge01hcH0gYXR0cnMgTWFwIG9mIGtleS12YWx1ZSBwYWlycyB0aGF0IGFyZSBhdHRyaWJ1dGVzIG9mIHRoZSBub2RlLlxuICAgKiBAcmV0dXJuIHtNYXAgfCBudWxsfSBUaGUgYWxsb3dlZCBhdHRyaWJ1dGVzIG9yIG51bGwsIGlmIHRoZSBlbGVtZW50IHNob3VsZCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIobm9kZU5hbWUsIGF0dHJzKSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGJhc2ljIGZpbHRlciB0aGF0IGZpbHRlcnMgb3V0IGRhbmdlcm91cyBwcm9wZXJ0aWVzIVxuICAgIHJldHVybiBhdHRycztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gZmlsdGVyRG9tQXR0cmlidXRlcyhkb20sIGZpbHRlcikge1xuICAgIHZhciBhdHRycyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBpID0gZG9tLmF0dHJpYnV0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhdHRyID0gZG9tLmF0dHJpYnV0ZXNbaV07XG4gICAgICBhdHRycy5zZXQoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcihkb20ubm9kZU5hbWUsIGF0dHJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgZmlsdGVyIG9uIGEgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RG9tQmluZGluZ30gYmluZGluZyBUaGUgRE9NIGJpbmRpbmcgaW5zdGFuY2UgdGhhdCBoYXMgdGhlIGRvbSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7WVhtbEVsZW1lbnQgfCBZWG1sRnJhZ21lbnQgfSB0eXBlIFRoZSB0eXBlIHRvIGFwcGx5IHRoZSBmaWx0ZXIgdG8uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseUZpbHRlck9uVHlwZSh5LCBiaW5kaW5nLCB0eXBlKSB7XG4gICAgaWYgKGlzUGFyZW50T2YoYmluZGluZy50eXBlLCB0eXBlKSkge1xuICAgICAgdmFyIG5vZGVOYW1lID0gdHlwZS5ub2RlTmFtZTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgICAgaWYgKHR5cGUuZ2V0QXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBhdHRycyA9IHR5cGUuZ2V0QXR0cmlidXRlcygpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLnNldChrZXksIGF0dHJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZmlsdGVyZWRBdHRyaWJ1dGVzID0gYmluZGluZy5maWx0ZXIobm9kZU5hbWUsIG5ldyBNYXAoYXR0cmlidXRlcykpO1xuICAgICAgaWYgKGZpbHRlcmVkQXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlLl9kZWxldGUoeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpdGVyYXRlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgLy8gZGVsZXRlIGFsbCBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vdCBpbiBmaWx0ZXJlZEF0dHJpYnV0ZXNcbiAgICAgICAgICBpZiAoZmlsdGVyZWRBdHRyaWJ1dGVzLmhhcyhrZXkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdHlwZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgWWpzIHR5cGUgKFlYbWwpIGJhc2VkIG9uIHRoZSBjb250ZW50cyBvZiBhIERPTSBFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8VGV4dE5vZGV9IGVsZW1lbnQgVGhlIERPTSBFbGVtZW50XG4gICAqIEBwYXJhbSB7P0RvY3VtZW50fSBfZG9jdW1lbnQgT3B0aW9uYWwuIFByb3ZpZGUgdGhlIGdsb2JhbCBkb2N1bWVudCBvYmplY3RcbiAgICogQHBhcmFtIHtIb29rc30gW2hvb2tzID0ge31dIE9wdGlvbmFsLiBTZXQgb2YgWWpzIEhvb2tzXG4gICAqIEBwYXJhbSB7RmlsdGVyfSBbZmlsdGVyPWRlZmF1bHRGaWx0ZXJdIE9wdGlvbmFsLiBEb20gZWxlbWVudCBmaWx0ZXJcbiAgICogQHBhcmFtIHs/RG9tQmluZGluZ30gYmluZGluZyBXYXJuaW5nOiBUaGlzIHByb3BlcnR5IGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seSFcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnQgfCBZWG1sVGV4dH1cbiAgICovXG4gIGZ1bmN0aW9uIGRvbVRvVHlwZShlbGVtZW50KSB7XG4gICAgdmFyIF9kb2N1bWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZG9jdW1lbnQ7XG5cbiAgICB2YXIgaG9va3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBmaWx0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGRlZmF1bHRGaWx0ZXI7XG4gICAgdmFyIGJpbmRpbmcgPSBhcmd1bWVudHNbNF07XG5cbiAgICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKGVsZW1lbnQubm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgX2RvY3VtZW50LkVMRU1FTlRfTk9ERTpcbiAgICAgICAgdmFyIGhvb2tOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIGhvb2sgPSB2b2lkIDA7XG4gICAgICAgIC8vIGNvbmZpZ3VyZSBgaG9va05hbWUgIT09IHVuZGVmaW5lZGAgaWYgZWxlbWVudCBpcyBhIGhvb2suXG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS15anMtaG9vaycpKSB7XG4gICAgICAgICAgaG9va05hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS15anMtaG9vaycpO1xuICAgICAgICAgIGhvb2sgPSBob29rc1tob29rTmFtZV07XG4gICAgICAgICAgaWYgKGhvb2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5rbm93biBob29rIFwiJyArIGhvb2tOYW1lICsgJ1wiLiBEZWxldGluZyB5anNIb29rIGRhdGFzZXQgcHJvcGVydHkuJyk7XG4gICAgICAgICAgICBkZWxldGUgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEteWpzLWhvb2snKTtcbiAgICAgICAgICAgIGhvb2tOYW1lID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gTm90IGEgaG9va1xuICAgICAgICAgIHZhciBhdHRycyA9IGZpbHRlckRvbUF0dHJpYnV0ZXMoZWxlbWVudCwgZmlsdGVyKTtcbiAgICAgICAgICBpZiAoYXR0cnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHR5cGUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IG5ldyBZWG1sRWxlbWVudChlbGVtZW50Lm5vZGVOYW1lKTtcbiAgICAgICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICAgICAgICAgIHR5cGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHlwZS5pbnNlcnQoMCwgZG9tc1RvVHlwZXMoZWxlbWVudC5jaGlsZE5vZGVzLCBkb2N1bWVudCwgaG9va3MsIGZpbHRlciwgYmluZGluZykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJcyBhIGhvb2tcbiAgICAgICAgICB0eXBlID0gbmV3IFlYbWxIb29rKGhvb2tOYW1lKTtcbiAgICAgICAgICBob29rLmZpbGxUeXBlKGVsZW1lbnQsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfZG9jdW1lbnQuVEVYVF9OT0RFOlxuICAgICAgICB0eXBlID0gbmV3IFlYbWxUZXh0KCk7XG4gICAgICAgIHR5cGUuaW5zZXJ0KDAsIGVsZW1lbnQubm9kZVZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdHJhbnNmb3JtIHRoaXMgbm9kZSB0eXBlIHRvIGEgWVhtbCB0eXBlIScpO1xuICAgIH1cbiAgICBjcmVhdGVBc3NvY2lhdGlvbihiaW5kaW5nLCBlbGVtZW50LCB0eXBlKTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBpdGVtcyB1bnRpbCBhbiB1bmRlbGV0ZWQgaXRlbSBpcyBmb3VuZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdGVVbnRpbFVuZGVsZXRlZChpdGVtKSB7XG4gICAgd2hpbGUgKGl0ZW0gIT09IG51bGwgJiYgaXRlbS5fZGVsZXRlZCkge1xuICAgICAgaXRlbSA9IGl0ZW0uX3JpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGFzc29jaWF0aW9uICh0aGUgaW5mb3JtYXRpb24gdGhhdCBhIERPTSBlbGVtZW50IGJlbG9uZ3MgdG8gYVxuICAgKiB0eXBlKS5cbiAgICpcbiAgICogQHBhcmFtIHtEb21CaW5kaW5nfSBkb21CaW5kaW5nIFRoZSBiaW5kaW5nIG9iamVjdFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbSBUaGUgZG9tIHRoYXQgaXMgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHR5cGVcbiAgICogQHBhcmFtIHtZWG1sRWxlbWVudHxZWG1sSG9va30gdHlwZSBUaGUgdHlwZSB0aGF0IGlzIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCBkb21cbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUFzc29jaWF0aW9uKGRvbUJpbmRpbmcsIGRvbSwgdHlwZSkge1xuICAgIGRvbUJpbmRpbmcuZG9tVG9UeXBlLmRlbGV0ZShkb20pO1xuICAgIGRvbUJpbmRpbmcudHlwZVRvRG9tLmRlbGV0ZSh0eXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFzc29jaWF0aW9uICh0aGUgaW5mb3JtYXRpb24gdGhhdCBhIERPTSBlbGVtZW50IGJlbG9uZ3MgdG8gYVxuICAgKiB0eXBlKS5cbiAgICpcbiAgICogQHBhcmFtIHtEb21CaW5kaW5nfSBkb21CaW5kaW5nIFRoZSBiaW5kaW5nIG9iamVjdFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbSBUaGUgZG9tIHRoYXQgaXMgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHR5cGVcbiAgICogQHBhcmFtIHtZWG1sRWxlbWVudHxZWG1sSG9va30gdHlwZSBUaGUgdHlwZSB0aGF0IGlzIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCBkb21cbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUFzc29jaWF0aW9uKGRvbUJpbmRpbmcsIGRvbSwgdHlwZSkge1xuICAgIGlmIChkb21CaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRvbUJpbmRpbmcuZG9tVG9UeXBlLnNldChkb20sIHR5cGUpO1xuICAgICAgZG9tQmluZGluZy50eXBlVG9Eb20uc2V0KHR5cGUsIGRvbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIG9sZERvbSBpcyBhc3NvY2lhdGVkIHdpdGggYSB0eXBlLCBhc3NvY2lhdGUgbmV3RG9tIHdpdGggdGhlIHR5cGUgYW5kXG4gICAqIGZvcmdldCBhYm91dCBvbGREb20uIElmIG9sZERvbSBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIGFueSB0eXBlLCBub3RoaW5nIGhhcHBlbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9tQmluZGluZ30gZG9tQmluZGluZyBUaGUgYmluZGluZyBvYmplY3RcbiAgICogQHBhcmFtIHtFbGVtZW50fSBvbGREb20gVGhlIGV4aXN0aW5nIGRvbVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5ld0RvbSBUaGUgbmV3IGRvbSBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIHN3aXRjaEFzc29jaWF0aW9uKGRvbUJpbmRpbmcsIG9sZERvbSwgbmV3RG9tKSB7XG4gICAgaWYgKGRvbUJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHR5cGUgPSBkb21CaW5kaW5nLmRvbVRvVHlwZS5nZXQob2xkRG9tKTtcbiAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVtb3ZlQXNzb2NpYXRpb24oZG9tQmluZGluZywgb2xkRG9tLCB0eXBlKTtcbiAgICAgICAgY3JlYXRlQXNzb2NpYXRpb24oZG9tQmluZGluZywgbmV3RG9tLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IERvbSBFbGVtZW50cyBhZnRlciBvbmUgb2YgdGhlIGNoaWxkcmVuIG9mIHRoaXMgWVhtbEZyYWdtZW50LlxuICAgKiBUaGUgRG9tIGVsZW1lbnRzIHdpbGwgYmUgYm91bmQgdG8gYSBuZXcgWVhtbEVsZW1lbnQgYW5kIGluc2VydGVkIGF0IHRoZVxuICAgKiBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7WVhtbEVsZW1lbnR9IHR5cGUgVGhlIHR5cGUgaW4gd2hpY2ggdG8gaW5zZXJ0IERPTSBlbGVtZW50cy5cbiAgICogQHBhcmFtIHtZWG1sRWxlbWVudHxudWxsfSBwcmV2IFRoZSByZWZlcmVuY2Ugbm9kZS4gTmV3IFl4bWxFbGVtZW50cyBhcmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZCBhZnRlciB0aGlzIG5vZGUuIFNldCBudWxsIHRvIGluc2VydCBhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBiZWdpbm5pbmcuXG4gICAqIEBwYXJhbSB7QXJyYXk8RWxlbWVudD59IGRvbXMgVGhlIERvbSBlbGVtZW50cyB0byBpbnNlcnQuXG4gICAqIEBwYXJhbSB7P0RvY3VtZW50fSBfZG9jdW1lbnQgT3B0aW9uYWwuIFByb3ZpZGUgdGhlIGdsb2JhbCBkb2N1bWVudCBvYmplY3QuXG4gICAqIEBwYXJhbSB7RG9tQmluZGluZ30gYmluZGluZyBUaGUgZG9tIGJpbmRpbmdcbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnQ+fSBUaGUgWXhtbEVsZW1lbnRzIHRoYXQgYXJlIGluc2VydGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0RG9tRWxlbWVudHNBZnRlcih0eXBlLCBwcmV2LCBkb21zLCBfZG9jdW1lbnQsIGJpbmRpbmcpIHtcbiAgICB2YXIgdHlwZXMgPSBkb21zVG9UeXBlcyhkb21zLCBfZG9jdW1lbnQsIGJpbmRpbmcub3B0cy5ob29rcywgYmluZGluZy5maWx0ZXIsIGJpbmRpbmcpO1xuICAgIHJldHVybiB0eXBlLmluc2VydEFmdGVyKHByZXYsIHR5cGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbXNUb1R5cGVzKGRvbXMsIF9kb2N1bWVudCwgaG9va3MsIGZpbHRlciwgYmluZGluZykge1xuICAgIHZhciB0eXBlcyA9IFtdO1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZG9tc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgdmFyIGRvbSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIHZhciB0ID0gZG9tVG9UeXBlKGRvbSwgX2RvY3VtZW50LCBob29rcywgZmlsdGVyLCBiaW5kaW5nKTtcbiAgICAgICAgaWYgKHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdHlwZXMucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9kZUhlbHBlcih5eG1sLCBwcmV2RXhwZWN0ZWROb2RlLCBjaGlsZCwgX2RvY3VtZW50LCBiaW5kaW5nKSB7XG4gICAgdmFyIGluc2VydGVkTm9kZXMgPSBpbnNlcnREb21FbGVtZW50c0FmdGVyKHl4bWwsIHByZXZFeHBlY3RlZE5vZGUsIFtjaGlsZF0sIF9kb2N1bWVudCwgYmluZGluZyk7XG4gICAgaWYgKGluc2VydGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGluc2VydGVkTm9kZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmV2RXhwZWN0ZWROb2RlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY2hpbGRyZW4gdW50aWwgYGVsZW1gIGlzIGZvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCBUaGUgcGFyZW50IG9mIGBlbGVtYCBhbmQgYGN1cnJlbnRDaGlsZGAuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY3VycmVudENoaWxkIFN0YXJ0IHJlbW92aW5nIGVsZW1lbnRzIHdpdGggYGN1cnJlbnRDaGlsZGAuIElmXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBjdXJyZW50Q2hpbGRgIGlzIGBlbGVtYCBpdCB3b24ndCBiZSByZW1vdmVkLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8bnVsbH0gZWxlbSBUaGUgZWxlbW50IHRvIGxvb2sgZm9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlRG9tQ2hpbGRyZW5VbnRpbEVsZW1lbnRGb3VuZChwYXJlbnQsIGN1cnJlbnRDaGlsZCwgZWxlbSkge1xuICAgIHdoaWxlIChjdXJyZW50Q2hpbGQgIT09IGVsZW0pIHtcbiAgICAgIHZhciBkZWwgPSBjdXJyZW50Q2hpbGQ7XG4gICAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZGVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyB0ZXh0IGluIGEgRG9tIEVsZW1lbnQuIEluIHRoZSBmdXR1cmUgdGhpcyB0eXBlIHdpbGwgYWxzbyBoYW5kbGVcbiAgICogc2ltcGxlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gbGlrZSBib2xkIGFuZCBpdGFsaWMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhcmcxIEluaXRpYWwgdmFsdWUuXG4gICAqL1xuXG4gIHZhciBZWG1sVGV4dCA9IGZ1bmN0aW9uIChfWVRleHQpIHtcbiAgICBpbmhlcml0cyhZWG1sVGV4dCwgX1lUZXh0KTtcblxuICAgIGZ1bmN0aW9uIFlYbWxUZXh0KCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWVhtbFRleHQpO1xuICAgICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFlYbWxUZXh0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbFRleHQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhZWG1sVGV4dCwgW3tcbiAgICAgIGtleTogJ3RvRG9tJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbFRleHQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgICAgICogQHBhcmFtIHtPYmplY3Q8a2V5Omhvb2tEZWZpbml0aW9uPn0gW2hvb2tzXSBPcHRpb25hbCBwcm9wZXJ0eSB0byBjdXN0b21pemUgaG93IGhvb2tzXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgICAgICogQHBhcmFtIHtEb21CaW5kaW5nfSBbYmluZGluZ10gWW91IHNob3VsZCBub3Qgc2V0IHRoaXMgcHJvcGVydHkuIFRoaXMgaXNcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGUuXG4gICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRG9tKCkge1xuICAgICAgICB2YXIgX2RvY3VtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBkb2N1bWVudDtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgdmFyIGRvbSA9IF9kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICBjcmVhdGVBc3NvY2lhdGlvbihiaW5kaW5nLCBkb20sIHRoaXMpO1xuICAgICAgICByZXR1cm4gZG9tO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE1hcmsgdGhpcyBJdGVtIGFzIGRlbGV0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlRGVsZXRlIFdoZXRoZXIgdG8gcHJvcGFnYXRlIGEgbWVzc2FnZSB0aGF0IHRoaXNcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFR5cGUgd2FzIGRlbGV0ZWQuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnY0NoaWxkcmVuPXkuX2hhc1VuZG9NYW5hZ2VyPT09ZmFsc2VdIFdoZXRoZXIgdG8gZ2FyYmFnZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3QgdGhlIGNoaWxkcmVuIG9mIHRoaXMgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGVsZXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKHksIGNyZWF0ZURlbGV0ZSwgZ2NDaGlsZHJlbikge1xuICAgICAgICBnZXQoWVhtbFRleHQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbFRleHQucHJvdG90eXBlKSwgJ19kZWxldGUnLCB0aGlzKS5jYWxsKHRoaXMsIHksIGNyZWF0ZURlbGV0ZSwgZ2NDaGlsZHJlbik7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBZWG1sVGV4dDtcbiAgfShZVGV4dCk7XG5cbiAgdmFyIHN0cnVjdHMgPSBuZXcgTWFwKCk7XG4gIHZhciByZWZlcmVuY2VzID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIG5ldyBZanMgdHlwZXMuIFRoZSBzYW1lIHR5cGUgbXVzdCBiZSBkZWZpbmVkIHdpdGggdGhlIHNhbWVcbiAgICogcmVmZXJlbmNlIG9uIGFsbCBjbGllbnRzIVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVmZXJlbmNlXG4gICAqIEBwYXJhbSB7Y2xhc3N9IHN0cnVjdENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyU3RydWN0KHJlZmVyZW5jZSwgc3RydWN0Q29uc3RydWN0b3IpIHtcbiAgICBzdHJ1Y3RzLnNldChyZWZlcmVuY2UsIHN0cnVjdENvbnN0cnVjdG9yKTtcbiAgICByZWZlcmVuY2VzLnNldChzdHJ1Y3RDb25zdHJ1Y3RvciwgcmVmZXJlbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RydWN0KHJlZmVyZW5jZSkge1xuICAgIHJldHVybiBzdHJ1Y3RzLmdldChyZWZlcmVuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdHJ1Y3RSZWZlcmVuY2UodHlwZUNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIHJlZmVyZW5jZXMuZ2V0KHR5cGVDb25zdHJ1Y3Rvcik7XG4gIH1cblxuICAvLyBUT0RPOiByZW9yZGVyIChJdGVtKiBzaG91bGQgaGF2ZSBsb3cgbnVtYmVycylcbiAgcmVnaXN0ZXJTdHJ1Y3QoMCwgSXRlbUpTT04pO1xuICByZWdpc3RlclN0cnVjdCgxLCBJdGVtU3RyaW5nKTtcbiAgcmVnaXN0ZXJTdHJ1Y3QoMTAsIEl0ZW1Gb3JtYXQpO1xuICByZWdpc3RlclN0cnVjdCgxMSwgSXRlbUVtYmVkKTtcbiAgcmVnaXN0ZXJTdHJ1Y3QoMiwgRGVsZXRlKTtcblxuICByZWdpc3RlclN0cnVjdCgzLCBZQXJyYXkpO1xuICByZWdpc3RlclN0cnVjdCg0LCBZTWFwKTtcbiAgcmVnaXN0ZXJTdHJ1Y3QoNSwgWVRleHQpO1xuICByZWdpc3RlclN0cnVjdCg2LCBZWG1sRnJhZ21lbnQpO1xuICByZWdpc3RlclN0cnVjdCg3LCBZWG1sRWxlbWVudCk7XG4gIHJlZ2lzdGVyU3RydWN0KDgsIFlYbWxUZXh0KTtcbiAgcmVnaXN0ZXJTdHJ1Y3QoOSwgWVhtbEhvb2spO1xuXG4gIHJlZ2lzdGVyU3RydWN0KDEyLCBHQyk7XG5cbiAgdmFyIFJvb3RGYWtlVXNlcklEID0gMHhGRkZGRkY7XG5cbiAgdmFyIFJvb3RJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb290SUQobmFtZSwgdHlwZUNvbnN0cnVjdG9yKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSb290SUQpO1xuXG4gICAgICB0aGlzLnVzZXIgPSBSb290RmFrZVVzZXJJRDtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLnR5cGUgPSBnZXRTdHJ1Y3RSZWZlcmVuY2UodHlwZUNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhSb290SUQsIFt7XG4gICAgICBrZXk6ICdlcXVhbHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhpZCkge1xuICAgICAgICByZXR1cm4gaWQgIT09IG51bGwgJiYgaWQudXNlciA9PT0gdGhpcy51c2VyICYmIGlkLm5hbWUgPT09IHRoaXMubmFtZSAmJiBpZC50eXBlID09PSB0aGlzLnR5cGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbGVzc1RoYW4nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxlc3NUaGFuKGlkKSB7XG4gICAgICAgIGlmIChpZC5jb25zdHJ1Y3RvciA9PT0gUm9vdElEKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudXNlciA8IGlkLnVzZXIgfHwgdGhpcy51c2VyID09PSBpZC51c2VyICYmICh0aGlzLm5hbWUgPCBpZC5uYW1lIHx8IHRoaXMubmFtZSA9PT0gaWQubmFtZSAmJiB0aGlzLnR5cGUgPCBpZC50eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gUm9vdElEO1xuICB9KCk7XG5cbiAgdmFyIE9wZXJhdGlvblN0b3JlID0gZnVuY3Rpb24gKF9UcmVlKSB7XG4gICAgaW5oZXJpdHMoT3BlcmF0aW9uU3RvcmUsIF9UcmVlKTtcblxuICAgIGZ1bmN0aW9uIE9wZXJhdGlvblN0b3JlKHkpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9wZXJhdGlvblN0b3JlKTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoT3BlcmF0aW9uU3RvcmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcGVyYXRpb25TdG9yZSkpLmNhbGwodGhpcykpO1xuXG4gICAgICBfdGhpcy55ID0geTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhPcGVyYXRpb25TdG9yZSwgW3tcbiAgICAgIGtleTogJ2xvZ1RhYmxlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dUYWJsZSgpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIHRoaXMuaXRlcmF0ZShudWxsLCBudWxsLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGlmIChpdGVtLmNvbnN0cnVjdG9yID09PSBHQykge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiBsb2dJRChpdGVtKSxcbiAgICAgICAgICAgICAgY29udGVudDogaXRlbS5fbGVuZ3RoLFxuICAgICAgICAgICAgICBkZWxldGVkOiAnR0MnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiBsb2dJRChpdGVtKSxcbiAgICAgICAgICAgICAgb3JpZ2luOiBsb2dJRChpdGVtLl9vcmlnaW4gPT09IG51bGwgPyBudWxsIDogaXRlbS5fb3JpZ2luLl9sYXN0SWQpLFxuICAgICAgICAgICAgICBsZWZ0OiBsb2dJRChpdGVtLl9sZWZ0ID09PSBudWxsID8gbnVsbCA6IGl0ZW0uX2xlZnQuX2xhc3RJZCksXG4gICAgICAgICAgICAgIHJpZ2h0OiBsb2dJRChpdGVtLl9yaWdodCksXG4gICAgICAgICAgICAgIHJpZ2h0X29yaWdpbjogbG9nSUQoaXRlbS5fcmlnaHRfb3JpZ2luKSxcbiAgICAgICAgICAgICAgcGFyZW50OiBsb2dJRChpdGVtLl9wYXJlbnQpLFxuICAgICAgICAgICAgICBwYXJlbnRTdWI6IGl0ZW0uX3BhcmVudFN1YixcbiAgICAgICAgICAgICAgZGVsZXRlZDogaXRlbS5fZGVsZXRlZCxcbiAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoaXRlbS5fY29udGVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUudGFibGUoaXRlbXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0JCQxKGlkKSB7XG4gICAgICAgIHZhciBzdHJ1Y3QgPSB0aGlzLmZpbmQoaWQpO1xuICAgICAgICBpZiAoc3RydWN0ID09PSBudWxsICYmIGlkIGluc3RhbmNlb2YgUm9vdElEKSB7XG4gICAgICAgICAgdmFyIENvbnN0ciA9IGdldFN0cnVjdChpZC50eXBlKTtcbiAgICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgICBzdHJ1Y3QgPSBuZXcgQ29uc3RyKCk7XG4gICAgICAgICAgc3RydWN0Ll9pZCA9IGlkO1xuICAgICAgICAgIHN0cnVjdC5fcGFyZW50ID0geTtcbiAgICAgICAgICB5LnRyYW5zYWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0cnVjdC5faW50ZWdyYXRlKHkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucHV0KHN0cnVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBnZXRJdGVtIGZvciBzdHJ1Y3RzIHdpdGggX2xlbmd0aCA+IDFcblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEl0ZW0nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW0oaWQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmZpbmRXaXRoVXBwZXJCb3VuZChpZCk7XG4gICAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW1JRCA9IGl0ZW0uX2lkO1xuICAgICAgICBpZiAoaWQudXNlciA9PT0gaXRlbUlELnVzZXIgJiYgaWQuY2xvY2sgPCBpdGVtSUQuY2xvY2sgKyBpdGVtLl9sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmV0dXJuIGFuIGluc2VydGlvbiBzdWNoIHRoYXQgaWQgaXMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgY29udGVudFxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBtYW5pcHVsYXRlcyBhbiBpdGVtLCBpZiBuZWNlc3NhcnlcblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEl0ZW1DbGVhblN0YXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJdGVtQ2xlYW5TdGFydChpZCkge1xuICAgICAgICB2YXIgaW5zID0gdGhpcy5nZXRJdGVtKGlkKTtcbiAgICAgICAgaWYgKGlucyA9PT0gbnVsbCB8fCBpbnMuX2xlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBpbnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluc0lEID0gaW5zLl9pZDtcbiAgICAgICAgaWYgKGluc0lELmNsb2NrID09PSBpZC5jbG9jaykge1xuICAgICAgICAgIHJldHVybiBpbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlucy5fc3BsaXRBdCh0aGlzLnksIGlkLmNsb2NrIC0gaW5zSUQuY2xvY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZXR1cm4gYW4gaW5zZXJ0aW9uIHN1Y2ggdGhhdCBpZCBpcyB0aGUgbGFzdCBlbGVtZW50IG9mIGNvbnRlbnRcbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gbWFuaXB1bGF0ZXMgYW4gb3BlcmF0aW9uLCBpZiBuZWNlc3NhcnlcblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEl0ZW1DbGVhbkVuZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbUNsZWFuRW5kKGlkKSB7XG4gICAgICAgIHZhciBpbnMgPSB0aGlzLmdldEl0ZW0oaWQpO1xuICAgICAgICBpZiAoaW5zID09PSBudWxsIHx8IGlucy5fbGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGlucztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5zSUQgPSBpbnMuX2lkO1xuICAgICAgICBpZiAoaW5zSUQuY2xvY2sgKyBpbnMuX2xlbmd0aCAtIDEgPT09IGlkLmNsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIGlucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnMuX3NwbGl0QXQodGhpcy55LCBpZC5jbG9jayAtIGluc0lELmNsb2NrICsgMSk7XG4gICAgICAgICAgcmV0dXJuIGlucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gT3BlcmF0aW9uU3RvcmU7XG4gIH0oVHJlZSk7XG5cbiAgdmFyIFN0YXRlU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVTdG9yZSh5KSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdGF0ZVN0b3JlKTtcblxuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMuc3RhdGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoU3RhdGVTdG9yZSwgW3tcbiAgICAgIGtleTogJ2xvZ1RhYmxlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dUYWJsZSgpIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5zdGF0ZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IHNsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgIHVzZXIgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICB1c2VyOiB1c2VyLCBzdGF0ZTogc3RhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLnRhYmxlKGVudHJpZXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldE5leHRJRCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmV4dElEKGxlbikge1xuICAgICAgICB2YXIgdXNlciA9IHRoaXMueS51c2VySUQ7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUodXNlcik7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodXNlciwgc3RhdGUgKyBsZW4pO1xuICAgICAgICByZXR1cm4gbmV3IElEKHVzZXIsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVSZW1vdGVTdGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUmVtb3RlU3RhdGUoc3RydWN0KSB7XG4gICAgICAgIHZhciB1c2VyID0gc3RydWN0Ll9pZC51c2VyO1xuICAgICAgICB2YXIgdXNlclN0YXRlID0gdGhpcy5zdGF0ZS5nZXQodXNlcik7XG4gICAgICAgIHdoaWxlIChzdHJ1Y3QgIT09IG51bGwgJiYgc3RydWN0Ll9pZC5jbG9jayA9PT0gdXNlclN0YXRlKSB7XG4gICAgICAgICAgdXNlclN0YXRlICs9IHN0cnVjdC5fbGVuZ3RoO1xuICAgICAgICAgIHN0cnVjdCA9IHRoaXMueS5vcy5nZXQobmV3IElEKHVzZXIsIHVzZXJTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0KHVzZXIsIHVzZXJTdGF0ZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0U3RhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlKHVzZXIpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZS5nZXQodXNlcik7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldFN0YXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdGF0ZSh1c2VyLCBzdGF0ZSkge1xuICAgICAgICAvLyBUT0RPOiBtb2RpZnkgbWlzc2luZ2kgc3RydWN0cyBoZXJlXG4gICAgICAgIHZhciBiZWZvcmVTdGF0ZSA9IHRoaXMueS5fdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGU7XG4gICAgICAgIGlmICghYmVmb3JlU3RhdGUuaGFzKHVzZXIpKSB7XG4gICAgICAgICAgYmVmb3JlU3RhdGUuc2V0KHVzZXIsIHRoaXMuZ2V0U3RhdGUodXNlcikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0KHVzZXIsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFN0YXRlU3RvcmU7XG4gIH0oKTtcblxuICAvKiBnbG9iYWwgY3J5cHRvICovXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21VaW50MzIoKSB7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBicm93c2VyXG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgcmV0dXJuIGFyclswXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21CeXRlcyAhPSBudWxsKSB7XG4gICAgICAvLyBub2RlXG4gICAgICB2YXIgYnVmID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShidWYuYnVmZmVyKVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChNYXRoLnJhbmRvbSgpICogMHhGRkZGRkZGRik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgbmFtZWQgZXZlbnRzLlxuICAgKi9cbiAgdmFyIE5hbWVkRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hbWVkRXZlbnRIYW5kbGVyKCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTmFtZWRFdmVudEhhbmRsZXIpO1xuXG4gICAgICB0aGlzLl9ldmVudExpc3RlbmVyID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5fc3RhdGVMaXN0ZW5lciA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFJldHVybnMgYWxsIGxpc3RlbmVycyB0aGF0IGxpc3RlbiB0byBhIHNwZWNpZmllZCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIHF1ZXJ5IGV2ZW50IG5hbWUuXG4gICAgICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKE5hbWVkRXZlbnRIYW5kbGVyLCBbe1xuICAgICAga2V5OiAnX2dldExpc3RlbmVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TGlzdGVuZXIobmFtZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lci5nZXQobmFtZSk7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIG9uY2U6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIG9uOiBuZXcgU2V0KClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXIuc2V0KG5hbWUsIGxpc3RlbmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGEgbmFtZWQgZXZlbnQgbGlzdGVuZXIuIFRoZSBsaXN0ZW5lciBpcyByZW1vdmVkIGFmdGVyIGl0IGhhcyBiZWVuXG4gICAgICAgKiBjYWxsZWQgb25jZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZXZlbnQgbmFtZSB0byBsaXN0ZW4gdG8uXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvbmNlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKG5hbWUsIGYpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2dldExpc3RlbmVyKG5hbWUpO1xuICAgICAgICBsaXN0ZW5lcnMub25jZS5hZGQoZik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBhIG5hbWVkIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBldmVudCBuYW1lIHRvIGxpc3RlbiB0by5cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbihuYW1lLCBmKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9nZXRMaXN0ZW5lcihuYW1lKTtcbiAgICAgICAgbGlzdGVuZXJzLm9uLmFkZChmKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogSW5pdCB0aGUgc2F2ZWQgc3RhdGUgZm9yIGFuIGV2ZW50IG5hbWUuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19pbml0U3RhdGVMaXN0ZW5lcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRTdGF0ZUxpc3RlbmVyKG5hbWUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGVMaXN0ZW5lci5nZXQobmFtZSk7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RhdGUgPSB7fTtcbiAgICAgICAgICBzdGF0ZS5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX3N0YXRlTGlzdGVuZXIuc2V0KG5hbWUsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIFByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSBldmVudCBuYW1lIGlzIGNhbGxlZC5cbiAgICAgICAqIFRoZSBQcm9taXNlIGlzIGltbWVkaWF0ZWx5IHJlc29sdmVkIHdoZW4gdGhlIGV2ZW50IG5hbWUgd2FzIGNhbGxlZCBpbiB0aGVcbiAgICAgICAqIHBhc3QuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3doZW4nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdoZW4obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdFN0YXRlTGlzdGVuZXIobmFtZSkucHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCB3YXMgcmVnaXN0ZXJlZCB3aXRoIGVpdGhlclxuICAgICAgICoge0BsaW5rIEV2ZW50SGFuZGxlciNvbn0gb3Ige0BsaW5rIEV2ZW50SGFuZGxlciNvbmNlfS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb2ZmJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYobmFtZSwgZikge1xuICAgICAgICBpZiAobmFtZSA9PSBudWxsIHx8IGYgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBldmVudCBuYW1lIGFuZCBmdW5jdGlvbiEnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9ldmVudExpc3RlbmVyLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5vbi5kZWxldGUoZik7XG4gICAgICAgICAgbGlzdGVuZXIub25jZS5kZWxldGUoZik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbWl0IGEgbmFtZWQgZXZlbnQuIEFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyB0aGF0IGxpc3RlbiB0byB0aGVcbiAgICAgICAqIHNwZWNpZmllZCBuYW1lIHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2VtaXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQobmFtZSkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2luaXRTdGF0ZUxpc3RlbmVyKG5hbWUpLnJlc29sdmUoKTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5fZXZlbnRMaXN0ZW5lci5nZXQobmFtZSk7XG4gICAgICAgIGlmIChsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGlzdGVuZXIub24uZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGlzdGVuZXIub25jZS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsaXN0ZW5lci5vbmNlID0gbmV3IFNldCgpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lciA9IG51bGw7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBOYW1lZEV2ZW50SGFuZGxlcjtcbiAgfSgpO1xuXG4gIC8vIFRPRE86IEltcGxlbWVudCBmdW5jdGlvbiB0byBkZXNjcmliZSByYW5nZXNcblxuICAvKipcbiAgICogQSByZWxhdGl2ZSBwb3NpdGlvbiB0aGF0IGlzIGJhc2VkIG9uIHRoZSBZanMgbW9kZWwuIEluIGNvbnRyYXN0IHRvIGFuXG4gICAqIGFic29sdXRlIHBvc2l0aW9uIChwb3NpdGlvbiBieSBpbmRleCksIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBjYW4gYmVcbiAgICogcmVjb21wdXRlZCB3aGVuIHJlbW90ZSBjaGFuZ2VzIGFyZSByZWNlaXZlZC4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIGBgYEluc2VydCgwLCAneCcpKCdhfGJjJykgPSAneGF8YmMnYGBgIFdoZXJlIHwgaXMgdGhlIGN1cnNvciBwb3NpdGlvbi5cbiAgICpcbiAgICogQSByZWxhdGl2ZSBjdXJzb3IgcG9zaXRpb24gY2FuIGJlIG9idGFpbmVkIHdpdGggdGhlIGZ1bmN0aW9uXG4gICAqIHtAbGluayBnZXRSZWxhdGl2ZVBvc2l0aW9ufSBhbmQgaXQgY2FuIGJlIHRyYW5zZm9ybWVkIHRvIGFuIGFic29sdXRlIHBvc2l0aW9uXG4gICAqIHdpdGgge0BsaW5rIGZyb21SZWxhdGl2ZVBvc2l0aW9ufS5cbiAgICpcbiAgICogUHJvIHRpcDogVXNlIHRoaXMgdG8gaW1wbGVtZW50IHNoYXJlZCBjdXJzb3IgbG9jYXRpb25zIGluIFlUZXh0IG9yIFlYbWwhXG4gICAqIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpcyB7QGxpbmsgZW5jb2RhYmxlfSwgc28geW91IGNhbiBzZW5kIGl0IHRvIG90aGVyXG4gICAqIGNsaWVudHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIGlzIGF0IHBvc2l0aW9uIDEwXG4gICAqIGxldCByZWxhdGl2ZVBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbih5VGV4dCwgMTApXG4gICAqIC8vIG1vZGlmeSB5VGV4dFxuICAgKiB5VGV4dC5pbnNlcnQoMCwgJ2FiYycpXG4gICAqIHlUZXh0LmRlbGV0ZSgzLCAxMClcbiAgICogLy8gQ29tcHV0ZSB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gICAqIGxldCBhYnNvbHV0ZVBvc2l0aW9uID0gZnJvbVJlbGF0aXZlUG9zaXRpb24oeSwgcmVsYXRpdmVQb3NpdGlvbilcbiAgICogYWJzb2x1dGVQb3NpdGlvbi50eXBlIC8vID0+IHlUZXh0XG4gICAqIGNvbnNvbGUubG9nKCdjdXJzb3IgbG9jYXRpb24gaXMgJyArIGFic29sdXRlUG9zaXRpb24ub2Zmc2V0KSAvLyA9PiBjdXJzb3IgbG9jYXRpb24gaXMgM1xuICAgKlxuICAgKiBAdHlwZWRlZiB7ZW5jb2RhYmxlfSBSZWxhdGl2ZVBvc2l0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZWxhdGl2ZVBvc2l0aW9uIGJhc2VkIG9uIGEgYWJzb2x1dGUgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7WVR5cGV9IHR5cGUgVGhlIGJhc2UgdHlwZSAoZS5nLiBZVGV4dCBvciBZQXJyYXkpLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IG9mZnNldCBUaGUgYWJzb2x1dGUgcG9zaXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIG9mZnNldCkge1xuICAgIC8vIFRPRE86IHJlbmFtZSB0byBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uXG4gICAgdmFyIHQgPSB0eXBlLl9zdGFydDtcbiAgICB3aGlsZSAodCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHQuX2RlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0Ll9sZW5ndGggPiBvZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gW3QuX2lkLnVzZXIsIHQuX2lkLmNsb2NrICsgb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgLT0gdC5fbGVuZ3RoO1xuICAgICAgfVxuICAgICAgdCA9IHQuX3JpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gWydlbmRvZicsIHR5cGUuX2lkLnVzZXIsIHR5cGUuX2lkLmNsb2NrIHx8IG51bGwsIHR5cGUuX2lkLm5hbWUgfHwgbnVsbCwgdHlwZS5faWQudHlwZSB8fCBudWxsXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBBYnNvbHV0ZVBvc2l0aW9uIFRoZSByZXN1bHQgb2Yge0BsaW5rIGZyb21SZWxhdGl2ZVBvc2l0aW9ufVxuICAgKiBAcHJvcGVydHkge1lUeXBlfSB0eXBlIFRoZSB0eXBlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZSBhYnNvbHV0ZSBwb3NpdGlvbi5cbiAgICogQHByb3BlcnR5IHtJbnRlZ2VyfSBvZmZzZXQgVGhlIGFic29sdXRlIG9mZnNldC5yXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGEgcmVsYXRpdmUgcG9zaXRpb24gYmFjayB0byBhIHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZSBpbiB3aGljaCB0byBxdWVyeSBmb3IgdGhlIGFic29sdXRlIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3MgVGhlIHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtBYnNvbHV0ZVBvc2l0aW9ufSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gaW4gdGhlIFlqcyBtb2RlbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSArIG9mZnNldCkuXG4gICAqL1xuICBmdW5jdGlvbiBmcm9tUmVsYXRpdmVQb3NpdGlvbih5LCBycG9zKSB7XG4gICAgaWYgKHJwb3NbMF0gPT09ICdlbmRvZicpIHtcbiAgICAgIHZhciBpZCA9IHZvaWQgMDtcbiAgICAgIGlmIChycG9zWzNdID09PSBudWxsKSB7XG4gICAgICAgIGlkID0gbmV3IElEKHJwb3NbMV0sIHJwb3NbMl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWQgPSBuZXcgUm9vdElEKHJwb3NbM10sIHJwb3NbNF0pO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB5Lm9zLmdldChpZCk7XG4gICAgICB3aGlsZSAodHlwZS5fcmVkb25lICE9PSBudWxsKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlLl9yZWRvbmU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlLmNvbnN0cnVjdG9yID09PSBHQykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIG9mZnNldDogdHlwZS5sZW5ndGhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIHN0cnVjdCA9IHkub3MuZmluZE5vZGVXaXRoVXBwZXJCb3VuZChuZXcgSUQocnBvc1swXSwgcnBvc1sxXSkpLnZhbDtcbiAgICAgIHZhciBkaWZmID0gcnBvc1sxXSAtIHN0cnVjdC5faWQuY2xvY2s7XG4gICAgICB3aGlsZSAoc3RydWN0Ll9yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgICAgc3RydWN0ID0gc3RydWN0Ll9yZWRvbmU7XG4gICAgICB9XG4gICAgICB2YXIgcGFyZW50ID0gc3RydWN0Ll9wYXJlbnQ7XG4gICAgICBpZiAoc3RydWN0LmNvbnN0cnVjdG9yID09PSBHQyB8fCBwYXJlbnQuX2RlbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cnVjdC5fZGVsZXRlZCkge1xuICAgICAgICBvZmZzZXQgPSBkaWZmO1xuICAgICAgfVxuICAgICAgc3RydWN0ID0gc3RydWN0Ll9sZWZ0O1xuICAgICAgd2hpbGUgKHN0cnVjdCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIXN0cnVjdC5fZGVsZXRlZCkge1xuICAgICAgICAgIG9mZnNldCArPSBzdHJ1Y3QuX2xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3QuX2xlZnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBwYXJlbnQsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IHJlbmFtZSBtdXRleFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbXV0dWFsIGV4Y2x1ZGUgZnVuY3Rpb24gd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnR5OlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBtdXR1YWxFeGNsdWRlID0gY3JlYXRlTXV0dWFsRXhjbHVkZSgpXG4gICAqIG11dHVhbEV4Y2x1ZGUoZnVuY3Rpb24gKCkge1xuICAgKiAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgaW1tZWRpYXRlbHkgZXhlY3V0ZWRcbiAgICogICBtdXR1YWxFeGNsdWRlKGZ1bmN0aW9uICgpIHtcbiAgICogICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbmV2ZXIgZXhlY3V0ZWQsIGFzIGl0IGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lXG4gICAqICAgICAvLyBtdXR1YWxFeGNsdWRlXG4gICAqICAgfSlcbiAgICogfSlcbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259IEEgbXV0dWFsIGV4Y2x1ZGUgZnVuY3Rpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlTXV0dWFsRXhjbHVkZSgpIHtcbiAgICB2YXIgdG9rZW4gPSB0cnVlO1xuICAgIHJldHVybiBmdW5jdGlvbiBtdXR1YWxFeGNsdWRlKGYpIHtcbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICB0b2tlbiA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGYoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWJzdHJhY3QgY2xhc3MgZm9yIGJpbmRpbmdzLlxuICAgKlxuICAgKiBBIGJpbmRpbmcgaGFuZGxlcyBkYXRhIGJpbmRpbmcgZnJvbSBhIFlqcyB0eXBlIHRvIGEgZGF0YSBvYmplY3QuIEZvciBleGFtcGxlLFxuICAgKiB5b3UgY2FuIGJpbmQgYSBRdWlsbCBlZGl0b3IgaW5zdGFuY2UgdG8gYSBZVGV4dCBpbnN0YW5jZSB3aXRoIHRoZSBgUXVpbGxCaW5kaW5nYCBjbGFzcy5cbiAgICpcbiAgICogSXQgaXMgZXhwZWN0ZWQgdGhhdCBhIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIGFjY2VwdHMgdHdvIHBhcmFtZXRlcnNcbiAgICogKHR5cGUgYW5kIGJpbmRpbmcgdGFyZ2V0KS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBjb25zdCBxdWlsbCA9IG5ldyBRdWlsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcbiAgICogICBjb25zdCB0eXBlID0geS5kZWZpbmUoJ3F1aWxsJywgWS5UZXh0KVxuICAgKiAgIGNvbnN0IGJpbmRpbmcgPSBuZXcgWS5RdWlsbEJpbmRpbmcocXVpbGwsIHR5cGUpXG4gICAqXG4gICAqL1xuXG4gIHZhciBCaW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7WVR5cGV9IHR5cGUgWWpzIHR5cGUuXG4gICAgICogQHBhcmFtIHthbnl9IHRhcmdldCBCaW5kaW5nIFRhcmdldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaW5kaW5nKHR5cGUsIHRhcmdldCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQmluZGluZyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIFlqcyB0eXBlIHRoYXQgaXMgYm91bmQgdG8gYHRhcmdldGBcbiAgICAgICAqIEB0eXBlIHtZVHlwZX1cbiAgICAgICAqL1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRhcmdldCB0aGF0IGB0eXBlYCBpcyBib3VuZCB0by5cbiAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICovXG4gICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgdGhpcy5fbXV0dWFsRXhjbHVkZSA9IGNyZWF0ZU11dHVhbEV4Y2x1ZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBkYXRhIG9ic2VydmVycyAoYm90aCBmcm9tIHRoZSB0eXBlIGFuZCB0aGUgdGFyZ2V0KS5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoQmluZGluZywgW3tcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEJpbmRpbmc7XG4gIH0oKTtcblxuICAvKiBnbG9iYWxzIGdldFNlbGVjdGlvbiAqL1xuXG4gIHZhciByZWxhdGl2ZVNlbGVjdGlvbiA9IG51bGw7XG5cbiAgZnVuY3Rpb24gX2dldEN1cnJlbnRSZWxhdGl2ZVNlbGVjdGlvbihkb21CaW5kaW5nKSB7XG4gICAgdmFyIF9nZXRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgYmFzZU5vZGUgPSBfZ2V0U2VsZWN0aW9uLmJhc2VOb2RlLFxuICAgICAgICBiYXNlT2Zmc2V0ID0gX2dldFNlbGVjdGlvbi5iYXNlT2Zmc2V0LFxuICAgICAgICBleHRlbnROb2RlID0gX2dldFNlbGVjdGlvbi5leHRlbnROb2RlLFxuICAgICAgICBleHRlbnRPZmZzZXQgPSBfZ2V0U2VsZWN0aW9uLmV4dGVudE9mZnNldDtcblxuICAgIHZhciBiYXNlTm9kZVR5cGUgPSBkb21CaW5kaW5nLmRvbVRvVHlwZS5nZXQoYmFzZU5vZGUpO1xuICAgIHZhciBleHRlbnROb2RlVHlwZSA9IGRvbUJpbmRpbmcuZG9tVG9UeXBlLmdldChleHRlbnROb2RlKTtcbiAgICBpZiAoYmFzZU5vZGVUeXBlICE9PSB1bmRlZmluZWQgJiYgZXh0ZW50Tm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogZ2V0UmVsYXRpdmVQb3NpdGlvbihiYXNlTm9kZVR5cGUsIGJhc2VPZmZzZXQpLFxuICAgICAgICB0bzogZ2V0UmVsYXRpdmVQb3NpdGlvbihleHRlbnROb2RlVHlwZSwgZXh0ZW50T2Zmc2V0KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZ2V0Q3VycmVudFJlbGF0aXZlU2VsZWN0aW9uID0gdHlwZW9mIGdldFNlbGVjdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBfZ2V0Q3VycmVudFJlbGF0aXZlU2VsZWN0aW9uIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uRml4ZXIoZG9tQmluZGluZywgcmVtb3RlKSB7XG4gICAgaWYgKHJlbW90ZSkge1xuICAgICAgcmVsYXRpdmVTZWxlY3Rpb24gPSBnZXRDdXJyZW50UmVsYXRpdmVTZWxlY3Rpb24oZG9tQmluZGluZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBhZnRlclRyYW5zYWN0aW9uU2VsZWN0aW9uRml4ZXIoZG9tQmluZGluZywgcmVtb3RlKSB7XG4gICAgaWYgKHJlbGF0aXZlU2VsZWN0aW9uICE9PSBudWxsICYmIHJlbW90ZSkge1xuICAgICAgZG9tQmluZGluZy5yZXN0b3JlU2VsZWN0aW9uKHJlbGF0aXZlU2VsZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKiBnbG9iYWwgZ2V0U2VsZWN0aW9uICovXG5cbiAgZnVuY3Rpb24gZmluZFNjcm9sbFJlZmVyZW5jZShzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgaWYgKHNjcm9sbGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBhbmNob3IgPSBnZXRTZWxlY3Rpb24oKS5hbmNob3JOb2RlO1xuICAgICAgaWYgKGFuY2hvciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHNjcm9sbGluZ0VsZW1lbnQuY2hpbGRyZW47IC8vIG9ubHkgaXRlcmF0ZSB0aHJvdWdoIG5vbi10ZXh0IG5vZGVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlbSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBpZiAocmVjdC50b3AgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZWxlbTogZWxlbSwgdG9wOiByZWN0LnRvcCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFuY2hvci5ub2RlVHlwZSA9PT0gZG9jdW1lbnQuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgYW5jaG9yID0gYW5jaG9yLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcCA9IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgIHJldHVybiB7IGVsZW06IGFuY2hvciwgdG9wOiB0b3AgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBmaXhTY3JvbGwoc2Nyb2xsaW5nRWxlbWVudCwgcmVmKSB7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGVsZW0gPSByZWYuZWxlbSxcbiAgICAgICAgICB0b3AgPSByZWYudG9wO1xuXG4gICAgICB2YXIgY3VycmVudFRvcCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgdmFyIG5ld1Njcm9sbCA9IHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wICsgY3VycmVudFRvcCAtIHRvcDtcbiAgICAgIGlmIChuZXdTY3JvbGwgPj0gMCkge1xuICAgICAgICBzY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCA9IG5ld1Njcm9sbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHR5cGVPYnNlcnZlcihldmVudHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fbXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2Nyb2xsUmVmID0gZmluZFNjcm9sbFJlZmVyZW5jZShfdGhpcy5zY3JvbGxpbmdFbGVtZW50KTtcbiAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgeXhtbCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgdmFyIGRvbSA9IF90aGlzLnR5cGVUb0RvbS5nZXQoeXhtbCk7XG4gICAgICAgIGlmIChkb20gIT09IHVuZGVmaW5lZCAmJiBkb20gIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKHl4bWwuY29uc3RydWN0b3IgPT09IFlYbWxUZXh0KSB7XG4gICAgICAgICAgICBkb20ubm9kZVZhbHVlID0geXhtbC50b1N0cmluZygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuYXR0cmlidXRlc0NoYW5nZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXNDaGFuZ2VkLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0geXhtbC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVE9ETzogaW5zdGVhZCBvZiBoYXJkLWNoZWNraW5nIHRoZSB0eXBlcywgaXQgd291bGQgYmUgYmVzdCB0b1xuICAgICAgICAgICAgICogICAgICAgc3BlY2lmeSB0aGUgdHlwZSdzIGZlYXR1cmVzLiBFLmcuXG4gICAgICAgICAgICAgKiAgICAgICAgIC0gX3l4bWxIYXNBdHRyaWJ1dGVzXG4gICAgICAgICAgICAgKiAgICAgICAgIC0gX3l4bWxIYXNDaGlsZHJlblxuICAgICAgICAgICAgICogICAgICAgRnVydGhlcm1vcmUsIHRoZSBmZWF0dXJlcyBzaG91bGRuJ3QgYmUgZW5jb2RlZCBpbiB0aGUgdHlwZXMsXG4gICAgICAgICAgICAgKiAgICAgICBvbmx5IGluIHRoZSBhdHRyaWJ1dGVzIChhYm92ZSlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGV2ZW50LmNoaWxkTGlzdENoYW5nZWQgJiYgeXhtbC5jb25zdHJ1Y3RvciAhPT0gWVhtbEhvb2spIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZCA9IGRvbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICB5eG1sLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBfdGhpcy50eXBlVG9Eb20uZ2V0KGNoaWxkVHlwZSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgICAgICAvLyBEb2VzIG5vdCBleGlzdC4gQ3JlYXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNoaWxkVHlwZS50b0RvbShfdGhpcy5vcHRzLmRvY3VtZW50LCBfdGhpcy5vcHRzLmhvb2tzLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5pbnNlcnRCZWZvcmUobm9kZSwgY3VycmVudENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgICAgICAgICAvLyBub3BcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBJcyBhbHJlYWR5IGF0dGFjaGVkIHRvIHRoZSBkb20uXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgaXQgYW5kIHJlbW92ZSBhbGwgZG9tIG5vZGVzIGluLWJldHdlZW4uXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbUNoaWxkcmVuVW50aWxFbGVtZW50Rm91bmQoZG9tLCBjdXJyZW50Q2hpbGQsIGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGlsZCA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVtb3ZlRG9tQ2hpbGRyZW5VbnRpbEVsZW1lbnRGb3VuZChkb20sIGN1cnJlbnRDaGlsZCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZpeFNjcm9sbChfdGhpcy5zY3JvbGxpbmdFbGVtZW50LCBzY3JvbGxSZWYpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgU2ltcGxlRGlmZiBkZXNjcmliZXMgYSBjaGFuZ2Ugb24gYSBTdHJpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnNvbGUubG9nKGEpIC8vIHRoZSBvbGQgdmFsdWVcbiAgICogY29uc29sZS5sb2coYikgLy8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgICogLy8gQXBwbHkgY2hhbmdlcyBvZiBkaWZmIChwc2V1ZG9jb2RlKVxuICAgKiBhLnJlbW92ZShkaWZmLnBvcywgZGlmZi5yZW1vdmUpIC8vIFJlbW92ZSBgZGlmZi5yZW1vdmVgIGNoYXJhY3RlcnNcbiAgICogYS5pbnNlcnQoZGlmZi5wb3MsIGRpZmYuaW5zZXJ0KSAvLyBJbnNlcnQgYGRpZmYuaW5zZXJ0YFxuICAgKiBhID09PSBiIC8vIHZhbHVlcyBtYXRjaFxuICAgKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTaW1wbGVEaWZmXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwb3MgVGhlIGluZGV4IHdoZXJlIGNoYW5nZXMgd2VyZSBhcHBsaWVkXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWxldGUgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGRlbGV0ZSBzdGFydGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdCBgaW5kZXhgLlxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gaW5zZXJ0IFRoZSBuZXcgdGV4dCB0byBpbnNlcnQgYXQgYGluZGV4YCBhZnRlciBhcHBseWluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGBkZWxldGVgXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkaWZmIGJldHdlZW4gdHdvIHN0cmluZ3MuIFRoaXMgZGlmZiBpbXBsZW1lbnRhdGlvbiBpcyBoaWdobHlcbiAgICogZWZmaWNpZW50LCBidXQgbm90IHZlcnkgc29waGlzdGljYXRlZC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYSBUaGUgb2xkIHZlcnNpb24gb2YgdGhlIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYiBUaGUgdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmdcbiAgICogQHJldHVybiB7U2ltcGxlRGlmZn0gVGhlIGRpZmYgZGVzY3JpcHRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBzaW1wbGVEaWZmKGEsIGIpIHtcbiAgICB2YXIgbGVmdCA9IDA7IC8vIG51bWJlciBvZiBzYW1lIGNoYXJhY3RlcnMgY291bnRpbmcgZnJvbSBsZWZ0XG4gICAgdmFyIHJpZ2h0ID0gMDsgLy8gbnVtYmVyIG9mIHNhbWUgY2hhcmFjdGVycyBjb3VudGluZyBmcm9tIHJpZ2h0XG4gICAgd2hpbGUgKGxlZnQgPCBhLmxlbmd0aCAmJiBsZWZ0IDwgYi5sZW5ndGggJiYgYVtsZWZ0XSA9PT0gYltsZWZ0XSkge1xuICAgICAgbGVmdCsrO1xuICAgIH1cbiAgICBpZiAobGVmdCAhPT0gYS5sZW5ndGggfHwgbGVmdCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIC8vIE9ubHkgY2hlY2sgcmlnaHQgaWYgYSAhPT0gYlxuICAgICAgd2hpbGUgKHJpZ2h0ICsgbGVmdCA8IGEubGVuZ3RoICYmIHJpZ2h0ICsgbGVmdCA8IGIubGVuZ3RoICYmIGFbYS5sZW5ndGggLSByaWdodCAtIDFdID09PSBiW2IubGVuZ3RoIC0gcmlnaHQgLSAxXSkge1xuICAgICAgICByaWdodCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zOiBsZWZ0LCAvLyBUT0RPOiByZW5hbWUgdG8gaW5kZXggKGFsc28gaW4gdHlwZSBhYm92ZSlcbiAgICAgIHJlbW92ZTogYS5sZW5ndGggLSBsZWZ0IC0gcmlnaHQsXG4gICAgICBpbnNlcnQ6IGIuc2xpY2UobGVmdCwgYi5sZW5ndGggLSByaWdodClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIDEuIENoZWNrIGlmIGFueSBvZiB0aGUgbm9kZXMgd2FzIGRlbGV0ZWRcbiAgICogMi4gSXRlcmF0ZSBvdmVyIHRoZSBjaGlsZHJlbi5cbiAgICogICAgMi4xIElmIGEgbm9kZSBleGlzdHMgdGhhdCBpcyBub3QgeWV0IGJvdW5kIHRvIGEgdHlwZSwgaW5zZXJ0IGEgbmV3IG5vZGVcbiAgICogICAgMi4yIElmIF9jb250ZW50cy5sZW5ndGggPCBkb20uY2hpbGROb2Rlcy5sZW5ndGgsIGZpbGwgdGhlXG4gICAqICAgICAgICByZXN0IG9mIF9jb250ZW50IHdpdGggY2hpbGROb2Rlc1xuICAgKiAgICAyLjMgSWYgYSBub2RlIHdhcyBtb3ZlZCwgZGVsZXRlIGl0IGFuZFxuICAgKiAgICAgICByZWNyZWF0ZSBhIG5ldyB5eG1sIGVsZW1lbnQgdGhhdCBpcyBib3VuZCB0byB0aGF0IG5vZGUuXG4gICAqICAgICAgIFlvdSBjYW4gZGV0ZWN0IHRoYXQgYSBub2RlIHdhcyBtb3ZlZCBiZWNhdXNlIGV4cGVjdGVkSWRcbiAgICogICAgICAgIT09IGFjdHVhbElkIGluIHRoZSBsaXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseUNoYW5nZXNGcm9tRG9tKGJpbmRpbmcsIGRvbSwgeXhtbCwgX2RvY3VtZW50KSB7XG4gICAgaWYgKHl4bWwgPT0gbnVsbCB8fCB5eG1sID09PSBmYWxzZSB8fCB5eG1sLmNvbnN0cnVjdG9yID09PSBZWG1sSG9vaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgeSA9IHl4bWwuX3k7XG4gICAgdmFyIGtub3duQ2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IGRvbS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdHlwZSA9IGJpbmRpbmcuZG9tVG9UeXBlLmdldChkb20uY2hpbGROb2Rlc1tpXSk7XG4gICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGtub3duQ2hpbGRyZW4uYWRkKHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyAxLiBDaGVjayBpZiBhbnkgb2YgdGhlIG5vZGVzIHdhcyBkZWxldGVkXG4gICAgeXhtbC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFR5cGUpIHtcbiAgICAgIGlmIChrbm93bkNoaWxkcmVuLmhhcyhjaGlsZFR5cGUpID09PSBmYWxzZSkge1xuICAgICAgICBjaGlsZFR5cGUuX2RlbGV0ZSh5KTtcbiAgICAgICAgcmVtb3ZlQXNzb2NpYXRpb24oYmluZGluZywgYmluZGluZy50eXBlVG9Eb20uZ2V0KGNoaWxkVHlwZSksIGNoaWxkVHlwZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gMi4gaXRlcmF0ZVxuICAgIHZhciBjaGlsZE5vZGVzID0gZG9tLmNoaWxkTm9kZXM7XG4gICAgdmFyIGxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIHZhciBwcmV2RXhwZWN0ZWRUeXBlID0gbnVsbDtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gaXRlcmF0ZVVudGlsVW5kZWxldGVkKHl4bWwuX3N0YXJ0KTtcbiAgICBmb3IgKHZhciBkb21DbnQgPSAwOyBkb21DbnQgPCBsZW47IGRvbUNudCsrKSB7XG4gICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tkb21DbnRdO1xuICAgICAgdmFyIGNoaWxkVHlwZSA9IGJpbmRpbmcuZG9tVG9UeXBlLmdldChjaGlsZE5vZGUpO1xuICAgICAgaWYgKGNoaWxkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChjaGlsZFR5cGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gc2hvdWxkIGJlIGlnbm9yZWQgb3IgaXMgZ29pbmcgdG8gYmUgZGVsZXRlZFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZFR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWRUeXBlICE9PSBjaGlsZFR5cGUpIHtcbiAgICAgICAgICAgIC8vIDIuMyBOb3QgZXhwZWN0ZWQgbm9kZVxuICAgICAgICAgICAgaWYgKGNoaWxkVHlwZS5fcGFyZW50ICE9PSB5eG1sKSB7XG4gICAgICAgICAgICAgIC8vIGNoaWxkIHdhcyBtb3ZlZCBmcm9tIGFub3RoZXIgcGFyZW50XG4gICAgICAgICAgICAgIC8vIGNoaWxkVHlwZSBpcyBnb2luZyB0byBiZSBkZWxldGVkIGJ5IGl0cyBwcmV2aW91cyBwYXJlbnRcbiAgICAgICAgICAgICAgcmVtb3ZlQXNzb2NpYXRpb24oYmluZGluZywgY2hpbGROb2RlLCBjaGlsZFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY2hpbGQgd2FzIG1vdmVkIHRvIGEgZGlmZmVyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICByZW1vdmVBc3NvY2lhdGlvbihiaW5kaW5nLCBjaGlsZE5vZGUsIGNoaWxkVHlwZSk7XG4gICAgICAgICAgICAgIGNoaWxkVHlwZS5fZGVsZXRlKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkV4cGVjdGVkVHlwZSA9IGluc2VydE5vZGVIZWxwZXIoeXhtbCwgcHJldkV4cGVjdGVkVHlwZSwgY2hpbGROb2RlLCBfZG9jdW1lbnQsIGJpbmRpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBleHBlY3RlZCBub2RlLiBDb250aW51ZS5cbiAgICAgICAgICAgIHByZXZFeHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGU7XG4gICAgICAgICAgICBleHBlY3RlZFR5cGUgPSBpdGVyYXRlVW50aWxVbmRlbGV0ZWQoZXhwZWN0ZWRUeXBlLl9yaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDIuMiBGaWxsIF9jb250ZW50IHdpdGggY2hpbGQgbm9kZXNcbiAgICAgICAgICBwcmV2RXhwZWN0ZWRUeXBlID0gaW5zZXJ0Tm9kZUhlbHBlcih5eG1sLCBwcmV2RXhwZWN0ZWRUeXBlLCBjaGlsZE5vZGUsIF9kb2N1bWVudCwgYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDIuMSBBIG5ldyBub2RlIHdhcyBmb3VuZFxuICAgICAgICBwcmV2RXhwZWN0ZWRUeXBlID0gaW5zZXJ0Tm9kZUhlbHBlcih5eG1sLCBwcmV2RXhwZWN0ZWRUeXBlLCBjaGlsZE5vZGUsIF9kb2N1bWVudCwgYmluZGluZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBkb21PYnNlcnZlcihtdXRhdGlvbnMsIF9kb2N1bWVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9tdXR1YWxFeGNsdWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnR5cGUuX3kudHJhbnNhY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGlmZkNoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICB2YXIgZG9tID0gbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICAgIHZhciB5eG1sID0gX3RoaXMuZG9tVG9UeXBlLmdldChkb20pO1xuICAgICAgICAgIGlmICh5eG1sID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgeXhtbCBpcyB1bmRlZmluZWQsIHdlIGRvdWJsZSBjaGVjayBpZiB3ZSBmb3Jnb3QgdG8gYmluZCB0aGUgZG9tXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZG9tO1xuICAgICAgICAgICAgdmFyIHlQYXJlbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICB5UGFyZW50ID0gX3RoaXMuZG9tVG9UeXBlLmdldChwYXJlbnQpO1xuICAgICAgICAgICAgfSB3aGlsZSAoeVBhcmVudCA9PT0gdW5kZWZpbmVkICYmIHBhcmVudCAhPT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAoeVBhcmVudCAhPT0gZmFsc2UgJiYgeVBhcmVudCAhPT0gdW5kZWZpbmVkICYmIHlQYXJlbnQuY29uc3RydWN0b3IgIT09IFlYbWxIb29rKSB7XG4gICAgICAgICAgICAgIGRpZmZDaGlsZHJlbi5hZGQocGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHl4bWwgPT09IGZhbHNlIHx8IHl4bWwuY29uc3RydWN0b3IgPT09IFlYbWxIb29rKSB7XG4gICAgICAgICAgICAvLyBkb20gZWxlbWVudCBpcyBmaWx0ZXJlZCAvIGEgZG9tIGhvb2tcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChtdXRhdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjaGFyYWN0ZXJEYXRhJzpcbiAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IHNpbXBsZURpZmYoeXhtbC50b1N0cmluZygpLCBkb20ubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgeXhtbC5kZWxldGUoY2hhbmdlLnBvcywgY2hhbmdlLnJlbW92ZSk7XG4gICAgICAgICAgICAgIHl4bWwuaW5zZXJ0KGNoYW5nZS5wb3MsIGNoYW5nZS5pbnNlcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICBpZiAoeXhtbC5jb25zdHJ1Y3RvciA9PT0gWVhtbEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgICB2YXIgdmFsID0gZG9tLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZmlsdGVyIGFjY2VwdHMgYXR0cmlidXRlXG4gICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnNldChuYW1lLCB2YWwpO1xuICAgICAgICAgICAgICBpZiAoeXhtbC5jb25zdHJ1Y3RvciAhPT0gWVhtbEZyYWdtZW50ICYmIF90aGlzLmZpbHRlcihkb20ubm9kZU5hbWUsIGF0dHJpYnV0ZXMpLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHl4bWwuZ2V0QXR0cmlidXRlKG5hbWUpICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB5eG1sLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHl4bWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgZGlmZkNoaWxkcmVuLmFkZChtdXRhdGlvbi50YXJnZXQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBkaWZmQ2hpbGRyZW5bU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIHZhciB5eG1sID0gX3RoaXMuZG9tVG9UeXBlLmdldChkb20pO1xuICAgICAgICAgICAgYXBwbHlDaGFuZ2VzRnJvbURvbShfdGhpcywgZG9tLCB5eG1sLCBfZG9jdW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyogZ2xvYmFsIE11dGF0aW9uT2JzZXJ2ZXIsIGdldFNlbGVjdGlvbiAqL1xuXG4gIC8qKlxuICAgKiBBIGJpbmRpbmcgdGhhdCBiaW5kcyB0aGUgY2hpbGRyZW4gb2YgYSBZWG1sRnJhZ21lbnQgdG8gYSBET00gZWxlbWVudC5cbiAgICpcbiAgICogVGhpcyBiaW5kaW5nIGlzIGF1dG9tYXRpY2FsbHkgZGVzdHJveWVkIHdoZW4gaXRzIHBhcmVudCBpcyBkZWxldGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgKiBjb25zdCB0eXBlID0geS5kZWZpbmUoJ3htbCcsIFkuWG1sRnJhZ21lbnQpXG4gICAqIGNvbnN0IGJpbmRpbmcgPSBuZXcgWS5RdWlsbEJpbmRpbmcodHlwZSwgZGl2KVxuICAgKlxuICAgKi9cblxuICB2YXIgRG9tQmluZGluZyA9IGZ1bmN0aW9uIChfQmluZGluZykge1xuICAgIGluaGVyaXRzKERvbUJpbmRpbmcsIF9CaW5kaW5nKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7WVhtbEZyYWdtZW50fSB0eXBlIFRoZSBiaW5kIHNvdXJjZS4gVGhpcyBpcyB0aGUgdWx0aW1hdGUgc291cmNlIG9mXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1dGguXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIGJpbmQgdGFyZ2V0LiBNaXJyb3JzIHRoZSB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBPcHRpb25hbCBjb25maWd1cmF0aW9uc1xuICAgICAgKiBAcGFyYW0ge0ZpbHRlckZ1bmN0aW9ufSBbb3B0cy5maWx0ZXI9ZGVmYXVsdEZpbHRlcl0gVGhlIGZpbHRlciBmdW5jdGlvbiB0byB1c2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRG9tQmluZGluZyh0eXBlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERvbUJpbmRpbmcpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEb21CaW5kaW5nLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRG9tQmluZGluZykpLmNhbGwodGhpcywgdHlwZSwgdGFyZ2V0KSk7XG4gICAgICAvLyBCaW5kaW5nIGhhbmRsZXMgdGV4dFR5cGUgYXMgdGhpcy50eXBlIGFuZCBkb21UZXh0YXJlYSBhcyB0aGlzLnRhcmdldFxuXG5cbiAgICAgIF90aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgb3B0cy5kb2N1bWVudCA9IG9wdHMuZG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgICBvcHRzLmhvb2tzID0gb3B0cy5ob29rcyB8fCB7fTtcbiAgICAgIF90aGlzLnNjcm9sbGluZ0VsZW1lbnQgPSBvcHRzLnNjcm9sbGluZ0VsZW1lbnQgfHwgbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogTWFwcyBlYWNoIERPTSBlbGVtZW50IHRvIHRoZSB0eXBlIHRoYXQgaXQgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICAgICogQHR5cGUge01hcH1cbiAgICAgICAqL1xuICAgICAgX3RoaXMuZG9tVG9UeXBlID0gbmV3IE1hcCgpO1xuICAgICAgLyoqXG4gICAgICAgKiBNYXBzIGVhY2ggWVhtbCB0eXBlIHRvIHRoZSBET00gZWxlbWVudCB0aGF0IGl0IGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAgICAqIEB0eXBlIHtNYXB9XG4gICAgICAgKi9cbiAgICAgIF90aGlzLnR5cGVUb0RvbSA9IG5ldyBNYXAoKTtcbiAgICAgIC8qKlxuICAgICAgICogRGVmaW5lcyB3aGljaCBET00gYXR0cmlidXRlcyBhbmQgZWxlbWVudHMgdG8gZmlsdGVyIG91dC5cbiAgICAgICAqIEFsc28gZmlsdGVycyByZW1vdGUgY2hhbmdlcy5cbiAgICAgICAqIEB0eXBlIHtGaWx0ZXJGdW5jdGlvbn1cbiAgICAgICAqL1xuICAgICAgX3RoaXMuZmlsdGVyID0gb3B0cy5maWx0ZXIgfHwgZGVmYXVsdEZpbHRlcjtcbiAgICAgIC8vIHNldCBpbml0aWFsIHZhbHVlXG4gICAgICB0YXJnZXQuaW5uZXJIVE1MID0gJyc7XG4gICAgICB0eXBlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoY2hpbGQudG9Eb20ob3B0cy5kb2N1bWVudCwgb3B0cy5ob29rcywgX3RoaXMpLCBudWxsKTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMuX3R5cGVPYnNlcnZlciA9IHR5cGVPYnNlcnZlci5iaW5kKF90aGlzKTtcbiAgICAgIF90aGlzLl9kb21PYnNlcnZlciA9IGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICAgICAgZG9tT2JzZXJ2ZXIuY2FsbChfdGhpcywgbXV0YXRpb25zLCBvcHRzLmRvY3VtZW50KTtcbiAgICAgIH07XG4gICAgICB0eXBlLm9ic2VydmVEZWVwKF90aGlzLl90eXBlT2JzZXJ2ZXIpO1xuICAgICAgX3RoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihfdGhpcy5fZG9tT2JzZXJ2ZXIpO1xuICAgICAgX3RoaXMuX211dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIF90aGlzLl9jdXJyZW50U2VsID0gbnVsbDtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX2N1cnJlbnRTZWwgPSBnZXRDdXJyZW50UmVsYXRpdmVTZWxlY3Rpb24oX3RoaXMpO1xuICAgICAgfSk7XG4gICAgICB2YXIgeSA9IHR5cGUuX3k7XG4gICAgICBfdGhpcy55ID0geTtcbiAgICAgIC8vIEZvcmNlIGZsdXNoIGRvbSBjaGFuZ2VzIGJlZm9yZSBUeXBlIGNoYW5nZXMgYXJlIGFwcGxpZWQgKHRoZXkgbWlnaHRcbiAgICAgIC8vIG1vZGlmeSB0aGUgZG9tKVxuICAgICAgX3RoaXMuX2JlZm9yZVRyYW5zYWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICh5LCB0cmFuc2FjdGlvbiwgcmVtb3RlKSB7XG4gICAgICAgIF90aGlzLl9kb21PYnNlcnZlcihfdGhpcy5fbXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICAgICAgX3RoaXMuX211dHVhbEV4Y2x1ZGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uRml4ZXIoX3RoaXMsIHJlbW90ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHkub24oJ2JlZm9yZVRyYW5zYWN0aW9uJywgX3RoaXMuX2JlZm9yZVRyYW5zYWN0aW9uSGFuZGxlcik7XG4gICAgICBfdGhpcy5fYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoeSwgdHJhbnNhY3Rpb24sIHJlbW90ZSkge1xuICAgICAgICBfdGhpcy5fbXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYWZ0ZXJUcmFuc2FjdGlvblNlbGVjdGlvbkZpeGVyKF90aGlzLCByZW1vdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVtb3ZlIGFzc29jaWF0aW9uc1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGNvdWxkIGJlIGRvbmUgbW9yZSBlZmZpY2llbnRseVxuICAgICAgICAvLyBlLmcuIEFsd2F5cyBkZWxldGUgdXNpbmcgdGhlIGZvbGxvd2luZyBhcHByb2FjaCwgb3IgcmVtb3ZlQXNzb2NpYXRpb25cbiAgICAgICAgLy8gaW4gZG9tL3R5cGUtb2JzZXJ2ZXIuLlxuICAgICAgICB0cmFuc2FjdGlvbi5kZWxldGVkU3RydWN0cy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdmFyIGRvbSA9IF90aGlzLnR5cGVUb0RvbS5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKGRvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZW1vdmVBc3NvY2lhdGlvbihfdGhpcywgZG9tLCB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHkub24oJ2FmdGVyVHJhbnNhY3Rpb24nLCBfdGhpcy5fYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIpO1xuICAgICAgLy8gQmVmb3JlIGNhbGxpbmcgb2JzZXJ2ZXJzLCBhcHBseSBkb20gZmlsdGVyIHRvIGFsbCBjaGFuZ2VkIGFuZCBuZXcgdHlwZXMuXG4gICAgICBfdGhpcy5fYmVmb3JlT2JzZXJ2ZXJDYWxsc0hhbmRsZXIgPSBmdW5jdGlvbiAoeSwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gQXBwbHkgZG9tIGZpbHRlciB0byBuZXcgYW5kIGNoYW5nZWQgdHlwZXNcbiAgICAgICAgdHJhbnNhY3Rpb24uY2hhbmdlZFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHN1YnMsIHR5cGUpIHtcbiAgICAgICAgICAvLyBPbmx5IGNoZWNrIGF0dHJpYnV0ZXMuIE5ldyB0eXBlcyBhcmUgZmlsdGVyZWQgYmVsb3cuXG4gICAgICAgICAgaWYgKHN1YnMuc2l6ZSA+IDEgfHwgc3Vicy5zaXplID09PSAxICYmIHN1YnMuaGFzKG51bGwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXBwbHlGaWx0ZXJPblR5cGUoeSwgX3RoaXMsIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLm5ld1R5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICBhcHBseUZpbHRlck9uVHlwZSh5LCBfdGhpcywgdHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHkub24oJ2JlZm9yZU9ic2VydmVyQ2FsbHMnLCBfdGhpcy5fYmVmb3JlT2JzZXJ2ZXJDYWxsc0hhbmRsZXIpO1xuICAgICAgY3JlYXRlQXNzb2NpYXRpb24oX3RoaXMsIHRhcmdldCwgdHlwZSk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTk9URTogY3VycmVudGx5IGRvZXMgbm90IGFwcGx5IGZpbHRlciB0byBleGlzdGluZyBlbGVtZW50cyFcbiAgICAgKiBAcGFyYW0ge0ZpbHRlckZ1bmN0aW9ufSBmaWx0ZXIgVGhlIGZpbHRlciBmdW5jdGlvbiB0byB1c2UgZnJvbSBub3cgb24uXG4gICAgICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKERvbUJpbmRpbmcsIFt7XG4gICAgICBrZXk6ICdzZXRGaWx0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIC8vIFRPRE86IGFwcGx5IGZpbHRlciB0byBhbGwgZWxlbWVudHNcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2V0VW5kb1N0YWNrSW5mbycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFVuZG9TdGFja0luZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZXN0b3JlVW5kb1N0YWNrSW5mbycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmVVbmRvU3RhY2tJbmZvKGluZm8pIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlU2VsZWN0aW9uKGluZm8pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFNlbGVjdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFNlbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZXN0b3JlU2VsZWN0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHRvID0gc2VsZWN0aW9uLnRvLFxuICAgICAgICAgICAgICBmcm9tID0gc2VsZWN0aW9uLmZyb207XG5cbiAgICAgICAgICB2YXIgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlcmUgaXMgbGl0dGxlIGluZm9ybWF0aW9uIG9uIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYW5jaG9yL2ZvY3VzIGFuZCBiYXNlL2V4dGVudC5cbiAgICAgICAgICAgKiBNRE4gZG9lc24ndCBldmVuIG1lbnRpb24gYmFzZS9leHRlbnQgYW55bW9yZS4uIHRob3VnaCB5b3Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgICAgICAgICogc2V0QmFzZUFuZEV4dGVudCB0byBjaGFuZ2UgdGhlIHNlbGVjdGlvbi4uXG4gICAgICAgICAgICogSSBjYW4gb2JzZXJ2ZSB0aGF0IGJhc2UvZXh0ZW5kIHJlZmVyIHRvIG5vdGVzIGhpZ2hlciB1cCBpbiB0aGUgeG1sIGhpZXJhY2h5LlxuICAgICAgICAgICAqIEVzcGVzaWFsbHkgZm9yIHVuZG8vcmVkbyB0aGlzIGlzIHByZWZlcnJlZC4gSWYgdGhpcyBiZWNvbWVzIGEgcHJvYmxlbSBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAgICAqIHdlIHNob3VsZCBwcm9iYWJseSBnbyBiYWNrIHRvIGFuY2hvci9mb2N1cy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB2YXIgYnJvd3NlclNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbigpO1xuICAgICAgICAgIHZhciBiYXNlTm9kZSA9IGJyb3dzZXJTZWxlY3Rpb24uYmFzZU5vZGUsXG4gICAgICAgICAgICAgIGJhc2VPZmZzZXQgPSBicm93c2VyU2VsZWN0aW9uLmJhc2VPZmZzZXQsXG4gICAgICAgICAgICAgIGV4dGVudE5vZGUgPSBicm93c2VyU2VsZWN0aW9uLmV4dGVudE5vZGUsXG4gICAgICAgICAgICAgIGV4dGVudE9mZnNldCA9IGJyb3dzZXJTZWxlY3Rpb24uZXh0ZW50T2Zmc2V0O1xuXG4gICAgICAgICAgaWYgKGZyb20gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzZWwgPSBmcm9tUmVsYXRpdmVQb3NpdGlvbih0aGlzLnksIGZyb20pO1xuICAgICAgICAgICAgaWYgKHNlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMudHlwZVRvRG9tLmdldChzZWwudHlwZSk7XG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzZWwub2Zmc2V0O1xuICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gYmFzZU5vZGUgfHwgb2Zmc2V0ICE9PSBiYXNlT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYmFzZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIGJhc2VPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfc2VsID0gZnJvbVJlbGF0aXZlUG9zaXRpb24odGhpcy55LCB0byk7XG4gICAgICAgICAgICBpZiAoX3NlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgX25vZGUgPSB0aGlzLnR5cGVUb0RvbS5nZXQoX3NlbC50eXBlKTtcbiAgICAgICAgICAgICAgdmFyIF9vZmZzZXQgPSBfc2VsLm9mZnNldDtcbiAgICAgICAgICAgICAgaWYgKF9ub2RlICE9PSBleHRlbnROb2RlIHx8IF9vZmZzZXQgIT09IGV4dGVudE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGV4dGVudE5vZGUgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICBleHRlbnRPZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgYnJvd3NlclNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KGJhc2VOb2RlLCBiYXNlT2Zmc2V0LCBleHRlbnROb2RlLCBleHRlbnRPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgcHJvcGVydGllcyB0aGF0IGFyZSBoYW5kbGVkIGJ5IHRoaXMgY2xhc3MuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZG9tVG9UeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy50eXBlVG9Eb20gPSBudWxsO1xuICAgICAgICB0aGlzLnR5cGUudW5vYnNlcnZlRGVlcCh0aGlzLl90eXBlT2JzZXJ2ZXIpO1xuICAgICAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnR5cGUuX3k7XG4gICAgICAgIHkub2ZmKCdiZWZvcmVUcmFuc2FjdGlvbicsIHRoaXMuX2JlZm9yZVRyYW5zYWN0aW9uSGFuZGxlcik7XG4gICAgICAgIHkub2ZmKCdiZWZvcmVPYnNlcnZlckNhbGxzJywgdGhpcy5fYmVmb3JlT2JzZXJ2ZXJDYWxsc0hhbmRsZXIpO1xuICAgICAgICB5Lm9mZignYWZ0ZXJUcmFuc2FjdGlvbicsIHRoaXMuX2FmdGVyVHJhbnNhY3Rpb25IYW5kbGVyKTtcbiAgICAgICAgZ2V0KERvbUJpbmRpbmcucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRG9tQmluZGluZy5wcm90b3R5cGUpLCAnZGVzdHJveScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBEb21CaW5kaW5nO1xuICB9KEJpbmRpbmcpO1xuXG4gIC8qKlxuICAgKiBBbnl0aGluZyB0aGF0IGNhbiBiZSBlbmNvZGVkIHdpdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgY2FuIGJlIGRlY29kZWQgd2l0aFxuICAgKiBgSlNPTi5wYXJzZWAuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydHkgc2hvdWxkIGhvbGQ6XG4gICAqIGBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGtleSkpPT09a2V5YFxuICAgKlxuICAgKiBBdCB0aGUgbW9tZW50IHRoZSBvbmx5IHNhZmUgdmFsdWVzIGFyZSBudW1iZXIgYW5kIHN0cmluZy5cbiAgICpcbiAgICogQHR5cGVkZWYgeyhudW1iZXJ8c3RyaW5nKX0gZW5jb2RhYmxlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIFlqcyBpbnN0YW5jZSBoYW5kbGVzIHRoZSBzdGF0ZSBvZiBzaGFyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb20gVXNlcnMgaW4gdGhlIHNhbWUgcm9vbSBzaGFyZSB0aGUgc2FtZSBjb250ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIENvbm5lY3RvciBkZWZpbml0aW9uXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RQZXJzaXN0ZW5jZX0gcGVyc2lzdGVuY2UgUGVyc2lzdGVuY2UgYWRhcHRlciBpbnN0YW5jZVxuICAgKi9cblxuICB2YXIgWSA9IGZ1bmN0aW9uIChfTmFtZWRFdmVudEhhbmRsZXIpIHtcbiAgICBpbmhlcml0cyhZLCBfTmFtZWRFdmVudEhhbmRsZXIpO1xuXG4gICAgZnVuY3Rpb24gWShyb29tLCBvcHRzLCBwZXJzaXN0ZW5jZSkge1xuICAgICAgdmFyIGNvbmYgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWSk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFkuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZKSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgIF90aGlzLmdjRW5hYmxlZCA9IGNvbmYuZ2MgfHwgZmFsc2U7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSByb29tIG5hbWUgdGhhdCB0aGlzIFlqcyBpbnN0YW5jZSBjb25uZWN0cyB0by5cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIF90aGlzLnJvb20gPSByb29tO1xuICAgICAgaWYgKG9wdHMgIT0gbnVsbCkge1xuICAgICAgICBvcHRzLmNvbm5lY3Rvci5yb29tID0gcm9vbTtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9jb250ZW50UmVhZHkgPSBmYWxzZTtcbiAgICAgIF90aGlzLl9vcHRzID0gb3B0cztcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy51c2VySUQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIF90aGlzLnVzZXJJRCA9IGdlbmVyYXRlUmFuZG9tVWludDMyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy51c2VySUQgPSBvcHRzLnVzZXJJRDtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIGEgTWFwIHNvIHdlIGNhbiB1c2UgZW5jb2RhYmxlcyBhcyBrZXlzXG4gICAgICBfdGhpcy5zaGFyZSA9IHt9O1xuICAgICAgX3RoaXMuZHMgPSBuZXcgRGVsZXRlU3RvcmUoX3RoaXMpO1xuICAgICAgX3RoaXMub3MgPSBuZXcgT3BlcmF0aW9uU3RvcmUoX3RoaXMpO1xuICAgICAgX3RoaXMuc3MgPSBuZXcgU3RhdGVTdG9yZShfdGhpcyk7XG4gICAgICBfdGhpcy5fbWlzc2luZ1N0cnVjdHMgPSBuZXcgTWFwKCk7XG4gICAgICBfdGhpcy5fcmVhZHlUb0ludGVncmF0ZSA9IFtdO1xuICAgICAgX3RoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHtAbGluayBBYnN0cmFjdENvbm5lY3Rvcn0udGhhdCBpcyB1c2VkIGJ5IHRoaXMgWWpzIGluc3RhbmNlLlxuICAgICAgICogQHR5cGUge0Fic3RyYWN0Q29ubmVjdG9yfVxuICAgICAgICovXG4gICAgICBfdGhpcy5jb25uZWN0b3IgPSBudWxsO1xuICAgICAgX3RoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB2YXIgaW5pdENvbm5lY3Rpb24gPSBmdW5jdGlvbiBpbml0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKG9wdHMgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLmNvbm5lY3RvciA9IG5ldyBZW29wdHMuY29ubmVjdG9yLm5hbWVdKF90aGlzLCBvcHRzLmNvbm5lY3Rvcik7XG4gICAgICAgICAgX3RoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBfdGhpcy5lbWl0KCdjb25uZWN0b3JSZWFkeScpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUge0BsaW5rIEFic3RyYWN0UGVyc2lzdGVuY2V9IHRoYXQgaXMgdXNlZCBieSB0aGlzIFlqcyBpbnN0YW5jZS5cbiAgICAgICAqIEB0eXBlIHtBYnN0cmFjdFBlcnNpc3RlbmNlfVxuICAgICAgICovXG4gICAgICBfdGhpcy5wZXJzaXN0ZW5jZSA9IG51bGw7XG4gICAgICBpZiAocGVyc2lzdGVuY2UgIT0gbnVsbCkge1xuICAgICAgICBfdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuICAgICAgICBwZXJzaXN0ZW5jZS5faW5pdChfdGhpcykudGhlbihpbml0Q29ubmVjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0Q29ubmVjdGlvbigpO1xuICAgICAgfVxuICAgICAgLy8gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBpc1BhcmVudE9mXG4gICAgICBfdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgIF90aGlzLl9oYXNVbmRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKFksIFt7XG4gICAgICBrZXk6ICdfc2V0Q29udGVudFJlYWR5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q29udGVudFJlYWR5KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbnRlbnRSZWFkeSkge1xuICAgICAgICAgIHRoaXMuX2NvbnRlbnRSZWFkeSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjb250ZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd3aGVuQ29udGVudFJlYWR5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aGVuQ29udGVudFJlYWR5KCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5fY29udGVudFJlYWR5KSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMyLm9uY2UoJ2NvbnRlbnQnLCByZXNvbHZlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19iZWZvcmVDaGFuZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iZWZvcmVDaGFuZ2UoKSB7fVxuICAgICAgLyoqXG4gICAgICAgKiBDaGFuZ2VzIHRoYXQgaGFwcGVuIGluc2lkZSBvZiBhIHRyYW5zYWN0aW9uIGFyZSBidW5kbGVkLiBUaGlzIG1lYW5zIHRoYXRcbiAgICAgICAqIHRoZSBvYnNlcnZlciBmaXJlcyBfYWZ0ZXJfIHRoZSB0cmFuc2FjdGlvbiBpcyBmaW5pc2hlZCBhbmQgdGhhdCBhbGwgY2hhbmdlc1xuICAgICAgICogdGhhdCBoYXBwZW5lZCBpbnNpZGUgb2YgdGhlIHRyYW5zYWN0aW9uIGFyZSBzZW50IGFzIG9uZSBtZXNzYWdlIHRvIHRoZVxuICAgICAgICogb3RoZXIgcGVlcnMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiBUaGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgYXMgYSB0cmFuc2FjdGlvblxuICAgICAgICogQHBhcmFtIHs/Qm9vbGVhbn0gcmVtb3RlIE9wdGlvbmFsLiBXaGV0aGVyIHRoaXMgdHJhbnNhY3Rpb24gaXMgaW5pdGlhdGVkIGJ5XG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYSByZW1vdGUgcGVlci4gVGhpcyBzaG91bGQgbm90IGJlIHNldCBtYW51YWxseSFcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndHJhbnNhY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zYWN0KGYpIHtcbiAgICAgICAgdmFyIHJlbW90ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIGluaXRpYWxDYWxsID0gdGhpcy5fdHJhbnNhY3Rpb24gPT09IG51bGw7XG4gICAgICAgIGlmIChpbml0aWFsQ2FsbCkge1xuICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZW1pdCgnYmVmb3JlVHJhbnNhY3Rpb24nLCB0aGlzLCB0aGlzLl90cmFuc2FjdGlvbiwgcmVtb3RlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGYodGhpcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsQ2FsbCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnYmVmb3JlT2JzZXJ2ZXJDYWxscycsIHRoaXMsIHRoaXMuX3RyYW5zYWN0aW9uLCByZW1vdGUpO1xuICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuX3RyYW5zYWN0aW9uO1xuICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAvLyBlbWl0IGNoYW5nZSBldmVudHMgb24gY2hhbmdlZCB0eXBlc1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzLCB0eXBlKSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgdHlwZS5fY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBzdWJzLCByZW1vdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudHMsIHR5cGUpIHtcbiAgICAgICAgICAgIGlmICghdHlwZS5fZGVsZXRlZCkge1xuICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhZXZlbnQudGFyZ2V0Ll9kZWxldGVkO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHR5cGU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIGNoZWNrIGZvciBldmVudHMubGVuZ3RoXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gd2F5IGV2ZW50cyBpcyBlbXB0eS4uXG4gICAgICAgICAgICAgIHR5cGUuX2RlZXBFdmVudEhhbmRsZXIuY2FsbEV2ZW50TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBldmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIHdoZW4gYWxsIGNoYW5nZXMgJiBldmVudHMgYXJlIHByb2Nlc3NlZCwgZW1pdCBhZnRlclRyYW5zYWN0aW9uIGV2ZW50XG4gICAgICAgICAgdGhpcy5lbWl0KCdhZnRlclRyYW5zYWN0aW9uJywgdGhpcywgdHJhbnNhY3Rpb24sIHJlbW90ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogRmFrZSBfc3RhcnQgZm9yIHJvb3QgcHJvcGVydGllcyAoeS5zZXQoJ25hbWUnLCB0eXBlKSlcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVmaW5lJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIERlZmluZSBhIHNoYXJlZCBkYXRhIHR5cGUuXG4gICAgICAgKlxuICAgICAgICogTXVsdGlwbGUgY2FsbHMgb2YgYHkuZGVmaW5lKG5hbWUsIFR5cGVDb25zdHJ1Y3RvcilgIHlpZWxkIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgICogYW5kIGRvIG5vdCBvdmVyd3JpdGUgZWFjaCBvdGhlci4gSS5lLlxuICAgICAgICogYHkuZGVmaW5lKG5hbWUsIHR5cGUpID09PSB5LmRlZmluZShuYW1lLCB0eXBlKWBcbiAgICAgICAqXG4gICAgICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSB0eXBlIGlzIGFsc28gYXZhaWxhYmxlIG9uIGB5LnNoYXJlW25hbWVdYC5cbiAgICAgICAqXG4gICAgICAgKiAqQmVzdCBQcmFjdGljZXM6KlxuICAgICAgICogRWl0aGVyIGRlZmluZSBhbGwgdHlwZXMgcmlnaHQgYWZ0ZXIgdGhlIFlqcyBpbnN0YW5jZSBpcyBjcmVhdGVkIG9yIGFsd2F5c1xuICAgICAgICogdXNlIGB5LmRlZmluZSguLilgIHdoZW4gYWNjZXNzaW5nIGEgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogICAvLyBPcHRpb24gMVxuICAgICAgICogICBjb25zdCB5ID0gbmV3IFkoLi4pXG4gICAgICAgKiAgIHkuZGVmaW5lKCdteUFycmF5JywgWUFycmF5KVxuICAgICAgICogICB5LmRlZmluZSgnbXlNYXAnLCBZTWFwKVxuICAgICAgICogICAvLyAuLiB3aGVuIGFjY2Vzc2luZyB0aGUgdHlwZSB1c2UgeS5zaGFyZVtuYW1lXVxuICAgICAgICogICB5LnNoYXJlLm15QXJyYXkuaW5zZXJ0KC4uKVxuICAgICAgICogICB5LnNoYXJlLm15TWFwLnNldCguLilcbiAgICAgICAqXG4gICAgICAgKiAgIC8vIE9wdGlvbjJcbiAgICAgICAqICAgY29uc3QgeSA9IG5ldyBZKC4uKVxuICAgICAgICogICAvLyAuLiB3aGVuIGFjY2Vzc2luZyB0aGUgdHlwZSB1c2UgYHkuZGVmaW5lKC4uKWBcbiAgICAgICAqICAgeS5kZWZpbmUoJ215QXJyYXknLCBZQXJyYXkpLmluc2VydCguLilcbiAgICAgICAqICAgeS5kZWZpbmUoJ215TWFwJywgWU1hcCkuc2V0KC4uKVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge1lUeXBlIENvbnN0cnVjdG9yfSBUeXBlQ29uc3RydWN0b3IgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSB0eXBlIGRlZmluaXRpb25cbiAgICAgICAqIEByZXR1cm5zIHtZVHlwZX0gVGhlIGNyZWF0ZWQgdHlwZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVmaW5lKG5hbWUsIFR5cGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICB2YXIgaWQgPSBuZXcgUm9vdElEKG5hbWUsIFR5cGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5vcy5nZXQoaWQpO1xuICAgICAgICBpZiAodGhpcy5zaGFyZVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5zaGFyZVtuYW1lXSA9IHR5cGU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaGFyZVtuYW1lXSAhPT0gdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHlwZSBpcyBhbHJlYWR5IGRlZmluZWQgd2l0aCBhIGRpZmZlcmVudCBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCBhIGRlZmluZWQgdHlwZS4gVGhlIHR5cGUgbXVzdCBiZSBkZWZpbmVkIGxvY2FsbHkuIEZpcnN0IGRlZmluZSB0aGVcbiAgICAgICAqIHR5cGUgd2l0aCB7QGxpbmsgZGVmaW5lfS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIHJldHVybnMgdGhlIHNhbWUgdmFsdWUgYXMgYHkuc2hhcmVbbmFtZV1gXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIHR5cGVuYW1lXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0JCQxKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzY29ubmVjdCB0aGlzIFlqcyBJbnN0YW5jZSBmcm9tIHRoZSBuZXR3b3JrLiBUaGUgY29ubmVjdG9yIHdpbGxcbiAgICAgICAqIHVuc3Vic2NyaWJlIGZyb20gdGhlIHJvb20gYW5kIGRvY3VtZW50IHVwZGF0ZXMgYXJlIG5vdCBzaGFyZWQgYW55bW9yZS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzY29ubmVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIElmIGRpc2Nvbm5lY3RlZCwgdGVsbCB0aGUgY29ubmVjdG9yIHRvIHJlY29ubmVjdCB0byB0aGUgcm9vbS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVjb25uZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvbm5lY3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLnJlY29ubmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERpc2Nvbm5lY3QgZnJvbSB0aGUgcm9vbSwgYW5kIGRlc3Ryb3kgYWxsIHRyYWNlcyBvZiB0aGlzIFlqcyBpbnN0YW5jZS5cbiAgICAgICAqIFBlcnNpc3RlZCBkYXRhIHdpbGwgcmVtYWluIHVudGlsIHJlbW92ZWQgYnkgdGhlIHBlcnNpc3RlbmNlIGFkYXB0ZXIuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGdldChZLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFkucHJvdG90eXBlKSwgJ2Rlc3Ryb3knLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNoYXJlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IuZGVzdHJveSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5kZXN0cm95KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlLmRlaW5pdCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3MgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zdGFydCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEZha2UgX3N0YXJ0IGZvciByb290IHByb3BlcnRpZXMgKHkuc2V0KCduYW1lJywgdHlwZSkpXG4gICAgICAgKi9cbiAgICAgICxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gWTtcbiAgfShOYW1lZEV2ZW50SGFuZGxlcik7XG5cblxuICBZLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZFlqcygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGYgPSBhcmd1bWVudHNbaV07XG4gICAgICBpZiAodHlwZW9mIGYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZihZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBmdW5jdGlvbiEnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIFJldmVyc2VPcGVyYXRpb24gPSBmdW5jdGlvbiBSZXZlcnNlT3BlcmF0aW9uKHksIHRyYW5zYWN0aW9uLCBiaW5kaW5nSW5mb3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmV2ZXJzZU9wZXJhdGlvbik7XG5cbiAgICB0aGlzLmNyZWF0ZWQgPSBuZXcgRGF0ZSgpO1xuICAgIHZhciBiZWZvcmVTdGF0ZSA9IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlO1xuICAgIGlmIChiZWZvcmVTdGF0ZS5oYXMoeS51c2VySUQpKSB7XG4gICAgICB0aGlzLnRvU3RhdGUgPSBuZXcgSUQoeS51c2VySUQsIHkuc3MuZ2V0U3RhdGUoeS51c2VySUQpIC0gMSk7XG4gICAgICB0aGlzLmZyb21TdGF0ZSA9IG5ldyBJRCh5LnVzZXJJRCwgYmVmb3JlU3RhdGUuZ2V0KHkudXNlcklEKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9TdGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLmZyb21TdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZGVsZXRlZFN0cnVjdHMgPSBuZXcgU2V0KCk7XG4gICAgdHJhbnNhY3Rpb24uZGVsZXRlZFN0cnVjdHMuZm9yRWFjaChmdW5jdGlvbiAoc3RydWN0KSB7XG4gICAgICBfdGhpcy5kZWxldGVkU3RydWN0cy5hZGQoe1xuICAgICAgICBmcm9tOiBzdHJ1Y3QuX2lkLFxuICAgICAgICBsZW46IHN0cnVjdC5fbGVuZ3RoXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBNYXBzIGZyb20gYmluZGluZyB0byBiaW5kaW5nIGluZm9ybWF0aW9uIChlLmcuIGN1cnNvciBpbmZvcm1hdGlvbilcbiAgICAgKi9cbiAgICB0aGlzLmJpbmRpbmdJbmZvcyA9IGJpbmRpbmdJbmZvcztcbiAgfTtcblxuICBmdW5jdGlvbiBhcHBseVJldmVyc2VPcGVyYXRpb24oeSwgc2NvcGUsIHJldmVyc2VCdWZmZXIpIHtcbiAgICB2YXIgcGVyZm9ybWVkVW5kbyA9IGZhbHNlO1xuICAgIHZhciB1bmRvT3AgPSB2b2lkIDA7XG4gICAgeS50cmFuc2FjdChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgdW5kb09wID0gcmV2ZXJzZUJ1ZmZlci5wb3AoKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgaXQgaXMgcG9zc2libGUgdG8gaXRlcmF0ZSB7ZnJvbX0te3RvfVxuICAgICAgICBpZiAodW5kb09wLmZyb21TdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHkub3MuZ2V0SXRlbUNsZWFuU3RhcnQodW5kb09wLmZyb21TdGF0ZSk7XG4gICAgICAgICAgeS5vcy5nZXRJdGVtQ2xlYW5FbmQodW5kb09wLnRvU3RhdGUpO1xuICAgICAgICAgIHkub3MuaXRlcmF0ZSh1bmRvT3AuZnJvbVN0YXRlLCB1bmRvT3AudG9TdGF0ZSwgZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICB3aGlsZSAob3AuX2RlbGV0ZWQgJiYgb3AuX3JlZG9uZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBvcCA9IG9wLl9yZWRvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3AuX2RlbGV0ZWQgPT09IGZhbHNlICYmIGlzUGFyZW50T2Yoc2NvcGUsIG9wKSkge1xuICAgICAgICAgICAgICBwZXJmb3JtZWRVbmRvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgb3AuX2RlbGV0ZSh5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVkb2l0ZW1zID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB1bmRvT3AuZGVsZXRlZFN0cnVjdHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZGVsID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBmcm9tU3RhdGUgPSBkZWwuZnJvbTtcbiAgICAgICAgICAgIHZhciB0b1N0YXRlID0gbmV3IElEKGZyb21TdGF0ZS51c2VyLCBmcm9tU3RhdGUuY2xvY2sgKyBkZWwubGVuIC0gMSk7XG4gICAgICAgICAgICB5Lm9zLmdldEl0ZW1DbGVhblN0YXJ0KGZyb21TdGF0ZSk7XG4gICAgICAgICAgICB5Lm9zLmdldEl0ZW1DbGVhbkVuZCh0b1N0YXRlKTtcbiAgICAgICAgICAgIHkub3MuaXRlcmF0ZShmcm9tU3RhdGUsIHRvU3RhdGUsIGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgICBpZiAoaXNQYXJlbnRPZihzY29wZSwgb3ApICYmIG9wLl9wYXJlbnQgIT09IHkgJiYgKG9wLl9pZC51c2VyICE9PSB5LnVzZXJJRCB8fCB1bmRvT3AuZnJvbVN0YXRlID09PSBudWxsIHx8IG9wLl9pZC5jbG9jayA8IHVuZG9PcC5mcm9tU3RhdGUuY2xvY2sgfHwgb3AuX2lkLmNsb2NrID4gdW5kb09wLnRvU3RhdGUuY2xvY2spKSB7XG4gICAgICAgICAgICAgICAgcmVkb2l0ZW1zLmFkZChvcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZWRvaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICB2YXIgb3BVbmRvbmUgPSBvcC5fcmVkbyh5LCByZWRvaXRlbXMpO1xuICAgICAgICAgIHBlcmZvcm1lZFVuZG8gPSBwZXJmb3JtZWRVbmRvIHx8IG9wVW5kb25lO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlICghcGVyZm9ybWVkVW5kbyAmJiByZXZlcnNlQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX2xvb3AoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocGVyZm9ybWVkVW5kbykge1xuICAgICAgLy8gc2hvdWxkIGJlIHBlcmZvcm1lZCBhZnRlciB0aGUgdW5kbyB0cmFuc2FjdGlvblxuICAgICAgdW5kb09wLmJpbmRpbmdJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvLCBiaW5kaW5nKSB7XG4gICAgICAgIGJpbmRpbmcuX3Jlc3RvcmVVbmRvU3RhY2tJbmZvKGluZm8pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwZXJmb3JtZWRVbmRvO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIGEgaGlzdG9yeSBvZiBsb2NhbGx5IGFwcGxpZWQgb3BlcmF0aW9ucy4gVGhlIFVuZG9NYW5hZ2VyIGhhbmRsZXMgdGhlXG4gICAqIHVuZG9pbmcgYW5kIHJlZG9pbmcgb2YgbG9jYWxseSBjcmVhdGVkIGNoYW5nZXMuXG4gICAqL1xuXG4gIHZhciBVbmRvTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1lUeXBlfSBzY29wZSBUaGUgc2NvcGUgb24gd2hpY2ggdG8gbGlzdGVuIGZvciBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsbHkgcHJvdmlkZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbmRvTWFuYWdlcihzY29wZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFVuZG9NYW5hZ2VyKTtcblxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuX2JpbmRpbmdzID0gbmV3IFNldChvcHRpb25zLmJpbmRpbmdzKTtcbiAgICAgIG9wdGlvbnMuY2FwdHVyZVRpbWVvdXQgPSBvcHRpb25zLmNhcHR1cmVUaW1lb3V0ID09IG51bGwgPyA1MDAgOiBvcHRpb25zLmNhcHR1cmVUaW1lb3V0O1xuICAgICAgdGhpcy5fdW5kb0J1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5fcmVkb0J1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5fc2NvcGUgPSBzY29wZTtcbiAgICAgIHRoaXMuX3VuZG9pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlZG9pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2xhc3RUcmFuc2FjdGlvbldhc1VuZG8gPSBmYWxzZTtcbiAgICAgIHZhciB5ID0gc2NvcGUuX3k7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgeS5faGFzVW5kb01hbmFnZXIgPSB0cnVlO1xuICAgICAgdmFyIGJpbmRpbmdJbmZvcyA9IHZvaWQgMDtcbiAgICAgIHkub24oJ2JlZm9yZVRyYW5zYWN0aW9uJywgZnVuY3Rpb24gKHksIHRyYW5zYWN0aW9uLCByZW1vdGUpIHtcbiAgICAgICAgaWYgKCFyZW1vdGUpIHtcbiAgICAgICAgICAvLyBTdG9yZSBiaW5kaW5nIGluZm9ybWF0aW9uIGJlZm9yZSB0cmFuc2FjdGlvbiBpcyBleGVjdXRlZFxuICAgICAgICAgIC8vIEJ5IHJlc3RvcmluZyB0aGUgYmluZGluZyBpbmZvcm1hdGlvbiwgd2UgY2FuIG1ha2Ugc3VyZSB0aGF0IHRoZSBzdGF0ZVxuICAgICAgICAgIC8vIGJlZm9yZSB0aGUgdHJhbnNhY3Rpb24gY2FuIGJlIHJlY292ZXJlZFxuICAgICAgICAgIGJpbmRpbmdJbmZvcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBfdGhpczIuX2JpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGJpbmRpbmdJbmZvcy5zZXQoYmluZGluZywgYmluZGluZy5fZ2V0VW5kb1N0YWNrSW5mbygpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5Lm9uKCdhZnRlclRyYW5zYWN0aW9uJywgZnVuY3Rpb24gKHksIHRyYW5zYWN0aW9uLCByZW1vdGUpIHtcbiAgICAgICAgaWYgKCFyZW1vdGUgJiYgdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzLmhhcyhzY29wZSkpIHtcbiAgICAgICAgICB2YXIgcmV2ZXJzZU9wZXJhdGlvbiA9IG5ldyBSZXZlcnNlT3BlcmF0aW9uKHksIHRyYW5zYWN0aW9uLCBiaW5kaW5nSW5mb3MpO1xuICAgICAgICAgIGlmICghX3RoaXMyLl91bmRvaW5nKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFVuZG9PcCA9IF90aGlzMi5fdW5kb0J1ZmZlci5sZW5ndGggPiAwID8gX3RoaXMyLl91bmRvQnVmZmVyW190aGlzMi5fdW5kb0J1ZmZlci5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLl9yZWRvaW5nID09PSBmYWxzZSAmJiBfdGhpczIuX2xhc3RUcmFuc2FjdGlvbldhc1VuZG8gPT09IGZhbHNlICYmIGxhc3RVbmRvT3AgIT09IG51bGwgJiYgKG9wdGlvbnMuY2FwdHVyZVRpbWVvdXQgPCAwIHx8IHJldmVyc2VPcGVyYXRpb24uY3JlYXRlZCAtIGxhc3RVbmRvT3AuY3JlYXRlZCA8PSBvcHRpb25zLmNhcHR1cmVUaW1lb3V0KSkge1xuICAgICAgICAgICAgICBsYXN0VW5kb09wLmNyZWF0ZWQgPSByZXZlcnNlT3BlcmF0aW9uLmNyZWF0ZWQ7XG4gICAgICAgICAgICAgIGlmIChyZXZlcnNlT3BlcmF0aW9uLnRvU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsYXN0VW5kb09wLnRvU3RhdGUgPSByZXZlcnNlT3BlcmF0aW9uLnRvU3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RVbmRvT3AuZnJvbVN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBsYXN0VW5kb09wLmZyb21TdGF0ZSA9IHJldmVyc2VPcGVyYXRpb24uZnJvbVN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXZlcnNlT3BlcmF0aW9uLmRlbGV0ZWRTdHJ1Y3RzLmZvckVhY2gobGFzdFVuZG9PcC5kZWxldGVkU3RydWN0cy5hZGQsIGxhc3RVbmRvT3AuZGVsZXRlZFN0cnVjdHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9sYXN0VHJhbnNhY3Rpb25XYXNVbmRvID0gZmFsc2U7XG4gICAgICAgICAgICAgIF90aGlzMi5fdW5kb0J1ZmZlci5wdXNoKHJldmVyc2VPcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfdGhpczIuX3JlZG9pbmcpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9yZWRvQnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzMi5fbGFzdFRyYW5zYWN0aW9uV2FzVW5kbyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpczIuX3JlZG9CdWZmZXIucHVzaChyZXZlcnNlT3BlcmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuZm9yY2UgdGhhdCB0aGUgbmV4dCBjaGFuZ2UgaXMgY3JlYXRlZCBhcyBhIHNlcGFyYXRlIGl0ZW0gaW4gdGhlIHVuZG8gc3RhY2tcbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoVW5kb01hbmFnZXIsIFt7XG4gICAgICBrZXk6ICdmbHVzaENoYW5nZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5fbGFzdFRyYW5zYWN0aW9uV2FzVW5kbyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5kbyB0aGUgbGFzdCBsb2NhbGx5IGNyZWF0ZWQgY2hhbmdlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1bmRvJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bmRvKCkge1xuICAgICAgICB0aGlzLl91bmRvaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1lZFVuZG8gPSBhcHBseVJldmVyc2VPcGVyYXRpb24odGhpcy55LCB0aGlzLl9zY29wZSwgdGhpcy5fdW5kb0J1ZmZlcik7XG4gICAgICAgIHRoaXMuX3VuZG9pbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1lZFVuZG87XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVkbyB0aGUgbGFzdCBsb2NhbGx5IGNyZWF0ZWQgY2hhbmdlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWRvJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWRvKCkge1xuICAgICAgICB0aGlzLl9yZWRvaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1lZFJlZG8gPSBhcHBseVJldmVyc2VPcGVyYXRpb24odGhpcy55LCB0aGlzLl9zY29wZSwgdGhpcy5fcmVkb0J1ZmZlcik7XG4gICAgICAgIHRoaXMuX3JlZG9pbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1lZFJlZG87XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBVbmRvTWFuYWdlcjtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcbiAgXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVycy5cbiAgICovXG5cbiAgdmFyIHMgPSAxMDAwO1xuICB2YXIgbSA9IHMgKiA2MDtcbiAgdmFyIGggPSBtICogNjA7XG4gIHZhciBkID0gaCAqIDI0O1xuICB2YXIgeSA9IGQgKiAzNjUuMjU7XG5cbiAgLyoqXG4gICAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gICAqXG4gICAqIE9wdGlvbnM6XG4gICAqXG4gICAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICAgKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB2YXIgaW5kZXggPSBmdW5jdGlvbiBpbmRleCh2YWwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCk7XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgKyBKU09OLnN0cmluZ2lmeSh2YWwpKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3llYXJzJzpcbiAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgY2FzZSAneXJzJzpcbiAgICAgIGNhc2UgJ3lyJzpcbiAgICAgIGNhc2UgJ3knOlxuICAgICAgICByZXR1cm4gbiAqIHk7XG4gICAgICBjYXNlICdkYXlzJzpcbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICBjYXNlICdkJzpcbiAgICAgICAgcmV0dXJuIG4gKiBkO1xuICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgY2FzZSAnaG91cic6XG4gICAgICBjYXNlICdocnMnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAnaCc6XG4gICAgICAgIHJldHVybiBuICogaDtcbiAgICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgIGNhc2UgJ21pbnMnOlxuICAgICAgY2FzZSAnbWluJzpcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICByZXR1cm4gbiAqIG07XG4gICAgICBjYXNlICdzZWNvbmRzJzpcbiAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICBjYXNlICdzZWNzJzpcbiAgICAgIGNhc2UgJ3NlYyc6XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgcmV0dXJuIG4gKiBzO1xuICAgICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgIGNhc2UgJ21zZWNzJzpcbiAgICAgIGNhc2UgJ21zZWMnOlxuICAgICAgY2FzZSAnbXMnOlxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gICAgaWYgKG1zID49IGQpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gICAgfVxuICAgIGlmIChtcyA+PSBoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICAgIH1cbiAgICBpZiAobXMgPj0gbSkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgICB9XG4gICAgaWYgKG1zID49IHMpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gICAgfVxuICAgIHJldHVybiBtcyArICdtcyc7XG4gIH1cblxuICAvKipcbiAgICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fCBtcyArICcgbXMnO1xuICB9XG5cbiAgLyoqXG4gICAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICAgKi9cblxuICBmdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgICBpZiAobXMgPCBuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xuICB9XG5cbiAgdmFyIGRlYnVnID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICAgICAqXG4gICAgICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICAgICAqL1xuXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG4gICAgZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG4gICAgZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgICBleHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbiAgICBleHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIGV4cG9ydHMuaHVtYW5pemUgPSBpbmRleDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICAgICAqL1xuXG4gICAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICAgIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAgICAgKi9cblxuICAgIGV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAgICAgKi9cblxuICAgIHZhciBwcmV2VGltZTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhIGNvbG9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICAgIHZhciBoYXNoID0gMCxcbiAgICAgICAgICBpO1xuXG4gICAgICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgICAvLyBkaXNhYmxlZD9cbiAgICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgICAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgICAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgICBzZWxmLmRpZmYgPSBtcztcbiAgICAgICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgICAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIHZhciBpbmRleCQkMSA9IDA7XG4gICAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGZvcm1hdCkge1xuICAgICAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgICAgICBpbmRleCQkMSsrO1xuICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXgkJDFdO1xuICAgICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgICAgICBhcmdzLnNwbGljZShpbmRleCQkMSwgMSk7XG4gICAgICAgICAgICBpbmRleCQkMS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgICAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICAgIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAgICAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWJ1ZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICAgICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgICAgIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgICAgIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICAgICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgZXhwb3J0cy5lbmFibGUoJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgICB2YXIgaSwgbGVuO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvZXJjZSBgdmFsYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgICAqIEByZXR1cm4ge01peGVkfVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0pO1xuICB2YXIgZGVidWdfMSA9IGRlYnVnLmNvZXJjZTtcbiAgdmFyIGRlYnVnXzIgPSBkZWJ1Zy5kaXNhYmxlO1xuICB2YXIgZGVidWdfMyA9IGRlYnVnLmVuYWJsZTtcbiAgdmFyIGRlYnVnXzQgPSBkZWJ1Zy5lbmFibGVkO1xuICB2YXIgZGVidWdfNSA9IGRlYnVnLmh1bWFuaXplO1xuICB2YXIgZGVidWdfNiA9IGRlYnVnLm5hbWVzO1xuICB2YXIgZGVidWdfNyA9IGRlYnVnLnNraXBzO1xuICB2YXIgZGVidWdfOCA9IGRlYnVnLmZvcm1hdHRlcnM7XG5cbiAgdmFyIGJyb3dzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICAgICAqXG4gICAgICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICAgICAqL1xuXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG4gICAgZXhwb3J0cy5sb2cgPSBsb2c7XG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICBleHBvcnRzLnNhdmUgPSBzYXZlO1xuICAgIGV4cG9ydHMubG9hZCA9IGxvYWQ7XG4gICAgZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG4gICAgZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZSAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2UgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbCA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4gICAgLyoqXG4gICAgICogQ29sb3JzLlxuICAgICAqL1xuXG4gICAgZXhwb3J0cy5jb2xvcnMgPSBbJ2xpZ2h0c2VhZ3JlZW4nLCAnZm9yZXN0Z3JlZW4nLCAnZ29sZGVucm9kJywgJ2RvZGdlcmJsdWUnLCAnZGFya29yY2hpZCcsICdjcmltc29uJ107XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICAgICAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICAgICAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gICAgICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gICAgICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAgICAgLy8gZXhwbGljaXRseVxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gICAgICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICAgICAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSB8fFxuICAgICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fFxuICAgICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHxcbiAgICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAgICAgKi9cblxuICAgIGV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgICAgIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICAgICAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpICsgdGhpcy5uYW1lc3BhY2UgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpICsgYXJnc1swXSArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgICAgIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgICAgIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgICAgIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG4gICAgICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAgICAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAgICAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RDID0gMDtcbiAgICAgIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGxvZygpIHtcbiAgICAgIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gICAgICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICAgICAgcmV0dXJuICdvYmplY3QnID09PSAodHlwZW9mIGNvbnNvbGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbnNvbGUpKSAmJiBjb25zb2xlLmxvZyAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgIHZhciByO1xuICAgICAgdHJ5IHtcbiAgICAgICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgICAgIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgICAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gICAgICovXG5cbiAgICBleHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4gICAgLyoqXG4gICAgICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gICAgICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAgICAgKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfSk7XG4gIHZhciBicm93c2VyXzEgPSBicm93c2VyLmxvZztcbiAgdmFyIGJyb3dzZXJfMiA9IGJyb3dzZXIuZm9ybWF0QXJncztcbiAgdmFyIGJyb3dzZXJfMyA9IGJyb3dzZXIuc2F2ZTtcbiAgdmFyIGJyb3dzZXJfNCA9IGJyb3dzZXIubG9hZDtcbiAgdmFyIGJyb3dzZXJfNSA9IGJyb3dzZXIudXNlQ29sb3JzO1xuICB2YXIgYnJvd3Nlcl82ID0gYnJvd3Nlci5zdG9yYWdlO1xuICB2YXIgYnJvd3Nlcl83ID0gYnJvd3Nlci5jb2xvcnM7XG5cbiAgLy8gVE9ETzogcmVuYW1lIENvbm5lY3RvclxuXG4gIHZhciBBYnN0cmFjdENvbm5lY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENvbm5lY3Rvcih5LCBvcHRzKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdENvbm5lY3Rvcik7XG5cbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgaWYgKG9wdHMucm9sZSA9PSBudWxsIHx8IG9wdHMucm9sZSA9PT0gJ21hc3RlcicpIHtcbiAgICAgICAgdGhpcy5yb2xlID0gJ21hc3Rlcic7XG4gICAgICB9IGVsc2UgaWYgKG9wdHMucm9sZSA9PT0gJ3NsYXZlJykge1xuICAgICAgICB0aGlzLnJvbGUgPSAnc2xhdmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9sZSBtdXN0IGJlIGVpdGhlciAnbWFzdGVyJyBvciAnc2xhdmUnIVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nID0gYnJvd3NlcigneTpjb25uZWN0b3InKTtcbiAgICAgIHRoaXMubG9nTWVzc2FnZSA9IGJyb3dzZXIoJ3k6Y29ubmVjdG9yLW1lc3NhZ2UnKTtcbiAgICAgIHRoaXMuX2ZvcndhcmRBcHBsaWVkU3RydWN0cyA9IG9wdHMuZm9yd2FyZEFwcGxpZWRPcGVyYXRpb25zIHx8IGZhbHNlOyAvLyBUT0RPOiByZW5hbWVcbiAgICAgIHRoaXMucm9sZSA9IG9wdHMucm9sZTtcbiAgICAgIHRoaXMuY29ubmVjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmlzU3luY2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnVzZXJFdmVudExpc3RlbmVycyA9IFtdO1xuICAgICAgdGhpcy53aGVuU3luY2VkTGlzdGVuZXJzID0gW107XG4gICAgICB0aGlzLmN1cnJlbnRTeW5jVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuZGVidWcgPSBvcHRzLmRlYnVnID09PSB0cnVlO1xuICAgICAgdGhpcy5icm9hZGNhc3RCdWZmZXIgPSBuZXcgQmluYXJ5RW5jb2RlcigpO1xuICAgICAgdGhpcy5icm9hZGNhc3RCdWZmZXJTaXplID0gMDtcbiAgICAgIHRoaXMucHJvdG9jb2xWZXJzaW9uID0gMTE7XG4gICAgICB0aGlzLmF1dGhJbmZvID0gb3B0cy5hdXRoIHx8IG51bGw7XG4gICAgICB0aGlzLmNoZWNrQXV0aCA9IG9wdHMuY2hlY2tBdXRoIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnd3JpdGUnKTtcbiAgICAgIH07IC8vIGRlZmF1bHQgaXMgZXZlcnlvbmUgaGFzIHdyaXRlIGFjY2Vzc1xuICAgICAgaWYgKG9wdHMubWF4QnVmZmVyTGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5tYXhCdWZmZXJMZW5ndGggPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWF4QnVmZmVyTGVuZ3RoID0gb3B0cy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoQWJzdHJhY3RDb25uZWN0b3IsIFt7XG4gICAgICBrZXk6ICdyZWNvbm5lY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5sb2coJ3JlY29ubmVjdGluZy4uJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzY29ubmVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5sb2coJ2Rpc2Nyb25uZWN0aW5nLi4nKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pc1N5bmNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnRTeW5jVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy53aGVuU3luY2VkTGlzdGVuZXJzID0gW107XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvblVzZXJFdmVudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25Vc2VyRXZlbnQoZikge1xuICAgICAgICB0aGlzLnVzZXJFdmVudExpc3RlbmVycy5wdXNoKGYpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbW92ZVVzZXJFdmVudExpc3RlbmVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVVc2VyRXZlbnRMaXN0ZW5lcihmKSB7XG4gICAgICAgIHRoaXMudXNlckV2ZW50TGlzdGVuZXJzID0gdGhpcy51c2VyRXZlbnRMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgcmV0dXJuIGYgIT09IGc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VzZXJMZWZ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1c2VyTGVmdCh1c2VyKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zLmhhcyh1c2VyKSkge1xuICAgICAgICAgIHRoaXMubG9nKCclczogVXNlciBsZWZ0ICVzJywgdGhpcy55LnVzZXJJRCwgdXNlcik7XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5kZWxldGUodXNlcik7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgaXNTeW5jZWQgZXZlbnQgY2FuIGJlIHNlbnQgbm93XG4gICAgICAgICAgdGhpcy5fc2V0U3luY2VkV2l0aChudWxsKTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMudXNlckV2ZW50TGlzdGVuZXJzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgZiA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGYoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3VzZXJMZWZ0JyxcbiAgICAgICAgICAgICAgICB1c2VyOiB1c2VyXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VzZXJKb2luZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVzZXJKb2luZWQodXNlciwgcm9sZSwgYXV0aCkge1xuICAgICAgICBpZiAocm9sZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IHRoZSByb2xlIG9mIHRoZSBqb2luZWQgdXNlciEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9ucy5oYXModXNlcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdXNlciBhbHJlYWR5IGpvaW5lZCEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZygnJXM6IFVzZXIgam9pbmVkICVzJywgdGhpcy55LnVzZXJJRCwgdXNlcik7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMuc2V0KHVzZXIsIHtcbiAgICAgICAgICB1aWQ6IHVzZXIsXG4gICAgICAgICAgaXNTeW5jZWQ6IGZhbHNlLFxuICAgICAgICAgIHJvbGU6IHJvbGUsXG4gICAgICAgICAgcHJvY2Vzc0FmdGVyQXV0aDogW10sXG4gICAgICAgICAgcHJvY2Vzc0FmdGVyU3luYzogW10sXG4gICAgICAgICAgYXV0aDogYXV0aCB8fCBudWxsLFxuICAgICAgICAgIHJlY2VpdmVkU3luY1N0ZXAyOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlZmVyID0ge307XG4gICAgICAgIGRlZmVyLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGRlZmVyLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5nZXQodXNlcikuc3luY1N0ZXAyID0gZGVmZXI7XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLnVzZXJFdmVudExpc3RlbmVyc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGYgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgIGYoe1xuICAgICAgICAgICAgICBhY3Rpb246ICd1c2VySm9pbmVkJyxcbiAgICAgICAgICAgICAgdXNlcjogdXNlcixcbiAgICAgICAgICAgICAgcm9sZTogcm9sZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zeW5jV2l0aFVzZXIodXNlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4ZWN1dGUgYSBmdW5jdGlvbiBfd2hlbl8gd2UgYXJlIGNvbm5lY3RlZC5cbiAgICAgIC8vIElmIG5vdCBjb25uZWN0ZWQsIHdhaXQgdW50aWwgY29ubmVjdGVkXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd3aGVuU3luY2VkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aGVuU3luY2VkKGYpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTeW5jZWQpIHtcbiAgICAgICAgICBmKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy53aGVuU3luY2VkTGlzdGVuZXJzLnB1c2goZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc3luY1dpdGhVc2VyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3luY1dpdGhVc2VyKHVzZXJJRCkge1xuICAgICAgICBpZiAodGhpcy5yb2xlID09PSAnc2xhdmUnKSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyBcIlRoZSBjdXJyZW50IHN5bmMgaGFzIG5vdCBmaW5pc2hlZCBvciB0aGlzIGlzIGNvbnRyb2xsZWQgYnkgYSBtYXN0ZXIhXCJcbiAgICAgICAgfVxuICAgICAgICBzZW5kU3luY1N0ZXAxKHRoaXMsIHVzZXJJRCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpcmVJc1N5bmNlZExpc3RlbmVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpcmVJc1N5bmNlZExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3luY2VkKSB7XG4gICAgICAgICAgdGhpcy5pc1N5bmNlZCA9IHRydWU7XG4gICAgICAgICAgLy8gSXQgaXMgc2FmZXIgdG8gcmVtb3ZlIHRoaXMhXG4gICAgICAgICAgLy8gY2FsbCB3aGVuc3luY2VkIGxpc3RlbmVyc1xuICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IHRoaXMud2hlblN5bmNlZExpc3RlbmVyc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgZiA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgICBmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMud2hlblN5bmNlZExpc3RlbmVycyA9IFtdO1xuICAgICAgICAgIHRoaXMueS5fc2V0Q29udGVudFJlYWR5KCk7XG4gICAgICAgICAgdGhpcy55LmVtaXQoJ3N5bmNlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2VuZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZCh1aWQsIGJ1ZmZlcikge1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIE1lc3NhZ2UgdG8gYmUgYW4gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSAtIGRvblxcJ3QgdXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgY3VzdG9tIG1lc3NhZ2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coJ1VzZXIlcyB0byBVc2VyJXM6IFNlbmQgXFwnJXlcXCcnLCB5LnVzZXJJRCwgdWlkLCBidWZmZXIpO1xuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UoJ1VzZXIlcyB0byBVc2VyJXM6IFNlbmQgJVknLCB5LnVzZXJJRCwgdWlkLCBbeSwgYnVmZmVyXSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnYnJvYWRjYXN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBicm9hZGNhc3QoYnVmZmVyKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgTWVzc2FnZSB0byBiZSBhbiBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IC0gZG9uXFwndCB1c2UgdGhpcyBtZXRob2QgdG8gc2VuZCBjdXN0b20gbWVzc2FnZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZygnVXNlciVzOiBCcm9hZGNhc3QgXFwnJXlcXCcnLCB5LnVzZXJJRCwgYnVmZmVyKTtcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKCdVc2VyJXM6IEJyb2FkY2FzdDogJVknLCB5LnVzZXJJRCwgW3ksIGJ1ZmZlcl0pO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICBCdWZmZXIgb3BlcmF0aW9ucywgYW5kIGJyb2FkY2FzdCB0aGVtIHdoZW4gcmVhZHkuXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYnJvYWRjYXN0U3RydWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBicm9hZGNhc3RTdHJ1Y3Qoc3RydWN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGZpcnN0Q29udGVudCA9IHRoaXMuYnJvYWRjYXN0QnVmZmVyLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKGZpcnN0Q29udGVudCkge1xuICAgICAgICAgIHRoaXMuYnJvYWRjYXN0QnVmZmVyLndyaXRlVmFyU3RyaW5nKHRoaXMueS5yb29tKTtcbiAgICAgICAgICB0aGlzLmJyb2FkY2FzdEJ1ZmZlci53cml0ZVZhclN0cmluZygndXBkYXRlJyk7XG4gICAgICAgICAgdGhpcy5icm9hZGNhc3RCdWZmZXJTaXplID0gMDtcbiAgICAgICAgICB0aGlzLmJyb2FkY2FzdEJ1ZmZlclNpemVQb3MgPSB0aGlzLmJyb2FkY2FzdEJ1ZmZlci5wb3M7XG4gICAgICAgICAgdGhpcy5icm9hZGNhc3RCdWZmZXIud3JpdGVVaW50MzIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5icm9hZGNhc3RCdWZmZXJTaXplKys7XG4gICAgICAgIHN0cnVjdC5fdG9CaW5hcnkodGhpcy5icm9hZGNhc3RCdWZmZXIpO1xuICAgICAgICBpZiAodGhpcy5tYXhCdWZmZXJMZW5ndGggPiAwICYmIHRoaXMuYnJvYWRjYXN0QnVmZmVyLmxlbmd0aCA+IHRoaXMubWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gaXQgaXMgbmVjZXNzYXJ5IHRvIHNlbmQgdGhlIGJ1ZmZlciBub3dcbiAgICAgICAgICAvLyBjYWNoZSB0aGUgYnVmZmVyIGFuZCBjaGVjayBpZiBzZXJ2ZXIgaXMgcmVzcG9uc2l2ZVxuICAgICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJyb2FkY2FzdEJ1ZmZlcjtcbiAgICAgICAgICBidWZmZXIuc2V0VWludDMyKHRoaXMuYnJvYWRjYXN0QnVmZmVyU2l6ZVBvcywgdGhpcy5icm9hZGNhc3RCdWZmZXJTaXplKTtcbiAgICAgICAgICB0aGlzLmJyb2FkY2FzdEJ1ZmZlciA9IG5ldyBCaW5hcnlFbmNvZGVyKCk7XG4gICAgICAgICAgdGhpcy53aGVuUmVtb3RlUmVzcG9uc2l2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuYnJvYWRjYXN0KGJ1ZmZlci5jcmVhdGVCdWZmZXIoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RDb250ZW50KSB7XG4gICAgICAgICAgLy8gc2VuZCB0aGUgYnVmZmVyIHdoZW4gYWxsIHRyYW5zYWN0aW9ucyBhcmUgZmluaXNoZWRcbiAgICAgICAgICAvLyAob3IgYnVmZmVyIGV4Y2VlZHMgbWF4QnVmZmVyTGVuZ3RoKVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmJyb2FkY2FzdEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBfYnVmZmVyID0gX3RoaXMuYnJvYWRjYXN0QnVmZmVyO1xuICAgICAgICAgICAgICBfYnVmZmVyLnNldFVpbnQzMihfdGhpcy5icm9hZGNhc3RCdWZmZXJTaXplUG9zLCBfdGhpcy5icm9hZGNhc3RCdWZmZXJTaXplKTtcbiAgICAgICAgICAgICAgX3RoaXMuYnJvYWRjYXN0KF9idWZmZXIuY3JlYXRlQnVmZmVyKCkpO1xuICAgICAgICAgICAgICBfdGhpcy5icm9hZGNhc3RCdWZmZXIgPSBuZXcgQmluYXJ5RW5jb2RlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKiBTb21laG93IGNoZWNrIHRoZSByZXNwb25zaXZlbmVzcyBvZiB0aGUgcmVtb3RlIGNsaWVudHMvc2VydmVyXG4gICAgICAgKiBEZWZhdWx0IGJlaGF2aW9yOlxuICAgICAgICogICBXYWl0IDEwMG1zIGJlZm9yZSBicm9hZGNhc3RpbmcgdGhlIG5leHQgYmF0Y2ggb2Ygb3BlcmF0aW9uc1xuICAgICAgICpcbiAgICAgICAqIE9ubHkgdXNlZCB3aGVuIG1heEJ1ZmZlckxlbmd0aCBpcyBzZXRcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3doZW5SZW1vdGVSZXNwb25zaXZlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aGVuUmVtb3RlUmVzcG9uc2l2ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCAxMDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAgWW91IHJlY2VpdmVkIGEgcmF3IG1lc3NhZ2UsIGFuZCB5b3Uga25vdyB0aGF0IGl0IGlzIGludGVuZGVkIGZvciBZanMuIFRoZW4gY2FsbCB0aGlzIGZ1bmN0aW9uLlxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlY2VpdmVNZXNzYWdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNlaXZlTWVzc2FnZShzZW5kZXIsIGJ1ZmZlciwgc2tpcEF1dGgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHZhciB1c2VySUQgPSB5LnVzZXJJRDtcbiAgICAgICAgc2tpcEF1dGggPSBza2lwQXV0aCB8fCBmYWxzZTtcbiAgICAgICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdFeHBlY3RlZCBNZXNzYWdlIHRvIGJlIGFuIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkhJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW5kZXIgPT09IHVzZXJJRCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVjb2RlciA9IG5ldyBCaW5hcnlEZWNvZGVyKGJ1ZmZlcik7XG4gICAgICAgIHZhciBlbmNvZGVyID0gbmV3IEJpbmFyeUVuY29kZXIoKTtcbiAgICAgICAgdmFyIHJvb21uYW1lID0gZGVjb2Rlci5yZWFkVmFyU3RyaW5nKCk7IC8vIHJlYWQgcm9vbSBuYW1lXG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJTdHJpbmcocm9vbW5hbWUpO1xuICAgICAgICB2YXIgbWVzc2FnZVR5cGUgPSBkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKTtcbiAgICAgICAgdmFyIHNlbmRlckNvbm4gPSB0aGlzLmNvbm5lY3Rpb25zLmdldChzZW5kZXIpO1xuICAgICAgICB0aGlzLmxvZygnVXNlciVzIGZyb20gVXNlciVzOiBSZWNlaXZlIFxcJyVzXFwnJywgdXNlcklELCBzZW5kZXIsIG1lc3NhZ2VUeXBlKTtcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKCdVc2VyJXMgZnJvbSBVc2VyJXM6IFJlY2VpdmUgJVknLCB1c2VySUQsIHNlbmRlciwgW3ksIGJ1ZmZlcl0pO1xuICAgICAgICBpZiAoc2VuZGVyQ29ubiA9PSBudWxsICYmICFza2lwQXV0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIHVua25vd24gcGVlciEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZVR5cGUgPT09ICdzeW5jIHN0ZXAgMScgfHwgbWVzc2FnZVR5cGUgPT09ICdzeW5jIHN0ZXAgMicpIHtcbiAgICAgICAgICB2YXIgYXV0aCA9IGRlY29kZXIucmVhZFZhclVpbnQoKTtcbiAgICAgICAgICBpZiAoc2VuZGVyQ29ubi5hdXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHNlbmRlckNvbm4ucHJvY2Vzc0FmdGVyQXV0aC5wdXNoKFttZXNzYWdlVHlwZSwgc2VuZGVyQ29ubiwgZGVjb2RlciwgZW5jb2Rlciwgc2VuZGVyXSk7XG4gICAgICAgICAgICAvLyBjaGVjayBhdXRoXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0F1dGgoYXV0aCwgeSwgc2VuZGVyKS50aGVuKGZ1bmN0aW9uIChhdXRoUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbmRlckNvbm4uYXV0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VuZGVyQ29ubi5hdXRoID0gYXV0aFBlcm1pc3Npb25zO1xuICAgICAgICAgICAgICAgIHkuZW1pdCgndXNlckF1dGhlbnRpY2F0ZWQnLCB7XG4gICAgICAgICAgICAgICAgICB1c2VyOiBzZW5kZXJDb25uLnVpZCxcbiAgICAgICAgICAgICAgICAgIGF1dGg6IGF1dGhQZXJtaXNzaW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IHNlbmRlckNvbm4ucHJvY2Vzc0FmdGVyQXV0aDtcbiAgICAgICAgICAgICAgc2VuZGVyQ29ubi5wcm9jZXNzQWZ0ZXJBdXRoID0gW107XG5cbiAgICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuY29tcHV0ZU1lc3NhZ2UobVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoc2tpcEF1dGggfHwgc2VuZGVyQ29ubi5hdXRoICE9IG51bGwpICYmIChtZXNzYWdlVHlwZSAhPT0gJ3VwZGF0ZScgfHwgc2VuZGVyQ29ubi5pc1N5bmNlZCkpIHtcbiAgICAgICAgICB0aGlzLmNvbXB1dGVNZXNzYWdlKG1lc3NhZ2VUeXBlLCBzZW5kZXJDb25uLCBkZWNvZGVyLCBlbmNvZGVyLCBzZW5kZXIsIHNraXBBdXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZW5kZXJDb25uLnByb2Nlc3NBZnRlclN5bmMucHVzaChbbWVzc2FnZVR5cGUsIHNlbmRlckNvbm4sIGRlY29kZXIsIGVuY29kZXIsIHNlbmRlciwgZmFsc2VdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NvbXB1dGVNZXNzYWdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlTWVzc2FnZShtZXNzYWdlVHlwZSwgc2VuZGVyQ29ubiwgZGVjb2RlciwgZW5jb2Rlciwgc2VuZGVyLCBza2lwQXV0aCkge1xuICAgICAgICBpZiAobWVzc2FnZVR5cGUgPT09ICdzeW5jIHN0ZXAgMScgJiYgKHNlbmRlckNvbm4uYXV0aCA9PT0gJ3dyaXRlJyB8fCBzZW5kZXJDb25uLmF1dGggPT09ICdyZWFkJykpIHtcbiAgICAgICAgICAvLyBjYW5ub3Qgd2FpdCBmb3Igc3luYyBzdGVwIDEgdG8gZmluaXNoLCBiZWNhdXNlIHdlIG1heSB3YWl0IGZvciBzeW5jIHN0ZXAgMiBpbiBzeW5jIHN0ZXAgMSAoLT5sb2NrKVxuICAgICAgICAgIHJlYWRTeW5jU3RlcDEoZGVjb2RlciwgZW5jb2RlciwgdGhpcy55LCBzZW5kZXJDb25uLCBzZW5kZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICAgIHkudHJhbnNhY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VUeXBlID09PSAnc3luYyBzdGVwIDInICYmIHNlbmRlckNvbm4uYXV0aCA9PT0gJ3dyaXRlJykge1xuICAgICAgICAgICAgICByZWFkU3luY1N0ZXAyKGRlY29kZXIsIGVuY29kZXIsIHksIHNlbmRlckNvbm4sIHNlbmRlcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2VUeXBlID09PSAndXBkYXRlJyAmJiAoc2tpcEF1dGggfHwgc2VuZGVyQ29ubi5hdXRoID09PSAnd3JpdGUnKSkge1xuICAgICAgICAgICAgICBpbnRlZ3JhdGVSZW1vdGVTdHJ1Y3RzKHksIGRlY29kZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVjZWl2ZSBtZXNzYWdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0U3luY2VkV2l0aCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN5bmNlZFdpdGgodXNlcikge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAodXNlciAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHVzZXJDb25uID0gdGhpcy5jb25uZWN0aW9ucy5nZXQodXNlcik7XG4gICAgICAgICAgdXNlckNvbm4uaXNTeW5jZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBtZXNzYWdlcyA9IHVzZXJDb25uLnByb2Nlc3NBZnRlclN5bmM7XG4gICAgICAgICAgdXNlckNvbm4ucHJvY2Vzc0FmdGVyU3luYyA9IFtdO1xuICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIF90aGlzMy5jb21wdXRlTWVzc2FnZShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubnMgPSBBcnJheS5mcm9tKHRoaXMuY29ubmVjdGlvbnMudmFsdWVzKCkpO1xuICAgICAgICBpZiAoY29ubnMubGVuZ3RoID4gMCAmJiBjb25ucy5ldmVyeShmdW5jdGlvbiAodSkge1xuICAgICAgICAgIHJldHVybiB1LmlzU3luY2VkO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHRoaXMuX2ZpcmVJc1N5bmNlZExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBBYnN0cmFjdENvbm5lY3RvcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBEZWNvZGVyIGFuZCBmaWxsIHRoZSBZanMgaW5zdGFuY2Ugd2l0aCBkYXRhIGluIHRoZSBkZWNvZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0JpbmFyeURlY29kZXJ9IGRlY29kZXIgVGhlIEJpbmFyeURlY29kZXIgdG8gcmVhZCBmcm9tLlxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbUJpbmFyeSh5LCBkZWNvZGVyKSB7XG4gICAgeS50cmFuc2FjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpbnRlZ3JhdGVSZW1vdGVTdHJ1Y3RzKHksIGRlY29kZXIpO1xuICAgICAgcmVhZERlbGV0ZVNldCh5LCBkZWNvZGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgdGhlIFlqcyBtb2RlbCB0byBiaW5hcnkgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtCaW5hcnlFbmNvZGVyfSBUaGUgZW5jb2RlciBpbnN0YW5jZSB0aGF0IGNhbiBiZSB0cmFuc2Zvcm1lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0byBBcnJheUJ1ZmZlciBvciBCdWZmZXIuXG4gICAqL1xuICBmdW5jdGlvbiB0b0JpbmFyeSh5KSB7XG4gICAgdmFyIGVuY29kZXIgPSBuZXcgQmluYXJ5RW5jb2RlcigpO1xuICAgIHdyaXRlU3RydWN0cyh5LCBlbmNvZGVyLCBuZXcgTWFwKCkpO1xuICAgIHdyaXRlRGVsZXRlU2V0KHksIGVuY29kZXIpO1xuICAgIHJldHVybiBlbmNvZGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RnJlc2hDbmYoKSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBCaW5hcnlFbmNvZGVyKCk7XG4gICAgYnVmZmVyLndyaXRlVWludDMyKDApO1xuICAgIHJldHVybiB7XG4gICAgICBsZW46IDAsXG4gICAgICBidWZmZXI6IGJ1ZmZlclxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWJzdHJhY3QgcGVyc2lzdGVuY2UgY2xhc3MuXG4gICAqL1xuXG4gIHZhciBBYnN0cmFjdFBlcnNpc3RlbmNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0UGVyc2lzdGVuY2Uob3B0cykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3RQZXJzaXN0ZW5jZSk7XG5cbiAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICB0aGlzLnlzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKEFic3RyYWN0UGVyc2lzdGVuY2UsIFt7XG4gICAgICBrZXk6ICdfaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjbmYgPSB0aGlzLnlzLmdldCh5KTtcbiAgICAgICAgaWYgKGNuZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY25mID0gZ2V0RnJlc2hDbmYoKTtcbiAgICAgICAgICBjbmYubXV0dWFsRXhjbHVkZSA9IGNyZWF0ZU11dHVhbEV4Y2x1ZGUoKTtcbiAgICAgICAgICB0aGlzLnlzLnNldCh5LCBjbmYpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmluaXQoeSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB5Lm9uKCdhZnRlclRyYW5zYWN0aW9uJywgZnVuY3Rpb24gKHksIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBjbmYgPSBfdGhpcy55cy5nZXQoeSk7XG4gICAgICAgICAgICAgIGlmIChjbmYubGVuID4gMCkge1xuICAgICAgICAgICAgICAgIGNuZi5idWZmZXIuc2V0VWludDMyKDAsIGNuZi5sZW4pO1xuICAgICAgICAgICAgICAgIF90aGlzLnNhdmVVcGRhdGUoeSwgY25mLmJ1ZmZlci5jcmVhdGVCdWZmZXIoKSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIHZhciBfY25mID0gZ2V0RnJlc2hDbmYoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX2NuZikge1xuICAgICAgICAgICAgICAgICAgY25mW2tleV0gPSBfY25mW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXRyaWV2ZSh5KTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY25mKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNuZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZWluaXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlaW5pdCh5KSB7XG4gICAgICAgIHRoaXMueXMuZGVsZXRlKHkpO1xuICAgICAgICB5LnBlcnNpc3RlbmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZXN0cm95JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnlzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgYWxsIHBlcnNpc3RlZCBkYXRhIHRoYXQgYmVsb25ncyB0byBhIHJvb20uXG4gICAgICAgKiBBdXRvbWF0aWNhbGx5IGRlc3Ryb3lzIGFsbCBZanMgYWxsIFlqcyBpbnN0YW5jZXMgdGhhdCBwZXJzaXN0IHRvXG4gICAgICAgKiB0aGUgcm9vbS4gSWYgYGRlc3Ryb3lZanNJbnN0YW5jZXMgPSBmYWxzZWAgdGhlIHBlcnNpc3RlbmNlIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAqIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBZanMgaW5zdGFuY2VzLlxuICAgICAgICpcbiAgICAgICAqICoqIE11c3QgYmUgb3ZlcndyaXR0ZW4hICoqXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbW92ZVBlcnNpc3RlZERhdGEnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVBlcnNpc3RlZERhdGEocm9vbSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgZGVzdHJveVlqc0luc3RhbmNlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgICB0aGlzLnlzLmZvckVhY2goZnVuY3Rpb24gKGNuZiwgeSkge1xuICAgICAgICAgIGlmICh5LnJvb20gPT09IHJvb20pIHtcbiAgICAgICAgICAgIGlmIChkZXN0cm95WWpzSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgIHkuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMyLmRlaW5pdCh5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKiBvdmVyd3JpdGUgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVVcGRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmVVcGRhdGUoYnVmZmVyKSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIFNhdmUgc3RydWN0IHRvIHVwZGF0ZSBidWZmZXIuXG4gICAgICAgKiBzYXZlVXBkYXRlIGlzIGNhbGxlZCB3aGVuIHRyYW5zYWN0aW9uIGVuZHNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZVN0cnVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZVN0cnVjdCh5LCBzdHJ1Y3QpIHtcbiAgICAgICAgdmFyIGNuZiA9IHRoaXMueXMuZ2V0KHkpO1xuICAgICAgICBpZiAoY25mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbmYubXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdHJ1Y3QuX3RvQmluYXJ5KGNuZi5idWZmZXIpO1xuICAgICAgICAgICAgY25mLmxlbisrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIG92ZXJ3cml0ZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmV0cmlldmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJldHJpZXZlKHksIG1vZGVsLCB1cGRhdGVzKSB7XG4gICAgICAgIHZhciBjbmYgPSB0aGlzLnlzLmdldCh5KTtcbiAgICAgICAgaWYgKGNuZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY25mLm11dHVhbEV4Y2x1ZGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgeS50cmFuc2FjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChtb2RlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZnJvbUJpbmFyeSh5LCBuZXcgQmluYXJ5RGVjb2RlcihuZXcgVWludDhBcnJheShtb2RlbCkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodXBkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpbnRlZ3JhdGVSZW1vdGVTdHJ1Y3RzKHksIG5ldyBCaW5hcnlEZWNvZGVyKG5ldyBVaW50OEFycmF5KHVwZGF0ZXNbaV0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHkuZW1pdCgncGVyc2lzdGVuY2VSZWFkeScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIG92ZXJ3cml0ZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncGVyc2lzdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGVyc2lzdCh5KSB7XG4gICAgICAgIHJldHVybiB0b0JpbmFyeSh5KS5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEFic3RyYWN0UGVyc2lzdGVuY2U7XG4gIH0oKTtcblxuICBmdW5jdGlvbiB0eXBlT2JzZXJ2ZXIkMSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fbXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGV4dGFyZWEgPSBfdGhpcy50YXJnZXQ7XG4gICAgICB2YXIgdGV4dFR5cGUgPSBfdGhpcy50eXBlO1xuICAgICAgdmFyIHJlbGF0aXZlU3RhcnQgPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKHRleHRUeXBlLCB0ZXh0YXJlYS5zZWxlY3Rpb25TdGFydCk7XG4gICAgICB2YXIgcmVsYXRpdmVFbmQgPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKHRleHRUeXBlLCB0ZXh0YXJlYS5zZWxlY3Rpb25FbmQpO1xuICAgICAgdGV4dGFyZWEudmFsdWUgPSB0ZXh0VHlwZS50b1N0cmluZygpO1xuICAgICAgdmFyIHN0YXJ0ID0gZnJvbVJlbGF0aXZlUG9zaXRpb24odGV4dFR5cGUuX3ksIHJlbGF0aXZlU3RhcnQpO1xuICAgICAgdmFyIGVuZCA9IGZyb21SZWxhdGl2ZVBvc2l0aW9uKHRleHRUeXBlLl95LCByZWxhdGl2ZUVuZCk7XG4gICAgICB0ZXh0YXJlYS5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbU9ic2VydmVyJDEoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0aGlzLl9tdXR1YWxFeGNsdWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkaWZmID0gc2ltcGxlRGlmZihfdGhpczIudHlwZS50b1N0cmluZygpLCBfdGhpczIudGFyZ2V0LnZhbHVlKTtcbiAgICAgIF90aGlzMi50eXBlLmRlbGV0ZShkaWZmLnBvcywgZGlmZi5yZW1vdmUpO1xuICAgICAgX3RoaXMyLnR5cGUuaW5zZXJ0KGRpZmYucG9zLCBkaWZmLmluc2VydCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBiaW5kaW5nIHRoYXQgYmluZHMgYSBZVGV4dCB0byBhIGRvbSB0ZXh0YXJlYS5cbiAgICpcbiAgICogVGhpcyBiaW5kaW5nIGlzIGF1dG9tYXRpY2FsbHkgZGVzdHJveWVkIHdoZW4gaXRzIHBhcmVudCBpcyBkZWxldGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGNvbnN0IHRleHRhcmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpXG4gICAqICAgY29uc3QgdHlwZSA9IHkuZGVmaW5lKCd0ZXh0YXJlYScsIFkuVGV4dClcbiAgICogICBjb25zdCBiaW5kaW5nID0gbmV3IFkuUXVpbGxCaW5kaW5nKHR5cGUsIHRleHRhcmVhKVxuICAgKlxuICAgKi9cblxuICB2YXIgVGV4dGFyZWFCaW5kaW5nID0gZnVuY3Rpb24gKF9CaW5kaW5nKSB7XG4gICAgaW5oZXJpdHMoVGV4dGFyZWFCaW5kaW5nLCBfQmluZGluZyk7XG5cbiAgICBmdW5jdGlvbiBUZXh0YXJlYUJpbmRpbmcodGV4dFR5cGUsIGRvbVRleHRhcmVhKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0YXJlYUJpbmRpbmcpO1xuXG4gICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgdmFyIF90aGlzMyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRleHRhcmVhQmluZGluZy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRleHRhcmVhQmluZGluZykpLmNhbGwodGhpcywgdGV4dFR5cGUsIGRvbVRleHRhcmVhKSk7XG4gICAgICAvLyBCaW5kaW5nIGhhbmRsZXMgdGV4dFR5cGUgYXMgdGhpcy50eXBlIGFuZCBkb21UZXh0YXJlYSBhcyB0aGlzLnRhcmdldFxuXG5cbiAgICAgIGRvbVRleHRhcmVhLnZhbHVlID0gdGV4dFR5cGUudG9TdHJpbmcoKTtcbiAgICAgIC8vIE9ic2VydmVycyBhcmUgaGFuZGxlZCBieSB0aGlzIGNsYXNzXG4gICAgICBfdGhpczMuX3R5cGVPYnNlcnZlciA9IHR5cGVPYnNlcnZlciQxLmJpbmQoX3RoaXMzKTtcbiAgICAgIF90aGlzMy5fZG9tT2JzZXJ2ZXIgPSBkb21PYnNlcnZlciQxLmJpbmQoX3RoaXMzKTtcbiAgICAgIHRleHRUeXBlLm9ic2VydmUoX3RoaXMzLl90eXBlT2JzZXJ2ZXIpO1xuICAgICAgZG9tVGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBfdGhpczMuX2RvbU9ic2VydmVyKTtcbiAgICAgIHJldHVybiBfdGhpczM7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoVGV4dGFyZWFCaW5kaW5nLCBbe1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgdGhhdCBpcyBoYW5kbGVkIGJ5IHRoaXMgY2xhc3NcbiAgICAgICAgdGhpcy50eXBlLnVub2JzZXJ2ZSh0aGlzLl90eXBlT2JzZXJ2ZXIpO1xuICAgICAgICB0aGlzLnRhcmdldC51bm9ic2VydmUodGhpcy5fZG9tT2JzZXJ2ZXIpO1xuICAgICAgICBnZXQoVGV4dGFyZWFCaW5kaW5nLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRleHRhcmVhQmluZGluZy5wcm90b3R5cGUpLCAnZGVzdHJveScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBUZXh0YXJlYUJpbmRpbmc7XG4gIH0oQmluZGluZyk7XG5cbiAgZnVuY3Rpb24gdHlwZU9ic2VydmVyJDIoZXZlbnQpIHtcbiAgICB2YXIgcXVpbGwgPSB0aGlzLnRhcmdldDtcbiAgICAvLyBGb3JjZSBmbHVzaCBRdWlsbCBjaGFuZ2VzLlxuICAgIHF1aWxsLnVwZGF0ZSgneWpzJyk7XG4gICAgdGhpcy5fbXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBBcHBseSBjb21wdXRlZCBkZWx0YS5cbiAgICAgIHF1aWxsLnVwZGF0ZUNvbnRlbnRzKGV2ZW50LmRlbHRhLCAneWpzJyk7XG4gICAgICAvLyBGb3JjZSBmbHVzaCBRdWlsbCBjaGFuZ2VzLiBJZ25vcmUgYXBwbGllZCBjaGFuZ2VzLlxuICAgICAgcXVpbGwudXBkYXRlKCd5anMnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1aWxsT2JzZXJ2ZXIoZGVsdGEpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fbXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy50eXBlLmFwcGx5RGVsdGEoZGVsdGEub3BzKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIEJpbmRpbmcgdGhhdCBiaW5kcyBhIFlUZXh0IHR5cGUgdG8gYSBRdWlsbCBlZGl0b3IuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHF1aWxsID0gbmV3IFF1aWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgKiBjb25zdCB0eXBlID0geS5kZWZpbmUoJ3F1aWxsJywgWS5UZXh0KVxuICAgKiBjb25zdCBiaW5kaW5nID0gbmV3IFkuUXVpbGxCaW5kaW5nKHF1aWxsLCB0eXBlKVxuICAgKiAvLyBOb3cgbW9kaWZpY2F0aW9ucyBvbiB0aGUgRE9NIHdpbGwgYmUgcmVmbGVjdGVkIGluIHRoZSBUeXBlLCBhbmQgdGhlIG90aGVyXG4gICAqIC8vIHdheSBhcm91bmQhXG4gICAqL1xuXG4gIHZhciBRdWlsbEJpbmRpbmcgPSBmdW5jdGlvbiAoX0JpbmRpbmcpIHtcbiAgICBpbmhlcml0cyhRdWlsbEJpbmRpbmcsIF9CaW5kaW5nKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7WVRleHR9IHRleHRUeXBlXG4gICAgICogQHBhcmFtIHtRdWlsbH0gcXVpbGxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdWlsbEJpbmRpbmcodGV4dFR5cGUsIHF1aWxsKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBRdWlsbEJpbmRpbmcpO1xuXG4gICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZS5cbiAgICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChRdWlsbEJpbmRpbmcuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihRdWlsbEJpbmRpbmcpKS5jYWxsKHRoaXMsIHRleHRUeXBlLCBxdWlsbCkpO1xuICAgICAgLy8gQmluZGluZyBoYW5kbGVzIHRleHRUeXBlIGFzIHRoaXMudHlwZSBhbmQgcXVpbGwgYXMgdGhpcy50YXJnZXQuXG5cblxuICAgICAgcXVpbGwuc2V0Q29udGVudHModGV4dFR5cGUudG9EZWx0YSgpLCAneWpzJyk7XG4gICAgICAvLyBPYnNlcnZlcnMgYXJlIGhhbmRsZWQgYnkgdGhpcyBjbGFzcy5cbiAgICAgIF90aGlzMi5fdHlwZU9ic2VydmVyID0gdHlwZU9ic2VydmVyJDIuYmluZChfdGhpczIpO1xuICAgICAgX3RoaXMyLl9xdWlsbE9ic2VydmVyID0gcXVpbGxPYnNlcnZlci5iaW5kKF90aGlzMik7XG4gICAgICB0ZXh0VHlwZS5vYnNlcnZlKF90aGlzMi5fdHlwZU9ic2VydmVyKTtcbiAgICAgIHF1aWxsLm9uKCd0ZXh0LWNoYW5nZScsIF90aGlzMi5fcXVpbGxPYnNlcnZlcik7XG4gICAgICByZXR1cm4gX3RoaXMyO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKFF1aWxsQmluZGluZywgW3tcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIHRoYXQgaXMgaGFuZGxlZCBieSB0aGlzIGNsYXNzLlxuICAgICAgICB0aGlzLnR5cGUudW5vYnNlcnZlKHRoaXMuX3R5cGVPYnNlcnZlcik7XG4gICAgICAgIHRoaXMudGFyZ2V0Lm9mZigndGV4dC1jaGFuZ2UnLCB0aGlzLl9xdWlsbE9ic2VydmVyKTtcbiAgICAgICAgZ2V0KFF1aWxsQmluZGluZy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihRdWlsbEJpbmRpbmcucHJvdG90eXBlKSwgJ2Rlc3Ryb3knLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gUXVpbGxCaW5kaW5nO1xuICB9KEJpbmRpbmcpO1xuXG4gIGZ1bmN0aW9uIHR5cGVPYnNlcnZlciQzKGV2ZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX211dHVhbEV4Y2x1ZGUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvZGVNaXJyb3IgPSBfdGhpcy50YXJnZXQ7XG4gICAgICB2YXIgZGVsdGFzID0gZXZlbnQuZGVsdGE7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIGZyb20gPSBjb2RlTWlycm9yLnBvc0Zyb21JbmRleChpbmRleCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07XG4gICAgICAgIGlmIChkZWx0YS5yZXRhaW4pIHtcbiAgICAgICAgICBpbmRleCA9IGRlbHRhLnJldGFpbjtcbiAgICAgICAgICBmcm9tID0gY29kZU1pcnJvci5wb3NGcm9tSW5kZXgoaW5kZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhLmluc2VydCkge1xuICAgICAgICAgIGNvZGVNaXJyb3IucmVwbGFjZVJhbmdlKGRlbHRhLmluc2VydCwgZnJvbSwgZnJvbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGEuZGVsZXRlKSB7XG4gICAgICAgICAgY29kZU1pcnJvci5yZXBsYWNlUmFuZ2UoJycsIGZyb20sIGNvZGVNaXJyb3IucG9zRnJvbUluZGV4KGluZGV4ICsgZGVsdGEuZGVsZXRlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvZGVNaXJyb3JPYnNlcnZlcihjb2RlTWlycm9yLCBkZWx0YXMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHRoaXMuX211dHVhbEV4Y2x1ZGUoZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRlbHRhID0gZGVsdGFzW2ldO1xuICAgICAgICB2YXIgc3RhcnQgPSBjb2RlTWlycm9yLmluZGV4RnJvbVBvcyhkZWx0YS5mcm9tKTtcbiAgICAgICAgLy8gYXBwbHkgdGhlIGRlbGV0ZSBvcGVyYXRpb24gZmlyc3RcbiAgICAgICAgaWYgKGRlbHRhLnJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBkZWxMZW5ndGggPSAwO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVsdGEucmVtb3ZlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZGVsTGVuZ3RoICs9IGRlbHRhLnJlbW92ZWRbal0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBcImVudGVyXCIgaXMgYWxzbyBhIGNoYXJhY3RlciBpbiBvdXIgY2FzZVxuICAgICAgICAgIGRlbExlbmd0aCArPSBkZWx0YS5yZW1vdmVkLmxlbmd0aCAtIDE7XG4gICAgICAgICAgX3RoaXMyLnR5cGUuZGVsZXRlKHN0YXJ0LCBkZWxMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGx5IGluc2VydCBvcGVyYXRpb25cbiAgICAgICAgX3RoaXMyLnR5cGUuaW5zZXJ0KHN0YXJ0LCBkZWx0YS50ZXh0LmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGJpbmRpbmcgdGhhdCBiaW5kcyBhIFlUZXh0IHRvIGEgY29kZW1pcnJvci5cbiAgICpcbiAgICogVGhpcyBiaW5kaW5nIGlzIGF1dG9tYXRpY2FsbHkgZGVzdHJveWVkIHdoZW4gaXRzIHBhcmVudCBpcyBkZWxldGVkLlxuICAgKlxuICAgKi9cblxuICB2YXIgQ29kZU1pcnJvckJpbmRpbmcgPSBmdW5jdGlvbiAoX0JpbmRpbmcpIHtcbiAgICBpbmhlcml0cyhDb2RlTWlycm9yQmluZGluZywgX0JpbmRpbmcpO1xuXG4gICAgZnVuY3Rpb24gQ29kZU1pcnJvckJpbmRpbmcodGV4dFR5cGUsIGNvZGVNaXJyb3IpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvZGVNaXJyb3JCaW5kaW5nKTtcblxuICAgICAgLy8gc2V0IGluaXRpYWwgdmFsdWVcbiAgICAgIHZhciBfdGhpczMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2RlTWlycm9yQmluZGluZy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGVNaXJyb3JCaW5kaW5nKSkuY2FsbCh0aGlzLCB0ZXh0VHlwZSwgY29kZU1pcnJvcikpO1xuXG4gICAgICBjb2RlTWlycm9yLnNldFZhbHVlKHRleHRUeXBlLnRvU3RyaW5nKCkpO1xuICAgICAgLy8gT2JzZXJ2ZXJzIGFyZSBoYW5kbGVkIGJ5IHRoaXMgY2xhc3NcbiAgICAgIF90aGlzMy5fdHlwZU9ic2VydmVyID0gdHlwZU9ic2VydmVyJDMuYmluZChfdGhpczMpO1xuICAgICAgX3RoaXMzLl9jb2RlTWlycm9yT2JzZXJ2ZXIgPSBjb2RlTWlycm9yT2JzZXJ2ZXIuYmluZChfdGhpczMpO1xuICAgICAgdGV4dFR5cGUub2JzZXJ2ZShfdGhpczMuX3R5cGVPYnNlcnZlcik7XG4gICAgICBjb2RlTWlycm9yLm9uKCdjaGFuZ2VzJywgX3RoaXMzLl9jb2RlTWlycm9yT2JzZXJ2ZXIpO1xuICAgICAgcmV0dXJuIF90aGlzMztcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhDb2RlTWlycm9yQmluZGluZywgW3tcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIHRoYXQgaXMgaGFuZGxlZCBieSB0aGlzIGNsYXNzXG4gICAgICAgIHRoaXMudHlwZS51bm9ic2VydmUodGhpcy5fdHlwZU9ic2VydmVyKTtcbiAgICAgICAgdGhpcy50YXJnZXQudW5vYnNlcnZlKHRoaXMuX2NvZGVNaXJyb3JPYnNlcnZlcik7XG4gICAgICAgIGdldChDb2RlTWlycm9yQmluZGluZy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2RlTWlycm9yQmluZGluZy5wcm90b3R5cGUpLCAnZGVzdHJveScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBDb2RlTWlycm9yQmluZGluZztcbiAgfShCaW5kaW5nKTtcblxuICAvLyBUT0RPOiBUaGUgZm9sbG93aW5nIGFzc2lnbm1lbnRzIHNob3VsZCBiZSBtb3ZlZCB0byB5anMtZGlzdFxuICBZLkFic3RyYWN0Q29ubmVjdG9yID0gQWJzdHJhY3RDb25uZWN0b3I7XG4gIFkuQWJzdHJhY3RQZXJzaXN0ZW5jZSA9IEFic3RyYWN0UGVyc2lzdGVuY2U7XG4gIFkuQXJyYXkgPSBZQXJyYXk7XG4gIFkuTWFwID0gWU1hcDtcbiAgWS5UZXh0ID0gWVRleHQ7XG4gIFkuWG1sRWxlbWVudCA9IFlYbWxFbGVtZW50O1xuICBZLlhtbEZyYWdtZW50ID0gWVhtbEZyYWdtZW50O1xuICBZLlhtbFRleHQgPSBZWG1sVGV4dDtcbiAgWS5YbWxIb29rID0gWVhtbEhvb2s7XG5cbiAgWS5UZXh0YXJlYUJpbmRpbmcgPSBUZXh0YXJlYUJpbmRpbmc7XG4gIFkuUXVpbGxCaW5kaW5nID0gUXVpbGxCaW5kaW5nO1xuICBZLkRvbUJpbmRpbmcgPSBEb21CaW5kaW5nO1xuICBZLkNvZGVNaXJyb3JCaW5kaW5nID0gQ29kZU1pcnJvckJpbmRpbmc7XG5cbiAgRG9tQmluZGluZy5kb21Ub1R5cGUgPSBkb21Ub1R5cGU7XG4gIERvbUJpbmRpbmcuZG9tc1RvVHlwZXMgPSBkb21zVG9UeXBlcztcbiAgRG9tQmluZGluZy5zd2l0Y2hBc3NvY2lhdGlvbiA9IHN3aXRjaEFzc29jaWF0aW9uO1xuXG4gIFkudXRpbHMgPSB7XG4gICAgQmluYXJ5RGVjb2RlcjogQmluYXJ5RGVjb2RlcixcbiAgICBVbmRvTWFuYWdlcjogVW5kb01hbmFnZXIsXG4gICAgZ2V0UmVsYXRpdmVQb3NpdGlvbjogZ2V0UmVsYXRpdmVQb3NpdGlvbixcbiAgICBmcm9tUmVsYXRpdmVQb3NpdGlvbjogZnJvbVJlbGF0aXZlUG9zaXRpb24sXG4gICAgcmVnaXN0ZXJTdHJ1Y3Q6IHJlZ2lzdGVyU3RydWN0LFxuICAgIGludGVncmF0ZVJlbW90ZVN0cnVjdHM6IGludGVncmF0ZVJlbW90ZVN0cnVjdHMsXG4gICAgdG9CaW5hcnk6IHRvQmluYXJ5LFxuICAgIGZyb21CaW5hcnk6IGZyb21CaW5hcnlcbiAgfTtcblxuICBZLmRlYnVnID0gYnJvd3NlcjtcbiAgYnJvd3Nlci5mb3JtYXR0ZXJzLlkgPSBtZXNzYWdlVG9TdHJpbmc7XG4gIGJyb3dzZXIuZm9ybWF0dGVycy55ID0gbWVzc2FnZVRvUm9vbW5hbWU7XG5cbiAgcmV0dXJuIFk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD15LmpzLm1hcFxuIiwiXG4vKipcbiAqIHlqcyAtIEEgZnJhbWV3b3JrIGZvciByZWFsLXRpbWUgcDJwIHNoYXJlZCBlZGl0aW5nIG9uIGFueSBkYXRhXG4gKiBAdmVyc2lvbiB2MTMuMC4wLTYyXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwuWSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9O1xuXG4gIHZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuXG4gICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gICAgfVxuXG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICB9O1xuXG4gIHZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbiAgfTtcblxuICB2YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgICAgdmFyIF9hcnIgPSBbXTtcbiAgICAgIHZhciBfbiA9IHRydWU7XG4gICAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgIF9lID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9hcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7XG4gICAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gcm90YXRlKHRyZWUsIHBhcmVudCwgbmV3UGFyZW50LCBuKSB7XG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJlZS5yb290ID0gbmV3UGFyZW50O1xuICAgICAgbmV3UGFyZW50Ll9wYXJlbnQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocGFyZW50LmxlZnQgPT09IG4pIHtcbiAgICAgIHBhcmVudC5sZWZ0ID0gbmV3UGFyZW50O1xuICAgIH0gZWxzZSBpZiAocGFyZW50LnJpZ2h0ID09PSBuKSB7XG4gICAgICBwYXJlbnQucmlnaHQgPSBuZXdQYXJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVsZW1lbnRzIGFyZSB3cm9uZ2x5IGNvbm5lY3RlZCEnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBIGNyZWF0ZWQgbm9kZSBpcyBhbHdheXMgcmVkIVxuICAgIGZ1bmN0aW9uIE4odmFsKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOKTtcblxuICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICB0aGlzLmNvbG9yID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2xlZnQgPSBudWxsO1xuICAgICAgdGhpcy5fcmlnaHQgPSBudWxsO1xuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhOLCBbe1xuICAgICAga2V5OiAnaXNSZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzUmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc0JsYWNrJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JsYWNrKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sb3I7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncmVkZGVuJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWRkZW4oKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSB0cnVlO3JldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2JsYWNrZW4nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJsYWNrZW4oKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBmYWxzZTtyZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyb3RhdGVMZWZ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVMZWZ0KHRyZWUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgbmV3UGFyZW50ID0gdGhpcy5yaWdodDtcbiAgICAgICAgdmFyIG5ld1JpZ2h0ID0gdGhpcy5yaWdodC5sZWZ0O1xuICAgICAgICBuZXdQYXJlbnQubGVmdCA9IHRoaXM7XG4gICAgICAgIHRoaXMucmlnaHQgPSBuZXdSaWdodDtcbiAgICAgICAgcm90YXRlKHRyZWUsIHBhcmVudCwgbmV3UGFyZW50LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICduZXh0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHNlYXJjaCB0aGUgbW9zdCBsZWZ0IG5vZGUgaW4gdGhlIHJpZ2h0IHRyZWVcbiAgICAgICAgICB2YXIgbyA9IHRoaXMucmlnaHQ7XG4gICAgICAgICAgd2hpbGUgKG8ubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG8ubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHAgPSB0aGlzO1xuICAgICAgICAgIHdoaWxlIChwLnBhcmVudCAhPT0gbnVsbCAmJiBwICE9PSBwLnBhcmVudC5sZWZ0KSB7XG4gICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3ByZXYnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBzZWFyY2ggdGhlIG1vc3QgcmlnaHQgbm9kZSBpbiB0aGUgbGVmdCB0cmVlXG4gICAgICAgICAgdmFyIG8gPSB0aGlzLmxlZnQ7XG4gICAgICAgICAgd2hpbGUgKG8ucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG8gPSBvLnJpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcCA9IHRoaXM7XG4gICAgICAgICAgd2hpbGUgKHAucGFyZW50ICE9PSBudWxsICYmIHAgIT09IHAucGFyZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JvdGF0ZVJpZ2h0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVSaWdodCh0cmVlKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IHRoaXMubGVmdDtcbiAgICAgICAgdmFyIG5ld0xlZnQgPSB0aGlzLmxlZnQucmlnaHQ7XG4gICAgICAgIG5ld1BhcmVudC5yaWdodCA9IHRoaXM7XG4gICAgICAgIHRoaXMubGVmdCA9IG5ld0xlZnQ7XG4gICAgICAgIHJvdGF0ZSh0cmVlLCBwYXJlbnQsIG5ld1BhcmVudCwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0VW5jbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVuY2xlKCkge1xuICAgICAgICAvLyB3ZSBjYW4gYXNzdW1lIHRoYXQgZ3JhbmRwYXJlbnQgZXhpc3RzIHdoZW4gdGhpcyBpcyBjYWxsZWQhXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCA9PT0gdGhpcy5wYXJlbnQucGFyZW50LmxlZnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucGFyZW50LnJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wYXJlbnQubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dyYW5kcGFyZW50JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3BhcmVudCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzaWJsaW5nJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcyA9PT0gdGhpcy5wYXJlbnQubGVmdCA/IHRoaXMucGFyZW50LnJpZ2h0IDogdGhpcy5wYXJlbnQubGVmdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdsZWZ0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShuKSB7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgbi5fcGFyZW50ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZWZ0ID0gbjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyaWdodCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG4pIHtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICBuLl9wYXJlbnQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gbjtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIE47XG4gIH0oKTtcblxuICAvKlxuICAgKiBUaGlzIGlzIGEgUmVkIEJsYWNrIFRyZWUgaW1wbGVtZW50YXRpb25cbiAgICovXG5cblxuICB2YXIgVHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlKCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZSk7XG5cbiAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoVHJlZSwgW3tcbiAgICAgIGtleTogJ2ZpbmROZXh0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTmV4dChpZCkge1xuICAgICAgICB2YXIgbmV4dElEID0gaWQuY2xvbmUoKTtcbiAgICAgICAgbmV4dElELmNsb2NrICs9IDE7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRXaXRoTG93ZXJCb3VuZChuZXh0SUQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmRQcmV2JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kUHJldihpZCkge1xuICAgICAgICB2YXIgcHJldklEID0gaWQuY2xvbmUoKTtcbiAgICAgICAgcHJldklELmNsb2NrIC09IDE7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRXaXRoVXBwZXJCb3VuZChwcmV2SUQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmROb2RlV2l0aExvd2VyQm91bmQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmROb2RlV2l0aExvd2VyQm91bmQoZnJvbSkge1xuICAgICAgICB2YXIgbyA9IHRoaXMucm9vdDtcbiAgICAgICAgaWYgKG8gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IG51bGwgfHwgZnJvbS5sZXNzVGhhbihvLnZhbC5faWQpICYmIG8ubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBvIGlzIGluY2x1ZGVkIGluIHRoZSBib3VuZFxuICAgICAgICAgICAgICAvLyB0cnkgdG8gZmluZCBhbiBlbGVtZW50IHRoYXQgaXMgY2xvc2VyIHRvIHRoZSBib3VuZFxuICAgICAgICAgICAgICBvID0gby5sZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcm9tICE9PSBudWxsICYmIG8udmFsLl9pZC5sZXNzVGhhbihmcm9tKSkge1xuICAgICAgICAgICAgICAvLyBvIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kLCBtYXliZSBvbmUgb2YgdGhlIHJpZ2h0IGVsZW1lbnRzIGlzLi5cbiAgICAgICAgICAgICAgaWYgKG8ucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvID0gby5yaWdodDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyByaWdodCBlbGVtZW50LiBTZWFyY2ggZm9yIHRoZSBuZXh0IGJpZ2dlciBlbGVtZW50LFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIG8ubmV4dCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaW5kTm9kZVdpdGhVcHBlckJvdW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTm9kZVdpdGhVcHBlckJvdW5kKHRvKSB7XG4gICAgICAgIGlmICh0byA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBkZWZpbmUgZnJvbSEnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbyA9IHRoaXMucm9vdDtcbiAgICAgICAgaWYgKG8gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCh0byA9PT0gbnVsbCB8fCBvLnZhbC5faWQubGVzc1RoYW4odG8pKSAmJiBvLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIG8gaXMgaW5jbHVkZWQgaW4gdGhlIGJvdW5kXG4gICAgICAgICAgICAgIC8vIHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgdGhhdCBpcyBjbG9zZXIgdG8gdGhlIGJvdW5kXG4gICAgICAgICAgICAgIG8gPSBvLnJpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0byAhPT0gbnVsbCAmJiB0by5sZXNzVGhhbihvLnZhbC5faWQpKSB7XG4gICAgICAgICAgICAgIC8vIG8gaXMgbm90IHdpdGhpbiB0aGUgYm91bmQsIG1heWJlIG9uZSBvZiB0aGUgbGVmdCBlbGVtZW50cyBpcy4uXG4gICAgICAgICAgICAgIGlmIChvLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvID0gby5sZWZ0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIGxlZnQgZWxlbWVudC4gU2VhcmNoIGZvciB0aGUgcHJldiBzbWFsbGVyIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgYmUgd2l0aGluIHRoZSBib3VuZHNcbiAgICAgICAgICAgICAgICByZXR1cm4gby5wcmV2KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmRTbWFsbGVzdE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRTbWFsbGVzdE5vZGUoKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5yb290O1xuICAgICAgICB3aGlsZSAobyAhPSBudWxsICYmIG8ubGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgbyA9IG8ubGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaW5kV2l0aExvd2VyQm91bmQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRXaXRoTG93ZXJCb3VuZChmcm9tKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5maW5kTm9kZVdpdGhMb3dlckJvdW5kKGZyb20pO1xuICAgICAgICByZXR1cm4gbiA9PSBudWxsID8gbnVsbCA6IG4udmFsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmRXaXRoVXBwZXJCb3VuZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFdpdGhVcHBlckJvdW5kKHRvKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5maW5kTm9kZVdpdGhVcHBlckJvdW5kKHRvKTtcbiAgICAgICAgcmV0dXJuIG4gPT0gbnVsbCA/IG51bGwgOiBuLnZhbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpdGVyYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpdGVyYXRlKGZyb20sIHRvLCBmKSB7XG4gICAgICAgIHZhciBvO1xuICAgICAgICBpZiAoZnJvbSA9PT0gbnVsbCkge1xuICAgICAgICAgIG8gPSB0aGlzLmZpbmRTbWFsbGVzdE5vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvID0gdGhpcy5maW5kTm9kZVdpdGhMb3dlckJvdW5kKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmICh0byA9PT0gbnVsbCB8fCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVubW9kaWZpZWQtbG9vcC1jb25kaXRpb25cbiAgICAgICAgby52YWwuX2lkLmxlc3NUaGFuKHRvKSB8fCBvLnZhbC5faWQuZXF1YWxzKHRvKSkpIHtcbiAgICAgICAgICBmKG8udmFsKTtcbiAgICAgICAgICBvID0gby5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kKGlkKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5maW5kTm9kZShpZCk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG4udmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZmluZE5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmROb2RlKGlkKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5yb290O1xuICAgICAgICBpZiAobyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAobyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZC5sZXNzVGhhbihvLnZhbC5faWQpKSB7XG4gICAgICAgICAgICAgIG8gPSBvLmxlZnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG8udmFsLl9pZC5sZXNzVGhhbihpZCkpIHtcbiAgICAgICAgICAgICAgbyA9IG8ucmlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZWxldGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoaWQpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmZpbmROb2RlKGlkKTtcbiAgICAgICAgaWYgKGQgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBkb2VzIG5vdCBleGlzdCEnKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICBpZiAoZC5sZWZ0ICE9PSBudWxsICYmIGQucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBzd2l0Y2ggZCB3aXRoIHRoZSBncmVhdGVzIGVsZW1lbnQgaW4gdGhlIGxlZnQgc3VidHJlZS5cbiAgICAgICAgICAvLyBvIHNob3VsZCBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlxuICAgICAgICAgIHZhciBvID0gZC5sZWZ0O1xuICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICB3aGlsZSAoby5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG8ucmlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN3aXRjaFxuICAgICAgICAgIGQudmFsID0gby52YWw7XG4gICAgICAgICAgZCA9IG87XG4gICAgICAgIH1cbiAgICAgICAgLy8gZCBoYXMgYXQgbW9zdCBvbmUgY2hpbGRcbiAgICAgICAgLy8gbGV0IG4gYmUgdGhlIG5vZGUgdGhhdCByZXBsYWNlcyBkXG4gICAgICAgIHZhciBpc0Zha2VDaGlsZDtcbiAgICAgICAgdmFyIGNoaWxkID0gZC5sZWZ0IHx8IGQucmlnaHQ7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlzRmFrZUNoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBjaGlsZCA9IG5ldyBOKG51bGwpO1xuICAgICAgICAgIGNoaWxkLmJsYWNrZW4oKTtcbiAgICAgICAgICBkLnJpZ2h0ID0gY2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNGYWtlQ2hpbGQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmICghaXNGYWtlQ2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IGNoaWxkO1xuICAgICAgICAgICAgY2hpbGQuYmxhY2tlbigpO1xuICAgICAgICAgICAgY2hpbGQuX3BhcmVudCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChkLnBhcmVudC5sZWZ0ID09PSBkKSB7XG4gICAgICAgICAgZC5wYXJlbnQubGVmdCA9IGNoaWxkO1xuICAgICAgICB9IGVsc2UgaWYgKGQucGFyZW50LnJpZ2h0ID09PSBkKSB7XG4gICAgICAgICAgZC5wYXJlbnQucmlnaHQgPSBjaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcG9zc2libGUhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuaXNCbGFjaygpKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmlzUmVkKCkpIHtcbiAgICAgICAgICAgIGNoaWxkLmJsYWNrZW4oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZml4RGVsZXRlKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290LmJsYWNrZW4oKTtcbiAgICAgICAgaWYgKGlzRmFrZUNoaWxkKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLnBhcmVudC5sZWZ0ID09PSBjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50LmxlZnQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQucGFyZW50LnJpZ2h0ID09PSBjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50LnJpZ2h0ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlICMzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpeERlbGV0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeERlbGV0ZShuKSB7XG4gICAgICAgIGZ1bmN0aW9uIGlzQmxhY2sobm9kZSkge1xuICAgICAgICAgIHJldHVybiBub2RlICE9PSBudWxsID8gbm9kZS5pc0JsYWNrKCkgOiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzUmVkKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZSAhPT0gbnVsbCA/IG5vZGUuaXNSZWQoKSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIHRoaXMgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBmaXJzdCBpdGVyYXRpb24gb2YgZml4RGVsZXRlLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBkIHdhcyBhbHJlYWR5IHJlcGxhY2VkIGJ5IHRoZSBjaGlsZFxuICAgICAgICAvLyBkIGlzIG5vdCB0aGUgcm9vdFxuICAgICAgICAvLyBkIGFuZCBjaGlsZCBhcmUgYmxhY2tcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBuLnNpYmxpbmc7XG4gICAgICAgIGlmIChpc1JlZChzaWJsaW5nKSkge1xuICAgICAgICAgIC8vIG1ha2Ugc2libGluZyB0aGUgZ3JhbmRmYXRoZXJcbiAgICAgICAgICBuLnBhcmVudC5yZWRkZW4oKTtcbiAgICAgICAgICBzaWJsaW5nLmJsYWNrZW4oKTtcbiAgICAgICAgICBpZiAobiA9PT0gbi5wYXJlbnQubGVmdCkge1xuICAgICAgICAgICAgbi5wYXJlbnQucm90YXRlTGVmdCh0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IG4ucGFyZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICBuLnBhcmVudC5yb3RhdGVSaWdodCh0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlICMyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpYmxpbmcgPSBuLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFyZW50LCBzaWJsaW5nLCBhbmQgY2hpbGRyZW4gb2YgbiBhcmUgYmxhY2tcbiAgICAgICAgaWYgKG4ucGFyZW50LmlzQmxhY2soKSAmJiBzaWJsaW5nLmlzQmxhY2soKSAmJiBpc0JsYWNrKHNpYmxpbmcubGVmdCkgJiYgaXNCbGFjayhzaWJsaW5nLnJpZ2h0KSkge1xuICAgICAgICAgIHNpYmxpbmcucmVkZGVuKCk7XG4gICAgICAgICAgdGhpcy5fZml4RGVsZXRlKG4ucGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChuLnBhcmVudC5pc1JlZCgpICYmIHNpYmxpbmcuaXNCbGFjaygpICYmIGlzQmxhY2soc2libGluZy5sZWZ0KSAmJiBpc0JsYWNrKHNpYmxpbmcucmlnaHQpKSB7XG4gICAgICAgICAgc2libGluZy5yZWRkZW4oKTtcbiAgICAgICAgICBuLnBhcmVudC5ibGFja2VuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG4gPT09IG4ucGFyZW50LmxlZnQgJiYgc2libGluZy5pc0JsYWNrKCkgJiYgaXNSZWQoc2libGluZy5sZWZ0KSAmJiBpc0JsYWNrKHNpYmxpbmcucmlnaHQpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLnJlZGRlbigpO1xuICAgICAgICAgICAgc2libGluZy5sZWZ0LmJsYWNrZW4oKTtcbiAgICAgICAgICAgIHNpYmxpbmcucm90YXRlUmlnaHQodGhpcyk7XG4gICAgICAgICAgICBzaWJsaW5nID0gbi5zaWJsaW5nO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gbi5wYXJlbnQucmlnaHQgJiYgc2libGluZy5pc0JsYWNrKCkgJiYgaXNSZWQoc2libGluZy5yaWdodCkgJiYgaXNCbGFjayhzaWJsaW5nLmxlZnQpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLnJlZGRlbigpO1xuICAgICAgICAgICAgc2libGluZy5yaWdodC5ibGFja2VuKCk7XG4gICAgICAgICAgICBzaWJsaW5nLnJvdGF0ZUxlZnQodGhpcyk7XG4gICAgICAgICAgICBzaWJsaW5nID0gbi5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWJsaW5nLmNvbG9yID0gbi5wYXJlbnQuY29sb3I7XG4gICAgICAgICAgbi5wYXJlbnQuYmxhY2tlbigpO1xuICAgICAgICAgIGlmIChuID09PSBuLnBhcmVudC5sZWZ0KSB7XG4gICAgICAgICAgICBzaWJsaW5nLnJpZ2h0LmJsYWNrZW4oKTtcbiAgICAgICAgICAgIG4ucGFyZW50LnJvdGF0ZUxlZnQodGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcubGVmdC5ibGFja2VuKCk7XG4gICAgICAgICAgICBuLnBhcmVudC5yb3RhdGVSaWdodCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdwdXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1dCh2KSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE4odik7XG4gICAgICAgIGlmICh0aGlzLnJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgcCA9IHRoaXMucm9vdDsgLy8gcCBhYmJyZXYuIHBhcmVudFxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS52YWwuX2lkLmxlc3NUaGFuKHAudmFsLl9pZCkpIHtcbiAgICAgICAgICAgICAgaWYgKHAubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHAubGVmdCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHAubGVmdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwLnZhbC5faWQubGVzc1RoYW4obm9kZS52YWwuX2lkKSkge1xuICAgICAgICAgICAgICBpZiAocC5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHAucmlnaHQgPSBub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBwLnJpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnZhbCA9IG5vZGUudmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZml4SW5zZXJ0KG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucm9vdCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgdGhpcy5yb290LmJsYWNrZW4oKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpeEluc2VydCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeEluc2VydChuKSB7XG4gICAgICAgIGlmIChuLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIG4uYmxhY2tlbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChuLnBhcmVudC5pc0JsYWNrKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVuY2xlID0gbi5nZXRVbmNsZSgpO1xuICAgICAgICBpZiAodW5jbGUgIT09IG51bGwgJiYgdW5jbGUuaXNSZWQoKSkge1xuICAgICAgICAgIC8vIE5vdGU6IHBhcmVudDogcmVkLCB1bmNsZTogcmVkXG4gICAgICAgICAgbi5wYXJlbnQuYmxhY2tlbigpO1xuICAgICAgICAgIHVuY2xlLmJsYWNrZW4oKTtcbiAgICAgICAgICBuLmdyYW5kcGFyZW50LnJlZGRlbigpO1xuICAgICAgICAgIHRoaXMuX2ZpeEluc2VydChuLmdyYW5kcGFyZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3RlOiBwYXJlbnQ6IHJlZCwgdW5jbGU6IGJsYWNrIG9yIG51bGxcbiAgICAgICAgICAvLyBOb3cgd2UgdHJhbnNmb3JtIHRoZSB0cmVlIGluIHN1Y2ggYSB3YXkgdGhhdFxuICAgICAgICAgIC8vIGVpdGhlciBvZiB0aGVzZSBob2xkczpcbiAgICAgICAgICAvLyAgIDEpIGdyYW5kcGFyZW50LmxlZnQuaXNSZWRcbiAgICAgICAgICAvLyAgICAgYW5kIGdyYW5kcGFyZW50LmxlZnQubGVmdC5pc1JlZFxuICAgICAgICAgIC8vICAgMikgZ3JhbmRwYXJlbnQucmlnaHQuaXNSZWRcbiAgICAgICAgICAvLyAgICAgYW5kIGdyYW5kcGFyZW50LnJpZ2h0LnJpZ2h0LmlzUmVkXG4gICAgICAgICAgaWYgKG4gPT09IG4ucGFyZW50LnJpZ2h0ICYmIG4ucGFyZW50ID09PSBuLmdyYW5kcGFyZW50LmxlZnQpIHtcbiAgICAgICAgICAgIG4ucGFyZW50LnJvdGF0ZUxlZnQodGhpcyk7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSByb3RhdGVkIGFuZCB3YW50IHRvIHVzZSB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIGNhc2VzLCB3ZSBuZWVkIHRvIHNldCBuIGluIHN1Y2ggYSB3YXkgdGhhdFxuICAgICAgICAgICAgLy8gbi5wYXJlbnQuaXNSZWQgYWdhaW5cbiAgICAgICAgICAgIG4gPSBuLmxlZnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChuID09PSBuLnBhcmVudC5sZWZ0ICYmIG4ucGFyZW50ID09PSBuLmdyYW5kcGFyZW50LnJpZ2h0KSB7XG4gICAgICAgICAgICBuLnBhcmVudC5yb3RhdGVSaWdodCh0aGlzKTtcbiAgICAgICAgICAgIC8vIHNlZSBhYm92ZVxuICAgICAgICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhc2UgMSkgb3IgMikgaG9sZCBmcm9tIGhlcmUgb24uXG4gICAgICAgICAgLy8gTm93IHRyYXZlcnNlIGdyYW5kcGFyZW50LCBtYWtlIHBhcmVudCBhIGJsYWNrIG5vZGVcbiAgICAgICAgICAvLyBvbiB0aGUgaGlnaGVzdCBsZXZlbCB3aGljaCBob2xkcyB0d28gcmVkIG5vZGVzLlxuICAgICAgICAgIG4ucGFyZW50LmJsYWNrZW4oKTtcbiAgICAgICAgICBuLmdyYW5kcGFyZW50LnJlZGRlbigpO1xuICAgICAgICAgIGlmIChuID09PSBuLnBhcmVudC5sZWZ0KSB7XG4gICAgICAgICAgICAvLyBDYXNlIDFcbiAgICAgICAgICAgIG4uZ3JhbmRwYXJlbnQucm90YXRlUmlnaHQodGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhc2UgMlxuICAgICAgICAgICAgbi5ncmFuZHBhcmVudC5yb3RhdGVMZWZ0KHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gVHJlZTtcbiAgfSgpO1xuXG4gIHZhciBJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJRCh1c2VyLCBjbG9jaykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSUQpO1xuXG4gICAgICB0aGlzLnVzZXIgPSB1c2VyOyAvLyBUT0RPOiByZW5hbWUgdG8gY2xpZW50XG4gICAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoSUQsIFt7XG4gICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJRCh0aGlzLnVzZXIsIHRoaXMuY2xvY2spO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlcXVhbHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkICE9PSBudWxsICYmIGlkLnVzZXIgPT09IHRoaXMudXNlciAmJiBpZC5jbG9jayA9PT0gdGhpcy5jbG9jaztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGVzc1RoYW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsZXNzVGhhbihpZCkge1xuICAgICAgICBpZiAoaWQuY29uc3RydWN0b3IgPT09IElEKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudXNlciA8IGlkLnVzZXIgfHwgdGhpcy51c2VyID09PSBpZC51c2VyICYmIHRoaXMuY2xvY2sgPCBpZC5jbG9jaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIElEO1xuICB9KCk7XG5cbiAgdmFyIERTTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEU05vZGUoaWQsIGxlbiwgZ2MpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERTTm9kZSk7XG5cbiAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICAgIHRoaXMuZ2MgPSBnYztcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhEU05vZGUsIFt7XG4gICAgICBrZXk6ICdjbG9uZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRFNOb2RlKHRoaXMuX2lkLCB0aGlzLmxlbiwgdGhpcy5nYyk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBEU05vZGU7XG4gIH0oKTtcblxuICB2YXIgRGVsZXRlU3RvcmUgPSBmdW5jdGlvbiAoX1RyZWUpIHtcbiAgICBpbmhlcml0cyhEZWxldGVTdG9yZSwgX1RyZWUpO1xuXG4gICAgZnVuY3Rpb24gRGVsZXRlU3RvcmUoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEZWxldGVTdG9yZSk7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRGVsZXRlU3RvcmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEZWxldGVTdG9yZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKERlbGV0ZVN0b3JlLCBbe1xuICAgICAga2V5OiAnbG9nVGFibGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ1RhYmxlKCkge1xuICAgICAgICB2YXIgZGVsZXRlcyA9IFtdO1xuICAgICAgICB0aGlzLml0ZXJhdGUobnVsbCwgbnVsbCwgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICBkZWxldGVzLnB1c2goe1xuICAgICAgICAgICAgdXNlcjogbi5faWQudXNlcixcbiAgICAgICAgICAgIGNsb2NrOiBuLl9pZC5jbG9jayxcbiAgICAgICAgICAgIGxlbjogbi5sZW4sXG4gICAgICAgICAgICBnYzogbi5nY1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS50YWJsZShkZWxldGVzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpc0RlbGV0ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGVsZXRlZChpZCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuZmluZFdpdGhVcHBlckJvdW5kKGlkKTtcbiAgICAgICAgcmV0dXJuIG4gIT09IG51bGwgJiYgbi5faWQudXNlciA9PT0gaWQudXNlciAmJiBpZC5jbG9jayA8IG4uX2lkLmNsb2NrICsgbi5sZW47XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFyaycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFyayhpZCwgbGVuZ3RoLCBnYykge1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIC8vIFN0ZXAgMS4gVW5tYXJrIHJhbmdlXG4gICAgICAgIHZhciBsZWZ0RCA9IHRoaXMuZmluZFdpdGhVcHBlckJvdW5kKG5ldyBJRChpZC51c2VyLCBpZC5jbG9jayAtIDEpKTtcbiAgICAgICAgLy8gUmVzaXplIGxlZnQgRFNOb2RlIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAobGVmdEQgIT09IG51bGwgJiYgbGVmdEQuX2lkLnVzZXIgPT09IGlkLnVzZXIpIHtcbiAgICAgICAgICBpZiAobGVmdEQuX2lkLmNsb2NrIDwgaWQuY2xvY2sgJiYgaWQuY2xvY2sgPCBsZWZ0RC5faWQuY2xvY2sgKyBsZWZ0RC5sZW4pIHtcbiAgICAgICAgICAgIC8vIG5vZGUgaXMgb3ZlcmxhcHBpbmcuIG5lZWQgdG8gcmVzaXplXG4gICAgICAgICAgICBpZiAoaWQuY2xvY2sgKyBsZW5ndGggPCBsZWZ0RC5faWQuY2xvY2sgKyBsZWZ0RC5sZW4pIHtcbiAgICAgICAgICAgICAgLy8gb3ZlcmxhcHMgbmV3IG1hcmsgcmFuZ2UgYW5kIHNvbWUgbW9yZVxuICAgICAgICAgICAgICAvLyBjcmVhdGUgYW5vdGhlciBEU05vZGUgdG8gdGhlIHJpZ2h0IG9mIG5ldyBtYXJrXG4gICAgICAgICAgICAgIHRoaXMucHV0KG5ldyBEU05vZGUobmV3IElEKGlkLnVzZXIsIGlkLmNsb2NrICsgbGVuZ3RoKSwgbGVmdEQuX2lkLmNsb2NrICsgbGVmdEQubGVuIC0gaWQuY2xvY2sgLSBsZW5ndGgsIGxlZnRELmdjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXNpemUgbGVmdCBEU05vZGVcbiAgICAgICAgICAgIGxlZnRELmxlbiA9IGlkLmNsb2NrIC0gbGVmdEQuX2lkLmNsb2NrO1xuICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlIHRoZXJlIGlzIG5vIG92ZXJsYXBwaW5nXG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzaXplIHJpZ2h0IERTTm9kZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIHVwcGVyID0gbmV3IElEKGlkLnVzZXIsIGlkLmNsb2NrICsgbGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciByaWdodEQgPSB0aGlzLmZpbmRXaXRoVXBwZXJCb3VuZCh1cHBlcik7XG4gICAgICAgIGlmIChyaWdodEQgIT09IG51bGwgJiYgcmlnaHRELl9pZC51c2VyID09PSBpZC51c2VyKSB7XG4gICAgICAgICAgaWYgKHJpZ2h0RC5faWQuY2xvY2sgPCBpZC5jbG9jayArIGxlbmd0aCAmJiBpZC5jbG9jayA8PSByaWdodEQuX2lkLmNsb2NrICYmIGlkLmNsb2NrICsgbGVuZ3RoIDwgcmlnaHRELl9pZC5jbG9jayArIHJpZ2h0RC5sZW4pIHtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgY29uc2lkZXIgdGhlIGNhc2Ugd2hlcmUgd2UgcmVzaXplIHRoZSBub2RlXG4gICAgICAgICAgICB2YXIgZCA9IGlkLmNsb2NrICsgbGVuZ3RoIC0gcmlnaHRELl9pZC5jbG9jaztcbiAgICAgICAgICAgIHJpZ2h0RC5faWQgPSBuZXcgSUQocmlnaHRELl9pZC51c2VyLCByaWdodEQuX2lkLmNsb2NrICsgZCk7XG4gICAgICAgICAgICByaWdodEQubGVuIC09IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyB3ZSBvbmx5IGhhdmUgdG8gZGVsZXRlIGFsbCBpbm5lciBtYXJrc1xuICAgICAgICB2YXIgZGVsZXRlTm9kZUlkcyA9IFtdO1xuICAgICAgICB0aGlzLml0ZXJhdGUoaWQsIHVwcGVyLCBmdW5jdGlvbiAobSkge1xuICAgICAgICAgIGRlbGV0ZU5vZGVJZHMucHVzaChtLl9pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gZGVsZXRlTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMuZGVsZXRlKGRlbGV0ZU5vZGVJZHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdNYXJrID0gbmV3IERTTm9kZShpZCwgbGVuZ3RoLCBnYyk7XG4gICAgICAgIC8vIFN0ZXAgMi4gQ2hlY2sgaWYgd2UgY2FuIGV4dGVuZCBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgIGlmIChsZWZ0RCAhPT0gbnVsbCAmJiBsZWZ0RC5faWQudXNlciA9PT0gaWQudXNlciAmJiBsZWZ0RC5faWQuY2xvY2sgKyBsZWZ0RC5sZW4gPT09IGlkLmNsb2NrICYmIGxlZnRELmdjID09PSBnYykge1xuICAgICAgICAgIC8vIFdlIGNhbiBleHRlbmQgbGVmdFxuICAgICAgICAgIGxlZnRELmxlbiArPSBsZW5ndGg7XG4gICAgICAgICAgbmV3TWFyayA9IGxlZnREO1xuICAgICAgICB9XG4gICAgICAgIHZhciByaWdodE5leHQgPSB0aGlzLmZpbmQobmV3IElEKGlkLnVzZXIsIGlkLmNsb2NrICsgbGVuZ3RoKSk7XG4gICAgICAgIGlmIChyaWdodE5leHQgIT09IG51bGwgJiYgcmlnaHROZXh0Ll9pZC51c2VyID09PSBpZC51c2VyICYmIGlkLmNsb2NrICsgbGVuZ3RoID09PSByaWdodE5leHQuX2lkLmNsb2NrICYmIGdjID09PSByaWdodE5leHQuZ2MpIHtcbiAgICAgICAgICAvLyBXZSBjYW4gbWVyZ2UgbmV3TWFyayBhbmQgcmlnaHROZXh0XG4gICAgICAgICAgbmV3TWFyay5sZW4gKz0gcmlnaHROZXh0LmxlbjtcbiAgICAgICAgICB0aGlzLmRlbGV0ZShyaWdodE5leHQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdEQgIT09IG5ld01hcmspIHtcbiAgICAgICAgICAvLyBvbmx5IHB1dCBpZiB3ZSBkaWRuJ3QgZXh0ZW5kIGxlZnRcbiAgICAgICAgICB0aGlzLnB1dChuZXdNYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVE9ETzogZXhjaGFuZ2UgbWFya0RlbGV0ZWQgZm9yIG1hcmsoKVxuXG4gICAgfSwge1xuICAgICAga2V5OiAnbWFya0RlbGV0ZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtEZWxldGVkKGlkLCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5tYXJrKGlkLCBsZW5ndGgsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIERlbGV0ZVN0b3JlO1xuICB9KFRyZWUpO1xuXG4gIC8qKlxuICAgKiBBIEJpbmFyeURlY29kZXIgaGFuZGxlcyB0aGUgZGVjb2Rpbmcgb2YgYW4gQXJyYXlCdWZmZXIuXG4gICAqL1xuXG4gIHZhciBCaW5hcnlEZWNvZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheXxCdWZmZXJ9IGJ1ZmZlciBUaGUgYmluYXJ5IGRhdGEgdGhhdCB0aGlzIGluc3RhbmNlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQmluYXJ5RGVjb2RlcihidWZmZXIpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJpbmFyeURlY29kZXIpO1xuXG4gICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdGhpcy51aW50OGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYnVmZmVyIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIHRoaXMudWludDhhcnIgPSBidWZmZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFuIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkhJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmUgdGhpcyBkZWNvZGVyIGluc3RhbmNlLlxuICAgICAqIE9wdGlvbmFsbHkgc2V0IGEgbmV3IHBvc2l0aW9uIHBhcmFtZXRlci5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoQmluYXJ5RGVjb2RlciwgW3tcbiAgICAgIGtleTogJ2Nsb25lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIG5ld1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5wb3M7XG5cbiAgICAgICAgdmFyIGRlY29kZXIgPSBuZXcgQmluYXJ5RGVjb2Rlcih0aGlzLnVpbnQ4YXJyKTtcbiAgICAgICAgZGVjb2Rlci5wb3MgPSBuZXdQb3M7XG4gICAgICAgIHJldHVybiBkZWNvZGVyO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE51bWJlciBvZiBieXRlcy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2tpcDgnLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogU2tpcCBvbmUgYnl0ZSwganVtcCB0byB0aGUgbmV4dCBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNraXA4KCkge1xuICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWQgb25lIGJ5dGUgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVhZFVpbnQ4JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVWludDgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQ4YXJyW3RoaXMucG9zKytdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWQgNCBieXRlcyBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVhZFVpbnQzMicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFVpbnQzMigpIHtcbiAgICAgICAgdmFyIHVpbnQgPSB0aGlzLnVpbnQ4YXJyW3RoaXMucG9zXSArICh0aGlzLnVpbnQ4YXJyW3RoaXMucG9zICsgMV0gPDwgOCkgKyAodGhpcy51aW50OGFyclt0aGlzLnBvcyArIDJdIDw8IDE2KSArICh0aGlzLnVpbnQ4YXJyW3RoaXMucG9zICsgM10gPDwgMjQpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdWludDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMb29rIGFoZWFkIHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uLlxuICAgICAgICogdG8gdGhlIG5leHQgYnl0ZSBhbmQgcmVhZCBpdCBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncGVla1VpbnQ4JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwZWVrVWludDgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQ4YXJyW3RoaXMucG9zXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWFkIHVuc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAgICAgICAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gICAgICAgKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0ZS5cbiAgICAgICAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnl0ZXMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWFkVmFyVWludCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFZhclVpbnQoKSB7XG4gICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICB2YXIgbGVuID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgciA9IHRoaXMudWludDhhcnJbdGhpcy5wb3MrK107XG4gICAgICAgICAgbnVtID0gbnVtIHwgKHIgJiAxMjcpIDw8IGxlbjtcbiAgICAgICAgICBsZW4gKz0gNztcbiAgICAgICAgICBpZiAociA8IDEgPDwgNykge1xuICAgICAgICAgICAgcmV0dXJuIG51bSA+Pj4gMDsgLy8gcmV0dXJuIHVuc2lnbmVkIG51bWJlciFcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlbiA+IDM1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXIgb3V0IG9mIHJhbmdlIScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWQgc3RyaW5nIG9mIHZhcmlhYmxlIGxlbmd0aFxuICAgICAgICogKiB2YXJVaW50IGlzIHVzZWQgdG8gc3RvcmUgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmcuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlYWRWYXJTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRWYXJTdHJpbmcoKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgYnl0ZXNbaV0gPSB0aGlzLnVpbnQ4YXJyW3RoaXMucG9zKytdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmNvZGVkU3RyaW5nID0gYnl0ZXMubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGIpO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyU3RyaW5nIHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3BlZWtWYXJTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBlZWtWYXJTdHJpbmcoKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdmFyIHMgPSB0aGlzLnJlYWRWYXJTdHJpbmcoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWQgSUQuXG4gICAgICAgKiAqIElmIGZpcnN0IHZhclVpbnQgcmVhZCBpcyAweEZGRkZGRiBhIFJvb3RJRCBpcyByZXR1cm5lZC5cbiAgICAgICAqICogT3RoZXJ3aXNlIGFuIElEIGlzIHJldHVybmVkLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4gSURcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVhZElEJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkSUQoKSB7XG4gICAgICAgIHZhciB1c2VyID0gdGhpcy5yZWFkVmFyVWludCgpO1xuICAgICAgICBpZiAodXNlciA9PT0gUm9vdEZha2VVc2VySUQpIHtcbiAgICAgICAgICAvLyByZWFkIHByb3BlcnR5IG5hbWUgYW5kIHR5cGUgaWRcbiAgICAgICAgICB2YXIgcmlkID0gbmV3IFJvb3RJRCh0aGlzLnJlYWRWYXJTdHJpbmcoKSwgbnVsbCk7XG4gICAgICAgICAgcmlkLnR5cGUgPSB0aGlzLnJlYWRWYXJVaW50KCk7XG4gICAgICAgICAgcmV0dXJuIHJpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IElEKHVzZXIsIHRoaXMucmVhZFZhclVpbnQoKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbGVuZ3RoJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50OGFyci5sZW5ndGg7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBCaW5hcnlEZWNvZGVyO1xuICB9KCk7XG5cbiAgLy8gVE9ETyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBiYXNlIGNsYXNzIGFzIEl0ZW1cblxuICB2YXIgR0MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR0MoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBHQyk7XG5cbiAgICAgIHRoaXMuX2lkID0gbnVsbDtcbiAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoR0MsIFt7XG4gICAgICBrZXk6ICdfaW50ZWdyYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW50ZWdyYXRlKHkpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5faWQ7XG4gICAgICAgIHZhciB1c2VyU3RhdGUgPSB5LnNzLmdldFN0YXRlKGlkLnVzZXIpO1xuICAgICAgICBpZiAoaWQuY2xvY2sgPT09IHVzZXJTdGF0ZSkge1xuICAgICAgICAgIHkuc3Muc2V0U3RhdGUoaWQudXNlciwgaWQuY2xvY2sgKyB0aGlzLl9sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHkuZHMubWFyayh0aGlzLl9pZCwgdGhpcy5fbGVuZ3RoLCB0cnVlKTtcbiAgICAgICAgdmFyIG4gPSB5Lm9zLnB1dCh0aGlzKTtcbiAgICAgICAgdmFyIHByZXYgPSBuLnByZXYoKS52YWw7XG4gICAgICAgIGlmIChwcmV2ICE9PSBudWxsICYmIHByZXYuY29uc3RydWN0b3IgPT09IEdDICYmIHByZXYuX2lkLnVzZXIgPT09IG4udmFsLl9pZC51c2VyICYmIHByZXYuX2lkLmNsb2NrICsgcHJldi5fbGVuZ3RoID09PSBuLnZhbC5faWQuY2xvY2spIHtcbiAgICAgICAgICAvLyBUT0RPOiBkbyBtZXJnaW5nIGZvciBhbGwgaXRlbXMhXG4gICAgICAgICAgcHJldi5fbGVuZ3RoICs9IG4udmFsLl9sZW5ndGg7XG4gICAgICAgICAgeS5vcy5kZWxldGUobi52YWwuX2lkKTtcbiAgICAgICAgICBuID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobi52YWwpIHtcbiAgICAgICAgICBuID0gbi52YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQgPSB5Lm9zLmZpbmROZXh0KG4uX2lkKTtcbiAgICAgICAgaWYgKG5leHQgIT09IG51bGwgJiYgbmV4dC5jb25zdHJ1Y3RvciA9PT0gR0MgJiYgbmV4dC5faWQudXNlciA9PT0gbi5faWQudXNlciAmJiBuZXh0Ll9pZC5jbG9jayA9PT0gbi5faWQuY2xvY2sgKyBuLl9sZW5ndGgpIHtcbiAgICAgICAgICBuLl9sZW5ndGggKz0gbmV4dC5fbGVuZ3RoO1xuICAgICAgICAgIHkub3MuZGVsZXRlKG5leHQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQudXNlciAhPT0gUm9vdEZha2VVc2VySUQpIHtcbiAgICAgICAgICBpZiAoeS5jb25uZWN0b3IgIT09IG51bGwgJiYgKHkuY29ubmVjdG9yLl9mb3J3YXJkQXBwbGllZFN0cnVjdHMgfHwgaWQudXNlciA9PT0geS51c2VySUQpKSB7XG4gICAgICAgICAgICB5LmNvbm5lY3Rvci5icm9hZGNhc3RTdHJ1Y3QodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5LnBlcnNpc3RlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB5LnBlcnNpc3RlbmNlLnNhdmVTdHJ1Y3QoeSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAgICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0JpbmFyeUVuY29kZXJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190b0JpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvQmluYXJ5KGVuY29kZXIpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVVpbnQ4KGdldFN0cnVjdFJlZmVyZW5jZSh0aGlzLmNvbnN0cnVjdG9yKSk7XG4gICAgICAgIGVuY29kZXIud3JpdGVJRCh0aGlzLl9pZCk7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJVaW50KHRoaXMuX2xlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVhZCB0aGUgbmV4dCBJdGVtIGluIGEgRGVjb2RlciBhbmQgZmlsbCB0aGlzIEl0ZW0gd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gZGF0YSBpcyByZWNlaXZlZCBmcm9tIGEgcmVtb3RlIHBlZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2UgdGhhdCB0aGlzIEl0ZW0gYmVsb25ncyB0by5cbiAgICAgICAqIEBwYXJhbSB7QmluYXJ5RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBvYmplY3QgdG8gcmVhZCBkYXRhIGZyb20uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZnJvbUJpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zyb21CaW5hcnkoeSwgZGVjb2Rlcikge1xuICAgICAgICB2YXIgaWQgPSBkZWNvZGVyLnJlYWRJRCgpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHZhciBtaXNzaW5nID0gW107XG4gICAgICAgIGlmICh5LnNzLmdldFN0YXRlKGlkLnVzZXIpIDwgaWQuY2xvY2spIHtcbiAgICAgICAgICBtaXNzaW5nLnB1c2gobmV3IElEKGlkLnVzZXIsIGlkLmNsb2NrIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zcGxpdEF0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3BsaXRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2Nsb25lUGFydGlhbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Nsb25lUGFydGlhbChkaWZmKSB7XG4gICAgICAgIHZhciBnYyA9IG5ldyBHQygpO1xuICAgICAgICBnYy5faWQgPSBuZXcgSUQodGhpcy5faWQudXNlciwgdGhpcy5faWQuY2xvY2sgKyBkaWZmKTtcbiAgICAgICAgZ2MuX2xlbmd0aCA9IHRoaXMuX2xlbmd0aCAtIGRpZmY7XG4gICAgICAgIHJldHVybiBnYztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGVsZXRlZCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBHQztcbiAgfSgpO1xuXG4gIHZhciBNaXNzaW5nRW50cnkgPSBmdW5jdGlvbiBNaXNzaW5nRW50cnkoZGVjb2RlciwgbWlzc2luZywgc3RydWN0KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWlzc2luZ0VudHJ5KTtcblxuICAgIHRoaXMuZGVjb2RlciA9IGRlY29kZXI7XG4gICAgdGhpcy5taXNzaW5nID0gbWlzc2luZy5sZW5ndGg7XG4gICAgdGhpcy5zdHJ1Y3QgPSBzdHJ1Y3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEludGVncmF0ZSByZW1vdGUgc3RydWN0XG4gICAqIFdoZW4gYSByZW1vdGUgc3RydWN0IGlzIGludGVncmF0ZWQsIG90aGVyIHN0cnVjdHMgbWlnaHQgYmUgcmVhZHkgdG8gcmVhZHkgdG9cbiAgICogaW50ZWdyYXRlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIF9pbnRlZ3JhdGVSZW1vdGVTdHJ1Y3RIZWxwZXIoeSwgc3RydWN0KSB7XG4gICAgdmFyIGlkID0gc3RydWN0Ll9pZDtcbiAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RydWN0Ll9pbnRlZ3JhdGUoeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh5LnNzLmdldFN0YXRlKGlkLnVzZXIpID4gaWQuY2xvY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF5LmdjRW5hYmxlZCB8fCBzdHJ1Y3QuY29uc3RydWN0b3IgPT09IEdDIHx8IHN0cnVjdC5fcGFyZW50LmNvbnN0cnVjdG9yICE9PSBHQyAmJiBzdHJ1Y3QuX3BhcmVudC5fZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gSXMgZWl0aGVyIGEgR0Mgb3IgSXRlbSB3aXRoIGFuIHVuZGVsZXRlZCBwYXJlbnRcbiAgICAgICAgLy8gc2F2ZSB0byBpbnRlZ3JhdGVcbiAgICAgICAgc3RydWN0Ll9pbnRlZ3JhdGUoeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJcyBhbiBJdGVtLiBwYXJlbnQgd2FzIGRlbGV0ZWQuXG4gICAgICAgIHN0cnVjdC5fZ2MoeSk7XG4gICAgICB9XG4gICAgICB2YXIgbXN1ID0geS5fbWlzc2luZ1N0cnVjdHMuZ2V0KGlkLnVzZXIpO1xuICAgICAgaWYgKG1zdSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjbG9jayA9IGlkLmNsb2NrO1xuICAgICAgICB2YXIgZmluYWxDbG9jayA9IGNsb2NrICsgc3RydWN0Ll9sZW5ndGg7XG4gICAgICAgIGZvciAoOyBjbG9jayA8IGZpbmFsQ2xvY2s7IGNsb2NrKyspIHtcbiAgICAgICAgICB2YXIgbWlzc2luZ1N0cnVjdHMgPSBtc3UuZ2V0KGNsb2NrKTtcbiAgICAgICAgICBpZiAobWlzc2luZ1N0cnVjdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWlzc2luZ1N0cnVjdHMuZm9yRWFjaChmdW5jdGlvbiAobWlzc2luZ0RlZikge1xuICAgICAgICAgICAgICBtaXNzaW5nRGVmLm1pc3NpbmctLTtcbiAgICAgICAgICAgICAgaWYgKG1pc3NpbmdEZWYubWlzc2luZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWNvZGVyID0gbWlzc2luZ0RlZi5kZWNvZGVyO1xuICAgICAgICAgICAgICAgIHZhciBvbGRQb3MgPSBkZWNvZGVyLnBvcztcbiAgICAgICAgICAgICAgICB2YXIgbWlzc2luZyA9IG1pc3NpbmdEZWYuc3RydWN0Ll9mcm9tQmluYXJ5KHksIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIGRlY29kZXIucG9zID0gb2xkUG9zO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgeS5fcmVhZHlUb0ludGVncmF0ZS5wdXNoKG1pc3NpbmdEZWYuc3RydWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbXN1LmRlbGV0ZShjbG9jayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5U3RydWN0cyh5LCBkZWNvZGVyLCBzdHJCdWlsZGVyKSB7XG4gICAgdmFyIGxlbiA9IGRlY29kZXIucmVhZFVpbnQzMigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciByZWZlcmVuY2UgPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICB2YXIgQ29uc3RyID0gZ2V0U3RydWN0KHJlZmVyZW5jZSk7XG4gICAgICB2YXIgc3RydWN0ID0gbmV3IENvbnN0cigpO1xuICAgICAgdmFyIG1pc3NpbmcgPSBzdHJ1Y3QuX2Zyb21CaW5hcnkoeSwgZGVjb2Rlcik7XG4gICAgICB2YXIgbG9nTWVzc2FnZSA9ICcgICcgKyBzdHJ1Y3QuX2xvZ1N0cmluZygpO1xuICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICBsb2dNZXNzYWdlICs9ICcgLi4gbWlzc2luZzogJyArIG1pc3NpbmcubWFwKGxvZ0lEKS5qb2luKCcsICcpO1xuICAgICAgfVxuICAgICAgc3RyQnVpbGRlci5wdXNoKGxvZ01lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVncmF0ZVJlbW90ZVN0cnVjdHMoeSwgZGVjb2Rlcikge1xuICAgIHZhciBsZW4gPSBkZWNvZGVyLnJlYWRVaW50MzIoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgdmFyIENvbnN0ciA9IGdldFN0cnVjdChyZWZlcmVuY2UpO1xuICAgICAgdmFyIHN0cnVjdCA9IG5ldyBDb25zdHIoKTtcbiAgICAgIHZhciBkZWNvZGVyUG9zID0gZGVjb2Rlci5wb3M7XG4gICAgICB2YXIgbWlzc2luZyA9IHN0cnVjdC5fZnJvbUJpbmFyeSh5LCBkZWNvZGVyKTtcbiAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB3aGlsZSAoc3RydWN0ICE9IG51bGwpIHtcbiAgICAgICAgICBfaW50ZWdyYXRlUmVtb3RlU3RydWN0SGVscGVyKHksIHN0cnVjdCk7XG4gICAgICAgICAgc3RydWN0ID0geS5fcmVhZHlUb0ludGVncmF0ZS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2RlY29kZXIgPSBuZXcgQmluYXJ5RGVjb2RlcihkZWNvZGVyLnVpbnQ4YXJyKTtcbiAgICAgICAgX2RlY29kZXIucG9zID0gZGVjb2RlclBvcztcbiAgICAgICAgdmFyIG1pc3NpbmdFbnRyeSA9IG5ldyBNaXNzaW5nRW50cnkoX2RlY29kZXIsIG1pc3NpbmcsIHN0cnVjdCk7XG4gICAgICAgIHZhciBtaXNzaW5nU3RydWN0cyA9IHkuX21pc3NpbmdTdHJ1Y3RzO1xuICAgICAgICBmb3IgKHZhciBfaSA9IG1pc3NpbmcubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgICAgICAgIHZhciBtID0gbWlzc2luZ1tfaV07XG4gICAgICAgICAgaWYgKCFtaXNzaW5nU3RydWN0cy5oYXMobS51c2VyKSkge1xuICAgICAgICAgICAgbWlzc2luZ1N0cnVjdHMuc2V0KG0udXNlciwgbmV3IE1hcCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1zdSA9IG1pc3NpbmdTdHJ1Y3RzLmdldChtLnVzZXIpO1xuICAgICAgICAgIGlmICghbXN1LmhhcyhtLmNsb2NrKSkge1xuICAgICAgICAgICAgbXN1LnNldChtLmNsb2NrLCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtQXJyYXkgPSBtc3UgPSBtc3UuZ2V0KG0uY2xvY2spO1xuICAgICAgICAgIG1BcnJheS5wdXNoKG1pc3NpbmdFbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYml0czcgPSAxMjc7XG4gIHZhciBiaXRzOCA9IDI1NTtcblxuICAvKipcbiAgICogQSBCaW5hcnlFbmNvZGVyIGhhbmRsZXMgdGhlIGVuY29kaW5nIHRvIGFuIEFycmF5QnVmZmVyLlxuICAgKi9cblxuICB2YXIgQmluYXJ5RW5jb2RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5hcnlFbmNvZGVyKCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQmluYXJ5RW5jb2Rlcik7XG5cbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBjaGFpbmVkIFVpbnQ4QXJyYXkgYnVmZmVycyBpbnN0ZWFkIG9mIEFycmF5IGJ1ZmZlclxuICAgICAgLy8gVE9ETzogUmV3cml0ZSBhbGwgbWV0aG9kcyBhcyBmdW5jdGlvbnMhXG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBsZW5ndGggb2YgdGhlIGVuY29kZWQgZGF0YS5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoQmluYXJ5RW5jb2RlciwgW3tcbiAgICAgIGtleTogJ2NyZWF0ZUJ1ZmZlcicsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYW4gQXJyYXlCdWZmZXIuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7VWludDhBcnJheX0gQSBVaW50OEFycmF5IHRoYXQgcmVwcmVzZW50cyB0aGUgd3JpdHRlbiBkYXRhLlxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHRoaXMuZGF0YSkuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIG9uZSBieXRlIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnd3JpdGVVaW50OCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVaW50OChudW0pIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2gobnVtICYgYml0czgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIG9uZSBieXRlIGFzIGFuIHVuc2lnbmVkIEludGVnZXIgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRVaW50OCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VWludDgocG9zLCBudW0pIHtcbiAgICAgICAgdGhpcy5kYXRhW3Bvc10gPSBudW0gJiBiaXRzODtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd3cml0ZVVpbnQxNicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVaW50MTYobnVtKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKG51bSAmIGJpdHM4LCBudW0gPj4+IDggJiBiaXRzOCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUaGUgbG9jYXRpb24gd2hlcmUgdGhlIGRhdGEgd2lsbCBiZSB3cml0dGVuLlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0VWludDE2JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVaW50MTYocG9zLCBudW0pIHtcbiAgICAgICAgdGhpcy5kYXRhW3Bvc10gPSBudW0gJiBiaXRzODtcbiAgICAgICAgdGhpcy5kYXRhW3BvcyArIDFdID0gbnVtID4+PiA4ICYgYml0czg7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXJcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd3cml0ZVVpbnQzMicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVaW50MzIobnVtKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2gobnVtICYgYml0czgpO1xuICAgICAgICAgIG51bSA+Pj49IDg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldFVpbnQzMicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VWludDMyKHBvcywgbnVtKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kYXRhW3BvcyArIGldID0gbnVtICYgYml0czg7XG4gICAgICAgICAgbnVtID4+Pj0gODtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHVuc2lnbmVkIGludGVnZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnd3JpdGVWYXJVaW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZVZhclVpbnQobnVtKSB7XG4gICAgICAgIHdoaWxlIChudW0gPj0gMTI4KSB7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1c2goMTI4IHwgYml0czcgJiBudW0pO1xuICAgICAgICAgIG51bSA+Pj49IDc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhLnB1c2goYml0czcgJiBudW0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd3cml0ZVZhclN0cmluZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVWYXJTdHJpbmcoc3RyKSB7XG4gICAgICAgIHZhciBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBlbmNvZGVkU3RyaW5nLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gYy5jb2RlUG9pbnRBdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy53cml0ZVZhclVpbnQobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKGJ5dGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlIGFuIElEIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SUR9IGlkIFRoZSBJRCB0aGF0IGlzIHRvIGJlIHdyaXR0ZW4uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3dyaXRlSUQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlSUQoaWQpIHtcbiAgICAgICAgdmFyIHVzZXIgPSBpZC51c2VyO1xuICAgICAgICB0aGlzLndyaXRlVmFyVWludCh1c2VyKTtcbiAgICAgICAgaWYgKHVzZXIgIT09IFJvb3RGYWtlVXNlcklEKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVZhclVpbnQoaWQuY2xvY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud3JpdGVWYXJTdHJpbmcoaWQubmFtZSk7XG4gICAgICAgICAgdGhpcy53cml0ZVZhclVpbnQoaWQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdsZW5ndGgnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjdXJyZW50IHdyaXRlIHBvaW50ZXIgKHRoZSBzYW1lIGFzIHtAbGluayBsZW5ndGh9KS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncG9zJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEJpbmFyeUVuY29kZXI7XG4gIH0oKTtcblxuICBmdW5jdGlvbiByZWFkU3RhdGVTZXQoZGVjb2Rlcikge1xuICAgIHZhciBzcyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgc3NMZW5ndGggPSBkZWNvZGVyLnJlYWRVaW50MzIoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB1c2VyID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgdmFyIGNsb2NrID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgc3Muc2V0KHVzZXIsIGNsb2NrKTtcbiAgICB9XG4gICAgcmV0dXJuIHNzO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVTdGF0ZVNldCh5LCBlbmNvZGVyKSB7XG4gICAgdmFyIGxlblBvc2l0aW9uID0gZW5jb2Rlci5wb3M7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgZW5jb2Rlci53cml0ZVVpbnQzMigwKTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHkuc3Muc3RhdGVbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IHNsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgICAgdXNlciA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgY2xvY2sgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICBlbmNvZGVyLndyaXRlVmFyVWludCh1c2VyKTtcbiAgICAgICAgZW5jb2Rlci53cml0ZVZhclVpbnQoY2xvY2spO1xuICAgICAgICBsZW4rKztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbmNvZGVyLnNldFVpbnQzMihsZW5Qb3NpdGlvbiwgbGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlRGVsZXRlU2V0KHksIGVuY29kZXIpIHtcbiAgICB2YXIgY3VycmVudFVzZXIgPSBudWxsO1xuICAgIHZhciBjdXJyZW50TGVuZ3RoID0gdm9pZCAwO1xuICAgIHZhciBsYXN0TGVuUG9zID0gdm9pZCAwO1xuXG4gICAgdmFyIG51bWJlck9mVXNlcnMgPSAwO1xuICAgIHZhciBsYXRlckRTTGVuUHVzID0gZW5jb2Rlci5wb3M7XG4gICAgZW5jb2Rlci53cml0ZVVpbnQzMigwKTtcblxuICAgIHkuZHMuaXRlcmF0ZShudWxsLCBudWxsLCBmdW5jdGlvbiAobikge1xuICAgICAgdmFyIHVzZXIgPSBuLl9pZC51c2VyO1xuICAgICAgdmFyIGNsb2NrID0gbi5faWQuY2xvY2s7XG4gICAgICB2YXIgbGVuID0gbi5sZW47XG4gICAgICB2YXIgZ2MgPSBuLmdjO1xuICAgICAgaWYgKGN1cnJlbnRVc2VyICE9PSB1c2VyKSB7XG4gICAgICAgIG51bWJlck9mVXNlcnMrKztcbiAgICAgICAgLy8gYSBuZXcgdXNlciB3YXMgZm91bmRcbiAgICAgICAgaWYgKGN1cnJlbnRVc2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gaGFwcGVucyBvbiBmaXJzdCBpdGVyYXRpb25cbiAgICAgICAgICBlbmNvZGVyLnNldFVpbnQzMihsYXN0TGVuUG9zLCBjdXJyZW50TGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VXNlciA9IHVzZXI7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJVaW50KHVzZXIpO1xuICAgICAgICAvLyBwc2V1ZG8tZmlsbCBwb3NcbiAgICAgICAgbGFzdExlblBvcyA9IGVuY29kZXIucG9zO1xuICAgICAgICBlbmNvZGVyLndyaXRlVWludDMyKDApO1xuICAgICAgICBjdXJyZW50TGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGVuY29kZXIud3JpdGVWYXJVaW50KGNsb2NrKTtcbiAgICAgIGVuY29kZXIud3JpdGVWYXJVaW50KGxlbik7XG4gICAgICBlbmNvZGVyLndyaXRlVWludDgoZ2MgPyAxIDogMCk7XG4gICAgICBjdXJyZW50TGVuZ3RoKys7XG4gICAgfSk7XG4gICAgaWYgKGN1cnJlbnRVc2VyICE9PSBudWxsKSB7XG4gICAgICAvLyBoYXBwZW5zIG9uIGZpcnN0IGl0ZXJhdGlvblxuICAgICAgZW5jb2Rlci5zZXRVaW50MzIobGFzdExlblBvcywgY3VycmVudExlbmd0aCk7XG4gICAgfVxuICAgIGVuY29kZXIuc2V0VWludDMyKGxhdGVyRFNMZW5QdXMsIG51bWJlck9mVXNlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZERlbGV0ZVNldCh5LCBkZWNvZGVyKSB7XG4gICAgdmFyIGRzTGVuZ3RoID0gZGVjb2Rlci5yZWFkVWludDMyKCk7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICB2YXIgdXNlciA9IGRlY29kZXIucmVhZFZhclVpbnQoKTtcbiAgICAgIHZhciBkdiA9IFtdO1xuICAgICAgdmFyIGR2TGVuZ3RoID0gZGVjb2Rlci5yZWFkVWludDMyKCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGR2TGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGZyb20gPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHZhciBsZW4gPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHZhciBnYyA9IGRlY29kZXIucmVhZFVpbnQ4KCkgPT09IDE7XG4gICAgICAgIGR2LnB1c2goW2Zyb20sIGxlbiwgZ2NdKTtcbiAgICAgIH1cbiAgICAgIGlmIChkdkxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgIHZhciBkID0gZHZbcG9zXTtcbiAgICAgICAgdmFyIGRlbGV0aW9ucyA9IFtdO1xuICAgICAgICB5LmRzLml0ZXJhdGUobmV3IElEKHVzZXIsIDApLCBuZXcgSUQodXNlciwgTnVtYmVyLk1BWF9WQUxVRSksIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgLy8gY2FzZXM6XG4gICAgICAgICAgLy8gMS4gZCBkZWxldGVzIHNvbWV0aGluZyB0byB0aGUgcmlnaHQgb2YgblxuICAgICAgICAgIC8vICA9PiBnbyB0byBuZXh0IG4gKGJyZWFrKVxuICAgICAgICAgIC8vIDIuIGQgZGVsZXRlcyBzb21ldGhpbmcgdG8gdGhlIGxlZnQgb2YgblxuICAgICAgICAgIC8vICA9PiBjcmVhdGUgZGVsZXRpb25zXG4gICAgICAgICAgLy8gID0+IHJlc2V0IGQgYWNjb3JkaW5nbHlcbiAgICAgICAgICAvLyAgKik9PiBpZiBkIGRvZXNuJ3QgZGVsZXRlIGFueXRoaW5nIGFueW1vcmUsIGdvIHRvIG5leHQgZCAoY29udGludWUpXG4gICAgICAgICAgLy8gMy4gbm90IDIpIGFuZCBkIGRlbGV0ZXMgc29tZXRoaW5nIHRoYXQgYWxzbyBuIGRlbGV0ZXNcbiAgICAgICAgICAvLyAgPT4gcmVzZXQgZCBzbyB0aGF0IGl0IGRvZXNuJ3QgY29udGFpbiBuJ3MgZGVsZXRpb25cbiAgICAgICAgICAvLyAgKik9PiBpZiBkIGRvZXMgbm90IGRlbGV0ZSBhbnl0aGluZyBhbnltb3JlLCBnbyB0byBuZXh0IGQgKGNvbnRpbnVlKVxuICAgICAgICAgIHdoaWxlIChkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gMDsgLy8gZGVzY3JpYmUgdGhlIGRpZmYgb2YgbGVuZ3RoIGluIDEpIGFuZCAyKVxuICAgICAgICAgICAgaWYgKG4uX2lkLmNsb2NrICsgbi5sZW4gPD0gZFswXSkge1xuICAgICAgICAgICAgICAvLyAxKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZFswXSA8IG4uX2lkLmNsb2NrKSB7XG4gICAgICAgICAgICAgIC8vIDIpXG4gICAgICAgICAgICAgIC8vIGRlbGV0ZSBtYXhpbXVtIHRoZSBsZW4gb2YgZFxuICAgICAgICAgICAgICAvLyBlbHNlIGRlbGV0ZSBhcyBtdWNoIGFzIHBvc3NpYmxlXG4gICAgICAgICAgICAgIGRpZmYgPSBNYXRoLm1pbihuLl9pZC5jbG9jayAtIGRbMF0sIGRbMV0pO1xuICAgICAgICAgICAgICAvLyBkZWxldGVJdGVtUmFuZ2UoeSwgdXNlciwgZFswXSwgZGlmZiwgdHJ1ZSlcbiAgICAgICAgICAgICAgZGVsZXRpb25zLnB1c2goW3VzZXIsIGRbMF0sIGRpZmZdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIDMpXG4gICAgICAgICAgICAgIGRpZmYgPSBuLl9pZC5jbG9jayArIG4ubGVuIC0gZFswXTsgLy8gbmV2ZXIgbnVsbCAoc2VlIDEpXG4gICAgICAgICAgICAgIGlmIChkWzJdICYmICFuLmdjKSB7XG4gICAgICAgICAgICAgICAgLy8gZCBtYXJrcyBhcyBnYydkIGJ1dCBuIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgLy8gdGhlbiBkZWxldGUgZWl0aGVyIHdheVxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZUl0ZW1SYW5nZSh5LCB1c2VyLCBkWzBdLCBNYXRoLm1pbihkaWZmLCBkWzFdKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICBkZWxldGlvbnMucHVzaChbdXNlciwgZFswXSwgTWF0aC5taW4oZGlmZiwgZFsxXSldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRbMV0gPD0gZGlmZikge1xuICAgICAgICAgICAgICAvLyBkIGRvZXNuJ3QgZGVsZXRlIGFueXRoaW5nIGFueW1vcmVcbiAgICAgICAgICAgICAgZCA9IGR2WysrcG9zXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRbMF0gPSBkWzBdICsgZGlmZjsgLy8gcmVzZXQgcG9zXG4gICAgICAgICAgICAgIGRbMV0gPSBkWzFdIC0gZGlmZjsgLy8gcmVzZXQgbGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogSXQgd291bGQgYmUgbW9yZSBwZXJmb3JtYW50IHRvIGFwcGx5IHRoZSBkZWxldGVzIGluIHRoZSBhYm92ZSBsb29wXG4gICAgICAgIC8vIEFkYXB0IHRoZSBUcmVlIGltcGxlbWVudGF0aW9uIHRvIHN1cHBvcnQgZGVsZXRlIHdoaWxlIGl0ZXJhdGluZ1xuICAgICAgICBmb3IgKHZhciBfaSA9IGRlbGV0aW9ucy5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgICAgICAgdmFyIGRlbCA9IGRlbGV0aW9uc1tfaV07XG4gICAgICAgICAgZGVsZXRlSXRlbVJhbmdlKHksIGRlbFswXSwgZGVsWzFdLCBkZWxbMl0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciB0aGUgcmVzdC4uIGp1c3QgYXBwbHkgaXRcbiAgICAgICAgZm9yICg7IHBvcyA8IGR2Lmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgICBkID0gZHZbcG9zXTtcbiAgICAgICAgICBkZWxldGVJdGVtUmFuZ2UoeSwgdXNlciwgZFswXSwgZFsxXSwgdHJ1ZSk7XG4gICAgICAgICAgLy8gZGVsZXRpb25zLnB1c2goW3VzZXIsIGRbMF0sIGRbMV0sIGRbMl1dKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHNMZW5ndGg7IGkrKykge1xuICAgICAgX2xvb3AoaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5U3luY1N0ZXAxKHksIGRlY29kZXIsIHN0ckJ1aWxkZXIpIHtcbiAgICB2YXIgYXV0aCA9IGRlY29kZXIucmVhZFZhclN0cmluZygpO1xuICAgIHZhciBwcm90b2NvbFZlcnNpb24gPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgc3RyQnVpbGRlci5wdXNoKCcgIC0gYXV0aDogXCInICsgYXV0aCArICdcIicpO1xuICAgIHN0ckJ1aWxkZXIucHVzaCgnICAtIHByb3RvY29sVmVyc2lvbjogJyArIHByb3RvY29sVmVyc2lvbik7XG4gICAgLy8gd3JpdGUgU1NcbiAgICB2YXIgc3NCdWlsZGVyID0gW107XG4gICAgdmFyIGxlbiA9IGRlY29kZXIucmVhZFVpbnQzMigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB1c2VyID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgdmFyIGNsb2NrID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgc3NCdWlsZGVyLnB1c2goJygnICsgdXNlciArICc6JyArIGNsb2NrICsgJyknKTtcbiAgICB9XG4gICAgc3RyQnVpbGRlci5wdXNoKCcgID09IFNTOiAnICsgc3NCdWlsZGVyLmpvaW4oJywnKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZW5kU3luY1N0ZXAxKGNvbm5lY3Rvciwgc3luY1VzZXIpIHtcbiAgICB2YXIgZW5jb2RlciA9IG5ldyBCaW5hcnlFbmNvZGVyKCk7XG4gICAgZW5jb2Rlci53cml0ZVZhclN0cmluZyhjb25uZWN0b3IueS5yb29tKTtcbiAgICBlbmNvZGVyLndyaXRlVmFyU3RyaW5nKCdzeW5jIHN0ZXAgMScpO1xuICAgIGVuY29kZXIud3JpdGVWYXJTdHJpbmcoY29ubmVjdG9yLmF1dGhJbmZvIHx8ICcnKTtcbiAgICBlbmNvZGVyLndyaXRlVmFyVWludChjb25uZWN0b3IucHJvdG9jb2xWZXJzaW9uKTtcbiAgICB3cml0ZVN0YXRlU2V0KGNvbm5lY3Rvci55LCBlbmNvZGVyKTtcbiAgICBjb25uZWN0b3Iuc2VuZChzeW5jVXNlciwgZW5jb2Rlci5jcmVhdGVCdWZmZXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogV3JpdGUgYWxsIEl0ZW1zIHRoYXQgYXJlIG5vdCBub3QgaW5jbHVkZWQgaW4gc3MgdG9cbiAgICogdGhlIGVuY29kZXIgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVTdHJ1Y3RzKHksIGVuY29kZXIsIHNzKSB7XG4gICAgdmFyIGxlblBvcyA9IGVuY29kZXIucG9zO1xuICAgIGVuY29kZXIud3JpdGVVaW50MzIoMCk7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB5LnNzLnN0YXRlLmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgdmFyIHVzZXIgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICB2YXIgY2xvY2sgPSBzcy5nZXQodXNlcikgfHwgMDtcbiAgICAgICAgaWYgKHVzZXIgIT09IFJvb3RGYWtlVXNlcklEKSB7XG4gICAgICAgICAgdmFyIG1pbkJvdW5kID0gbmV3IElEKHVzZXIsIGNsb2NrKTtcbiAgICAgICAgICB2YXIgb3ZlcmxhcHBpbmdMZWZ0ID0geS5vcy5maW5kUHJldihtaW5Cb3VuZCk7XG4gICAgICAgICAgdmFyIHJpZ2h0SUQgPSBvdmVybGFwcGluZ0xlZnQgPT09IG51bGwgPyBudWxsIDogb3ZlcmxhcHBpbmdMZWZ0Ll9pZDtcbiAgICAgICAgICBpZiAocmlnaHRJRCAhPT0gbnVsbCAmJiByaWdodElELnVzZXIgPT09IHVzZXIgJiYgcmlnaHRJRC5jbG9jayArIG92ZXJsYXBwaW5nTGVmdC5fbGVuZ3RoID4gY2xvY2spIHtcbiAgICAgICAgICAgIHZhciBzdHJ1Y3QgPSBvdmVybGFwcGluZ0xlZnQuX2Nsb25lUGFydGlhbChjbG9jayAtIHJpZ2h0SUQuY2xvY2spO1xuICAgICAgICAgICAgc3RydWN0Ll90b0JpbmFyeShlbmNvZGVyKTtcbiAgICAgICAgICAgIGxlbisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5Lm9zLml0ZXJhdGUobWluQm91bmQsIG5ldyBJRCh1c2VyLCBOdW1iZXIuTUFYX1ZBTFVFKSwgZnVuY3Rpb24gKHN0cnVjdCkge1xuICAgICAgICAgICAgc3RydWN0Ll90b0JpbmFyeShlbmNvZGVyKTtcbiAgICAgICAgICAgIGxlbisrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZW5jb2Rlci5zZXRVaW50MzIobGVuUG9zLCBsZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFN5bmNTdGVwMShkZWNvZGVyLCBlbmNvZGVyLCB5LCBzZW5kZXJDb25uLCBzZW5kZXIpIHtcbiAgICB2YXIgcHJvdG9jb2xWZXJzaW9uID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgIC8vIGNoZWNrIHByb3RvY29sIHZlcnNpb25cbiAgICBpZiAocHJvdG9jb2xWZXJzaW9uICE9PSB5LmNvbm5lY3Rvci5wcm90b2NvbFZlcnNpb24pIHtcbiAgICAgIGNvbnNvbGUud2FybignWW91IHRyaWVkIHRvIHN5bmMgd2l0aCBhIFlqcyBpbnN0YW5jZSB0aGF0IGhhcyBhIGRpZmZlcmVudCBwcm90b2NvbCB2ZXJzaW9uXFxuICAgICAgKFlvdTogJyArIHByb3RvY29sVmVyc2lvbiArICcsIENsaWVudDogJyArIHByb3RvY29sVmVyc2lvbiArICcpLlxcbiAgICAgICcpO1xuICAgICAgeS5kZXN0cm95KCk7XG4gICAgfVxuICAgIC8vIHdyaXRlIHN5bmMgc3RlcCAyXG4gICAgZW5jb2Rlci53cml0ZVZhclN0cmluZygnc3luYyBzdGVwIDInKTtcbiAgICBlbmNvZGVyLndyaXRlVmFyU3RyaW5nKHkuY29ubmVjdG9yLmF1dGhJbmZvIHx8ICcnKTtcbiAgICB2YXIgc3MgPSByZWFkU3RhdGVTZXQoZGVjb2Rlcik7XG4gICAgd3JpdGVTdHJ1Y3RzKHksIGVuY29kZXIsIHNzKTtcbiAgICB3cml0ZURlbGV0ZVNldCh5LCBlbmNvZGVyKTtcbiAgICB5LmNvbm5lY3Rvci5zZW5kKHNlbmRlckNvbm4udWlkLCBlbmNvZGVyLmNyZWF0ZUJ1ZmZlcigpKTtcbiAgICBzZW5kZXJDb25uLnJlY2VpdmVkU3luY1N0ZXAyID0gdHJ1ZTtcbiAgICBpZiAoeS5jb25uZWN0b3Iucm9sZSA9PT0gJ3NsYXZlJykge1xuICAgICAgc2VuZFN5bmNTdGVwMSh5LmNvbm5lY3Rvciwgc2VuZGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlTeW5jU3RlcDIoeSwgZGVjb2Rlciwgc3RyQnVpbGRlcikge1xuICAgIHN0ckJ1aWxkZXIucHVzaCgnICAgICAtIGF1dGg6ICcgKyBkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKSk7XG4gICAgc3RyQnVpbGRlci5wdXNoKCcgID09IE9TOicpO1xuICAgIHN0cmluZ2lmeVN0cnVjdHMoeSwgZGVjb2Rlciwgc3RyQnVpbGRlcik7XG4gICAgLy8gd3JpdGUgRFMgdG8gc3RyaW5nXG4gICAgc3RyQnVpbGRlci5wdXNoKCcgID09IERTOicpO1xuICAgIHZhciBsZW4gPSBkZWNvZGVyLnJlYWRVaW50MzIoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdXNlciA9IGRlY29kZXIucmVhZFZhclVpbnQoKTtcbiAgICAgIHN0ckJ1aWxkZXIucHVzaCgnICAgIFVzZXI6ICcgKyB1c2VyICsgJzogJyk7XG4gICAgICB2YXIgbGVuMiA9IGRlY29kZXIucmVhZFVpbnQzMigpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgdmFyIGZyb20gPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIHZhciB0byA9IGRlY29kZXIucmVhZFZhclVpbnQoKTtcbiAgICAgICAgdmFyIGdjID0gZGVjb2Rlci5yZWFkVWludDgoKSA9PT0gMTtcbiAgICAgICAgc3RyQnVpbGRlci5wdXNoKCdbJyArIGZyb20gKyAnLCAnICsgdG8gKyAnLCAnICsgZ2MgKyAnXScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRTeW5jU3RlcDIoZGVjb2RlciwgZW5jb2RlciwgeSwgc2VuZGVyQ29ubiwgc2VuZGVyKSB7XG4gICAgaW50ZWdyYXRlUmVtb3RlU3RydWN0cyh5LCBkZWNvZGVyKTtcbiAgICByZWFkRGVsZXRlU2V0KHksIGRlY29kZXIpO1xuICAgIHkuY29ubmVjdG9yLl9zZXRTeW5jZWRXaXRoKHNlbmRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXNzYWdlVG9TdHJpbmcoX3JlZikge1xuICAgIHZhciBfcmVmMiA9IHNsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIHkgPSBfcmVmMlswXSxcbiAgICAgICAgYnVmZmVyID0gX3JlZjJbMV07XG5cbiAgICB2YXIgZGVjb2RlciA9IG5ldyBCaW5hcnlEZWNvZGVyKGJ1ZmZlcik7XG4gICAgZGVjb2Rlci5yZWFkVmFyU3RyaW5nKCk7IC8vIHJlYWQgcm9vbW5hbWVcbiAgICB2YXIgdHlwZSA9IGRlY29kZXIucmVhZFZhclN0cmluZygpO1xuICAgIHZhciBzdHJCdWlsZGVyID0gW107XG4gICAgc3RyQnVpbGRlci5wdXNoKCdcXG4gPT09ICcgKyB0eXBlICsgJyA9PT0nKTtcbiAgICBpZiAodHlwZSA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgIHN0cmluZ2lmeVN0cnVjdHMoeSwgZGVjb2Rlciwgc3RyQnVpbGRlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3luYyBzdGVwIDEnKSB7XG4gICAgICBzdHJpbmdpZnlTeW5jU3RlcDEoeSwgZGVjb2Rlciwgc3RyQnVpbGRlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3luYyBzdGVwIDInKSB7XG4gICAgICBzdHJpbmdpZnlTeW5jU3RlcDIoeSwgZGVjb2Rlciwgc3RyQnVpbGRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ckJ1aWxkZXIucHVzaCgnLS0gVW5rbm93biBtZXNzYWdlIHR5cGUgLSBwcm9iYWJseSBhbiBlbmNvZGluZyBpc3N1ZSEhIScpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyQnVpbGRlci5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lc3NhZ2VUb1Jvb21uYW1lKGJ1ZmZlcikge1xuICAgIHZhciBkZWNvZGVyID0gbmV3IEJpbmFyeURlY29kZXIoYnVmZmVyKTtcbiAgICBkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKTsgLy8gcm9vbW5hbWVcbiAgICByZXR1cm4gZGVjb2Rlci5yZWFkVmFyU3RyaW5nKCk7IC8vIG1lc3NhZ2VUeXBlXG4gIH1cblxuICBmdW5jdGlvbiBsb2dJRChpZCkge1xuICAgIGlmIChpZCAhPT0gbnVsbCAmJiBpZC5faWQgIT0gbnVsbCkge1xuICAgICAgaWQgPSBpZC5faWQ7XG4gICAgfVxuICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcoKSc7XG4gICAgfSBlbHNlIGlmIChpZCBpbnN0YW5jZW9mIElEKSB7XG4gICAgICByZXR1cm4gJygnICsgaWQudXNlciArICcsJyArIGlkLmNsb2NrICsgJyknO1xuICAgIH0gZWxzZSBpZiAoaWQgaW5zdGFuY2VvZiBSb290SUQpIHtcbiAgICAgIHJldHVybiAnKCcgKyBpZC5uYW1lICsgJywnICsgaWQudHlwZSArICcpJztcbiAgICB9IGVsc2UgaWYgKGlkLmNvbnN0cnVjdG9yID09PSBZKSB7XG4gICAgICByZXR1cm4gJ3knO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgaXMgbm90IGEgdmFsaWQgSUQhJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB1dGlsaXR5IHRvIGNvbnZlcnQgYW4gaXRlbSB0byBhIHJlYWRhYmxlIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGl0ZW0gY2xhc3MgKFlUZXh0LCBJdGVtU3RyaW5nLCAuLikuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSBUaGUgaXRlbSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFthcHBlbmRdIEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gYXBwZW5kIHRvIHRoZSByZXR1cm5lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgcmVhZGFibGUgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgaXRlbSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBsb2dJdGVtSGVscGVyKG5hbWUsIGl0ZW0sIGFwcGVuZCkge1xuICAgIHZhciBsZWZ0ID0gaXRlbS5fbGVmdCAhPT0gbnVsbCA/IGl0ZW0uX2xlZnQuX2xhc3RJZCA6IG51bGw7XG4gICAgdmFyIG9yaWdpbiA9IGl0ZW0uX29yaWdpbiAhPT0gbnVsbCA/IGl0ZW0uX29yaWdpbi5fbGFzdElkIDogbnVsbDtcbiAgICByZXR1cm4gbmFtZSArICcoaWQ6JyArIGxvZ0lEKGl0ZW0uX2lkKSArICcsbGVmdDonICsgbG9nSUQobGVmdCkgKyAnLG9yaWdpbjonICsgbG9nSUQob3JpZ2luKSArICcscmlnaHQ6JyArIGxvZ0lEKGl0ZW0uX3JpZ2h0KSArICcscGFyZW50OicgKyBsb2dJRChpdGVtLl9wYXJlbnQpICsgJyxwYXJlbnRTdWI6JyArIGl0ZW0uX3BhcmVudFN1YiArIChhcHBlbmQgIT09IHVuZGVmaW5lZCA/ICcgLSAnICsgYXBwZW5kIDogJycpICsgJyknO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIERlbGV0ZSBhbGwgaXRlbXMgaW4gYW4gSUQtcmFuZ2VcbiAgICogVE9ETzogaW1wbGVtZW50IGdldEl0ZW1DbGVhblN0YXJ0Tm9kZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlIChvbmx5IG9uZSBsb29rdXApXG4gICAqL1xuICBmdW5jdGlvbiBkZWxldGVJdGVtUmFuZ2UoeSwgdXNlciwgY2xvY2ssIHJhbmdlLCBnY0NoaWxkcmVuKSB7XG4gICAgdmFyIGNyZWF0ZURlbGV0ZSA9IHkuY29ubmVjdG9yICE9PSBudWxsICYmIHkuY29ubmVjdG9yLl9mb3J3YXJkQXBwbGllZFN0cnVjdHM7XG4gICAgdmFyIGl0ZW0gPSB5Lm9zLmdldEl0ZW1DbGVhblN0YXJ0KG5ldyBJRCh1c2VyLCBjbG9jaykpO1xuICAgIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgICBpZiAoIWl0ZW0uX2RlbGV0ZWQpIHtcbiAgICAgICAgaXRlbS5fc3BsaXRBdCh5LCByYW5nZSk7XG4gICAgICAgIGl0ZW0uX2RlbGV0ZSh5LCBjcmVhdGVEZWxldGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZW1MZW4gPSBpdGVtLl9sZW5ndGg7XG4gICAgICByYW5nZSAtPSBpdGVtTGVuO1xuICAgICAgY2xvY2sgKz0gaXRlbUxlbjtcbiAgICAgIGlmIChyYW5nZSA+IDApIHtcbiAgICAgICAgdmFyIG5vZGUgPSB5Lm9zLmZpbmROb2RlKG5ldyBJRCh1c2VyLCBjbG9jaykpO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBub2RlLnZhbCAhPT0gbnVsbCAmJiByYW5nZSA+IDAgJiYgbm9kZS52YWwuX2lkLmVxdWFscyhuZXcgSUQodXNlciwgY2xvY2spKSkge1xuICAgICAgICAgIHZhciBub2RlVmFsID0gbm9kZS52YWw7XG4gICAgICAgICAgaWYgKCFub2RlVmFsLl9kZWxldGVkKSB7XG4gICAgICAgICAgICBub2RlVmFsLl9zcGxpdEF0KHksIHJhbmdlKTtcbiAgICAgICAgICAgIG5vZGVWYWwuX2RlbGV0ZSh5LCBjcmVhdGVEZWxldGUsIGdjQ2hpbGRyZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbm9kZUxlbiA9IG5vZGVWYWwuX2xlbmd0aDtcbiAgICAgICAgICByYW5nZSAtPSBub2RlTGVuO1xuICAgICAgICAgIGNsb2NrICs9IG5vZGVMZW47XG4gICAgICAgICAgbm9kZSA9IG5vZGUubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEEgRGVsZXRlIGNoYW5nZSBpcyBub3QgYSByZWFsIEl0ZW0sIGJ1dCBpdCBwcm92aWRlcyB0aGUgc2FtZSBpbnRlcmZhY2UgYXMgYW5cbiAgICogSXRlbS4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGl0IHdpbGwgbm90IGJlIHNhdmVkIGluIHRoZSBJdGVtU3RvcmVcbiAgICogKE9wZXJhdGlvblN0b3JlKSwgYnV0IGluc3RlYWQgaXQgaXMgc2FmZWQgaW4gdGhlIERlbGV0ZVN0b3JlLlxuICAgKi9cblxuICB2YXIgRGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGV0ZSgpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERlbGV0ZSk7XG5cbiAgICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9sZW5ndGggPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogUmVhZCB0aGUgbmV4dCBJdGVtIGluIGEgRGVjb2RlciBhbmQgZmlsbCB0aGlzIEl0ZW0gd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBkYXRhIGlzIHJlY2VpdmVkIGZyb20gYSByZW1vdGUgcGVlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WX0geSBUaGUgWWpzIGluc3RhbmNlIHRoYXQgdGhpcyBJdGVtIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtCaW5hcnlEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIG9iamVjdCB0byByZWFkIGRhdGEgZnJvbS5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoRGVsZXRlLCBbe1xuICAgICAga2V5OiAnX2Zyb21CaW5hcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mcm9tQmluYXJ5KHksIGRlY29kZXIpIHtcbiAgICAgICAgLy8gVE9ETzogc2V0IHRhcmdldCwgYW5kIGFkZCBpdCB0byBtaXNzaW5nIGlmIG5vdCBmb3VuZFxuICAgICAgICAvLyBUaGVyZSBpcyBhbiBlZGdlIGNhc2UgaW4gcDJwIG5ldHdvcmtzIVxuICAgICAgICB2YXIgdGFyZ2V0SUQgPSBkZWNvZGVyLnJlYWRJRCgpO1xuICAgICAgICB0aGlzLl90YXJnZXRJRCA9IHRhcmdldElEO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBkZWNvZGVyLnJlYWRWYXJVaW50KCk7XG4gICAgICAgIGlmICh5Lm9zLmdldEl0ZW0odGFyZ2V0SUQpID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFt0YXJnZXRJRF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgICAgICogQmluYXJ5RW5jb2Rlci5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtCaW5hcnlFbmNvZGVyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190b0JpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvQmluYXJ5KGVuY29kZXIpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVVpbnQ4KGdldFN0cnVjdFJlZmVyZW5jZSh0aGlzLmNvbnN0cnVjdG9yKSk7XG4gICAgICAgIGVuY29kZXIud3JpdGVJRCh0aGlzLl90YXJnZXRJRCk7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJVaW50KHRoaXMuX2xlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEludGVncmF0ZXMgdGhpcyBJdGVtIGludG8gdGhlIHNoYXJlZCBzdHJ1Y3R1cmUuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgYWN0dWFsbHkgYXBwbGllcyB0aGUgY2hhbmdlIHRvIHRoZSBZanMgaW5zdGFuY2UuIEluIHRoZSBjYXNlIG9mXG4gICAgICAgKiBEZWxldGUgaXQgbWFya3MgdGhlIGRlbGV0ZSB0YXJnZXQgYXMgZGVsZXRlZC5cbiAgICAgICAqXG4gICAgICAgKiAqIElmIGNyZWF0ZWQgcmVtb3RlbHkgKGEgcmVtb3RlIHVzZXIgZGVsZXRlZCBzb21ldGhpbmcpLFxuICAgICAgICogICB0aGlzIERlbGV0ZSBpcyBhcHBsaWVkIHRvIGFsbCBzdHJ1Y3RzIGluIGlkLXJhbmdlLlxuICAgICAgICogKiBJZiBjcmVhdGVkIGxva2FsbHkgKGUuZy4gd2hlbiB5LWFycmF5IGRlbGV0ZXMgYSByYW5nZSBvZiBlbGVtZW50cyksXG4gICAgICAgKiAgIHRoaXMgc3RydWN0IGlzIGJyb2FkY2FzdGVkIG9ubHkgKGl0IGlzIGFscmVhZHkgZXhlY3V0ZWQpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19pbnRlZ3JhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnRlZ3JhdGUoeSkge1xuICAgICAgICB2YXIgbG9jYWxseUNyZWF0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICAgIGlmICghbG9jYWxseUNyZWF0ZWQpIHtcbiAgICAgICAgICAvLyBmcm9tIHJlbW90ZVxuICAgICAgICAgIHZhciBpZCA9IHRoaXMuX3RhcmdldElEO1xuICAgICAgICAgIGRlbGV0ZUl0ZW1SYW5nZSh5LCBpZC51c2VyLCBpZC5jbG9jaywgdGhpcy5fbGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoeS5jb25uZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBmcm9tIGxvY2FsXG4gICAgICAgICAgeS5jb25uZWN0b3IuYnJvYWRjYXN0U3RydWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5LnBlcnNpc3RlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgeS5wZXJzaXN0ZW5jZS5zYXZlU3RydWN0KHksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIHRoaXMgWVhtbCBUeXBlIHRvIGEgcmVhZGFibGUgZm9ybWF0LlxuICAgICAgICogVXNlZnVsIGZvciBsb2dnaW5nIGFzIGFsbCBJdGVtcyBhbmQgRGVsZXRlIGltcGxlbWVudCB0aGlzIG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbG9nU3RyaW5nJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9nU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ0RlbGV0ZSAtIHRhcmdldDogJyArIGxvZ0lEKHRoaXMuX3RhcmdldElEKSArICcsIGxlbjogJyArIHRoaXMuX2xlbmd0aDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIERlbGV0ZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBIHRyYW5zYWN0aW9uIGlzIGNyZWF0ZWQgZm9yIGV2ZXJ5IGNoYW5nZSBvbiB0aGUgWWpzIG1vZGVsLiBJdCBpcyBwb3NzaWJsZVxuICAgKiB0byBidW5kbGUgY2hhbmdlcyBvbiB0aGUgWWpzIG1vZGVsIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHRvXG4gICAqIG1pbmltaXplIHRoZSBudW1iZXIgb24gbWVzc2FnZXMgc2VudCBhbmQgdGhlIG51bWJlciBvZiBvYnNlcnZlciBjYWxscy5cbiAgICogSWYgcG9zc2libGUgdGhlIHVzZXIgb2YgdGhpcyBsaWJyYXJ5IHNob3VsZCBidW5kbGUgYXMgbWFueSBjaGFuZ2VzIGFzXG4gICAqIHBvc3NpYmxlLiBIZXJlIGlzIGFuIGV4YW1wbGUgdG8gaWxsdXN0cmF0ZSB0aGUgYWR2YW50YWdlcyBvZiBidW5kbGluZzpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgbWFwID0geS5kZWZpbmUoJ21hcCcsIFlNYXApXG4gICAqIC8vIExvZyBjb250ZW50IHdoZW4gY2hhbmdlIGlzIHRyaWdnZXJlZFxuICAgKiBtYXAub2JzZXJ2ZShmdW5jdGlvbiAoKSB7XG4gICAqICAgY29uc29sZS5sb2coJ2NoYW5nZSB0cmlnZ2VyZWQnKVxuICAgKiB9KVxuICAgKiAvLyBFYWNoIGNoYW5nZSBvbiB0aGUgbWFwIHR5cGUgdHJpZ2dlcnMgYSBsb2cgbWVzc2FnZTpcbiAgICogbWFwLnNldCgnYScsIDApIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gICAqIG1hcC5zZXQoJ2InLCAwKSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICAgKiAvLyBXaGVuIHB1dCBpbiBhIHRyYW5zYWN0aW9uLCBpdCB3aWxsIHRyaWdnZXIgdGhlIGxvZyBhZnRlciB0aGUgdHJhbnNhY3Rpb246XG4gICAqIHkudHJhbnNhY3QoZnVuY3Rpb24gKCkge1xuICAgKiAgIG1hcC5zZXQoJ2EnLCAxKVxuICAgKiAgIG1hcC5zZXQoJ2InLCAxKVxuICAgKiB9KSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICAgKlxuICAgKi9cbiAgdmFyIFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gVHJhbnNhY3Rpb24oeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zYWN0aW9uKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZfSBUaGUgWWpzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHRoaXMueSA9IHk7XG4gICAgLyoqXG4gICAgICogQWxsIG5ldyB0eXBlcyB0aGF0IGFyZSBhZGRlZCBkdXJpbmcgYSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMubmV3VHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogQWxsIHR5cGVzIHRoYXQgd2VyZSBkaXJlY3RseSBtb2RpZmllZCAocHJvcGVydHkgYWRkZWQgb3IgY2hpbGRcbiAgICAgKiBpbnNlcnRlZC9kZWxldGVkKS4gTmV3IHR5cGVzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhpcyBTZXQuXG4gICAgICogTWFwcyBmcm9tIHR5cGUgdG8gcGFyZW50U3VicyAoYGl0ZW0uX3BhcmVudFN1YiA9IG51bGxgIGZvciBZQXJyYXkpXG4gICAgICogQHR5cGUge1NldDxZVHlwZSxTdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlZFR5cGVzID0gbmV3IE1hcCgpO1xuICAgIC8vIFRPRE86IHJlbmFtZSBkZWxldGVkVHlwZXNcbiAgICAvKipcbiAgICAgKiBTZXQgb2YgYWxsIGRlbGV0ZWQgVHlwZXMgYW5kIFN0cnVjdHMuXG4gICAgICogQHR5cGUge1NldDxJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZWRTdHJ1Y3RzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBvbGQgc3RhdGUgc2V0IG9mIHRoZSBZanMgaW5zdGFuY2UuIElmIGEgc3RhdGUgd2FzIG1vZGlmaWVkLFxuICAgICAqIHRoZSBvcmlnaW5hbCB2YWx1ZSBpcyBzYXZlZCBoZXJlLlxuICAgICAqIEB0eXBlIHtNYXA8TnVtYmVyLE51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVTdGF0ZSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGV2ZW50cyBmb3IgdGhlIHR5cGVzIHRoYXQgb2JzZXJ2ZSBhbHNvIGNoaWxkIGVsZW1lbnRzLlxuICAgICAqIEl0IGlzIG1haW5seSB1c2VkIGJ5IGBvYnNlcnZlRGVlcGAuXG4gICAgICogQHR5cGUge01hcDxZVHlwZSxBcnJheTxZRXZlbnQ+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZWRQYXJlbnRUeXBlcyA9IG5ldyBNYXAoKTtcbiAgfTtcbiAgZnVuY3Rpb24gdHJhbnNhY3Rpb25UeXBlQ2hhbmdlZCh5LCB0eXBlLCBzdWIpIHtcbiAgICBpZiAodHlwZSAhPT0geSAmJiAhdHlwZS5fZGVsZXRlZCAmJiAheS5fdHJhbnNhY3Rpb24ubmV3VHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICB2YXIgY2hhbmdlZFR5cGVzID0geS5fdHJhbnNhY3Rpb24uY2hhbmdlZFR5cGVzO1xuICAgICAgdmFyIHN1YnMgPSBjaGFuZ2VkVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgaWYgKHN1YnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBjcmVhdGUgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXRcbiAgICAgICAgc3VicyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY2hhbmdlZFR5cGVzLnNldCh0eXBlLCBzdWJzKTtcbiAgICAgIH1cbiAgICAgIHN1YnMuYWRkKHN1Yik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEhlbHBlciB1dGlsaXR5IHRvIHNwbGl0IGFuIEl0ZW0gKHNlZSB7QGxpbmsgSXRlbSNfc3BsaXRBdH0pXG4gICAqIC0gY29waWVzIGFsbCBwcm9wZXJ0aWVzIGZyb20gYSB0byBiXG4gICAqIC0gY29ubmVjdHMgYSB0byBiXG4gICAqIC0gYXNzaWducyB0aGUgY29ycmVjdCBfaWRcbiAgICogLSBzYXZlcyBiIHRvIG9zXG4gICAqL1xuICBmdW5jdGlvbiBzcGxpdEhlbHBlcih5LCBhLCBiLCBkaWZmKSB7XG4gICAgdmFyIGFJRCA9IGEuX2lkO1xuICAgIGIuX2lkID0gbmV3IElEKGFJRC51c2VyLCBhSUQuY2xvY2sgKyBkaWZmKTtcbiAgICBiLl9vcmlnaW4gPSBhO1xuICAgIGIuX2xlZnQgPSBhO1xuICAgIGIuX3JpZ2h0ID0gYS5fcmlnaHQ7XG4gICAgaWYgKGIuX3JpZ2h0ICE9PSBudWxsKSB7XG4gICAgICBiLl9yaWdodC5fbGVmdCA9IGI7XG4gICAgfVxuICAgIGIuX3JpZ2h0X29yaWdpbiA9IGEuX3JpZ2h0X29yaWdpbjtcbiAgICAvLyBkbyBub3Qgc2V0IGEuX3JpZ2h0X29yaWdpbiwgYXMgdGhpcyB3aWxsIGxlYWQgdG8gcHJvYmxlbXMgd2hlbiBzeW5jaW5nXG4gICAgYS5fcmlnaHQgPSBiO1xuICAgIGIuX3BhcmVudCA9IGEuX3BhcmVudDtcbiAgICBiLl9wYXJlbnRTdWIgPSBhLl9wYXJlbnRTdWI7XG4gICAgYi5fZGVsZXRlZCA9IGEuX2RlbGV0ZWQ7XG4gICAgLy8gbm93IHNlYXJjaCBhbGwgcmVsZXZhbnQgaXRlbXMgdG8gdGhlIHJpZ2h0IGFuZCB1cGRhdGUgb3JpZ2luXG4gICAgLy8gaWYgb3JpZ2luIGlzIG5vdCBpdCBmb3VuZE9yaWdpbnMsIHdlIGRvbid0IGhhdmUgdG8gc2VhcmNoIGFueSBsb25nZXJcbiAgICB2YXIgZm91bmRPcmlnaW5zID0gbmV3IFNldCgpO1xuICAgIGZvdW5kT3JpZ2lucy5hZGQoYSk7XG4gICAgdmFyIG8gPSBiLl9yaWdodDtcbiAgICB3aGlsZSAobyAhPT0gbnVsbCAmJiBmb3VuZE9yaWdpbnMuaGFzKG8uX29yaWdpbikpIHtcbiAgICAgIGlmIChvLl9vcmlnaW4gPT09IGEpIHtcbiAgICAgICAgby5fb3JpZ2luID0gYjtcbiAgICAgIH1cbiAgICAgIGZvdW5kT3JpZ2lucy5hZGQobyk7XG4gICAgICBvID0gby5fcmlnaHQ7XG4gICAgfVxuICAgIHkub3MucHV0KGIpO1xuICAgIGlmICh5Ll90cmFuc2FjdGlvbi5uZXdUeXBlcy5oYXMoYSkpIHtcbiAgICAgIHkuX3RyYW5zYWN0aW9uLm5ld1R5cGVzLmFkZChiKTtcbiAgICB9IGVsc2UgaWYgKHkuX3RyYW5zYWN0aW9uLmRlbGV0ZWRTdHJ1Y3RzLmhhcyhhKSkge1xuICAgICAgeS5fdHJhbnNhY3Rpb24uZGVsZXRlZFN0cnVjdHMuYWRkKGIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYW55IGNvbnRlbnQuXG4gICAqL1xuXG4gIHZhciBJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEl0ZW0oKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJdGVtKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdW5pcWUgaWRlbnRpZmllciBvZiB0aGlzIHR5cGUuXG4gICAgICAgKiBAdHlwZSB7SUR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX2lkID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgbGVmdCBvZiB0aGlzIGl0ZW0uXG4gICAgICAgKiBAdHlwZSB7SXRlbX1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fb3JpZ2luID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAgICogQHR5cGUge0l0ZW19XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX2xlZnQgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgaXRlbSB0aGF0IGlzIGN1cnJlbnRseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAgICogQHR5cGUge0l0ZW19XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX3JpZ2h0ID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAgICogQHR5cGUge0l0ZW19XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX3JpZ2h0X29yaWdpbiA9IG51bGw7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBwYXJlbnQgdHlwZS5cbiAgICAgICAqIEB0eXBlIHtZfFlUeXBlfVxuICAgICAgICovXG4gICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgcGFyZW50IHJlZmVycyB0byB0aGlzIGl0ZW0gd2l0aCBzb21lIGtpbmQgb2Yga2V5IChlLmcuIFlNYXAsIHRoZVxuICAgICAgICoga2V5IGlzIHNwZWNpZmllZCBoZXJlLiBUaGUga2V5IGlzIHRoZW4gdXNlZCB0byByZWZlciB0byB0aGUgbGlzdCBpbiB3aGljaFxuICAgICAgICogdG8gaW5zZXJ0IHRoaXMgaXRlbS4gSWYgYHBhcmVudFN1YiA9IG51bGxgIHR5cGUuX3N0YXJ0IGlzIHRoZSBsaXN0IGluXG4gICAgICAgKiB3aGljaCB0byBpbnNlcnQgdG8uIE90aGVyd2lzZSBpdCBpcyBgcGFyZW50Ll9zdGFydGAuXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICB0aGlzLl9wYXJlbnRTdWIgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoaXMgaXRlbSB3YXMgZGVsZXRlZCBvciBub3QuXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGlzIHR5cGUncyBlZmZlY3QgaXMgcmV1bmRvbmUgdGhpcyB0eXBlIHJlZmVycyB0byB0aGUgdHlwZSB0aGF0IHVuZGlkXG4gICAgICAgKiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgICAqIEB0eXBlIHtJdGVtfVxuICAgICAgICovXG4gICAgICB0aGlzLl9yZWRvbmUgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoSXRlbSwgW3tcbiAgICAgIGtleTogJ19jb3B5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVkb2VzIHRoZSBlZmZlY3Qgb2YgdGhpcyBvcGVyYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlZG8nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWRvKHksIHJlZG9pdGVtcykge1xuICAgICAgICBpZiAodGhpcy5fcmVkb25lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RydWN0ID0gdGhpcy5fY29weSgpO1xuICAgICAgICB2YXIgbGVmdCA9IHRoaXMuX2xlZnQ7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXM7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHBhcmVudCBpcyByZWRvbmVcbiAgICAgICAgaWYgKHBhcmVudC5fZGVsZXRlZCA9PT0gdHJ1ZSAmJiBwYXJlbnQuX3JlZG9uZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIHRyeSB0byB1bmRvIHBhcmVudCBpZiBpdCB3aWxsIGJlIHVuZG9uZSBhbnl3YXlcbiAgICAgICAgICBpZiAoIXJlZG9pdGVtcy5oYXMocGFyZW50KSB8fCAhcGFyZW50Ll9yZWRvKHksIHJlZG9pdGVtcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudC5fcmVkb25lICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9yZWRvbmU7XG4gICAgICAgICAgLy8gZmluZCBuZXh0IGNsb25lZCBpdGVtc1xuICAgICAgICAgIHdoaWxlIChsZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGVmdC5fcmVkb25lICE9PSBudWxsICYmIGxlZnQuX3JlZG9uZS5fcGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuX3JlZG9uZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdC5fbGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmlnaHQuX3JlZG9uZSAhPT0gbnVsbCAmJiByaWdodC5fcmVkb25lLl9wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0Ll9yZWRvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByaWdodCA9IHJpZ2h0Ll9yaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RydWN0Ll9vcmlnaW4gPSBsZWZ0O1xuICAgICAgICBzdHJ1Y3QuX2xlZnQgPSBsZWZ0O1xuICAgICAgICBzdHJ1Y3QuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHN0cnVjdC5fcmlnaHRfb3JpZ2luID0gcmlnaHQ7XG4gICAgICAgIHN0cnVjdC5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICBzdHJ1Y3QuX3BhcmVudFN1YiA9IHRoaXMuX3BhcmVudFN1YjtcbiAgICAgICAgc3RydWN0Ll9pbnRlZ3JhdGUoeSk7XG4gICAgICAgIHRoaXMuX3JlZG9uZSA9IHN0cnVjdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29tcHV0ZXMgdGhlIGxhc3QgY29udGVudCBhZGRyZXNzIG9mIHRoaXMgSXRlbS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc3BsaXRBdCcsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBTcGxpdHMgdGhpcyBJdGVtIHNvIHRoYXQgYW5vdGhlciBJdGVtcyBjYW4gYmUgaW5zZXJ0ZWQgaW4tYmV0d2Vlbi5cbiAgICAgICAqIFRoaXMgbXVzdCBiZSBvdmVyd3JpdHRlbiBpZiBfbGVuZ3RoID4gMVxuICAgICAgICogUmV0dXJucyByaWdodCBwYXJ0IGFmdGVyIHNwbGl0XG4gICAgICAgKiAqIGRpZmYgPT09IDAgPT4gdGhpc1xuICAgICAgICogKiBkaWZmID09PSBsZW5ndGggPT4gdGhpcy5fcmlnaHRcbiAgICAgICAqICogb3RoZXJ3aXNlID0+IHNwbGl0IF9jb250ZW50IGFuZCByZXR1cm4gcmlnaHQgcGFydCBvZiBzcGxpdFxuICAgICAgICogKHNlZSB7QGxpbmsgSXRlbUpTT059L3tAbGluayBJdGVtU3RyaW5nfSBmb3IgaW1wbGVtZW50YXRpb24pXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zcGxpdEF0KHksIGRpZmYpIHtcbiAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWFyayB0aGlzIEl0ZW0gYXMgZGVsZXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGVEZWxldGUgV2hldGhlciB0byBwcm9wYWdhdGUgYSBtZXNzYWdlIHRoYXQgdGhpc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHlwZSB3YXMgZGVsZXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZGVsZXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKHkpIHtcbiAgICAgICAgdmFyIGNyZWF0ZURlbGV0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9kZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICB5LmRzLm1hcmsodGhpcy5faWQsIHRoaXMuX2xlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgIHZhciBkZWwgPSBuZXcgRGVsZXRlKCk7XG4gICAgICAgICAgZGVsLl90YXJnZXRJRCA9IHRoaXMuX2lkO1xuICAgICAgICAgIGRlbC5fbGVuZ3RoID0gdGhpcy5fbGVuZ3RoO1xuICAgICAgICAgIGlmIChjcmVhdGVEZWxldGUpIHtcbiAgICAgICAgICAgIC8vIGJyb2FkY2FzdCBhbmQgcGVyc2lzdHMgRGVsZXRlXG4gICAgICAgICAgICBkZWwuX2ludGVncmF0ZSh5LCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHkucGVyc2lzdGVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcGVyc2lzdCBEZWxldGVcbiAgICAgICAgICAgIHkucGVyc2lzdGVuY2Uuc2F2ZVN0cnVjdCh5LCBkZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc2FjdGlvblR5cGVDaGFuZ2VkKHksIHRoaXMuX3BhcmVudCwgdGhpcy5fcGFyZW50U3ViKTtcbiAgICAgICAgICB5Ll90cmFuc2FjdGlvbi5kZWxldGVkU3RydWN0cy5hZGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2NDaGlsZHJlbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2djQ2hpbGRyZW4oeSkge31cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2MnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nYyh5KSB7XG4gICAgICAgIHZhciBnYyA9IG5ldyBHQygpO1xuICAgICAgICBnYy5faWQgPSB0aGlzLl9pZDtcbiAgICAgICAgZ2MuX2xlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICAgICAgeS5vcy5kZWxldGUodGhpcy5faWQpO1xuICAgICAgICBnYy5faW50ZWdyYXRlKHkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSB0aGlzIEl0ZW0gcmVjZWl2ZXMgYW55IGNoaWxkcmVuLlxuICAgICAgICogSXQgY2FuIGJlIG92ZXJ3cml0dGVuIHRvIGFwcGx5IHBlbmRpbmcgY2hhbmdlcyBiZWZvcmUgYXBwbHlpbmcgcmVtb3RlIGNoYW5nZXNcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYmVmb3JlQ2hhbmdlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmVmb3JlQ2hhbmdlKCkge31cbiAgICAgIC8vIG5vcFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogSW50ZWdyYXRlcyB0aGlzIEl0ZW0gaW50byB0aGUgc2hhcmVkIHN0cnVjdHVyZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBhY3R1YWxseSBhcHBsaWVzIHRoZSBjaGFuZ2UgdG8gdGhlIFlqcyBpbnN0YW5jZS4gSW4gY2FzZSBvZlxuICAgICAgICogSXRlbSBpdCBjb25uZWN0cyBfbGVmdCBhbmQgX3JpZ2h0IHRvIHRoaXMgSXRlbSBhbmQgY2FsbHMgdGhlXG4gICAgICAgKiB7QGxpbmsgSXRlbSNiZWZvcmVDaGFuZ2V9IG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiAqIEludGVncmF0ZSB0aGUgc3RydWN0IHNvIHRoYXQgb3RoZXIgdHlwZXMvc3RydWN0cyBjYW4gc2VlIGl0XG4gICAgICAgKiAqIEFkZCB0aGlzIHN0cnVjdCB0byB5Lm9zXG4gICAgICAgKiAqIENoZWNrIGlmIHRoaXMgaXMgc3RydWN0IGRlbGV0ZWRcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaW50ZWdyYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW50ZWdyYXRlKHkpIHtcbiAgICAgICAgeS5fdHJhbnNhY3Rpb24ubmV3VHlwZXMuYWRkKHRoaXMpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICB2YXIgc2VsZklEID0gdGhpcy5faWQ7XG4gICAgICAgIHZhciB1c2VyID0gc2VsZklEID09PSBudWxsID8geS51c2VySUQgOiBzZWxmSUQudXNlcjtcbiAgICAgICAgdmFyIHVzZXJTdGF0ZSA9IHkuc3MuZ2V0U3RhdGUodXNlcik7XG4gICAgICAgIGlmIChzZWxmSUQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9pZCA9IHkuc3MuZ2V0TmV4dElEKHRoaXMuX2xlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZklELnVzZXIgPT09IFJvb3RGYWtlVXNlcklEKSA7IGVsc2UgaWYgKHNlbGZJRC5jbG9jayA8IHVzZXJTdGF0ZSkge1xuICAgICAgICAgIC8vIGFscmVhZHkgYXBwbGllZC4uXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGZJRC5jbG9jayA9PT0gdXNlclN0YXRlKSB7XG4gICAgICAgICAgeS5zcy5zZXRTdGF0ZShzZWxmSUQudXNlciwgdXNlclN0YXRlICsgdGhpcy5fbGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtaXNzaW5nIGNvbnRlbnQgZnJvbSB1c2VyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFwcGx5IHlldCEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5fZGVsZXRlZCAmJiAheS5fdHJhbnNhY3Rpb24uY2hhbmdlZFR5cGVzLmhhcyhwYXJlbnQpICYmICF5Ll90cmFuc2FjdGlvbi5uZXdUeXBlcy5oYXMocGFyZW50KSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgcGFyZW50IGlzIHVwZGF0ZWRcbiAgICAgICAgICAvLyBvciB0aGlzIHR5cGVzIGlzIG5ld1xuICAgICAgICAgIHRoaXMuX3BhcmVudC5fYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAjICR0aGlzIGhhcyB0byBmaW5kIGEgdW5pcXVlIHBvc2l0aW9uIGJldHdlZW4gb3JpZ2luIGFuZCB0aGUgbmV4dCBrbm93biBjaGFyYWN0ZXJcbiAgICAgICAgIyBjYXNlIDE6ICRvcmlnaW4gZXF1YWxzICRvLm9yaWdpbjogdGhlICRjcmVhdG9yIHBhcmFtZXRlciBkZWNpZGVzIGlmIGxlZnQgb3IgcmlnaHRcbiAgICAgICAgIyAgICAgICAgIGxldCAkT0w9IFtvMSxvMixvMyxvNF0sIHdoZXJlYnkgJHRoaXMgaXMgdG8gYmUgaW5zZXJ0ZWQgYmV0d2VlbiBvMSBhbmQgbzRcbiAgICAgICAgIyAgICAgICAgIG8yLG8zIGFuZCBvNCBvcmlnaW4gaXMgMSAodGhlIHBvc2l0aW9uIG9mIG8yKVxuICAgICAgICAjICAgICAgICAgdGhlcmUgaXMgdGhlIGNhc2UgdGhhdCAkdGhpcy5jcmVhdG9yIDwgbzIuY3JlYXRvciwgYnV0IG8zLmNyZWF0b3IgPCAkdGhpcy5jcmVhdG9yXG4gICAgICAgICMgICAgICAgICB0aGVuIG8yIGtub3dzIG8zLiBTaW5jZSBvbiBhbm90aGVyIGNsaWVudCAkT0wgY291bGQgYmUgW28xLG8zLG80XSB0aGUgcHJvYmxlbSBpcyBjb21wbGV4XG4gICAgICAgICMgICAgICAgICB0aGVyZWZvcmUgJHRoaXMgd291bGQgYmUgYWx3YXlzIHRvIHRoZSByaWdodCBvZiBvM1xuICAgICAgICAjIGNhc2UgMjogJG9yaWdpbiA8ICRvLm9yaWdpblxuICAgICAgICAjICAgICAgICAgaWYgY3VycmVudCAkdGhpcyBpbnNlcnRfcG9zaXRpb24gPiAkbyBvcmlnaW46ICR0aGlzIGluc1xuICAgICAgICAjICAgICAgICAgZWxzZSAkaW5zZXJ0X3Bvc2l0aW9uIHdpbGwgbm90IGNoYW5nZVxuICAgICAgICAjICAgICAgICAgKG1heWJlIHdlIGVuY291bnRlciBjYXNlIDEgbGF0ZXIsIHRoZW4gdGhpcyB3aWxsIGJlIHRvIHRoZSByaWdodCBvZiAkbylcbiAgICAgICAgIyBjYXNlIDM6ICRvcmlnaW4gPiAkby5vcmlnaW5cbiAgICAgICAgIyAgICAgICAgICR0aGlzIGluc2VydF9wb3NpdGlvbiBpcyB0byB0aGUgbGVmdCBvZiAkbyAoZm9yZXZlciEpXG4gICAgICAgICovXG4gICAgICAgIC8vIGhhbmRsZSBjb25mbGljdHNcbiAgICAgICAgdmFyIG8gPSB2b2lkIDA7XG4gICAgICAgIC8vIHNldCBvIHRvIHRoZSBmaXJzdCBjb25mbGljdGluZyBpdGVtXG4gICAgICAgIGlmICh0aGlzLl9sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbyA9IHRoaXMuX2xlZnQuX3JpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3BhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgIG8gPSB0aGlzLl9wYXJlbnQuX21hcC5nZXQodGhpcy5fcGFyZW50U3ViKSB8fCBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8gPSB0aGlzLl9wYXJlbnQuX3N0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25mbGljdGluZ0l0ZW1zID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgaXRlbXNCZWZvcmVPcmlnaW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIExldCBjIGluIGNvbmZsaWN0aW5nSXRlbXMsIGIgaW4gaXRlbXNCZWZvcmVPcmlnaW5cbiAgICAgICAgLy8gKioqe29yaWdpbn1iYmJie3RoaXN9e2MsYn17YyxifXtvfSoqKlxuICAgICAgICAvLyBOb3RlIHRoYXQgY29uZmxpY3RpbmdJdGVtcyBpcyBhIHN1YnNldCBvZiBpdGVtc0JlZm9yZU9yaWdpblxuICAgICAgICB3aGlsZSAobyAhPT0gbnVsbCAmJiBvICE9PSB0aGlzLl9yaWdodCkge1xuICAgICAgICAgIGl0ZW1zQmVmb3JlT3JpZ2luLmFkZChvKTtcbiAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmFkZChvKTtcbiAgICAgICAgICBpZiAodGhpcy5fb3JpZ2luID09PSBvLl9vcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIGNhc2UgMVxuICAgICAgICAgICAgaWYgKG8uX2lkLnVzZXIgPCB0aGlzLl9pZC51c2VyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xlZnQgPSBvO1xuICAgICAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtc0JlZm9yZU9yaWdpbi5oYXMoby5fb3JpZ2luKSkge1xuICAgICAgICAgICAgLy8gY2FzZSAyXG4gICAgICAgICAgICBpZiAoIWNvbmZsaWN0aW5nSXRlbXMuaGFzKG8uX29yaWdpbikpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGVmdCA9IG87XG4gICAgICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbXMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE86IHRyeSB0byB1c2UgcmlnaHRfb3JpZ2luIGluc3RlYWQuXG4gICAgICAgICAgLy8gVGhlbiB5b3UgY291bGQgYmFzaWNhbGx5IG9taXQgY29uZmxpY3RpbmdJdGVtcyFcbiAgICAgICAgICAvLyBOb3RlOiB5b3UgcHJvYmFibHkgY2FuJ3QgdXNlIHJpZ2h0X29yaWdpbiBpbiBldmVyeSBjYXNlLi4gb25seSB3aGVuIHNldHRpbmcgX2xlZnRcbiAgICAgICAgICBvID0gby5fcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjb25uZWN0IGxlZnQvcmlnaHQgKyB1cGRhdGUgcGFyZW50IG1hcC9zdGFydCBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIHBhcmVudFN1YiA9IHRoaXMuX3BhcmVudFN1YjtcbiAgICAgICAgaWYgKHRoaXMuX2xlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgcmlnaHQgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBtYXAgPSBwYXJlbnQuX21hcDtcbiAgICAgICAgICAgIHJpZ2h0ID0gcG1hcC5nZXQocGFyZW50U3ViKSB8fCBudWxsO1xuICAgICAgICAgICAgcG1hcC5zZXQocGFyZW50U3ViLCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBwYXJlbnQuX3N0YXJ0O1xuICAgICAgICAgICAgcGFyZW50Ll9zdGFydCA9IHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgaWYgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByaWdodC5fbGVmdCA9IHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fbGVmdDtcbiAgICAgICAgICB2YXIgX3JpZ2h0ID0gbGVmdC5fcmlnaHQ7XG4gICAgICAgICAgdGhpcy5fcmlnaHQgPSBfcmlnaHQ7XG4gICAgICAgICAgbGVmdC5fcmlnaHQgPSB0aGlzO1xuICAgICAgICAgIGlmIChfcmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9yaWdodC5fbGVmdCA9IHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQuX2RlbGV0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9kZWxldGUoeSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHkub3MucHV0KHRoaXMpO1xuICAgICAgICB0cmFuc2FjdGlvblR5cGVDaGFuZ2VkKHksIHBhcmVudCwgcGFyZW50U3ViKTtcbiAgICAgICAgaWYgKHRoaXMuX2lkLnVzZXIgIT09IFJvb3RGYWtlVXNlcklEKSB7XG4gICAgICAgICAgaWYgKHkuY29ubmVjdG9yICE9PSBudWxsICYmICh5LmNvbm5lY3Rvci5fZm9yd2FyZEFwcGxpZWRTdHJ1Y3RzIHx8IHRoaXMuX2lkLnVzZXIgPT09IHkudXNlcklEKSkge1xuICAgICAgICAgICAgeS5jb25uZWN0b3IuYnJvYWRjYXN0U3RydWN0KHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeS5wZXJzaXN0ZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgeS5wZXJzaXN0ZW5jZS5zYXZlU3RydWN0KHksIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgICAgICogQmluYXJ5RW5jb2Rlci5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtCaW5hcnlFbmNvZGVyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3RvQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9CaW5hcnkoZW5jb2Rlcikge1xuICAgICAgICBlbmNvZGVyLndyaXRlVWludDgoZ2V0U3RydWN0UmVmZXJlbmNlKHRoaXMuY29uc3RydWN0b3IpKTtcbiAgICAgICAgdmFyIGluZm8gPSAwO1xuICAgICAgICBpZiAodGhpcy5fb3JpZ2luICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5mbyArPSAxOyAvLyBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgICAvKiBubyBsb25nZXIgc2VuZCBfbGVmdFxuICAgICAgICBpZiAodGhpcy5fbGVmdCAhPT0gdGhpcy5fb3JpZ2luKSB7XG4gICAgICAgICAgaW5mbyArPSAwYjEwIC8vIGRvIG5vdCBjb3B5IG9yaWdpbiB0byBsZWZ0XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuX3JpZ2h0X29yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGluZm8gKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5mbyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZXIud3JpdGVVaW50OChpbmZvKTtcbiAgICAgICAgZW5jb2Rlci53cml0ZUlEKHRoaXMuX2lkKTtcbiAgICAgICAgaWYgKGluZm8gJiAxKSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZUlEKHRoaXMuX29yaWdpbi5fbGFzdElkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgLyogc2VlIGFib3ZlXG4gICAgICAgIGlmIChpbmZvICYgMGIxMCkge1xuICAgICAgICAgIGVuY29kZXIud3JpdGVJRCh0aGlzLl9sZWZ0Ll9sYXN0SWQpXG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKGluZm8gJiA0KSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZUlEKHRoaXMuX3JpZ2h0X29yaWdpbi5faWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaW5mbyAmIDUpID09PSAwKSB7XG4gICAgICAgICAgLy8gbmVpdGhlciBvcmlnaW4gbm9yIHJpZ2h0IGlzIGRlZmluZWRcbiAgICAgICAgICBlbmNvZGVyLndyaXRlSUQodGhpcy5fcGFyZW50Ll9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8gJiA4KSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVZhclN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLl9wYXJlbnRTdWIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlYWQgdGhlIG5leHQgSXRlbSBpbiBhIERlY29kZXIgYW5kIGZpbGwgdGhpcyBJdGVtIHdpdGggdGhlIHJlYWQgZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGRhdGEgaXMgcmVjZWl2ZWQgZnJvbSBhIHJlbW90ZSBwZWVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7WX0geSBUaGUgWWpzIGluc3RhbmNlIHRoYXQgdGhpcyBJdGVtIGJlbG9uZ3MgdG8uXG4gICAgICAgKiBAcGFyYW0ge0JpbmFyeURlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgb2JqZWN0IHRvIHJlYWQgZGF0YSBmcm9tLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19mcm9tQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZnJvbUJpbmFyeSh5LCBkZWNvZGVyKSB7XG4gICAgICAgIHZhciBtaXNzaW5nID0gW107XG4gICAgICAgIHZhciBpbmZvID0gZGVjb2Rlci5yZWFkVWludDgoKTtcbiAgICAgICAgdmFyIGlkID0gZGVjb2Rlci5yZWFkSUQoKTtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgLy8gcmVhZCBvcmlnaW5cbiAgICAgICAgaWYgKGluZm8gJiAxKSB7XG4gICAgICAgICAgLy8gb3JpZ2luICE9IG51bGxcbiAgICAgICAgICB2YXIgb3JpZ2luSUQgPSBkZWNvZGVyLnJlYWRJRCgpO1xuICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcXVlcnkgZm9yIGxlZnQgYWdhaW4gYmVjYXVzZSBpdCBtaWdodCBoYXZlIGJlZW4gc3BsaXQvbWVyZ2VkLi5cbiAgICAgICAgICB2YXIgb3JpZ2luID0geS5vcy5nZXRJdGVtQ2xlYW5FbmQob3JpZ2luSUQpO1xuICAgICAgICAgIGlmIChvcmlnaW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChvcmlnaW5JRCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgICAgIHRoaXMuX2xlZnQgPSB0aGlzLl9vcmlnaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWQgcmlnaHRcbiAgICAgICAgaWYgKGluZm8gJiA0KSB7XG4gICAgICAgICAgLy8gcmlnaHQgIT0gbnVsbFxuICAgICAgICAgIHZhciByaWdodElEID0gZGVjb2Rlci5yZWFkSUQoKTtcbiAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHF1ZXJ5IGZvciByaWdodCBhZ2FpbiBiZWNhdXNlIGl0IG1pZ2h0IGhhdmUgYmVlbiBzcGxpdC9tZXJnZWQuLlxuICAgICAgICAgIHZhciByaWdodCA9IHkub3MuZ2V0SXRlbUNsZWFuU3RhcnQocmlnaHRJRCk7XG4gICAgICAgICAgaWYgKHJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBtaXNzaW5nLnB1c2gocmlnaHRJRCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9yaWdodF9vcmlnaW4gPSByaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZCBwYXJlbnRcbiAgICAgICAgaWYgKChpbmZvICYgNSkgPT09IDApIHtcbiAgICAgICAgICAvLyBuZWl0aGVyIG9yaWdpbiBub3IgcmlnaHQgaXMgZGVmaW5lZFxuICAgICAgICAgIHZhciBwYXJlbnRJRCA9IGRlY29kZXIucmVhZElEKCk7XG4gICAgICAgICAgLy8gcGFyZW50IGRvZXMgbm90IGNoYW5nZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byBzZWFyY2ggZm9yIGl0IGFnYWluXG4gICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChwYXJlbnRJRC5jb25zdHJ1Y3RvciA9PT0gUm9vdElEKSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHkub3MuZ2V0KHBhcmVudElEKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHkub3MuZ2V0SXRlbShwYXJlbnRJRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIG1pc3NpbmcucHVzaChwYXJlbnRJRCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0aGlzLl9vcmlnaW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcmlnaW4uY29uc3RydWN0b3IgPT09IEdDKSB7XG4gICAgICAgICAgICAgIC8vIGlmIG9yaWdpbiBpcyBhIGdjLCBzZXQgcGFyZW50IGFsc28gZ2MnZFxuICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9vcmlnaW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9vcmlnaW4uX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3JpZ2h0X29yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaWYgb3JpZ2luIGlzIGEgZ2MsIHNldCBwYXJlbnQgYWxzbyBnYydkXG4gICAgICAgICAgICBpZiAodGhpcy5fcmlnaHRfb3JpZ2luLmNvbnN0cnVjdG9yID09PSBHQykge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9yaWdodF9vcmlnaW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9yaWdodF9vcmlnaW4uX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8gJiA4KSB7XG4gICAgICAgICAgLy8gVE9ETzogbWF5YmUgcHV0IHRoaXMgaW4gcmVhZCBwYXJlbnQgY29uZGl0aW9uICh5b3UgY2FuIGFsc28gcmVhZCBwYXJlbnRzdWIgZnJvbSBsZWZ0L3JpZ2h0KVxuICAgICAgICAgIHRoaXMuX3BhcmVudFN1YiA9IEpTT04ucGFyc2UoZGVjb2Rlci5yZWFkVmFyU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5LnNzLmdldFN0YXRlKGlkLnVzZXIpIDwgaWQuY2xvY2spIHtcbiAgICAgICAgICBtaXNzaW5nLnB1c2gobmV3IElEKGlkLnVzZXIsIGlkLmNsb2NrIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sYXN0SWQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSUQodGhpcy5faWQudXNlciwgdGhpcy5faWQuY2xvY2sgKyB0aGlzLl9sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgSXRlbS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbGVuZ3RoJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTaG91bGQgcmV0dXJuIGZhbHNlIGlmIHRoaXMgSXRlbSBpcyBzb21lIGtpbmQgb2YgbWV0YSBpbmZvcm1hdGlvblxuICAgICAgICogKGUuZy4gZm9ybWF0IGluZm9ybWF0aW9uKS5cbiAgICAgICAqXG4gICAgICAgKiAqIFdoZXRoZXIgdGhpcyBJdGVtIHNob3VsZCBiZSBhZGRyZXNzYWJsZSB2aWEgYHlhcnJheS5nZXQoaSlgXG4gICAgICAgKiAqIFdoZXRoZXIgdGhpcyBJdGVtIHNob3VsZCBiZSBjb3VudGVkIHdoZW4gY29tcHV0aW5nIHlhcnJheS5sZW5ndGhcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY291bnRhYmxlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEl0ZW07XG4gIH0oKTtcblxuICAvKipcbiAgICogR2VuZXJhbCBldmVudCBoYW5kbGVyIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgdmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEhhbmRsZXIoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudEhhbmRsZXIpO1xuXG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gcHJldmVudCBtZW1vcnkgbGVha3MsIGNhbGwgdGhpcyBtZXRob2Qgd2hlbiB0aGUgZXZlbnRMaXN0ZW5lcnMgd29uJ3QgYmVcbiAgICAgKiB1c2VkIGFueW1vcmUuXG4gICAgICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKEV2ZW50SGFuZGxlciwgW3tcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGlzIGNhbGxlZCB3aGVuXG4gICAgICAgKiB7QGxpbmsgRXZlbnRIYW5kbGVyI2NhbGxFdmVudExpc3RlbmVyc30gaXMgY2FsbGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihmKSB7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMucHVzaChmKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGV2ZW50IGhhbmRsZXIgdGhhdCB3YXMgYWRkZWQgd2l0aFxuICAgICAgICogICAgICAgICAgICAgICAgICAgICB7QGxpbmsgRXZlbnRIYW5kbGVyI2FkZEV2ZW50TGlzdGVuZXJ9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihmKSB7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoZykge1xuICAgICAgICAgIHJldHVybiBmICE9PSBnO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVBbGxFdmVudExpc3RlbmVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCBhbGwgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZCB2aWFcbiAgICAgICAqIHtAbGluayBFdmVudEhhbmRsZXIjYWRkRXZlbnRMaXN0ZW5lcn0uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIG9iamVjdCAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoaXM/XG4gICAgICAgKiBAcGFyYW0ge1lFdmVudH0gZXZlbnQgQW4gZXZlbnQgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2Ugb24gYSB0eXBlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2FsbEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FsbEV2ZW50TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBldmVudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGYgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgZihldmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgWW91ciBvYnNlcnZlciB0aHJldyBhbiBlcnJvci4gVGhpcyBlcnJvciB3YXMgY2F1Z2h0IHNvIHRoYXQgWWpzXG4gICAgICAgICAgICAgIGNhbiBlbnN1cmUgZGF0YSBjb25zaXN0ZW5jeSEgSW4gb3JkZXIgdG8gZGVidWcgdGhpcyBlcnJvciB5b3VcbiAgICAgICAgICAgICAgaGF2ZSB0byBjaGVjayBcIlBhdXNlIE9uIENhdWdodCBFeGNlcHRpb25zXCIgaW4gZGV2ZWxvcGVyIHRvb2xzLlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBFdmVudEhhbmRsZXI7XG4gIH0oKTtcblxuICAvLyByZXN0cnVjdHVyZSBjaGlsZHJlbiBhcyBpZiB0aGV5IHdlcmUgaW5zZXJ0ZWQgb25lIGFmdGVyIGFub3RoZXJcbiAgZnVuY3Rpb24gaW50ZWdyYXRlQ2hpbGRyZW4oeSwgc3RhcnQpIHtcbiAgICB2YXIgcmlnaHQgPSB2b2lkIDA7XG4gICAgZG8ge1xuICAgICAgcmlnaHQgPSBzdGFydC5fcmlnaHQ7XG4gICAgICBzdGFydC5fcmlnaHQgPSBudWxsO1xuICAgICAgc3RhcnQuX3JpZ2h0X29yaWdpbiA9IG51bGw7XG4gICAgICBzdGFydC5fb3JpZ2luID0gc3RhcnQuX2xlZnQ7XG4gICAgICBzdGFydC5faW50ZWdyYXRlKHkpO1xuICAgICAgc3RhcnQgPSByaWdodDtcbiAgICB9IHdoaWxlIChyaWdodCAhPT0gbnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBnY0NoaWxkcmVuKHksIGl0ZW0pIHtcbiAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgaXRlbS5fZGVsZXRlKHksIGZhbHNlLCB0cnVlKTtcbiAgICAgIGl0ZW0uX2djKHkpO1xuICAgICAgaXRlbSA9IGl0ZW0uX3JpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBYnN0cmFjdCBZanMgVHlwZSBjbGFzc1xuICAgKi9cblxuICB2YXIgVHlwZSA9IGZ1bmN0aW9uIChfSXRlbSkge1xuICAgIGluaGVyaXRzKFR5cGUsIF9JdGVtKTtcblxuICAgIGZ1bmN0aW9uIFR5cGUoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlKTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGUpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgX3RoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgIF90aGlzLl9zdGFydCA9IG51bGw7XG4gICAgICBfdGhpcy5feSA9IG51bGw7XG4gICAgICBfdGhpcy5fZXZlbnRIYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuICAgICAgX3RoaXMuX2RlZXBFdmVudEhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyKCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgcGF0aCBmcm9tIHRoaXMgdHlwZSB0byB0aGUgc3BlY2lmaWVkIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogSXQgc2hvdWxkIGJlIGFjY2Vzc2libGUgdmlhIGB0aGlzLmdldChyZXN1bHRbMF0pLmdldChyZXN1bHRbMV0pLi5gXG4gICAgICogY29uc3QgcGF0aCA9IHR5cGUuZ2V0UGF0aFRvKGNoaWxkKVxuICAgICAqIC8vIGFzc3VtaW5nIGB0eXBlIGluc3RhbmNlb2YgWUFycmF5YFxuICAgICAqIGNvbnNvbGUubG9nKHBhdGgpIC8vIG1pZ2h0IGxvb2sgbGlrZSA9PiBbMiwgJ2tleTEnXVxuICAgICAqIGNoaWxkID09PSB0eXBlLmdldChwYXRoWzBdKS5nZXQocGF0aFsxXSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WVR5cGV9IHR5cGUgVHlwZSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBQYXRoIHRvIHRoZSB0YXJnZXRcbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoVHlwZSwgW3tcbiAgICAgIGtleTogJ2dldFBhdGhUbycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aFRvKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHRoaXMpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSBbXTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLl95O1xuICAgICAgICB3aGlsZSAodHlwZSAhPT0gdGhpcyAmJiB0eXBlICE9PSB5KSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHR5cGUuX3BhcmVudDtcbiAgICAgICAgICBpZiAodHlwZS5fcGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXRoLnVuc2hpZnQodHlwZS5fcGFyZW50U3ViKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyZW50IGlzIGFycmF5LWlzaFxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHBhcmVudFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBzbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICBwYXRoLnVuc2hpZnQoaSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHlwZSBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIG5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQ2FsbCBldmVudCBsaXN0ZW5lcnMgd2l0aCBhbiBldmVudC4gVGhpcyB3aWxsIGFsc28gYWRkIGFuIGV2ZW50IHRvIGFsbFxuICAgICAgICogcGFyZW50cyAoZm9yIGAub2JzZXJ2ZURlZXBgIGhhbmRsZXJzKS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NhbGxFdmVudEhhbmRsZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxsRXZlbnRIYW5kbGVyKHRyYW5zYWN0aW9uLCBldmVudCkge1xuICAgICAgICB2YXIgY2hhbmdlZFBhcmVudFR5cGVzID0gdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzO1xuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXIuY2FsbEV2ZW50TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBldmVudCk7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHR5cGUgIT09IHRoaXMuX3kpIHtcbiAgICAgICAgICB2YXIgZXZlbnRzID0gY2hhbmdlZFBhcmVudFR5cGVzLmdldCh0eXBlKTtcbiAgICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgY2hhbmdlZFBhcmVudFR5cGVzLnNldCh0eXBlLCBldmVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudHMucHVzaChldmVudCk7XG4gICAgICAgICAgdHlwZSA9IHR5cGUuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHRyYW5zYWN0IGlmIHRoZSB5IGluc3RhbmNlIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqXG4gICAgICAgKiBUT0RPOiBDdXJyZW50bHkgZXZlbnQgaGFuZGxlcnMgYXJlIG5vdCB0aHJvd24gd2hlbiBhIHR5cGUgaXMgbm90IHJlZ2lzdGVyZWRcbiAgICAgICAqICAgICAgIHdpdGggYSBZanMgaW5zdGFuY2UuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190cmFuc2FjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zYWN0KGYpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLl95O1xuICAgICAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICAgIHkudHJhbnNhY3QoZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZih5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE9ic2VydmUgYWxsIGV2ZW50cyB0aGF0IGFyZSBjcmVhdGVkIG9uIHRoaXMgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29ic2VydmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9ic2VydmUoZikge31cbiAgICAgIC8vdGhpcy5fZXZlbnRIYW5kbGVyLmFkZEV2ZW50TGlzdGVuZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vICAgIGNvbnNvbGUubG9nKCdlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZScpO1xuICAgICAgLy8gICAgY29uc29sZS5sb2coZSk7XG4gICAgICAvL30pO1xuXG5cbiAgICAgIC8qKlxuICAgICAgICogT2JzZXJ2ZSBhbGwgZXZlbnRzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgdGhpcyB0eXBlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvYnNlcnZlRGVlcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb2JzZXJ2ZURlZXAoZikge1xuICAgICAgICB0aGlzLl9kZWVwRXZlbnRIYW5kbGVyLmFkZEV2ZW50TGlzdGVuZXIoZik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciBhbiBvYnNlcnZlciBmdW5jdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Vub2JzZXJ2ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5vYnNlcnZlKGYpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciBhbiBvYnNlcnZlciBmdW5jdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Vub2JzZXJ2ZURlZXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVub2JzZXJ2ZURlZXAoZikge1xuICAgICAgICB0aGlzLl9kZWVwRXZlbnRIYW5kbGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICAgICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAgICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaW50ZWdyYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW50ZWdyYXRlKHkpIHtcbiAgICAgICAgZ2V0KFR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHlwZS5wcm90b3R5cGUpLCAnX2ludGVncmF0ZScsIHRoaXMpLmNhbGwodGhpcywgeSk7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICAvLyB3aGVuIGludGVncmF0aW5nIGNoaWxkcmVuIHdlIG11c3QgbWFrZSBzdXJlIHRvXG4gICAgICAgIC8vIGludGVncmF0ZSBzdGFydFxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9zdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fc3RhcnQgPSBudWxsO1xuICAgICAgICAgIGludGVncmF0ZUNoaWxkcmVuKHksIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnRlZ3JhdGUgbWFwIGNoaWxkcmVuXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IG1hcC52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHQgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gbWFrZSBzdXJlIHRoYXQgcmlnaHQgZWxlbWVudHMgYXJlIGRlbGV0ZWQhXG4gICAgICAgICAgICBpbnRlZ3JhdGVDaGlsZHJlbih5LCB0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nY0NoaWxkcmVuJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2NDaGlsZHJlbih5KSB7XG4gICAgICAgIGdjQ2hpbGRyZW4oeSwgdGhpcy5fc3RhcnQpO1xuICAgICAgICB0aGlzLl9zdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hcC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgZ2NDaGlsZHJlbih5LCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZ2MnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nYyh5KSB7XG4gICAgICAgIHRoaXMuX2djQ2hpbGRyZW4oeSk7XG4gICAgICAgIGdldChUeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGUucHJvdG90eXBlKSwgJ19nYycsIHRoaXMpLmNhbGwodGhpcywgeSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIE1hcmsgdGhpcyBJdGVtIGFzIGRlbGV0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlRGVsZXRlIFdoZXRoZXIgdG8gcHJvcGFnYXRlIGEgbWVzc2FnZSB0aGF0IHRoaXNcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFR5cGUgd2FzIGRlbGV0ZWQuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnY0NoaWxkcmVuPXkuX2hhc1VuZG9NYW5hZ2VyPT09ZmFsc2VdIFdoZXRoZXIgdG8gZ2FyYmFnZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3QgdGhlIGNoaWxkcmVuIG9mIHRoaXMgdHlwZS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2RlbGV0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZSh5LCBjcmVhdGVEZWxldGUsIGdjQ2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGdjQ2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCAheS5nY0VuYWJsZWQpIHtcbiAgICAgICAgICBnY0NoaWxkcmVuID0geS5faGFzVW5kb01hbmFnZXIgPT09IGZhbHNlICYmIHkuZ2NFbmFibGVkO1xuICAgICAgICB9XG4gICAgICAgIGdldChUeXBlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGUucHJvdG90eXBlKSwgJ19kZWxldGUnLCB0aGlzKS5jYWxsKHRoaXMsIHksIGNyZWF0ZURlbGV0ZSwgZ2NDaGlsZHJlbik7XG4gICAgICAgIHkuX3RyYW5zYWN0aW9uLmNoYW5nZWRUeXBlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIC8vIGRlbGV0ZSBtYXAgdHlwZXNcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IHRoaXMuX21hcC52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJdGVtICYmICF2YWx1ZS5fZGVsZXRlZCkge1xuICAgICAgICAgICAgICB2YWx1ZS5fZGVsZXRlKHksIGZhbHNlLCBnY0NoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZGVsZXRlIGFycmF5IHR5cGVzXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIHdoaWxlICh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCF0Ll9kZWxldGVkKSB7XG4gICAgICAgICAgICB0Ll9kZWxldGUoeSwgZmFsc2UsIGdjQ2hpbGRyZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ID0gdC5fcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdjQ2hpbGRyZW4pIHtcbiAgICAgICAgICB0aGlzLl9nY0NoaWxkcmVuKHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBUeXBlO1xuICB9KEl0ZW0pO1xuXG4gIHZhciBJdGVtSlNPTiA9IGZ1bmN0aW9uIChfSXRlbSkge1xuICAgIGluaGVyaXRzKEl0ZW1KU09OLCBfSXRlbSk7XG5cbiAgICBmdW5jdGlvbiBJdGVtSlNPTigpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEl0ZW1KU09OKTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSXRlbUpTT04uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGVtSlNPTikpLmNhbGwodGhpcykpO1xuXG4gICAgICBfdGhpcy5fY29udGVudCA9IG51bGw7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoSXRlbUpTT04sIFt7XG4gICAgICBrZXk6ICdfY29weScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvcHkoKSB7XG4gICAgICAgIHZhciBzdHJ1Y3QgPSBnZXQoSXRlbUpTT04ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRlbUpTT04ucHJvdG90eXBlKSwgJ19jb3B5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgc3RydWN0Ll9jb250ZW50ID0gdGhpcy5fY29udGVudDtcbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZnJvbUJpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zyb21CaW5hcnkoeSwgZGVjb2Rlcikge1xuICAgICAgICB2YXIgbWlzc2luZyA9IGdldChJdGVtSlNPTi5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGVtSlNPTi5wcm90b3R5cGUpLCAnX2Zyb21CaW5hcnknLCB0aGlzKS5jYWxsKHRoaXMsIHksIGRlY29kZXIpO1xuICAgICAgICB2YXIgbGVuID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3RudCA9IGRlY29kZXIucmVhZFZhclN0cmluZygpO1xuICAgICAgICAgIHZhciBwYXJzZWQgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKGN0bnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoY3RudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NvbnRlbnRbaV0gPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pc3Npbmc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3RvQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9CaW5hcnkoZW5jb2Rlcikge1xuICAgICAgICBnZXQoSXRlbUpTT04ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRlbUpTT04ucHJvdG90eXBlKSwgJ190b0JpbmFyeScsIHRoaXMpLmNhbGwodGhpcywgZW5jb2Rlcik7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgZW5jb2Rlci53cml0ZVZhclVpbnQobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBlbmNvZGVkID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fY29udGVudFtpXTtcbiAgICAgICAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbmNvZGVkID0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kZWQgPSBKU09OLnN0cmluZ2lmeShjb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVZhclN0cmluZyhlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gdGhpcyBZWG1sIFR5cGUgdG8gYSByZWFkYWJsZSBmb3JtYXQuXG4gICAgICAgKiBVc2VmdWwgZm9yIGxvZ2dpbmcgYXMgYWxsIEl0ZW1zIGFuZCBEZWxldGUgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sb2dTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2dTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBsb2dJdGVtSGVscGVyKCdJdGVtSlNPTicsIHRoaXMsICdjb250ZW50OicgKyBKU09OLnN0cmluZ2lmeSh0aGlzLl9jb250ZW50KSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3NwbGl0QXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zcGxpdEF0KHksIGRpZmYpIHtcbiAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbSA9IG5ldyBJdGVtSlNPTigpO1xuICAgICAgICBpdGVtLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zcGxpY2UoZGlmZik7XG4gICAgICAgIHNwbGl0SGVscGVyKHksIHRoaXMsIGl0ZW0sIGRpZmYpO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbGVuZ3RoJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBJdGVtSlNPTjtcbiAgfShJdGVtKTtcblxuICB2YXIgSXRlbVN0cmluZyA9IGZ1bmN0aW9uIChfSXRlbSkge1xuICAgIGluaGVyaXRzKEl0ZW1TdHJpbmcsIF9JdGVtKTtcblxuICAgIGZ1bmN0aW9uIEl0ZW1TdHJpbmcoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJdGVtU3RyaW5nKTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSXRlbVN0cmluZy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1TdHJpbmcpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgX3RoaXMuX2NvbnRlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKEl0ZW1TdHJpbmcsIFt7XG4gICAgICBrZXk6ICdfY29weScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvcHkoKSB7XG4gICAgICAgIHZhciBzdHJ1Y3QgPSBnZXQoSXRlbVN0cmluZy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGVtU3RyaW5nLnByb3RvdHlwZSksICdfY29weScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgIHN0cnVjdC5fY29udGVudCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgIHJldHVybiBzdHJ1Y3Q7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2Zyb21CaW5hcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mcm9tQmluYXJ5KHksIGRlY29kZXIpIHtcbiAgICAgICAgdmFyIG1pc3NpbmcgPSBnZXQoSXRlbVN0cmluZy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGVtU3RyaW5nLnByb3RvdHlwZSksICdfZnJvbUJpbmFyeScsIHRoaXMpLmNhbGwodGhpcywgeSwgZGVjb2Rlcik7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIG1pc3Npbmc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3RvQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9CaW5hcnkoZW5jb2Rlcikge1xuICAgICAgICBnZXQoSXRlbVN0cmluZy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGVtU3RyaW5nLnByb3RvdHlwZSksICdfdG9CaW5hcnknLCB0aGlzKS5jYWxsKHRoaXMsIGVuY29kZXIpO1xuICAgICAgICBlbmNvZGVyLndyaXRlVmFyU3RyaW5nKHRoaXMuX2NvbnRlbnQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gdGhpcyBZWG1sIFR5cGUgdG8gYSByZWFkYWJsZSBmb3JtYXQuXG4gICAgICAgKiBVc2VmdWwgZm9yIGxvZ2dpbmcgYXMgYWxsIEl0ZW1zIGFuZCBEZWxldGUgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sb2dTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2dTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBsb2dJdGVtSGVscGVyKCdJdGVtU3RyaW5nJywgdGhpcywgJ2NvbnRlbnQ6XCInICsgdGhpcy5fY29udGVudCArICdcIicpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zcGxpdEF0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3BsaXRBdCh5LCBkaWZmKSB7XG4gICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZiA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW0gPSBuZXcgSXRlbVN0cmluZygpO1xuICAgICAgICBpdGVtLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zbGljZShkaWZmKTtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IHRoaXMuX2NvbnRlbnQuc2xpY2UoMCwgZGlmZik7XG4gICAgICAgIHNwbGl0SGVscGVyKHksIHRoaXMsIGl0ZW0sIGRpZmYpO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbGVuZ3RoJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBJdGVtU3RyaW5nO1xuICB9KEl0ZW0pO1xuXG4gIC8qKlxuICAgKiBZRXZlbnQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWVR5cGUuXG4gICAqL1xuICB2YXIgWUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7WVR5cGV9IHRhcmdldCBUaGUgY2hhbmdlZCB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFlFdmVudCh0YXJnZXQpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFlFdmVudCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHR5cGUgb24gd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZCBvbi5cbiAgICAgICAqIEB0eXBlIHtZVHlwZX1cbiAgICAgICAqL1xuICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjdXJyZW50IHRhcmdldCBvbiB3aGljaCB0aGUgb2JzZXJ2ZSBjYWxsYmFjayBpcyBjYWxsZWQuXG4gICAgICAgKiBAdHlwZSB7WVR5cGV9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgcGF0aCBmcm9tIGB5YCB0byB0aGUgY2hhbmdlZCB0eXBlLlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0eSBob2xkczpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgbGV0IHR5cGUgPSB5XG4gICAgICogICBldmVudC5wYXRoLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xuICAgICAqICAgICB0eXBlID0gdHlwZS5nZXQoZGlyKVxuICAgICAqICAgfSlcbiAgICAgKiAgIHR5cGUgPT09IGV2ZW50LnRhcmdldCAvLyA9PiB0cnVlXG4gICAgICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKFlFdmVudCwgW3tcbiAgICAgIGtleTogXCJwYXRoXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRhcmdldC5nZXRQYXRoVG8odGhpcy50YXJnZXQpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gWUV2ZW50O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWUFycmF5XG4gICAqXG4gICAqIEBwYXJhbSB7WUFycmF5fSB5YXJyYXkgVGhlIGNoYW5nZWQgdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW90ZSBXaGV0aGVyIHRoZSBjaGFuZ2VkIHdhcyBjYXVzZWQgYnkgYSByZW1vdGUgcGVlclxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0XG4gICAqL1xuICB2YXIgWUFycmF5RXZlbnQgPSBmdW5jdGlvbiAoX1lFdmVudCkge1xuICAgIGluaGVyaXRzKFlBcnJheUV2ZW50LCBfWUV2ZW50KTtcblxuICAgIGZ1bmN0aW9uIFlBcnJheUV2ZW50KHlhcnJheSwgcmVtb3RlLCB0cmFuc2FjdGlvbikge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWUFycmF5RXZlbnQpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChZQXJyYXlFdmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlBcnJheUV2ZW50KSkuY2FsbCh0aGlzLCB5YXJyYXkpKTtcblxuICAgICAgX3RoaXMucmVtb3RlID0gcmVtb3RlO1xuICAgICAgX3RoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICBfdGhpcy5fYWRkZWRFbGVtZW50cyA9IG51bGw7XG4gICAgICBfdGhpcy5fcmVtb3ZlZEVsZW1lbnRzID0gbnVsbDtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGlsZCBlbGVtZW50cyB0aGF0IHdlcmUgYWRkZWQgaW4gdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NldH1cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoWUFycmF5RXZlbnQsIFt7XG4gICAgICBrZXk6ICdhZGRlZEVsZW1lbnRzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkZWRFbGVtZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSB0aGlzLl90cmFuc2FjdGlvbjtcbiAgICAgICAgICB2YXIgYWRkZWRFbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5uZXdUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZS5fcGFyZW50ID09PSB0YXJnZXQgJiYgIXRyYW5zYWN0aW9uLmRlbGV0ZWRTdHJ1Y3RzLmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICBhZGRlZEVsZW1lbnRzLmFkZCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9hZGRlZEVsZW1lbnRzID0gYWRkZWRFbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkZWRFbGVtZW50cztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGlsZCBlbGVtZW50cyB0aGF0IHdlcmUgcmVtb3ZlZCBpbiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1NldH1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlZEVsZW1lbnRzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVtb3ZlZEVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuX3RyYW5zYWN0aW9uO1xuICAgICAgICAgIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlZFN0cnVjdHMuZm9yRWFjaChmdW5jdGlvbiAoc3RydWN0KSB7XG4gICAgICAgICAgICBpZiAoc3RydWN0Ll9wYXJlbnQgPT09IHRhcmdldCAmJiAhdHJhbnNhY3Rpb24ubmV3VHlwZXMuaGFzKHN0cnVjdCkpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlZEVsZW1lbnRzLmFkZChzdHJ1Y3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX3JlbW92ZWRFbGVtZW50cyA9IHJlbW92ZWRFbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlZEVsZW1lbnRzO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gWUFycmF5RXZlbnQ7XG4gIH0oWUV2ZW50KTtcblxuICAvKipcbiAgICogQSBzaGFyZWQgQXJyYXkgaW1wbGVtZW50YXRpb24uXG4gICAqL1xuXG4gIHZhciBZQXJyYXkgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgICBpbmhlcml0cyhZQXJyYXksIF9UeXBlKTtcblxuICAgIGZ1bmN0aW9uIFlBcnJheSgpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFlBcnJheSk7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoWUFycmF5Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWUFycmF5KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoWUFycmF5LCBbe1xuICAgICAga2V5OiAnX2NhbGxPYnNlcnZlcicsXG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIENyZWF0ZXMgWUFycmF5IEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzLCByZW1vdGUpIHtcbiAgICAgICAgdGhpcy5fY2FsbEV2ZW50SGFuZGxlcih0cmFuc2FjdGlvbiwgbmV3IFlBcnJheUV2ZW50KHRoaXMsIHJlbW90ZSwgdHJhbnNhY3Rpb24pKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBpLXRoIGVsZW1lbnQgZnJvbSBhIFlBcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4gZnJvbSB0aGUgWUFycmF5XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0JCQxKGluZGV4KSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFuLl9kZWxldGVkICYmIG4uX2NvdW50YWJsZSkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbi5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChuLmNvbnN0cnVjdG9yID09PSBJdGVtSlNPTiB8fCBuLmNvbnN0cnVjdG9yID09PSBJdGVtU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG4uX2NvbnRlbnRbaW5kZXhdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCAtPSBuLl9sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIG4gPSBuLl9yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b0FycmF5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtcyB0aGlzIFNoYXJlZCBUeXBlIHRvIGEgSlNPTiBvYmplY3QuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3RvSlNPTicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChjLnRvSlNPTiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gYy50b0pTT04oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBjLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIEFycmF5IHdpdGggdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnlcbiAgICAgICAqIGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiBGdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGVsZW1lbnQgb2YgdGhlIG5ldyBBcnJheVxuICAgICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5IHdpdGggZWFjaCBlbGVtZW50IGJlaW5nIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbWFwJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAoZikge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgIHJlcy5wdXNoKGYoYywgaSwgX3RoaXMzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBvdmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZvckVhY2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goZikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgbiA9IHRoaXMuX3N0YXJ0O1xuICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghbi5fZGVsZXRlZCAmJiBuLl9jb3VudGFibGUpIHtcbiAgICAgICAgICAgIGlmIChuIGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgICAgICAgICBmKG4sIGluZGV4KyssIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBuLl9jb250ZW50O1xuICAgICAgICAgICAgICB2YXIgY29udGVudExlbiA9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgZihjb250ZW50W2ldLCBpbmRleCwgdGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbiA9IG4uX3JpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29tcHV0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIFlBcnJheS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9pdGVtICE9PSBudWxsICYmICh0aGlzLl9pdGVtLl9kZWxldGVkIHx8IHRoaXMuX2l0ZW0uX2xlbmd0aCA8PSB0aGlzLl9pdGVtRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgLy8gaXRlbSBpcyBkZWxldGVkIG9yIGl0ZW1FbGVtZW50IGRvZXMgbm90IGV4aXN0IChpcyBkZWxldGVkKVxuICAgICAgICAgICAgICB0aGlzLl9pdGVtID0gdGhpcy5faXRlbS5fcmlnaHQ7XG4gICAgICAgICAgICAgIHRoaXMuX2l0ZW1FbGVtZW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5faXRlbSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMuX2l0ZW07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5faXRlbS5fY29udGVudFt0aGlzLl9pdGVtRWxlbWVudCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBjb250ZW50LFxuICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIF9pdGVtOiB0aGlzLl9zdGFydCxcbiAgICAgICAgICBfaXRlbUVsZW1lbnQ6IDAsXG4gICAgICAgICAgX2NvdW50OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlcyBlbGVtZW50cyBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcgZWxlbWVudHNcbiAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZWxldGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoaW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcblxuICAgICAgICB0aGlzLl95LnRyYW5zYWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzNC5fc3RhcnQ7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCAmJiBsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uX2RlbGV0ZWQgJiYgaXRlbS5fY291bnRhYmxlKSB7XG4gICAgICAgICAgICAgIGlmIChjb3VudCA8PSBpbmRleCAmJiBpbmRleCA8IGNvdW50ICsgaXRlbS5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmZEZWwgPSBpbmRleCAtIGNvdW50O1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLl9zcGxpdEF0KF90aGlzNC5feSwgZGlmZkRlbCk7XG4gICAgICAgICAgICAgICAgaXRlbS5fc3BsaXRBdChfdGhpczQuX3ksIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGVuZ3RoIC09IGl0ZW0uX2xlbmd0aDtcbiAgICAgICAgICAgICAgICBpdGVtLl9kZWxldGUoX3RoaXM0Ll95KTtcbiAgICAgICAgICAgICAgICBjb3VudCArPSBkaWZmRGVsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IGl0ZW0uX2xlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0uX3JpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxldGUgZXhjZWVkcyB0aGUgcmFuZ2Ugb2YgdGhlIFlBcnJheScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEluc2VydHMgY29udGVudCBhZnRlciBhbiBlbGVtZW50IGNvbnRhaW5lci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0l0ZW19IGxlZnQgVGhlIGVsZW1lbnQgY29udGFpbmVyIHRvIHVzZSBhcyBhIHJlZmVyZW5jZS5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRlbnQgVGhlIEFycmF5IG9mIGNvbnRlbnQgdG8gaW5zZXJ0IChzZWUge0BzZWUgaW5zZXJ0fSlcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaW5zZXJ0QWZ0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEFmdGVyKGxlZnQsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNhY3QoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICB2YXIgcmlnaHQgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKGxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gX3RoaXM1Ll9zdGFydDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBsZWZ0Ll9yaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHByZXZKc29uSW5zID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gY29udGVudFtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjID0gbmV3IGMoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXZKc29uSW5zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHByZXZKc29uSW5zLl9pbnRlZ3JhdGUoeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlZnQgPSBwcmV2SnNvbklucztcbiAgICAgICAgICAgICAgICBwcmV2SnNvbklucyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYy5fb3JpZ2luID0gbGVmdDtcbiAgICAgICAgICAgICAgYy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICAgIGMuX3JpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICAgIGMuX3JpZ2h0X29yaWdpbiA9IHJpZ2h0O1xuICAgICAgICAgICAgICBjLl9wYXJlbnQgPSBfdGhpczU7XG4gICAgICAgICAgICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYy5faW50ZWdyYXRlKHkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpczUuX3N0YXJ0ID0gYztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZWZ0Ll9yaWdodCA9IGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVmdCA9IGM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJldkpzb25JbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcmV2SnNvbklucyA9IG5ldyBJdGVtSlNPTigpO1xuICAgICAgICAgICAgICAgIHByZXZKc29uSW5zLl9vcmlnaW4gPSBsZWZ0O1xuICAgICAgICAgICAgICAgIHByZXZKc29uSW5zLl9sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgICAgICBwcmV2SnNvbklucy5fcmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgICAgICBwcmV2SnNvbklucy5fcmlnaHRfb3JpZ2luID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgcHJldkpzb25JbnMuX3BhcmVudCA9IF90aGlzNTtcbiAgICAgICAgICAgICAgICBwcmV2SnNvbklucy5fY29udGVudCA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByZXZKc29uSW5zLl9jb250ZW50LnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2SnNvbklucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldkpzb25JbnMuX2ludGVncmF0ZSh5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldkpzb25JbnMuX2xlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgX3RoaXM1Ll9zdGFydCA9IHByZXZKc29uSW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAgICAgKlxuICAgICAgICogSW1wb3J0YW50OiBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgYW4gYXJyYXkgb2YgY29udGVudC4gTm90IGp1c3QgYSBjb250ZW50XG4gICAgICAgKiBvYmplY3QuIFRoZSByZWFzb24gZm9yIHRoaXMgXCJ3ZWlyZG5lc3NcIiBpcyB0aGF0IGluc2VydGluZyBzZXZlcmFsIGVsZW1lbnRzXG4gICAgICAgKiBpcyB2ZXJ5IGVmZmljaWVudCB3aGVuIGl0IGlzIGRvbmUgYXMgYSBzaW5nbGUgb3BlcmF0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgICAgICogIHlhcnJheS5pbnNlcnQoMCwgWydhJ10pXG4gICAgICAgKiAgLy8gSW5zZXJ0IG51bWJlcnMgMSwgMiBhdCBwb3NpdGlvbiAxXG4gICAgICAgKiAgeWFycmF5Lmluc2VydCgyLCBbMSwgMl0pXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IGNvbnRlbnQgYXQuXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBjb250ZW50IFRoZSBhcnJheSBvZiBjb250ZW50XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2luc2VydCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0KGluZGV4LCBjb250ZW50KSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zYWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IG51bGw7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gX3RoaXM2Ll9zdGFydDtcbiAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgIHZhciB5ID0gX3RoaXM2Ll95O1xuICAgICAgICAgIHdoaWxlIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJpZ2h0TGVuID0gcmlnaHQuX2RlbGV0ZWQgPyAwIDogcmlnaHQuX2xlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAoY291bnQgPD0gaW5kZXggJiYgaW5kZXggPD0gY291bnQgKyByaWdodExlbikge1xuICAgICAgICAgICAgICB2YXIgc3BsaXREaWZmID0gaW5kZXggLSBjb3VudDtcbiAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5fc3BsaXRBdCh5LCBzcGxpdERpZmYpO1xuICAgICAgICAgICAgICBsZWZ0ID0gcmlnaHQuX2xlZnQ7XG4gICAgICAgICAgICAgIGNvdW50ICs9IHNwbGl0RGlmZjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJpZ2h0Ll9kZWxldGVkKSB7XG4gICAgICAgICAgICAgIGNvdW50ICs9IHJpZ2h0Ll9sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICAgICAgICByaWdodCA9IHJpZ2h0Ll9yaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4ID4gY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggZXhjZWVkcyBhcnJheSByYW5nZSEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXM2Lmluc2VydEFmdGVyKGxlZnQsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIGFwcGVuZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncHVzaCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChjb250ZW50KSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIHZhciBsYXN0VW5kZWxldGVkID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIW4uX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgIGxhc3RVbmRlbGV0ZWQgPSBuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gbi5fcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnNlcnRBZnRlcihsYXN0VW5kZWxldGVkLCBjb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gdGhpcyBZWG1sIFR5cGUgdG8gYSByZWFkYWJsZSBmb3JtYXQuXG4gICAgICAgKiBVc2VmdWwgZm9yIGxvZ2dpbmcgYXMgYWxsIEl0ZW1zIGFuZCBEZWxldGUgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sb2dTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2dTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBsb2dJdGVtSGVscGVyKCdZQXJyYXknLCB0aGlzLCAnc3RhcnQ6JyArIGxvZ0lEKHRoaXMuX3N0YXJ0KSArICdcIicpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2xlbmd0aCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIHZhciBuID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFuLl9kZWxldGVkICYmIG4uX2NvdW50YWJsZSkge1xuICAgICAgICAgICAgbGVuZ3RoICs9IG4uX2xlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbiA9IG4uX3JpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBZQXJyYXk7XG4gIH0oVHlwZSk7XG5cbiAgLyoqXG4gICAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWU1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtZTWFwfSB5bWFwIFRoZSBZQXJyYXkgdGhhdCBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge1NldDxhbnk+fSBzdWJzIFRoZSBrZXlzIHRoYXQgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSByZW1vdGUgV2hldGhlciB0aGUgY2hhbmdlIHdhcyBjcmVhdGVkIGJ5IGEgcmVtb3RlIHBlZXIuXG4gICAqL1xuICB2YXIgWU1hcEV2ZW50ID0gZnVuY3Rpb24gKF9ZRXZlbnQpIHtcbiAgICBpbmhlcml0cyhZTWFwRXZlbnQsIF9ZRXZlbnQpO1xuXG4gICAgZnVuY3Rpb24gWU1hcEV2ZW50KHltYXAsIHN1YnMsIHJlbW90ZSkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWU1hcEV2ZW50KTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoWU1hcEV2ZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWU1hcEV2ZW50KSkuY2FsbCh0aGlzLCB5bWFwKSk7XG5cbiAgICAgIF90aGlzLmtleXNDaGFuZ2VkID0gc3VicztcbiAgICAgIF90aGlzLnJlbW90ZSA9IHJlbW90ZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gWU1hcEV2ZW50O1xuICB9KFlFdmVudCk7XG5cbiAgLyoqXG4gICAqIEEgc2hhcmVkIE1hcCBpbXBsZW1lbnRhdGlvbi5cbiAgICovXG5cbiAgdmFyIFlNYXAgPSBmdW5jdGlvbiAoX1R5cGUpIHtcbiAgICBpbmhlcml0cyhZTWFwLCBfVHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIENyZWF0ZXMgWU1hcCBFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFlNYXAoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBZTWFwKTtcblxuICAgICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFlNYXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZTWFwKSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdjb25zdHJ1Y3RlZGRkZGRkZGRkZGRkZGRkZGRkZGQnKTtcbiAgICAgIF90aGlzMi5fZXZlbnRIYW5kbGVyLmFkZEV2ZW50TGlzdGVuZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpO1xuICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgdmFyIHggPSA5OTk5OTk5OTk5OTk5O1xuICAgICAgICBjb25zb2xlLmxvZyh4KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF90aGlzMjtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhZTWFwLCBbe1xuICAgICAga2V5OiAnX2NhbGxPYnNlcnZlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgcGFyZW50U3VicywgcmVtb3RlKSB7XG4gICAgICAgIHRoaXMuX2NhbGxFdmVudEhhbmRsZXIodHJhbnNhY3Rpb24sIG5ldyBZTWFwRXZlbnQodGhpcywgcGFyZW50U3VicywgcmVtb3RlKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtcyB0aGlzIFNoYXJlZCBUeXBlIHRvIGEgSlNPTiBvYmplY3QuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b0pTT04nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLl9tYXBbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBzbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICBpdGVtID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgICAgICAgIGlmICghaXRlbS5fZGVsZXRlZCkge1xuICAgICAgICAgICAgICB2YXIgcmVzID0gdm9pZCAwO1xuICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50b0pTT04gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgcmVzID0gaXRlbS50b0pTT04oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzID0gaXRlbS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSBpdGVtLl9jb250ZW50WzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1hcFtrZXldID0gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGtleXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgWU1hcCBUeXBlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdrZXlzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgcmV0dXJuIGVpdGhlciBJdGVyYXRvciBvciBTZXQhXG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLl9tYXBbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBzbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAga2V5ID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3N0ZXAyJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICBpZiAoIXZhbHVlLl9kZWxldGVkKSB7XG4gICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGlzIFlNYXAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtlbmNvZGFibGV9IGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVsZXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB0aGlzLl90cmFuc2FjdChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgIHZhciBjID0gX3RoaXMzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgICAgaWYgKHkgIT09IG51bGwgJiYgYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjLl9kZWxldGUoeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtlbmNvZGFibGV9IGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGlzIFlNYXAuXG4gICAgICAgKiBAcGFyYW0ge2VuY29kYWJsZSB8IFlUeXBlfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoaXNcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFlNYXAuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0JCQxKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNhY3QoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICB2YXIgb2xkID0gX3RoaXM0Ll9tYXAuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICAgICAgICBpZiAob2xkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAob2xkLmNvbnN0cnVjdG9yID09PSBJdGVtSlNPTiAmJiAhb2xkLl9kZWxldGVkICYmIG9sZC5fY29udGVudFswXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIG92ZXJ3cml0ZSB3aXRoIHNhbWUgdmFsdWVcbiAgICAgICAgICAgICAgLy8gYnJlYWsgaGVyZVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBvbGQuX2RlbGV0ZSh5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHYgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdiA9IG5ldyB2YWx1ZSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSXRlbSkge1xuICAgICAgICAgICAgdiA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gbmV3IEl0ZW1KU09OKCk7XG4gICAgICAgICAgICB2Ll9jb250ZW50ID0gW3ZhbHVlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdi5fcmlnaHQgPSBvbGQ7XG4gICAgICAgICAgdi5fcmlnaHRfb3JpZ2luID0gb2xkO1xuICAgICAgICAgIHYuX3BhcmVudCA9IF90aGlzNDtcbiAgICAgICAgICB2Ll9wYXJlbnRTdWIgPSBrZXk7XG4gICAgICAgICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHYuX2ludGVncmF0ZSh5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXM0Ll9tYXAuc2V0KGtleSwgdik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoaXMgWU1hcC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VuY29kYWJsZX0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldCQkMShrZXkpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdi5fZGVsZXRlZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHYuX2NvbnRlbnRbdi5fY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgb3Igbm90LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZW5jb2RhYmxlfSBrZXkgVGhlIGtleSB0byB0ZXN0LlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdi5fZGVsZXRlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aGlzIFlYbWwgVHlwZSB0byBhIHJlYWRhYmxlIGZvcm1hdC5cbiAgICAgICAqIFVzZWZ1bCBmb3IgbG9nZ2luZyBhcyBhbGwgSXRlbXMgYW5kIERlbGV0ZSBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2xvZ1N0cmluZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGxvZ0l0ZW1IZWxwZXIoJ1lNYXAnLCB0aGlzLCAnbWFwU2l6ZTonICsgdGhpcy5fbWFwLnNpemUpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gWU1hcDtcbiAgfShUeXBlKTtcblxuICB2YXIgSXRlbUVtYmVkID0gZnVuY3Rpb24gKF9JdGVtKSB7XG4gICAgaW5oZXJpdHMoSXRlbUVtYmVkLCBfSXRlbSk7XG5cbiAgICBmdW5jdGlvbiBJdGVtRW1iZWQoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJdGVtRW1iZWQpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJdGVtRW1iZWQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGVtRW1iZWQpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgX3RoaXMuZW1iZWQgPSBudWxsO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKEl0ZW1FbWJlZCwgW3tcbiAgICAgIGtleTogJ19jb3B5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29weSh1bmRlbGV0ZUNoaWxkcmVuLCBjb3B5UG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHN0cnVjdCA9IGdldChJdGVtRW1iZWQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRlbUVtYmVkLnByb3RvdHlwZSksICdfY29weScsIHRoaXMpLmNhbGwodGhpcywgdW5kZWxldGVDaGlsZHJlbiwgY29weVBvc2l0aW9uKTtcbiAgICAgICAgc3RydWN0LmVtYmVkID0gdGhpcy5lbWJlZDtcbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZnJvbUJpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zyb21CaW5hcnkoeSwgZGVjb2Rlcikge1xuICAgICAgICB2YXIgbWlzc2luZyA9IGdldChJdGVtRW1iZWQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRlbUVtYmVkLnByb3RvdHlwZSksICdfZnJvbUJpbmFyeScsIHRoaXMpLmNhbGwodGhpcywgeSwgZGVjb2Rlcik7XG4gICAgICAgIHRoaXMuZW1iZWQgPSBKU09OLnBhcnNlKGRlY29kZXIucmVhZFZhclN0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG1pc3Npbmc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3RvQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9CaW5hcnkoZW5jb2Rlcikge1xuICAgICAgICBnZXQoSXRlbUVtYmVkLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0ZW1FbWJlZC5wcm90b3R5cGUpLCAnX3RvQmluYXJ5JywgdGhpcykuY2FsbCh0aGlzLCBlbmNvZGVyKTtcbiAgICAgICAgZW5jb2Rlci53cml0ZVZhclN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLmVtYmVkKSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aGlzIFlYbWwgVHlwZSB0byBhIHJlYWRhYmxlIGZvcm1hdC5cbiAgICAgICAqIFVzZWZ1bCBmb3IgbG9nZ2luZyBhcyBhbGwgSXRlbXMgYW5kIERlbGV0ZSBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2xvZ1N0cmluZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGxvZ0l0ZW1IZWxwZXIoJ0l0ZW1FbWJlZCcsIHRoaXMsICdlbWJlZDonICsgSlNPTi5zdHJpbmdpZnkodGhpcy5lbWJlZCkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sZW5ndGgnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gSXRlbUVtYmVkO1xuICB9KEl0ZW0pO1xuXG4gIHZhciBJdGVtRm9ybWF0ID0gZnVuY3Rpb24gKF9JdGVtKSB7XG4gICAgaW5oZXJpdHMoSXRlbUZvcm1hdCwgX0l0ZW0pO1xuXG4gICAgZnVuY3Rpb24gSXRlbUZvcm1hdCgpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEl0ZW1Gb3JtYXQpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJdGVtRm9ybWF0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRlbUZvcm1hdCkpLmNhbGwodGhpcykpO1xuXG4gICAgICBfdGhpcy5rZXkgPSBudWxsO1xuICAgICAgX3RoaXMudmFsdWUgPSBudWxsO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKEl0ZW1Gb3JtYXQsIFt7XG4gICAgICBrZXk6ICdfY29weScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvcHkodW5kZWxldGVDaGlsZHJlbiwgY29weVBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBzdHJ1Y3QgPSBnZXQoSXRlbUZvcm1hdC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJdGVtRm9ybWF0LnByb3RvdHlwZSksICdfY29weScsIHRoaXMpLmNhbGwodGhpcywgdW5kZWxldGVDaGlsZHJlbiwgY29weVBvc2l0aW9uKTtcbiAgICAgICAgc3RydWN0LmtleSA9IHRoaXMua2V5O1xuICAgICAgICBzdHJ1Y3QudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19mcm9tQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZnJvbUJpbmFyeSh5LCBkZWNvZGVyKSB7XG4gICAgICAgIHZhciBtaXNzaW5nID0gZ2V0KEl0ZW1Gb3JtYXQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRlbUZvcm1hdC5wcm90b3R5cGUpLCAnX2Zyb21CaW5hcnknLCB0aGlzKS5jYWxsKHRoaXMsIHksIGRlY29kZXIpO1xuICAgICAgICB0aGlzLmtleSA9IGRlY29kZXIucmVhZFZhclN0cmluZygpO1xuICAgICAgICB0aGlzLnZhbHVlID0gSlNPTi5wYXJzZShkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ190b0JpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvQmluYXJ5KGVuY29kZXIpIHtcbiAgICAgICAgZ2V0KEl0ZW1Gb3JtYXQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSXRlbUZvcm1hdC5wcm90b3R5cGUpLCAnX3RvQmluYXJ5JywgdGhpcykuY2FsbCh0aGlzLCBlbmNvZGVyKTtcbiAgICAgICAgZW5jb2Rlci53cml0ZVZhclN0cmluZyh0aGlzLmtleSk7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJTdHJpbmcoSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSkpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gdGhpcyBZWG1sIFR5cGUgdG8gYSByZWFkYWJsZSBmb3JtYXQuXG4gICAgICAgKiBVc2VmdWwgZm9yIGxvZ2dpbmcgYXMgYWxsIEl0ZW1zIGFuZCBEZWxldGUgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sb2dTdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2dTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBsb2dJdGVtSGVscGVyKCdJdGVtRm9ybWF0JywgdGhpcywgJ2tleTonICsgSlNPTi5zdHJpbmdpZnkodGhpcy5rZXkpICsgJyx2YWx1ZTonICsgSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sZW5ndGgnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jb3VudGFibGUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEl0ZW1Gb3JtYXQ7XG4gIH0oSXRlbSk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpbnRlZ3JhdGVJdGVtKGl0ZW0sIHBhcmVudCwgeSwgbGVmdCwgcmlnaHQpIHtcbiAgICBpdGVtLl9vcmlnaW4gPSBsZWZ0O1xuICAgIGl0ZW0uX2xlZnQgPSBsZWZ0O1xuICAgIGl0ZW0uX3JpZ2h0ID0gcmlnaHQ7XG4gICAgaXRlbS5fcmlnaHRfb3JpZ2luID0gcmlnaHQ7XG4gICAgaXRlbS5fcGFyZW50ID0gcGFyZW50O1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBpdGVtLl9pbnRlZ3JhdGUoeSk7XG4gICAgfSBlbHNlIGlmIChsZWZ0ID09PSBudWxsKSB7XG4gICAgICBwYXJlbnQuX3N0YXJ0ID0gaXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdC5fcmlnaHQgPSBpdGVtO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZE5leHRQb3NpdGlvbihjdXJyZW50QXR0cmlidXRlcywgcGFyZW50LCBsZWZ0LCByaWdodCwgY291bnQpIHtcbiAgICB3aGlsZSAocmlnaHQgIT09IG51bGwgJiYgY291bnQgPiAwKSB7XG4gICAgICBzd2l0Y2ggKHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgSXRlbUVtYmVkOlxuICAgICAgICBjYXNlIEl0ZW1TdHJpbmc6XG4gICAgICAgICAgdmFyIHJpZ2h0TGVuID0gcmlnaHQuX2RlbGV0ZWQgPyAwIDogcmlnaHQuX2xlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGNvdW50IDw9IHJpZ2h0TGVuKSB7XG4gICAgICAgICAgICByaWdodCA9IHJpZ2h0Ll9zcGxpdEF0KHBhcmVudC5feSwgY291bnQpO1xuICAgICAgICAgICAgbGVmdCA9IHJpZ2h0Ll9sZWZ0O1xuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXNdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmlnaHQuX2RlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb3VudCAtPSByaWdodC5fbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJdGVtRm9ybWF0OlxuICAgICAgICAgIGlmIChyaWdodC5fZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgcmlnaHQgPSByaWdodC5fcmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBbbGVmdCwgcmlnaHQsIGN1cnJlbnRBdHRyaWJ1dGVzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZFBvc2l0aW9uKHBhcmVudCwgaW5kZXgpIHtcbiAgICB2YXIgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgdmFyIGxlZnQgPSBudWxsO1xuICAgIHZhciByaWdodCA9IHBhcmVudC5fc3RhcnQ7XG4gICAgcmV0dXJuIGZpbmROZXh0UG9zaXRpb24oY3VycmVudEF0dHJpYnV0ZXMsIHBhcmVudCwgbGVmdCwgcmlnaHQsIGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOZWdhdGUgYXBwbGllZCBmb3JtYXRzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnROZWdhdGVkQXR0cmlidXRlcyh5LCBwYXJlbnQsIGxlZnQsIHJpZ2h0LCBuZWdhdGVkQXR0cmlidXRlcykge1xuICAgIC8vIGNoZWNrIGlmIHdlIHJlYWxseSBuZWVkIHRvIHJlbW92ZSBhdHRyaWJ1dGVzXG4gICAgd2hpbGUgKHJpZ2h0ICE9PSBudWxsICYmIChyaWdodC5fZGVsZXRlZCA9PT0gdHJ1ZSB8fCByaWdodC5jb25zdHJ1Y3RvciA9PT0gSXRlbUZvcm1hdCAmJiBuZWdhdGVkQXR0cmlidXRlcy5nZXQocmlnaHQua2V5KSA9PT0gcmlnaHQudmFsdWUpKSB7XG4gICAgICBpZiAocmlnaHQuX2RlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLmRlbGV0ZShyaWdodC5rZXkpO1xuICAgICAgfVxuICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgcmlnaHQgPSByaWdodC5fcmlnaHQ7XG4gICAgfVxuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbmVnYXRlZEF0dHJpYnV0ZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IHNsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICB2YWwgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICB2YXIgZm9ybWF0ID0gbmV3IEl0ZW1Gb3JtYXQoKTtcbiAgICAgICAgZm9ybWF0LmtleSA9IGtleTtcbiAgICAgICAgZm9ybWF0LnZhbHVlID0gdmFsO1xuICAgICAgICBpbnRlZ3JhdGVJdGVtKGZvcm1hdCwgcGFyZW50LCB5LCBsZWZ0LCByaWdodCk7XG4gICAgICAgIGxlZnQgPSBmb3JtYXQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCBpdGVtKSB7XG4gICAgdmFyIHZhbHVlID0gaXRlbS52YWx1ZTtcbiAgICB2YXIga2V5ID0gaXRlbS5rZXk7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBjdXJyZW50QXR0cmlidXRlcy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzKGxlZnQsIHJpZ2h0LCBjdXJyZW50QXR0cmlidXRlcywgYXR0cmlidXRlcykge1xuICAgIC8vIGdvIHJpZ2h0IHdoaWxlIGF0dHJpYnV0ZXNbcmlnaHQua2V5XSA9PT0gcmlnaHQudmFsdWUgKG9yIHJpZ2h0IGlzIGRlbGV0ZWQpXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChyaWdodCA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAocmlnaHQuX2RlbGV0ZWQgPT09IHRydWUpIDsgZWxzZSBpZiAocmlnaHQuY29uc3RydWN0b3IgPT09IEl0ZW1Gb3JtYXQgJiYgKGF0dHJpYnV0ZXNbcmlnaHQua2V5XSB8fCBudWxsKSA9PT0gcmlnaHQudmFsdWUpIHtcbiAgICAgICAgLy8gZm91bmQgYSBmb3JtYXQsIHVwZGF0ZSBjdXJyZW50QXR0cmlidXRlcyBhbmQgY29udGludWVcbiAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VycmVudEF0dHJpYnV0ZXMsIHJpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgcmlnaHQgPSByaWdodC5fcmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnRBdHRyaWJ1dGVzKHksIHBhcmVudCwgbGVmdCwgcmlnaHQsIGF0dHJpYnV0ZXMsIGN1cnJlbnRBdHRyaWJ1dGVzKSB7XG4gICAgdmFyIG5lZ2F0ZWRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgIC8vIGluc2VydCBmb3JtYXQtc3RhcnQgaXRlbXNcbiAgICBmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgdmFyIHZhbCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIHZhciBjdXJyZW50VmFsID0gY3VycmVudEF0dHJpYnV0ZXMuZ2V0KGtleSk7XG4gICAgICBpZiAoY3VycmVudFZhbCAhPT0gdmFsKSB7XG4gICAgICAgIC8vIHNhdmUgbmVnYXRlZCBhdHRyaWJ1dGUgKHNldCBudWxsIGlmIGN1cnJlbnRWYWwgdW5kZWZpbmVkKVxuICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5zZXQoa2V5LCBjdXJyZW50VmFsIHx8IG51bGwpO1xuICAgICAgICB2YXIgZm9ybWF0ID0gbmV3IEl0ZW1Gb3JtYXQoKTtcbiAgICAgICAgZm9ybWF0LmtleSA9IGtleTtcbiAgICAgICAgZm9ybWF0LnZhbHVlID0gdmFsO1xuICAgICAgICBpbnRlZ3JhdGVJdGVtKGZvcm1hdCwgcGFyZW50LCB5LCBsZWZ0LCByaWdodCk7XG4gICAgICAgIGxlZnQgPSBmb3JtYXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbGVmdCwgcmlnaHQsIG5lZ2F0ZWRBdHRyaWJ1dGVzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0VGV4dCh5LCB0ZXh0LCBwYXJlbnQsIGxlZnQsIHJpZ2h0LCBjdXJyZW50QXR0cmlidXRlcywgYXR0cmlidXRlcykge1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGN1cnJlbnRBdHRyaWJ1dGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBzbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMSksXG4gICAgICAgICAgICBrZXkgPSBfc3RlcDIkdmFsdWVbMF07XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX21pbmltaXplQXR0cmlidXRlQ2hhID0gbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzKGxlZnQsIHJpZ2h0LCBjdXJyZW50QXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICB2YXIgX21pbmltaXplQXR0cmlidXRlQ2hhMiA9IHNsaWNlZFRvQXJyYXkoX21pbmltaXplQXR0cmlidXRlQ2hhLCAyKTtcblxuICAgIGxlZnQgPSBfbWluaW1pemVBdHRyaWJ1dGVDaGEyWzBdO1xuICAgIHJpZ2h0ID0gX21pbmltaXplQXR0cmlidXRlQ2hhMlsxXTtcblxuICAgIHZhciBuZWdhdGVkQXR0cmlidXRlcyA9IHZvaWQgMDtcblxuICAgIC8vIGluc2VydCBjb250ZW50XG4gICAgdmFyIF9pbnNlcnRBdHRyaWJ1dGVzID0gaW5zZXJ0QXR0cmlidXRlcyh5LCBwYXJlbnQsIGxlZnQsIHJpZ2h0LCBhdHRyaWJ1dGVzLCBjdXJyZW50QXR0cmlidXRlcyk7XG5cbiAgICB2YXIgX2luc2VydEF0dHJpYnV0ZXMyID0gc2xpY2VkVG9BcnJheShfaW5zZXJ0QXR0cmlidXRlcywgMyk7XG5cbiAgICBsZWZ0ID0gX2luc2VydEF0dHJpYnV0ZXMyWzBdO1xuICAgIHJpZ2h0ID0gX2luc2VydEF0dHJpYnV0ZXMyWzFdO1xuICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzID0gX2luc2VydEF0dHJpYnV0ZXMyWzJdO1xuICAgIHZhciBpdGVtID0gdm9pZCAwO1xuICAgIGlmICh0ZXh0LmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgIGl0ZW0gPSBuZXcgSXRlbVN0cmluZygpO1xuICAgICAgaXRlbS5fY29udGVudCA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0gPSBuZXcgSXRlbUVtYmVkKCk7XG4gICAgICBpdGVtLmVtYmVkID0gdGV4dDtcbiAgICB9XG4gICAgaW50ZWdyYXRlSXRlbShpdGVtLCBwYXJlbnQsIHksIGxlZnQsIHJpZ2h0KTtcbiAgICBsZWZ0ID0gaXRlbTtcbiAgICByZXR1cm4gaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXMoeSwgcGFyZW50LCBsZWZ0LCByaWdodCwgbmVnYXRlZEF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmb3JtYXRUZXh0KHksIGxlbmd0aCwgcGFyZW50LCBsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgX21pbmltaXplQXR0cmlidXRlQ2hhMyA9IG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgdmFyIF9taW5pbWl6ZUF0dHJpYnV0ZUNoYTQgPSBzbGljZWRUb0FycmF5KF9taW5pbWl6ZUF0dHJpYnV0ZUNoYTMsIDIpO1xuXG4gICAgbGVmdCA9IF9taW5pbWl6ZUF0dHJpYnV0ZUNoYTRbMF07XG4gICAgcmlnaHQgPSBfbWluaW1pemVBdHRyaWJ1dGVDaGE0WzFdO1xuXG4gICAgdmFyIG5lZ2F0ZWRBdHRyaWJ1dGVzID0gdm9pZCAwO1xuXG4gICAgLy8gaXRlcmF0ZSB1bnRpbCBmaXJzdCBub24tZm9ybWF0IG9yIG51bGwgaXMgZm91bmRcbiAgICAvLyBkZWxldGUgYWxsIGZvcm1hdHMgd2l0aCBhdHRyaWJ1dGVzW2Zvcm1hdC5rZXldICE9IG51bGxcbiAgICB2YXIgX2luc2VydEF0dHJpYnV0ZXMzID0gaW5zZXJ0QXR0cmlidXRlcyh5LCBwYXJlbnQsIGxlZnQsIHJpZ2h0LCBhdHRyaWJ1dGVzLCBjdXJyZW50QXR0cmlidXRlcyk7XG5cbiAgICB2YXIgX2luc2VydEF0dHJpYnV0ZXM0ID0gc2xpY2VkVG9BcnJheShfaW5zZXJ0QXR0cmlidXRlczMsIDMpO1xuXG4gICAgbGVmdCA9IF9pbnNlcnRBdHRyaWJ1dGVzNFswXTtcbiAgICByaWdodCA9IF9pbnNlcnRBdHRyaWJ1dGVzNFsxXTtcbiAgICBuZWdhdGVkQXR0cmlidXRlcyA9IF9pbnNlcnRBdHRyaWJ1dGVzNFsyXTtcbiAgICB3aGlsZSAobGVuZ3RoID4gMCAmJiByaWdodCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHJpZ2h0Ll9kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgICBzd2l0Y2ggKHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBJdGVtRm9ybWF0OlxuICAgICAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGVzW3JpZ2h0LmtleV07XG4gICAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyID09PSByaWdodC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLmRlbGV0ZShyaWdodC5rZXkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNldChyaWdodC5rZXksIHJpZ2h0LnZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByaWdodC5fZGVsZXRlKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VycmVudEF0dHJpYnV0ZXMsIHJpZ2h0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSXRlbUVtYmVkOlxuICAgICAgICAgIGNhc2UgSXRlbVN0cmluZzpcbiAgICAgICAgICAgIHJpZ2h0Ll9zcGxpdEF0KHksIGxlbmd0aCk7XG4gICAgICAgICAgICBsZW5ndGggLT0gcmlnaHQuX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICByaWdodCA9IHJpZ2h0Ll9yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzKHksIHBhcmVudCwgbGVmdCwgcmlnaHQsIG5lZ2F0ZWRBdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGVsZXRlVGV4dCh5LCBsZW5ndGgsIHBhcmVudCwgbGVmdCwgcmlnaHQsIGN1cnJlbnRBdHRyaWJ1dGVzKSB7XG4gICAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgcmlnaHQgIT09IG51bGwpIHtcbiAgICAgIGlmIChyaWdodC5fZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3dpdGNoIChyaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIGNhc2UgSXRlbUZvcm1hdDpcbiAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCByaWdodCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEl0ZW1FbWJlZDpcbiAgICAgICAgICBjYXNlIEl0ZW1TdHJpbmc6XG4gICAgICAgICAgICByaWdodC5fc3BsaXRBdCh5LCBsZW5ndGgpO1xuICAgICAgICAgICAgbGVuZ3RoIC09IHJpZ2h0Ll9sZW5ndGg7XG4gICAgICAgICAgICByaWdodC5fZGVsZXRlKHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gcmlnaHQuX3JpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgfVxuXG4gIC8vIFRPRE86IEluIHRoZSBxdWlsbCBkZWx0YSByZXByZXNlbnRhdGlvbiB3ZSBzaG91bGQgYWxzbyB1c2UgdGhlIGZvcm1hdCB7b3BzOlsuLl19XG4gIC8qKlxuICAgKiBUaGUgUXVpbGwgRGVsdGEgZm9ybWF0IHJlcHJlc2VudHMgY2hhbmdlcyBvbiBhIHRleHQgZG9jdW1lbnQgd2l0aFxuICAgKiBmb3JtYXR0aW5nIGluZm9ybWF0aW9uLiBGb3IgbW9yIGluZm9ybWF0aW9uIHZpc2l0IHtAbGluayBodHRwczovL3F1aWxsanMuY29tL2RvY3MvZGVsdGEvfFF1aWxsIERlbHRhfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIHtcbiAgICogICAgIG9wczogW1xuICAgKiAgICAgICB7IGluc2VydDogJ0dhbmRhbGYnLCBhdHRyaWJ1dGVzOiB7IGJvbGQ6IHRydWUgfSB9LFxuICAgKiAgICAgICB7IGluc2VydDogJyB0aGUgJyB9LFxuICAgKiAgICAgICB7IGluc2VydDogJ0dyZXknLCBhdHRyaWJ1dGVzOiB7IGNvbG9yOiAnI2NjY2NjYycgfSB9XG4gICAqICAgICBdXG4gICAqICAgfVxuICAgKlxuICAgKiBAdHlwZWRlZiB7QXJyYXk8T2JqZWN0Pn0gRGVsdGFcbiAgICovXG5cbiAgLyoqXG4gICAgKiBBdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIGFzc2lnbmVkIHRvIGEgc2VsZWN0aW9uIG9mIHRleHQuXG4gICAgKlxuICAgICogQGV4YW1wbGVcbiAgICAqICAge1xuICAgICogICAgIGJvbGQ6IHRydWUsXG4gICAgKiAgICAgZm9udC1zaXplOiAnNDBweCdcbiAgICAqICAgfVxuICAgICpcbiAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRBdHRyaWJ1dGVzXG4gICAgKi9cblxuICAvKipcbiAgICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgWVRleHRFdmVudCA9IGZ1bmN0aW9uIChfWUFycmF5RXZlbnQpIHtcbiAgICBpbmhlcml0cyhZVGV4dEV2ZW50LCBfWUFycmF5RXZlbnQpO1xuXG4gICAgZnVuY3Rpb24gWVRleHRFdmVudCh5dGV4dCwgcmVtb3RlLCB0cmFuc2FjdGlvbikge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWVRleHRFdmVudCk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFlUZXh0RXZlbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZVGV4dEV2ZW50KSkuY2FsbCh0aGlzLCB5dGV4dCwgcmVtb3RlLCB0cmFuc2FjdGlvbikpO1xuXG4gICAgICBfdGhpcy5fZGVsdGEgPSBudWxsO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBUT0RPOiBTaG91bGQgcHV0IHRoaXMgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbi4gdG9EZWx0YSBzaG91bGRuJ3QgYmUgaW5jbHVkZWRcbiAgICAvLyAgICAgICBpbiBldmVyeSBZanMgZGlzdHJpYnV0aW9uXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgY2hhbmdlcyBpbiB0aGUgZGVsdGEgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7RGVsdGF9IEEge0BsaW5rIGh0dHBzOi8vcXVpbGxqcy5jb20vZG9jcy9kZWx0YS98UXVpbGwgRGVsdGF9KSB0aGF0XG4gICAgICogICAgICAgICAgICAgICAgIHJlcHJlc2VudHMgdGhlIGNoYW5nZXMgb24gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhZVGV4dEV2ZW50LCBbe1xuICAgICAga2V5OiAnZGVsdGEnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLl9kZWx0YSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciB5ID0gdGhpcy50YXJnZXQuX3k7XG4gICAgICAgICAgeS50cmFuc2FjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzMi50YXJnZXQuX3N0YXJ0O1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gW107XG4gICAgICAgICAgICB2YXIgYWRkZWQgPSBfdGhpczIuYWRkZWRFbGVtZW50cztcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gX3RoaXMyLnJlbW92ZWRFbGVtZW50cztcbiAgICAgICAgICAgIF90aGlzMi5fZGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTsgLy8gY291bnRzIGFkZGVkIG9yIHJlbW92ZWQgbmV3IGF0dHJpYnV0ZXMgZm9yIHJldGFpblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpOyAvLyBzYXZlcyBhbGwgY3VycmVudCBhdHRyaWJ1dGVzIGZvciBpbnNlcnRcbiAgICAgICAgICAgIHZhciBvbGRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdmFyIGluc2VydCA9ICcnO1xuICAgICAgICAgICAgdmFyIHJldGFpbiA9IDA7XG4gICAgICAgICAgICB2YXIgZGVsZXRlTGVuID0gMDtcbiAgICAgICAgICAgIHZhciBhZGRPcCA9IGZ1bmN0aW9uIGFkZE9wKCkge1xuICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgICAgICBvcCA9IHsgZGVsZXRlOiBkZWxldGVMZW4gfTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGVuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICAgICAgICAgICAgICBvcCA9IHsgaW5zZXJ0OiBpbnNlcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGN1cnJlbnRBdHRyaWJ1dGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBzbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9zdGVwMyR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAncmV0YWluJzpcbiAgICAgICAgICAgICAgICAgICAgb3AgPSB7IHJldGFpbjogcmV0YWluIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldGFpbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWx0YS5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChpdGVtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBJdGVtRW1iZWQ6XG4gICAgICAgICAgICAgICAgICBpZiAoYWRkZWQuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdpbnNlcnQnO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBpdGVtLmVtYmVkO1xuICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZW1vdmVkLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGVuICs9IDE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uX2RlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSAncmV0YWluJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXRhaW4gKz0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgSXRlbVN0cmluZzpcbiAgICAgICAgICAgICAgICAgIGlmIChhZGRlZC5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdpbnNlcnQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydCArPSBpdGVtLl9jb250ZW50O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZW1vdmVkLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlTGVuICs9IGl0ZW0uX2xlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5fZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdyZXRhaW4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldGFpbiArPSBpdGVtLl9sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEl0ZW1Gb3JtYXQ6XG4gICAgICAgICAgICAgICAgICBpZiAoYWRkZWQuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJWYWwgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoaXRlbS5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJWYWwgIT09IGl0ZW0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IChvbGRBdHRyaWJ1dGVzLmdldChpdGVtLmtleSkgfHwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2l0ZW0ua2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1tpdGVtLmtleV0gPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtLl9kZWxldGUoeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVtb3ZlZC5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQXR0cmlidXRlcy5zZXQoaXRlbS5rZXksIGl0ZW0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2N1clZhbCA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldChpdGVtLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jdXJWYWwgIT09IGl0ZW0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1tpdGVtLmtleV0gPSBfY3VyVmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uX2RlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGl0ZW0ua2V5LCBpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGVzW2l0ZW0ua2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyICE9PSBpdGVtLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1tpdGVtLmtleV0gPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNbaXRlbS5rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl9kZWxldGUoeSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS5fZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLl9yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICB3aGlsZSAoX3RoaXMyLl9kZWx0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0T3AgPSBfdGhpczIuX2RlbHRhW190aGlzMi5fZGVsdGEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AucmV0YWluICE9PSB1bmRlZmluZWQgJiYgbGFzdE9wLmF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHJldGFpbiBkZWx0YSdzIGlmIHRoZXkgZG9uJ3QgYXNzaWduIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBfdGhpczIuX2RlbHRhLnBvcCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbHRhO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gWVRleHRFdmVudDtcbiAgfShZQXJyYXlFdmVudCk7XG5cbiAgLyoqXG4gICAqIFR5cGUgdGhhdCByZXByZXNlbnRzIHRleHQgd2l0aCBmb3JtYXR0aW5nIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBUaGlzIHR5cGUgcmVwbGFjZXMgeS1yaWNodGV4dCBhcyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGFibGUgdG8gaGFuZGxlXG4gICAqIGJsb2NrIGZvcm1hdHMgKGZvcm1hdCBpbmZvcm1hdGlvbiBvbiBhIHBhcmFncmFwaCksIGVtYmVkcyAoY29tcGxleCBlbGVtZW50c1xuICAgKiBsaWtlIHBpY3R1cmVzIGFuZCB2aWRlb3MpLCBhbmQgdGV4dCBmb3JtYXRzICgqKmJvbGQqKiwgKml0YWxpYyopLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBZVGV4dC5cbiAgICovXG5cblxuICB2YXIgWVRleHQgPSBmdW5jdGlvbiAoX1lBcnJheSkge1xuICAgIGluaGVyaXRzKFlUZXh0LCBfWUFycmF5KTtcblxuICAgIGZ1bmN0aW9uIFlUZXh0KHN0cmluZykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWVRleHQpO1xuXG4gICAgICB2YXIgX3RoaXMzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoWVRleHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZVGV4dCkpLmNhbGwodGhpcykpO1xuXG4gICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbmV3IEl0ZW1TdHJpbmcoKTtcbiAgICAgICAgc3RhcnQuX3BhcmVudCA9IF90aGlzMztcbiAgICAgICAgc3RhcnQuX2NvbnRlbnQgPSBzdHJpbmc7XG4gICAgICAgIF90aGlzMy5fc3RhcnQgPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdGhpczM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDcmVhdGVzIFlNYXAgRXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoWVRleHQsIFt7XG4gICAgICBrZXk6ICdfY2FsbE9ic2VydmVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzLCByZW1vdGUpIHtcbiAgICAgICAgdGhpcy5fY2FsbEV2ZW50SGFuZGxlcih0cmFuc2FjdGlvbiwgbmV3IFlUZXh0RXZlbnQodGhpcywgcmVtb3RlLCB0cmFuc2FjdGlvbikpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9zdGFydDtcbiAgICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIW4uX2RlbGV0ZWQgJiYgbi5fY291bnRhYmxlKSB7XG4gICAgICAgICAgICBzdHIgKz0gbi5fY29udGVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbiA9IG4uX3JpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQXBwbHkgYSB7QGxpbmsgRGVsdGF9IG9uIHRoaXMgc2hhcmVkIFlUZXh0IHR5cGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtEZWx0YX0gZGVsdGEgVGhlIGNoYW5nZXMgdG8gYXBwbHkgb24gdGhpcyBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYXBwbHlEZWx0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlEZWx0YShkZWx0YSkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB0aGlzLl90cmFuc2FjdChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgIHZhciBsZWZ0ID0gbnVsbDtcbiAgICAgICAgICB2YXIgcmlnaHQgPSBfdGhpczQuX3N0YXJ0O1xuICAgICAgICAgIHZhciBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3AgPSBkZWx0YVtpXTtcbiAgICAgICAgICAgIGlmIChvcC5pbnNlcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgX2luc2VydFRleHQgPSBpbnNlcnRUZXh0KHksIG9wLmluc2VydCwgX3RoaXM0LCBsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXMsIG9wLmF0dHJpYnV0ZXMgfHwge30pO1xuXG4gICAgICAgICAgICAgIHZhciBfaW5zZXJ0VGV4dDIgPSBzbGljZWRUb0FycmF5KF9pbnNlcnRUZXh0LCAyKTtcblxuICAgICAgICAgICAgICBsZWZ0ID0gX2luc2VydFRleHQyWzBdO1xuICAgICAgICAgICAgICByaWdodCA9IF9pbnNlcnRUZXh0MlsxXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3AucmV0YWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9mb3JtYXRUZXh0ID0gZm9ybWF0VGV4dCh5LCBvcC5yZXRhaW4sIF90aGlzNCwgbGVmdCwgcmlnaHQsIGN1cnJlbnRBdHRyaWJ1dGVzLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KTtcblxuICAgICAgICAgICAgICB2YXIgX2Zvcm1hdFRleHQyID0gc2xpY2VkVG9BcnJheShfZm9ybWF0VGV4dCwgMik7XG5cbiAgICAgICAgICAgICAgbGVmdCA9IF9mb3JtYXRUZXh0MlswXTtcbiAgICAgICAgICAgICAgcmlnaHQgPSBfZm9ybWF0VGV4dDJbMV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wLmRlbGV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBfZGVsZXRlVGV4dCA9IGRlbGV0ZVRleHQoeSwgb3AuZGVsZXRlLCBfdGhpczQsIGxlZnQsIHJpZ2h0LCBjdXJyZW50QXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgdmFyIF9kZWxldGVUZXh0MiA9IHNsaWNlZFRvQXJyYXkoX2RlbGV0ZVRleHQsIDIpO1xuXG4gICAgICAgICAgICAgIGxlZnQgPSBfZGVsZXRlVGV4dDJbMF07XG4gICAgICAgICAgICAgIHJpZ2h0ID0gX2RlbGV0ZVRleHQyWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgRGVsdGEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0RlbHRhfSBUaGUgRGVsdGEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9EZWx0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9EZWx0YSgpIHtcbiAgICAgICAgdmFyIG9wcyA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgdmFyIG4gPSB0aGlzLl9zdGFydDtcbiAgICAgICAgZnVuY3Rpb24gcGFja1N0cigpIHtcbiAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHBhY2sgc3RyIHdpdGggYXR0cmlidXRlcyB0byBvcHNcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICB2YXIgYWRkQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBjdXJyZW50QXR0cmlidXRlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBzbGljZWRUb0FycmF5KF9zdGVwNC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IF9zdGVwNCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfc3RlcDQkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgICBhZGRBdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7XG4gICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3AgPSB7IGluc2VydDogc3RyIH07XG4gICAgICAgICAgICBpZiAoYWRkQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgIHN0ciA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghbi5fZGVsZXRlZCkge1xuICAgICAgICAgICAgc3dpdGNoIChuLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgSXRlbVN0cmluZzpcbiAgICAgICAgICAgICAgICBzdHIgKz0gbi5fY29udGVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBJdGVtRm9ybWF0OlxuICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG4gPSBuLl9yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBwYWNrU3RyKCk7XG4gICAgICAgIHJldHVybiBvcHM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0IHRleHQgYXQgYSBnaXZlbiBpbmRleC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBpbnNlcnRpbmcuXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBpbnNlcnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgT3B0aW9uYWxseSBkZWZpbmUgc29tZSBmb3JtYXR0aW5nXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZSBpbnNlcnRlZFxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaW5zZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnQoaW5kZXgsIHRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0KGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgdmFyIF9maW5kUG9zaXRpb24gPSBmaW5kUG9zaXRpb24oX3RoaXM1LCBpbmRleCksXG4gICAgICAgICAgICAgIF9maW5kUG9zaXRpb24yID0gc2xpY2VkVG9BcnJheShfZmluZFBvc2l0aW9uLCAzKSxcbiAgICAgICAgICAgICAgbGVmdCA9IF9maW5kUG9zaXRpb24yWzBdLFxuICAgICAgICAgICAgICByaWdodCA9IF9maW5kUG9zaXRpb24yWzFdLFxuICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcyA9IF9maW5kUG9zaXRpb24yWzJdO1xuXG4gICAgICAgICAgaW5zZXJ0VGV4dCh5LCB0ZXh0LCBfdGhpczUsIGxlZnQsIHJpZ2h0LCBjdXJyZW50QXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluc2VydHMgYW4gZW1iZWQgYXQgYSBpbmRleC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgdGhlIGVtYmVkIGF0LlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVtYmVkIFRoZSBPYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBlbWJlZC5cbiAgICAgICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWJlZFxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaW5zZXJ0RW1iZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEVtYmVkKGluZGV4LCBlbWJlZCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgICAgaWYgKGVtYmVkLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtYmVkIG11c3QgYmUgYW4gT2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhbnNhY3QoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICB2YXIgX2ZpbmRQb3NpdGlvbjMgPSBmaW5kUG9zaXRpb24oX3RoaXM2LCBpbmRleCksXG4gICAgICAgICAgICAgIF9maW5kUG9zaXRpb240ID0gc2xpY2VkVG9BcnJheShfZmluZFBvc2l0aW9uMywgMyksXG4gICAgICAgICAgICAgIGxlZnQgPSBfZmluZFBvc2l0aW9uNFswXSxcbiAgICAgICAgICAgICAgcmlnaHQgPSBfZmluZFBvc2l0aW9uNFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMgPSBfZmluZFBvc2l0aW9uNFsyXTtcblxuICAgICAgICAgIGluc2VydFRleHQoeSwgZW1iZWQsIF90aGlzNiwgbGVmdCwgcmlnaHQsIGN1cnJlbnRBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlcyB0ZXh0IHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZy5cbiAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZWxldGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0KGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgdmFyIF9maW5kUG9zaXRpb241ID0gZmluZFBvc2l0aW9uKF90aGlzNywgaW5kZXgpLFxuICAgICAgICAgICAgICBfZmluZFBvc2l0aW9uNiA9IHNsaWNlZFRvQXJyYXkoX2ZpbmRQb3NpdGlvbjUsIDMpLFxuICAgICAgICAgICAgICBsZWZ0ID0gX2ZpbmRQb3NpdGlvbjZbMF0sXG4gICAgICAgICAgICAgIHJpZ2h0ID0gX2ZpbmRQb3NpdGlvbjZbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzID0gX2ZpbmRQb3NpdGlvbjZbMl07XG5cbiAgICAgICAgICBkZWxldGVUZXh0KHksIGxlbmd0aCwgX3RoaXM3LCBsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBc3NpZ25zIHByb3BlcnRpZXMgdG8gYSByYW5nZSBvZiB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggVGhlIHBvc2l0aW9uIHdoZXJlIHRvIHN0YXJ0IGZvcm1hdHRpbmcuXG4gICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGxlbmd0aCBUaGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8uXG4gICAgICAgKiBAcGFyYW0ge1RleHRBdHRyaWJ1dGVzfSBhdHRyaWJ1dGVzIEF0dHJpYnV0ZSBpbmZvcm1hdGlvbiB0byBhcHBseSBvbiB0aGVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KGluZGV4LCBsZW5ndGgsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNhY3QoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICB2YXIgX2ZpbmRQb3NpdGlvbjcgPSBmaW5kUG9zaXRpb24oX3RoaXM4LCBpbmRleCksXG4gICAgICAgICAgICAgIF9maW5kUG9zaXRpb244ID0gc2xpY2VkVG9BcnJheShfZmluZFBvc2l0aW9uNywgMyksXG4gICAgICAgICAgICAgIGxlZnQgPSBfZmluZFBvc2l0aW9uOFswXSxcbiAgICAgICAgICAgICAgcmlnaHQgPSBfZmluZFBvc2l0aW9uOFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMgPSBfZmluZFBvc2l0aW9uOFsyXTtcblxuICAgICAgICAgIGlmIChyaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3JtYXRUZXh0KHksIGxlbmd0aCwgX3RoaXM4LCBsZWZ0LCByaWdodCwgY3VycmVudEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IERlLWR1cGxpY2F0ZSBjb2RlLiBUaGUgZm9sbG93aW5nIGNvZGUgaXMgaW4gZXZlcnkgdHlwZS5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIHRoaXMgWVRleHQgdG8gYSByZWFkYWJsZSBmb3JtYXQuXG4gICAgICAgKiBVc2VmdWwgZm9yIGxvZ2dpbmcgYXMgYWxsIEl0ZW1zIGltcGxlbWVudCB0aGlzIG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbG9nU3RyaW5nJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9nU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gbG9nSXRlbUhlbHBlcignWVRleHQnLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFlUZXh0O1xuICB9KFlBcnJheSk7XG5cbiAgLyoqXG4gICAqIFlvdSBjYW4gbWFuYWdlIGJpbmRpbmcgdG8gYSBjdXN0b20gdHlwZSB3aXRoIFlYbWxIb29rLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIHZhciBZWG1sSG9vayA9IGZ1bmN0aW9uIChfWU1hcCkge1xuICAgIGluaGVyaXRzKFlYbWxIb29rLCBfWU1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaG9va05hbWUgbm9kZU5hbWUgb2YgdGhlIERvbSBOb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFlYbWxIb29rKGhvb2tOYW1lKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBZWG1sSG9vayk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFlYbWxIb29rLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbEhvb2spKS5jYWxsKHRoaXMpKTtcblxuICAgICAgX3RoaXMuaG9va05hbWUgPSBudWxsO1xuICAgICAgaWYgKGhvb2tOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3RoaXMuaG9va05hbWUgPSBob29rTmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEl0ZW0gd2l0aCB0aGUgc2FtZSBlZmZlY3QgYXMgdGhpcyBJdGVtICh3aXRob3V0IHBvc2l0aW9uIGVmZmVjdClcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKFlYbWxIb29rLCBbe1xuICAgICAga2V5OiAnX2NvcHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb3B5KCkge1xuICAgICAgICB2YXIgc3RydWN0ID0gZ2V0KFlYbWxIb29rLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxIb29rLnByb3RvdHlwZSksICdfY29weScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgIHN0cnVjdC5ob29rTmFtZSA9IHRoaXMuaG9va05hbWU7XG4gICAgICAgIHJldHVybiBzdHJ1Y3Q7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0PGtleTpob29rRGVmaW5pdGlvbj59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICAgICAqIEBwYXJhbSB7RG9tQmluZGluZ30gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uIHRvIHRoZSBjcmVhdGVkIERPTSB0eXBlXG4gICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9Eb20nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRG9tKCkge1xuXG4gICAgICAgIHZhciBob29rcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgIHZhciBiaW5kaW5nID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIHZhciBob29rID0gaG9va3NbdGhpcy5ob29rTmFtZV07XG4gICAgICAgIHZhciBkb20gPSB2b2lkIDA7XG4gICAgICAgIGlmIChob29rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkb20gPSBob29rLmNyZWF0ZURvbSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuaG9va05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEteWpzLWhvb2snLCB0aGlzLmhvb2tOYW1lKTtcbiAgICAgICAgY3JlYXRlQXNzb2NpYXRpb24oYmluZGluZywgZG9tLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWFkIHRoZSBuZXh0IEl0ZW0gaW4gYSBEZWNvZGVyIGFuZCBmaWxsIHRoaXMgSXRlbSB3aXRoIHRoZSByZWFkIGRhdGEuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBkYXRhIGlzIHJlY2VpdmVkIGZyb20gYSByZW1vdGUgcGVlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZSB0aGF0IHRoaXMgSXRlbSBiZWxvbmdzIHRvLlxuICAgICAgICogQHBhcmFtIHtCaW5hcnlEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIG9iamVjdCB0byByZWFkIGRhdGEgZnJvbS5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZnJvbUJpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zyb21CaW5hcnkoeSwgZGVjb2Rlcikge1xuICAgICAgICB2YXIgbWlzc2luZyA9IGdldChZWG1sSG9vay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZWG1sSG9vay5wcm90b3R5cGUpLCAnX2Zyb21CaW5hcnknLCB0aGlzKS5jYWxsKHRoaXMsIHksIGRlY29kZXIpO1xuICAgICAgICB0aGlzLmhvb2tOYW1lID0gZGVjb2Rlci5yZWFkVmFyU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBtaXNzaW5nO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgICAgICogQmluYXJ5RW5jb2Rlci5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtCaW5hcnlFbmNvZGVyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3RvQmluYXJ5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9CaW5hcnkoZW5jb2Rlcikge1xuICAgICAgICBnZXQoWVhtbEhvb2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbEhvb2sucHJvdG90eXBlKSwgJ190b0JpbmFyeScsIHRoaXMpLmNhbGwodGhpcywgZW5jb2Rlcik7XG4gICAgICAgIGVuY29kZXIud3JpdGVWYXJTdHJpbmcodGhpcy5ob29rTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgICAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICAgICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7WX0geSBUaGUgWWpzIGluc3RhbmNlXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2ludGVncmF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ludGVncmF0ZSh5KSB7XG4gICAgICAgIGlmICh0aGlzLmhvb2tOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdob29rTmFtZSBtdXN0IGJlIGRlZmluZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0KFlYbWxIb29rLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxIb29rLnByb3RvdHlwZSksICdfaW50ZWdyYXRlJywgdGhpcykuY2FsbCh0aGlzLCB5KTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFlYbWxIb29rO1xuICB9KFlNYXApO1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIGVsZW1lbnRzIHRvIHdoaWNoIGEgc2V0IG9mIENTUyBxdWVyaWVzIGFwcGx5LlxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19TZWxlY3RvcnN8Q1NTX1NlbGVjdG9yc31cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBxdWVyeSA9ICcuY2xhc3NTZWxlY3RvcidcbiAgICogICBxdWVyeSA9ICdub2RlU2VsZWN0b3InXG4gICAqICAgcXVlcnkgPSAnI2lkU2VsZWN0b3InXG4gICAqXG4gICAqIEB0eXBlZGVmIHtzdHJpbmd9IENTU19TZWxlY3RvclxuICAgKi9cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHN1YnNldCBvZiB0aGUgbm9kZXMgb2YgYSBZWG1sRWxlbWVudCAvIFlYbWxGcmFnbWVudCBhbmQgYVxuICAgKiBwb3NpdGlvbiB3aXRoaW4gdGhlbS5cbiAgICpcbiAgICogQ2FuIGJlIGNyZWF0ZWQgd2l0aCB7QGxpbmsgWVhtbEZyYWdtZW50I2NyZWF0ZVRyZWVXYWxrZXJ9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG5cbiAgdmFyIFlYbWxUcmVlV2Fsa2VyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFlYbWxUcmVlV2Fsa2VyKHJvb3QsIGYpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFlYbWxUcmVlV2Fsa2VyKTtcblxuICAgICAgdGhpcy5fZmlsdGVyID0gZiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3Jvb3QgPSByb290O1xuICAgICAgdGhpcy5fY3VycmVudE5vZGUgPSByb290O1xuICAgICAgdGhpcy5fZmlyc3RDYWxsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhZWG1sVHJlZVdhbGtlciwgW3tcbiAgICAgIGtleTogU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBuZXh0IG5vZGUuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7WVhtbEVsZW1lbnR9IFRoZSBuZXh0IG5vZGUuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICduZXh0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuX2N1cnJlbnROb2RlO1xuICAgICAgICBpZiAodGhpcy5fZmlyc3RDYWxsKSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3RDYWxsID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFuLl9kZWxldGVkICYmIHRoaXMuX2ZpbHRlcihuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG4sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoIW4uX2RlbGV0ZWQgJiYgKG4uY29uc3RydWN0b3IgPT09IFlYbWxGcmFnbWVudC5fWVhtbEVsZW1lbnQgfHwgbi5jb25zdHJ1Y3RvciA9PT0gWVhtbEZyYWdtZW50KSAmJiBuLl9zdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gd2FsayBkb3duIGluIHRoZSB0cmVlXG4gICAgICAgICAgICBuID0gbi5fc3RhcnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhbGsgcmlnaHQgb3IgdXAgaW4gdGhlIHRyZWVcbiAgICAgICAgICAgIHdoaWxlIChuICE9PSB0aGlzLl9yb290KSB7XG4gICAgICAgICAgICAgIGlmIChuLl9yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG4gPSBuLl9yaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuID0gbi5fcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG4gPT09IHRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgICAgbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuID09PSB0aGlzLl9yb290KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG4gIT09IG51bGwgJiYgKG4uX2RlbGV0ZWQgfHwgIXRoaXMuX2ZpbHRlcihuKSkpO1xuICAgICAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IG47XG4gICAgICAgIGlmIChuID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBuLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBZWG1sVHJlZVdhbGtlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBbiBFdmVudCB0aGF0IGRlc2NyaWJlcyBjaGFuZ2VzIG9uIGEgWVhtbCBFbGVtZW50IG9yIFl4bWwgRnJhZ21lbnRcbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuICB2YXIgWVhtbEV2ZW50ID0gZnVuY3Rpb24gKF9ZRXZlbnQpIHtcbiAgICBpbmhlcml0cyhZWG1sRXZlbnQsIF9ZRXZlbnQpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtZVHlwZX0gdGFyZ2V0IFRoZSB0YXJnZXQgb24gd2hpY2ggdGhlIGV2ZW50IGlzIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtTZXR9IHN1YnMgVGhlIHNldCBvZiBjaGFuZ2VkIGF0dHJpYnV0ZXMuIGBudWxsYCBpcyBpbmNsdWRlZCBpZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICBjaGlsZCBsaXN0IGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdGUgV2hldGhlciB0aGlzIGNoYW5nZSB3YXMgY3JlYXRlZCBieSBhIHJlbW90ZSBwZWVyLlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoIHdpY2ggdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlIHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFlYbWxFdmVudCh0YXJnZXQsIHN1YnMsIHJlbW90ZSwgdHJhbnNhY3Rpb24pIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFlYbWxFdmVudCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRyYW5zYWN0aW9uIGluc3RhbmNlIGZvciB0aGUgY29tcHV0ZWQgY2hhbmdlLlxuICAgICAgICogQHR5cGUge1RyYW5zYWN0aW9ufVxuICAgICAgICovXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChZWG1sRXZlbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZWG1sRXZlbnQpKS5jYWxsKHRoaXMsIHRhcmdldCkpO1xuXG4gICAgICBfdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBfdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBvZiBhbGwgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAgICogQHR5cGUge1NldH1cbiAgICAgICAqL1xuICAgICAgX3RoaXMuYXR0cmlidXRlc0NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdGhpcyBjaGFuZ2Ugd2FzIGNyZWF0ZWQgYnkgYSByZW1vdGUgcGVlci5cbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBfdGhpcy5yZW1vdGUgPSByZW1vdGU7XG4gICAgICBzdWJzLmZvckVhY2goZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuYXR0cmlidXRlc0NoYW5nZWQuYWRkKHN1Yik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBZWG1sRXZlbnQ7XG4gIH0oWUV2ZW50KTtcblxuICAvKipcbiAgICogRG9tIGZpbHRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQGNhbGxiYWNrIGRvbUZpbHRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7TWFwfSBhdHRyaWJ1dGVzIFRoZSBtYXAgb2YgYXR0cmlidXRlcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0byBpbmNsdWRlIHRoZSBEb20gbm9kZSBpbiB0aGUgWVhtbEVsZW1lbnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIGVsZW1lbnRzIHRvIHdoaWNoIGEgc2V0IG9mIENTUyBxdWVyaWVzIGFwcGx5LlxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19TZWxlY3RvcnN8Q1NTX1NlbGVjdG9yc31cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBxdWVyeSA9ICcuY2xhc3NTZWxlY3RvcidcbiAgICogICBxdWVyeSA9ICdub2RlU2VsZWN0b3InXG4gICAqICAgcXVlcnkgPSAnI2lkU2VsZWN0b3InXG4gICAqXG4gICAqIEB0eXBlZGVmIHtzdHJpbmd9IENTU19TZWxlY3RvclxuICAgKi9cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIGxpc3Qgb2Yge0BsaW5rIFlYbWxFbGVtZW50fS5hbmQge0BsaW5rIFlYbWxUZXh0fSB0eXBlcy5cbiAgICogQSBZeG1sRnJhZ21lbnQgaXMgc2ltaWxhciB0byBhIHtAbGluayBZWG1sRWxlbWVudH0sIGJ1dCBpdCBkb2VzIG5vdCBoYXZlIGFcbiAgICogbm9kZU5hbWUgYW5kIGl0IGRvZXMgbm90IGhhdmUgYXR0cmlidXRlcy4gVGhvdWdoIGl0IGNhbiBiZSBib3VuZCB0byBhIERPTVxuICAgKiBlbGVtZW50IC0gaW4gdGhpcyBjYXNlIHRoZSBhdHRyaWJ1dGVzIGFuZCB0aGUgbm9kZU5hbWUgYXJlIG5vdCBzaGFyZWQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG5cbiAgdmFyIFlYbWxGcmFnbWVudCA9IGZ1bmN0aW9uIChfWUFycmF5KSB7XG4gICAgaW5oZXJpdHMoWVhtbEZyYWdtZW50LCBfWUFycmF5KTtcblxuICAgIGZ1bmN0aW9uIFlYbWxGcmFnbWVudCgpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFlYbWxGcmFnbWVudCk7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoWVhtbEZyYWdtZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbEZyYWdtZW50KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoWVhtbEZyYWdtZW50LCBbe1xuICAgICAga2V5OiAnY3JlYXRlVHJlZVdhbGtlcicsXG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGEgc3VidHJlZSBvZiBjaGlsZE5vZGVzLlxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBjb25zdCB3YWxrZXIgPSBlbGVtLmNyZWF0ZVRyZWVXYWxrZXIoZG9tID0+IGRvbS5ub2RlTmFtZSA9PT0gJ2RpdicpXG4gICAgICAgKiBmb3IgKGxldCBub2RlIGluIHdhbGtlcikge1xuICAgICAgICogICAvLyBgbm9kZWAgaXMgYSBkaXYgbm9kZVxuICAgICAgICogICBub3Aobm9kZSlcbiAgICAgICAqIH1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXIgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gZWFjaCBjaGlsZCBlbGVtZW50IGFuZFxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2hpbGRcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgc3VidHJlZS5cbiAgICAgICAqIEByZXR1cm4ge1RyZWVXYWxrZXJ9IEEgc3VidHJlZSBhbmQgYSBwb3NpdGlvbiB3aXRoaW4gaXQuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVHJlZVdhbGtlcihmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBmaWx0ZXIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGZpcnN0IFlYbWxFbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgcXVlcnkuXG4gICAgICAgKiBTaW1pbGFyIHRvIERPTSdzIHtAbGluayBxdWVyeVNlbGVjdG9yfS5cbiAgICAgICAqXG4gICAgICAgKiBRdWVyeSBzdXBwb3J0OlxuICAgICAgICogICAtIHRhZ25hbWVcbiAgICAgICAqIFRPRE86XG4gICAgICAgKiAgIC0gaWRcbiAgICAgICAqICAgLSBhdHRyaWJ1dGVcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0NTU19TZWxlY3Rvcn0gcXVlcnkgVGhlIHF1ZXJ5IG9uIHRoZSBjaGlsZHJlbi5cbiAgICAgICAqIEByZXR1cm4gez9ZWG1sRWxlbWVudH0gVGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeSBvciBudWxsLlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncXVlcnlTZWxlY3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcXVlcnlTZWxlY3RvcihxdWVyeSkge1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lID09PSBxdWVyeTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFsbCBZWG1sRWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcXVlcnkuXG4gICAgICAgKiBTaW1pbGFyIHRvIERvbSdzIHtAbGluayBxdWVyeVNlbGVjdG9yQWxsfS5cbiAgICAgICAqXG4gICAgICAgKiBUT0RPOiBEb2VzIG5vdCB5ZXQgc3VwcG9ydCBhbGwgcXVlcmllcy4gQ3VycmVudGx5IG9ubHkgcXVlcnkgYnkgdGFnTmFtZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0NTU19TZWxlY3Rvcn0gcXVlcnkgVGhlIHF1ZXJ5IG9uIHRoZSBjaGlsZHJlblxuICAgICAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnQ+fSBUaGUgZWxlbWVudHMgdGhhdCBtYXRjaCB0aGlzIHF1ZXJ5LlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncXVlcnlTZWxlY3RvckFsbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChxdWVyeSkge1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lID09PSBxdWVyeTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgWUFycmF5IEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NhbGxPYnNlcnZlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgcGFyZW50U3VicywgcmVtb3RlKSB7XG4gICAgICAgIHRoaXMuX2NhbGxFdmVudEhhbmRsZXIodHJhbnNhY3Rpb24sIG5ldyBZWG1sRXZlbnQodGhpcywgcGFyZW50U3VicywgcmVtb3RlLCB0cmFuc2FjdGlvbikpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBZWG1sRnJhZ21lbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCBjaGlsZHJlbi5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKHhtbCkge1xuICAgICAgICAgIHJldHVybiB4bWwudG9TdHJpbmcoKTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIFVuYmluZCBmcm9tIERvbSBhbmQgbWFyayB0aGlzIEl0ZW0gYXMgZGVsZXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGVEZWxldGUgV2hldGhlciB0byBwcm9wYWdhdGUgYSBtZXNzYWdlIHRoYXQgdGhpc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHlwZSB3YXMgZGVsZXRlZC5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2djQ2hpbGRyZW49eS5faGFzVW5kb01hbmFnZXI9PT1mYWxzZV0gV2hldGhlciB0byBnYXJiYWdlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyB0eXBlLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZWxldGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoeSwgY3JlYXRlRGVsZXRlLCBnY0NoaWxkcmVuKSB7XG4gICAgICAgIGdldChZWG1sRnJhZ21lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbEZyYWdtZW50LnByb3RvdHlwZSksICdfZGVsZXRlJywgdGhpcykuY2FsbCh0aGlzLCB5LCBjcmVhdGVEZWxldGUsIGdjQ2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAgICAgKiBAcGFyYW0ge09iamVjdDxrZXk6aG9va0RlZmluaXRpb24+fSBbaG9va3M9e31dIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAgICAgKiBAcGFyYW0ge0RvbUJpbmRpbmd9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZVxuICAgICAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3RvRG9tJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0RvbSgpIHtcbiAgICAgICAgdmFyIF9kb2N1bWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZG9jdW1lbnQ7XG5cbiAgICAgICAgdmFyIGhvb2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgdmFyIGZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgY3JlYXRlQXNzb2NpYXRpb24oYmluZGluZywgZnJhZ21lbnQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHhtbFR5cGUpIHtcbiAgICAgICAgICBmcmFnbWVudC5pbnNlcnRCZWZvcmUoeG1sVHlwZS50b0RvbShfZG9jdW1lbnQsIGhvb2tzLCBiaW5kaW5nKSwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0aGlzIFlYbWwgVHlwZSB0byBhIHJlYWRhYmxlIGZvcm1hdC5cbiAgICAgICAqIFVzZWZ1bCBmb3IgbG9nZ2luZyBhcyBhbGwgSXRlbXMgYW5kIERlbGV0ZSBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2xvZ1N0cmluZycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvZ1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGxvZ0l0ZW1IZWxwZXIoJ1lYbWwnLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFlYbWxGcmFnbWVudDtcbiAgfShZQXJyYXkpO1xuXG4gIC8qKlxuICAgKiBBbiBZWG1sRWxlbWVudCBpbWl0YXRlcyB0aGUgYmVoYXZpb3Igb2YgYVxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9LlxuICAgKlxuICAgKiAqIEFuIFlYbWxFbGVtZW50IGhhcyBhdHRyaWJ1dGVzIChrZXkgdmFsdWUgcGFpcnMpXG4gICAqICogQW4gWVhtbEVsZW1lbnQgaGFzIGNoaWxkRWxlbWVudHMgdGhhdCBtdXN0IGluaGVyaXQgZnJvbSBZWG1sRWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWUgTm9kZSBuYW1lXG4gICAqL1xuXG4gIHZhciBZWG1sRWxlbWVudCA9IGZ1bmN0aW9uIChfWVhtbEZyYWdtZW50KSB7XG4gICAgaW5oZXJpdHMoWVhtbEVsZW1lbnQsIF9ZWG1sRnJhZ21lbnQpO1xuXG4gICAgZnVuY3Rpb24gWVhtbEVsZW1lbnQoKSB7XG4gICAgICB2YXIgbm9kZU5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdVTkRFRklORUQnO1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgWVhtbEVsZW1lbnQpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChZWG1sRWxlbWVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxFbGVtZW50KSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgIF90aGlzLm5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgICAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhZWG1sRWxlbWVudCwgW3tcbiAgICAgIGtleTogJ19jb3B5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29weSgpIHtcbiAgICAgICAgdmFyIHN0cnVjdCA9IGdldChZWG1sRWxlbWVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZWG1sRWxlbWVudC5wcm90b3R5cGUpLCAnX2NvcHknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICBzdHJ1Y3Qubm9kZU5hbWUgPSB0aGlzLm5vZGVOYW1lO1xuICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBSZWFkIHRoZSBuZXh0IEl0ZW0gaW4gYSBEZWNvZGVyIGFuZCBmaWxsIHRoaXMgSXRlbSB3aXRoIHRoZSByZWFkIGRhdGEuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBkYXRhIGlzIHJlY2VpdmVkIGZyb20gYSByZW1vdGUgcGVlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZSB0aGF0IHRoaXMgSXRlbSBiZWxvbmdzIHRvLlxuICAgICAgICogQHBhcmFtIHtCaW5hcnlEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIG9iamVjdCB0byByZWFkIGRhdGEgZnJvbS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2Zyb21CaW5hcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mcm9tQmluYXJ5KHksIGRlY29kZXIpIHtcbiAgICAgICAgdmFyIG1pc3NpbmcgPSBnZXQoWVhtbEVsZW1lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbEVsZW1lbnQucHJvdG90eXBlKSwgJ19mcm9tQmluYXJ5JywgdGhpcykuY2FsbCh0aGlzLCB5LCBkZWNvZGVyKTtcbiAgICAgICAgdGhpcy5ub2RlTmFtZSA9IGRlY29kZXIucmVhZFZhclN0cmluZygpO1xuICAgICAgICByZXR1cm4gbWlzc2luZztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICAgICAqIEJpbmFyeUVuY29kZXIuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7QmluYXJ5RW5jb2Rlcn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190b0JpbmFyeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvQmluYXJ5KGVuY29kZXIpIHtcbiAgICAgICAgZ2V0KFlYbWxFbGVtZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFlYbWxFbGVtZW50LnByb3RvdHlwZSksICdfdG9CaW5hcnknLCB0aGlzKS5jYWxsKHRoaXMsIGVuY29kZXIpO1xuICAgICAgICBlbmNvZGVyLndyaXRlVmFyU3RyaW5nKHRoaXMubm9kZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEludGVncmF0ZXMgdGhpcyBJdGVtIGludG8gdGhlIHNoYXJlZCBzdHJ1Y3R1cmUuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgYWN0dWFsbHkgYXBwbGllcyB0aGUgY2hhbmdlIHRvIHRoZSBZanMgaW5zdGFuY2UuIEluIGNhc2Ugb2ZcbiAgICAgICAqIEl0ZW0gaXQgY29ubmVjdHMgX2xlZnQgYW5kIF9yaWdodCB0byB0aGlzIEl0ZW0gYW5kIGNhbGxzIHRoZVxuICAgICAgICoge0BsaW5rIEl0ZW0jYmVmb3JlQ2hhbmdlfSBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogKiBDaGVja3MgZm9yIG5vZGVOYW1lXG4gICAgICAgKiAqIFNldHMgZG9tRmlsdGVyXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtZfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaW50ZWdyYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW50ZWdyYXRlKHkpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGVOYW1lIG11c3QgYmUgZGVmaW5lZCEnKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQoWVhtbEVsZW1lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbEVsZW1lbnQucHJvdG90eXBlKSwgJ19pbnRlZ3JhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlYbWxFbGVtZW50LlxuICAgICAgICogVGhlIGF0dHJpYnV0ZXMgYXJlIG9yZGVyZWQgYnkgYXR0cmlidXRlLW5hbWUsIHNvIHlvdSBjYW4gZWFzaWx5IHVzZSB0aGlzXG4gICAgICAgKiBtZXRob2QgdG8gY29tcGFyZSBZWG1sRWxlbWVudHNcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgdmFyIHN0cmluZ0J1aWxkZXIgPSBbXTtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgIHZhciBrZXlzTGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0xlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9rZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIHN0cmluZ0J1aWxkZXIucHVzaChfa2V5ICsgJz1cIicgKyBhdHRyc1tfa2V5XSArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGF0dHJzU3RyaW5nID0gc3RyaW5nQnVpbGRlci5sZW5ndGggPiAwID8gJyAnICsgc3RyaW5nQnVpbGRlci5qb2luKCcgJykgOiAnJztcbiAgICAgICAgcmV0dXJuICc8JyArIG5vZGVOYW1lICsgYXR0cnNTdHJpbmcgKyAnPicgKyBnZXQoWVhtbEVsZW1lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWVhtbEVsZW1lbnQucHJvdG90eXBlKSwgJ3RvU3RyaW5nJywgdGhpcykuY2FsbCh0aGlzKSArICc8LycgKyBub2RlTmFtZSArICc+JztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbW92ZUF0dHJpYnV0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFlNYXAucHJvdG90eXBlLmRlbGV0ZS5jYWxsKHRoaXMsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgb3IgdXBkYXRlcyBhbiBhdHRyaWJ1dGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZVZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZXRBdHRyaWJ1dGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gWU1hcC5wcm90b3R5cGUuc2V0LmNhbGwodGhpcywgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHZhbHVlIHRoYXQgYmVsb25ncyB0byB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaWRlbnRpZmllcyB0aGVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgdmFsdWUuXG4gICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBxdWVyaWVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEF0dHJpYnV0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFlNYXAucHJvdG90eXBlLmdldC5jYWxsKHRoaXMsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIGluIGEgSlNPTiBPYmplY3QuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBIEpTT04gT2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBhdHRyaWJ1dGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwdWJsaWNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0QXR0cmlidXRlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXR0cmlidXRlcygpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLl9tYXBbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBzbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICBpZiAoIXZhbHVlLl9kZWxldGVkKSB7XG4gICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUuX2NvbnRlbnRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBvdXRzb3VyY2UgdGhlIGJpbmRpbmcgcHJvcGVydHkuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAgICAgKiBAcGFyYW0ge09iamVjdDxrZXk6aG9va0RlZmluaXRpb24+fSBbaG9va3M9e31dIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAgICAgKiBAcGFyYW0ge0RvbUJpbmRpbmd9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b0RvbScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9Eb20oKSB7XG4gICAgICAgIHZhciBfZG9jdW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGRvY3VtZW50O1xuXG4gICAgICAgIHZhciBob29rcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgIHZhciBiaW5kaW5nID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIHZhciBkb20gPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm5vZGVOYW1lKTtcbiAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHl4bWwpIHtcbiAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoeXhtbC50b0RvbShfZG9jdW1lbnQsIGhvb2tzLCBiaW5kaW5nKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjcmVhdGVBc3NvY2lhdGlvbihiaW5kaW5nLCBkb20sIHRoaXMpO1xuICAgICAgICByZXR1cm4gZG9tO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gWVhtbEVsZW1lbnQ7XG4gIH0oWVhtbEZyYWdtZW50KTtcblxuXG4gIFlYbWxGcmFnbWVudC5fWVhtbEVsZW1lbnQgPSBZWG1sRWxlbWVudDtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYHBhcmVudGAgaXMgYSBwYXJlbnQgb2YgYGNoaWxkYC5cbiAgICpcbiAgICogQHBhcmFtIHtUeXBlfSBwYXJlbnRcbiAgICogQHBhcmFtIHtUeXBlfSBjaGlsZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGBwYXJlbnRgIGlzIGEgcGFyZW50IG9mIGBjaGlsZGAuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIGlzUGFyZW50T2YocGFyZW50LCBjaGlsZCkge1xuICAgIGNoaWxkID0gY2hpbGQuX3BhcmVudDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5fcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBmaWx0ZXIgbWV0aG9kIChkb2VzIG5vdGhpbmcpLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7TWFwfSBhdHRycyBNYXAgb2Yga2V5LXZhbHVlIHBhaXJzIHRoYXQgYXJlIGF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUuXG4gICAqIEByZXR1cm4ge01hcCB8IG51bGx9IFRoZSBhbGxvd2VkIGF0dHJpYnV0ZXMgb3IgbnVsbCwgaWYgdGhlIGVsZW1lbnQgc2hvdWxkIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gZGVmYXVsdEZpbHRlcihub2RlTmFtZSwgYXR0cnMpIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYmFzaWMgZmlsdGVyIHRoYXQgZmlsdGVycyBvdXQgZGFuZ2Vyb3VzIHByb3BlcnRpZXMhXG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBmaWx0ZXJEb21BdHRyaWJ1dGVzKGRvbSwgZmlsdGVyKSB7XG4gICAgdmFyIGF0dHJzID0gbmV3IE1hcCgpO1xuICAgIGZvciAodmFyIGkgPSBkb20uYXR0cmlidXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGF0dHIgPSBkb20uYXR0cmlidXRlc1tpXTtcbiAgICAgIGF0dHJzLnNldChhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyKGRvbS5ub2RlTmFtZSwgYXR0cnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBmaWx0ZXIgb24gYSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtEb21CaW5kaW5nfSBiaW5kaW5nIFRoZSBET00gYmluZGluZyBpbnN0YW5jZSB0aGF0IGhhcyB0aGUgZG9tIGZpbHRlci5cbiAgICogQHBhcmFtIHtZWG1sRWxlbWVudCB8IFlYbWxGcmFnbWVudCB9IHR5cGUgVGhlIHR5cGUgdG8gYXBwbHkgdGhlIGZpbHRlciB0by5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5RmlsdGVyT25UeXBlKHksIGJpbmRpbmcsIHR5cGUpIHtcbiAgICBpZiAoaXNQYXJlbnRPZihiaW5kaW5nLnR5cGUsIHR5cGUpKSB7XG4gICAgICB2YXIgbm9kZU5hbWUgPSB0eXBlLm5vZGVOYW1lO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICBpZiAodHlwZS5nZXRBdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gdHlwZS5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICAgIGF0dHJpYnV0ZXMuc2V0KGtleSwgYXR0cnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBmaWx0ZXJlZEF0dHJpYnV0ZXMgPSBiaW5kaW5nLmZpbHRlcihub2RlTmFtZSwgbmV3IE1hcChhdHRyaWJ1dGVzKSk7XG4gICAgICBpZiAoZmlsdGVyZWRBdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgIHR5cGUuX2RlbGV0ZSh5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0ZXJhdGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAvLyBkZWxldGUgYWxsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbm90IGluIGZpbHRlcmVkQXR0cmlidXRlc1xuICAgICAgICAgIGlmIChmaWx0ZXJlZEF0dHJpYnV0ZXMuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0eXBlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBZanMgdHlwZSAoWVhtbCkgYmFzZWQgb24gdGhlIGNvbnRlbnRzIG9mIGEgRE9NIEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxUZXh0Tm9kZX0gZWxlbWVudCBUaGUgRE9NIEVsZW1lbnRcbiAgICogQHBhcmFtIHs/RG9jdW1lbnR9IF9kb2N1bWVudCBPcHRpb25hbC4gUHJvdmlkZSB0aGUgZ2xvYmFsIGRvY3VtZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0hvb2tzfSBbaG9va3MgPSB7fV0gT3B0aW9uYWwuIFNldCBvZiBZanMgSG9va3NcbiAgICogQHBhcmFtIHtGaWx0ZXJ9IFtmaWx0ZXI9ZGVmYXVsdEZpbHRlcl0gT3B0aW9uYWwuIERvbSBlbGVtZW50IGZpbHRlclxuICAgKiBAcGFyYW0gez9Eb21CaW5kaW5nfSBiaW5kaW5nIFdhcm5pbmc6IFRoaXMgcHJvcGVydHkgaXMgZm9yIGludGVybmFsIHVzZSBvbmx5IVxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudCB8IFlYbWxUZXh0fVxuICAgKi9cbiAgZnVuY3Rpb24gZG9tVG9UeXBlKGVsZW1lbnQpIHtcbiAgICB2YXIgX2RvY3VtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBkb2N1bWVudDtcblxuICAgIHZhciBob29rcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIGZpbHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZGVmYXVsdEZpbHRlcjtcbiAgICB2YXIgYmluZGluZyA9IGFyZ3VtZW50c1s0XTtcblxuICAgIHZhciB0eXBlID0gdm9pZCAwO1xuICAgIHN3aXRjaCAoZWxlbWVudC5ub2RlVHlwZSkge1xuICAgICAgY2FzZSBfZG9jdW1lbnQuRUxFTUVOVF9OT0RFOlxuICAgICAgICB2YXIgaG9va05hbWUgPSBudWxsO1xuICAgICAgICB2YXIgaG9vayA9IHZvaWQgMDtcbiAgICAgICAgLy8gY29uZmlndXJlIGBob29rTmFtZSAhPT0gdW5kZWZpbmVkYCBpZiBlbGVtZW50IGlzIGEgaG9vay5cbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXlqcy1ob29rJykpIHtcbiAgICAgICAgICBob29rTmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXlqcy1ob29rJyk7XG4gICAgICAgICAgaG9vayA9IGhvb2tzW2hvb2tOYW1lXTtcbiAgICAgICAgICBpZiAoaG9vayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIGhvb2sgXCInICsgaG9va05hbWUgKyAnXCIuIERlbGV0aW5nIHlqc0hvb2sgZGF0YXNldCBwcm9wZXJ0eS4nKTtcbiAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS15anMtaG9vaycpO1xuICAgICAgICAgICAgaG9va05hbWUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va05hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBOb3QgYSBob29rXG4gICAgICAgICAgdmFyIGF0dHJzID0gZmlsdGVyRG9tQXR0cmlidXRlcyhlbGVtZW50LCBmaWx0ZXIpO1xuICAgICAgICAgIGlmIChhdHRycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHlwZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gbmV3IFlYbWxFbGVtZW50KGVsZW1lbnQubm9kZU5hbWUpO1xuICAgICAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgdHlwZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0eXBlLmluc2VydCgwLCBkb21zVG9UeXBlcyhlbGVtZW50LmNoaWxkTm9kZXMsIGRvY3VtZW50LCBob29rcywgZmlsdGVyLCBiaW5kaW5nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElzIGEgaG9va1xuICAgICAgICAgIHR5cGUgPSBuZXcgWVhtbEhvb2soaG9va05hbWUpO1xuICAgICAgICAgIGhvb2suZmlsbFR5cGUoZWxlbWVudCwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9kb2N1bWVudC5URVhUX05PREU6XG4gICAgICAgIHR5cGUgPSBuZXcgWVhtbFRleHQoKTtcbiAgICAgICAgdHlwZS5pbnNlcnQoMCwgZWxlbWVudC5ub2RlVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB0cmFuc2Zvcm0gdGhpcyBub2RlIHR5cGUgdG8gYSBZWG1sIHR5cGUhJyk7XG4gICAgfVxuICAgIGNyZWF0ZUFzc29jaWF0aW9uKGJpbmRpbmcsIGVsZW1lbnQsIHR5cGUpO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIGl0ZW1zIHVudGlsIGFuIHVuZGVsZXRlZCBpdGVtIGlzIGZvdW5kLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmF0ZVVudGlsVW5kZWxldGVkKGl0ZW0pIHtcbiAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCAmJiBpdGVtLl9kZWxldGVkKSB7XG4gICAgICBpdGVtID0gaXRlbS5fcmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXNzb2NpYXRpb24gKHRoZSBpbmZvcm1hdGlvbiB0aGF0IGEgRE9NIGVsZW1lbnQgYmVsb25ncyB0byBhXG4gICAqIHR5cGUpLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvbUJpbmRpbmd9IGRvbUJpbmRpbmcgVGhlIGJpbmRpbmcgb2JqZWN0XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tIFRoZSBkb20gdGhhdCBpcyB0byBiZSBhc3NvY2lhdGVkIHdpdGggdHlwZVxuICAgKiBAcGFyYW0ge1lYbWxFbGVtZW50fFlYbWxIb29rfSB0eXBlIFRoZSB0eXBlIHRoYXQgaXMgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIGRvbVxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlQXNzb2NpYXRpb24oZG9tQmluZGluZywgZG9tLCB0eXBlKSB7XG4gICAgZG9tQmluZGluZy5kb21Ub1R5cGUuZGVsZXRlKGRvbSk7XG4gICAgZG9tQmluZGluZy50eXBlVG9Eb20uZGVsZXRlKHR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXNzb2NpYXRpb24gKHRoZSBpbmZvcm1hdGlvbiB0aGF0IGEgRE9NIGVsZW1lbnQgYmVsb25ncyB0byBhXG4gICAqIHR5cGUpLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvbUJpbmRpbmd9IGRvbUJpbmRpbmcgVGhlIGJpbmRpbmcgb2JqZWN0XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tIFRoZSBkb20gdGhhdCBpcyB0byBiZSBhc3NvY2lhdGVkIHdpdGggdHlwZVxuICAgKiBAcGFyYW0ge1lYbWxFbGVtZW50fFlYbWxIb29rfSB0eXBlIFRoZSB0eXBlIHRoYXQgaXMgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIGRvbVxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQXNzb2NpYXRpb24oZG9tQmluZGluZywgZG9tLCB0eXBlKSB7XG4gICAgaWYgKGRvbUJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZG9tQmluZGluZy5kb21Ub1R5cGUuc2V0KGRvbSwgdHlwZSk7XG4gICAgICBkb21CaW5kaW5nLnR5cGVUb0RvbS5zZXQodHlwZSwgZG9tKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgb2xkRG9tIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHR5cGUsIGFzc29jaWF0ZSBuZXdEb20gd2l0aCB0aGUgdHlwZSBhbmRcbiAgICogZm9yZ2V0IGFib3V0IG9sZERvbS4gSWYgb2xkRG9tIGlzIG5vdCBhc3NvY2lhdGVkIHdpdGggYW55IHR5cGUsIG5vdGhpbmcgaGFwcGVucy5cbiAgICpcbiAgICogQHBhcmFtIHtEb21CaW5kaW5nfSBkb21CaW5kaW5nIFRoZSBiaW5kaW5nIG9iamVjdFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG9sZERvbSBUaGUgZXhpc3RpbmcgZG9tXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbmV3RG9tIFRoZSBuZXcgZG9tIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gc3dpdGNoQXNzb2NpYXRpb24oZG9tQmluZGluZywgb2xkRG9tLCBuZXdEb20pIHtcbiAgICBpZiAoZG9tQmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdHlwZSA9IGRvbUJpbmRpbmcuZG9tVG9UeXBlLmdldChvbGREb20pO1xuICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW1vdmVBc3NvY2lhdGlvbihkb21CaW5kaW5nLCBvbGREb20sIHR5cGUpO1xuICAgICAgICBjcmVhdGVBc3NvY2lhdGlvbihkb21CaW5kaW5nLCBuZXdEb20sIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgRG9tIEVsZW1lbnRzIGFmdGVyIG9uZSBvZiB0aGUgY2hpbGRyZW4gb2YgdGhpcyBZWG1sRnJhZ21lbnQuXG4gICAqIFRoZSBEb20gZWxlbWVudHMgd2lsbCBiZSBib3VuZCB0byBhIG5ldyBZWG1sRWxlbWVudCBhbmQgaW5zZXJ0ZWQgYXQgdGhlXG4gICAqIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtZWG1sRWxlbWVudH0gdHlwZSBUaGUgdHlwZSBpbiB3aGljaCB0byBpbnNlcnQgRE9NIGVsZW1lbnRzLlxuICAgKiBAcGFyYW0ge1lYbWxFbGVtZW50fG51bGx9IHByZXYgVGhlIHJlZmVyZW5jZSBub2RlLiBOZXcgWXhtbEVsZW1lbnRzIGFyZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydGVkIGFmdGVyIHRoaXMgbm9kZS4gU2V0IG51bGwgdG8gaW5zZXJ0IGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGJlZ2lubmluZy5cbiAgICogQHBhcmFtIHtBcnJheTxFbGVtZW50Pn0gZG9tcyBUaGUgRG9tIGVsZW1lbnRzIHRvIGluc2VydC5cbiAgICogQHBhcmFtIHs/RG9jdW1lbnR9IF9kb2N1bWVudCBPcHRpb25hbC4gUHJvdmlkZSB0aGUgZ2xvYmFsIGRvY3VtZW50IG9iamVjdC5cbiAgICogQHBhcmFtIHtEb21CaW5kaW5nfSBiaW5kaW5nIFRoZSBkb20gYmluZGluZ1xuICAgKiBAcmV0dXJuIHtBcnJheTxZWG1sRWxlbWVudD59IFRoZSBZeG1sRWxlbWVudHMgdGhhdCBhcmUgaW5zZXJ0ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnREb21FbGVtZW50c0FmdGVyKHR5cGUsIHByZXYsIGRvbXMsIF9kb2N1bWVudCwgYmluZGluZykge1xuICAgIHZhciB0eXBlcyA9IGRvbXNUb1R5cGVzKGRvbXMsIF9kb2N1bWVudCwgYmluZGluZy5vcHRzLmhvb2tzLCBiaW5kaW5nLmZpbHRlciwgYmluZGluZyk7XG4gICAgcmV0dXJuIHR5cGUuaW5zZXJ0QWZ0ZXIocHJldiwgdHlwZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9tc1RvVHlwZXMoZG9tcywgX2RvY3VtZW50LCBob29rcywgZmlsdGVyLCBiaW5kaW5nKSB7XG4gICAgdmFyIHR5cGVzID0gW107XG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBkb21zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgZG9tID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgdmFyIHQgPSBkb21Ub1R5cGUoZG9tLCBfZG9jdW1lbnQsIGhvb2tzLCBmaWx0ZXIsIGJpbmRpbmcpO1xuICAgICAgICBpZiAodCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0eXBlcy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnROb2RlSGVscGVyKHl4bWwsIHByZXZFeHBlY3RlZE5vZGUsIGNoaWxkLCBfZG9jdW1lbnQsIGJpbmRpbmcpIHtcbiAgICB2YXIgaW5zZXJ0ZWROb2RlcyA9IGluc2VydERvbUVsZW1lbnRzQWZ0ZXIoeXhtbCwgcHJldkV4cGVjdGVkTm9kZSwgW2NoaWxkXSwgX2RvY3VtZW50LCBiaW5kaW5nKTtcbiAgICBpZiAoaW5zZXJ0ZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gaW5zZXJ0ZWROb2Rlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZFeHBlY3RlZE5vZGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjaGlsZHJlbiB1bnRpbCBgZWxlbWAgaXMgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50IFRoZSBwYXJlbnQgb2YgYGVsZW1gIGFuZCBgY3VycmVudENoaWxkYC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBjdXJyZW50Q2hpbGQgU3RhcnQgcmVtb3ZpbmcgZWxlbWVudHMgd2l0aCBgY3VycmVudENoaWxkYC4gSWZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGN1cnJlbnRDaGlsZGAgaXMgYGVsZW1gIGl0IHdvbid0IGJlIHJlbW92ZWQuXG4gICAqIEBwYXJhbSB7RWxlbWVudHxudWxsfSBlbGVtIFRoZSBlbGVtbnQgdG8gbG9vayBmb3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVEb21DaGlsZHJlblVudGlsRWxlbWVudEZvdW5kKHBhcmVudCwgY3VycmVudENoaWxkLCBlbGVtKSB7XG4gICAgd2hpbGUgKGN1cnJlbnRDaGlsZCAhPT0gZWxlbSkge1xuICAgICAgdmFyIGRlbCA9IGN1cnJlbnRDaGlsZDtcbiAgICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5uZXh0U2libGluZztcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChkZWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIHRleHQgaW4gYSBEb20gRWxlbWVudC4gSW4gdGhlIGZ1dHVyZSB0aGlzIHR5cGUgd2lsbCBhbHNvIGhhbmRsZVxuICAgKiBzaW1wbGUgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiBsaWtlIGJvbGQgYW5kIGl0YWxpYy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFyZzEgSW5pdGlhbCB2YWx1ZS5cbiAgICovXG5cbiAgdmFyIFlYbWxUZXh0ID0gZnVuY3Rpb24gKF9ZVGV4dCkge1xuICAgIGluaGVyaXRzKFlYbWxUZXh0LCBfWVRleHQpO1xuXG4gICAgZnVuY3Rpb24gWVhtbFRleHQoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBZWG1sVGV4dCk7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoWVhtbFRleHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZWG1sVGV4dCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKFlYbWxUZXh0LCBbe1xuICAgICAga2V5OiAndG9Eb20nLFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sVGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAgICAgKiBAcGFyYW0ge09iamVjdDxrZXk6aG9va0RlZmluaXRpb24+fSBbaG9va3NdIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAgICAgKiBAcGFyYW0ge0RvbUJpbmRpbmd9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9Eb20oKSB7XG4gICAgICAgIHZhciBfZG9jdW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGRvY3VtZW50O1xuICAgICAgICB2YXIgYmluZGluZyA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgICB2YXIgZG9tID0gX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIGNyZWF0ZUFzc29jaWF0aW9uKGJpbmRpbmcsIGRvbSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWFyayB0aGlzIEl0ZW0gYXMgZGVsZXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1l9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGVEZWxldGUgV2hldGhlciB0byBwcm9wYWdhdGUgYSBtZXNzYWdlIHRoYXQgdGhpc1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHlwZSB3YXMgZGVsZXRlZC5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2djQ2hpbGRyZW49eS5faGFzVW5kb01hbmFnZXI9PT1mYWxzZV0gV2hldGhlciB0byBnYXJiYWdlXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyB0eXBlLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZWxldGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoeSwgY3JlYXRlRGVsZXRlLCBnY0NoaWxkcmVuKSB7XG4gICAgICAgIGdldChZWG1sVGV4dC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihZWG1sVGV4dC5wcm90b3R5cGUpLCAnX2RlbGV0ZScsIHRoaXMpLmNhbGwodGhpcywgeSwgY3JlYXRlRGVsZXRlLCBnY0NoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFlYbWxUZXh0O1xuICB9KFlUZXh0KTtcblxuICB2YXIgc3RydWN0cyA9IG5ldyBNYXAoKTtcbiAgdmFyIHJlZmVyZW5jZXMgPSBuZXcgTWFwKCk7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbmV3IFlqcyB0eXBlcy4gVGhlIHNhbWUgdHlwZSBtdXN0IGJlIGRlZmluZWQgd2l0aCB0aGUgc2FtZVxuICAgKiByZWZlcmVuY2Ugb24gYWxsIGNsaWVudHMhXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZWZlcmVuY2VcbiAgICogQHBhcmFtIHtjbGFzc30gc3RydWN0Q29uc3RydWN0b3JcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gcmVnaXN0ZXJTdHJ1Y3QocmVmZXJlbmNlLCBzdHJ1Y3RDb25zdHJ1Y3Rvcikge1xuICAgIHN0cnVjdHMuc2V0KHJlZmVyZW5jZSwgc3RydWN0Q29uc3RydWN0b3IpO1xuICAgIHJlZmVyZW5jZXMuc2V0KHN0cnVjdENvbnN0cnVjdG9yLCByZWZlcmVuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdHJ1Y3QocmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIHN0cnVjdHMuZ2V0KHJlZmVyZW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0cnVjdFJlZmVyZW5jZSh0eXBlQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gcmVmZXJlbmNlcy5nZXQodHlwZUNvbnN0cnVjdG9yKTtcbiAgfVxuXG4gIC8vIFRPRE86IHJlb3JkZXIgKEl0ZW0qIHNob3VsZCBoYXZlIGxvdyBudW1iZXJzKVxuICByZWdpc3RlclN0cnVjdCgwLCBJdGVtSlNPTik7XG4gIHJlZ2lzdGVyU3RydWN0KDEsIEl0ZW1TdHJpbmcpO1xuICByZWdpc3RlclN0cnVjdCgxMCwgSXRlbUZvcm1hdCk7XG4gIHJlZ2lzdGVyU3RydWN0KDExLCBJdGVtRW1iZWQpO1xuICByZWdpc3RlclN0cnVjdCgyLCBEZWxldGUpO1xuXG4gIHJlZ2lzdGVyU3RydWN0KDMsIFlBcnJheSk7XG4gIHJlZ2lzdGVyU3RydWN0KDQsIFlNYXApO1xuICByZWdpc3RlclN0cnVjdCg1LCBZVGV4dCk7XG4gIHJlZ2lzdGVyU3RydWN0KDYsIFlYbWxGcmFnbWVudCk7XG4gIHJlZ2lzdGVyU3RydWN0KDcsIFlYbWxFbGVtZW50KTtcbiAgcmVnaXN0ZXJTdHJ1Y3QoOCwgWVhtbFRleHQpO1xuICByZWdpc3RlclN0cnVjdCg5LCBZWG1sSG9vayk7XG5cbiAgcmVnaXN0ZXJTdHJ1Y3QoMTIsIEdDKTtcblxuICB2YXIgUm9vdEZha2VVc2VySUQgPSAweEZGRkZGRjtcblxuICB2YXIgUm9vdElEID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvb3RJRChuYW1lLCB0eXBlQ29uc3RydWN0b3IpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJvb3RJRCk7XG5cbiAgICAgIHRoaXMudXNlciA9IFJvb3RGYWtlVXNlcklEO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMudHlwZSA9IGdldFN0cnVjdFJlZmVyZW5jZSh0eXBlQ29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKFJvb3RJRCwgW3tcbiAgICAgIGtleTogJ2VxdWFscycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCAhPT0gbnVsbCAmJiBpZC51c2VyID09PSB0aGlzLnVzZXIgJiYgaWQubmFtZSA9PT0gdGhpcy5uYW1lICYmIGlkLnR5cGUgPT09IHRoaXMudHlwZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdsZXNzVGhhbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbGVzc1RoYW4oaWQpIHtcbiAgICAgICAgaWYgKGlkLmNvbnN0cnVjdG9yID09PSBSb290SUQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51c2VyIDwgaWQudXNlciB8fCB0aGlzLnVzZXIgPT09IGlkLnVzZXIgJiYgKHRoaXMubmFtZSA8IGlkLm5hbWUgfHwgdGhpcy5uYW1lID09PSBpZC5uYW1lICYmIHRoaXMudHlwZSA8IGlkLnR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBSb290SUQ7XG4gIH0oKTtcblxuICB2YXIgT3BlcmF0aW9uU3RvcmUgPSBmdW5jdGlvbiAoX1RyZWUpIHtcbiAgICBpbmhlcml0cyhPcGVyYXRpb25TdG9yZSwgX1RyZWUpO1xuXG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uU3RvcmUoeSkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgT3BlcmF0aW9uU3RvcmUpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChPcGVyYXRpb25TdG9yZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wZXJhdGlvblN0b3JlKSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgIF90aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKE9wZXJhdGlvblN0b3JlLCBbe1xuICAgICAga2V5OiAnbG9nVGFibGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ1RhYmxlKCkge1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVyYXRlKG51bGwsIG51bGwsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uY29uc3RydWN0b3IgPT09IEdDKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IGxvZ0lEKGl0ZW0pLFxuICAgICAgICAgICAgICBjb250ZW50OiBpdGVtLl9sZW5ndGgsXG4gICAgICAgICAgICAgIGRlbGV0ZWQ6ICdHQydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IGxvZ0lEKGl0ZW0pLFxuICAgICAgICAgICAgICBvcmlnaW46IGxvZ0lEKGl0ZW0uX29yaWdpbiA9PT0gbnVsbCA/IG51bGwgOiBpdGVtLl9vcmlnaW4uX2xhc3RJZCksXG4gICAgICAgICAgICAgIGxlZnQ6IGxvZ0lEKGl0ZW0uX2xlZnQgPT09IG51bGwgPyBudWxsIDogaXRlbS5fbGVmdC5fbGFzdElkKSxcbiAgICAgICAgICAgICAgcmlnaHQ6IGxvZ0lEKGl0ZW0uX3JpZ2h0KSxcbiAgICAgICAgICAgICAgcmlnaHRfb3JpZ2luOiBsb2dJRChpdGVtLl9yaWdodF9vcmlnaW4pLFxuICAgICAgICAgICAgICBwYXJlbnQ6IGxvZ0lEKGl0ZW0uX3BhcmVudCksXG4gICAgICAgICAgICAgIHBhcmVudFN1YjogaXRlbS5fcGFyZW50U3ViLFxuICAgICAgICAgICAgICBkZWxldGVkOiBpdGVtLl9kZWxldGVkLFxuICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShpdGVtLl9jb250ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS50YWJsZShpdGVtcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQkJDEoaWQpIHtcbiAgICAgICAgdmFyIHN0cnVjdCA9IHRoaXMuZmluZChpZCk7XG4gICAgICAgIGlmIChzdHJ1Y3QgPT09IG51bGwgJiYgaWQgaW5zdGFuY2VvZiBSb290SUQpIHtcbiAgICAgICAgICB2YXIgQ29uc3RyID0gZ2V0U3RydWN0KGlkLnR5cGUpO1xuICAgICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICAgIHN0cnVjdCA9IG5ldyBDb25zdHIoKTtcbiAgICAgICAgICBzdHJ1Y3QuX2lkID0gaWQ7XG4gICAgICAgICAgc3RydWN0Ll9wYXJlbnQgPSB5O1xuICAgICAgICAgIHkudHJhbnNhY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RydWN0Ll9pbnRlZ3JhdGUoeSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wdXQoc3RydWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgICAgfVxuICAgICAgLy8gVXNlIGdldEl0ZW0gZm9yIHN0cnVjdHMgd2l0aCBfbGVuZ3RoID4gMVxuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0SXRlbScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbShpZCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZmluZFdpdGhVcHBlckJvdW5kKGlkKTtcbiAgICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbUlEID0gaXRlbS5faWQ7XG4gICAgICAgIGlmIChpZC51c2VyID09PSBpdGVtSUQudXNlciAmJiBpZC5jbG9jayA8IGl0ZW1JRC5jbG9jayArIGl0ZW0uX2xlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZXR1cm4gYW4gaW5zZXJ0aW9uIHN1Y2ggdGhhdCBpZCBpcyB0aGUgZmlyc3QgZWxlbWVudCBvZiBjb250ZW50XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIG1hbmlwdWxhdGVzIGFuIGl0ZW0sIGlmIG5lY2Vzc2FyeVxuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0SXRlbUNsZWFuU3RhcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW1DbGVhblN0YXJ0KGlkKSB7XG4gICAgICAgIHZhciBpbnMgPSB0aGlzLmdldEl0ZW0oaWQpO1xuICAgICAgICBpZiAoaW5zID09PSBudWxsIHx8IGlucy5fbGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGlucztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5zSUQgPSBpbnMuX2lkO1xuICAgICAgICBpZiAoaW5zSUQuY2xvY2sgPT09IGlkLmNsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIGlucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaW5zLl9zcGxpdEF0KHRoaXMueSwgaWQuY2xvY2sgLSBpbnNJRC5jbG9jayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJldHVybiBhbiBpbnNlcnRpb24gc3VjaCB0aGF0IGlkIGlzIHRoZSBsYXN0IGVsZW1lbnQgb2YgY29udGVudFxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBtYW5pcHVsYXRlcyBhbiBvcGVyYXRpb24sIGlmIG5lY2Vzc2FyeVxuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0SXRlbUNsZWFuRW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJdGVtQ2xlYW5FbmQoaWQpIHtcbiAgICAgICAgdmFyIGlucyA9IHRoaXMuZ2V0SXRlbShpZCk7XG4gICAgICAgIGlmIChpbnMgPT09IG51bGwgfHwgaW5zLl9sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gaW5zO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnNJRCA9IGlucy5faWQ7XG4gICAgICAgIGlmIChpbnNJRC5jbG9jayArIGlucy5fbGVuZ3RoIC0gMSA9PT0gaWQuY2xvY2spIHtcbiAgICAgICAgICByZXR1cm4gaW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucy5fc3BsaXRBdCh0aGlzLnksIGlkLmNsb2NrIC0gaW5zSUQuY2xvY2sgKyAxKTtcbiAgICAgICAgICByZXR1cm4gaW5zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBPcGVyYXRpb25TdG9yZTtcbiAgfShUcmVlKTtcblxuICB2YXIgU3RhdGVTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZVN0b3JlKHkpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRlU3RvcmUpO1xuXG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhTdGF0ZVN0b3JlLCBbe1xuICAgICAga2V5OiAnbG9nVGFibGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ1RhYmxlKCkge1xuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLnN0YXRlW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgdXNlciA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgIHVzZXI6IHVzZXIsIHN0YXRlOiBzdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUudGFibGUoZW50cmllcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0TmV4dElEJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROZXh0SUQobGVuKSB7XG4gICAgICAgIHZhciB1c2VyID0gdGhpcy55LnVzZXJJRDtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZSh1c2VyKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh1c2VyLCBzdGF0ZSArIGxlbik7XG4gICAgICAgIHJldHVybiBuZXcgSUQodXNlciwgc3RhdGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZVJlbW90ZVN0YXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVSZW1vdGVTdGF0ZShzdHJ1Y3QpIHtcbiAgICAgICAgdmFyIHVzZXIgPSBzdHJ1Y3QuX2lkLnVzZXI7XG4gICAgICAgIHZhciB1c2VyU3RhdGUgPSB0aGlzLnN0YXRlLmdldCh1c2VyKTtcbiAgICAgICAgd2hpbGUgKHN0cnVjdCAhPT0gbnVsbCAmJiBzdHJ1Y3QuX2lkLmNsb2NrID09PSB1c2VyU3RhdGUpIHtcbiAgICAgICAgICB1c2VyU3RhdGUgKz0gc3RydWN0Ll9sZW5ndGg7XG4gICAgICAgICAgc3RydWN0ID0gdGhpcy55Lm9zLmdldChuZXcgSUQodXNlciwgdXNlclN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXQodXNlciwgdXNlclN0YXRlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTdGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGUodXNlcikge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlLmdldCh1c2VyKTtcbiAgICAgICAgaWYgKHN0YXRlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0U3RhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0YXRlKHVzZXIsIHN0YXRlKSB7XG4gICAgICAgIC8vIFRPRE86IG1vZGlmeSBtaXNzaW5naSBzdHJ1Y3RzIGhlcmVcbiAgICAgICAgdmFyIGJlZm9yZVN0YXRlID0gdGhpcy55Ll90cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZTtcbiAgICAgICAgaWYgKCFiZWZvcmVTdGF0ZS5oYXModXNlcikpIHtcbiAgICAgICAgICBiZWZvcmVTdGF0ZS5zZXQodXNlciwgdGhpcy5nZXRTdGF0ZSh1c2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXQodXNlciwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gU3RhdGVTdG9yZTtcbiAgfSgpO1xuXG4gIC8qIGdsb2JhbCBjcnlwdG8gKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVVpbnQzMigpIHtcbiAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIGJyb3dzZXJcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDMyQXJyYXkoMSk7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyWzBdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbUJ5dGVzICE9IG51bGwpIHtcbiAgICAgIC8vIG5vZGVcbiAgICAgIHZhciBidWYgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNCk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGJ1Zi5idWZmZXIpWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRkZGKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBuYW1lZCBldmVudHMuXG4gICAqL1xuICB2YXIgTmFtZWRFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmFtZWRFdmVudEhhbmRsZXIoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOYW1lZEV2ZW50SGFuZGxlcik7XG5cbiAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXIgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLl9zdGF0ZUxpc3RlbmVyID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogUmV0dXJucyBhbGwgbGlzdGVuZXJzIHRoYXQgbGlzdGVuIHRvIGEgc3BlY2lmaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgcXVlcnkgZXZlbnQgbmFtZS5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoTmFtZWRFdmVudEhhbmRsZXIsIFt7XG4gICAgICBrZXk6ICdfZ2V0TGlzdGVuZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRMaXN0ZW5lcihuYW1lKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgb25jZTogbmV3IFNldCgpLFxuICAgICAgICAgICAgb246IG5ldyBTZXQoKVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lci5zZXQobmFtZSwgbGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgYSBuYW1lZCBldmVudCBsaXN0ZW5lci4gVGhlIGxpc3RlbmVyIGlzIHJlbW92ZWQgYWZ0ZXIgaXQgaGFzIGJlZW5cbiAgICAgICAqIGNhbGxlZCBvbmNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBldmVudCBuYW1lIHRvIGxpc3RlbiB0by5cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uY2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uY2UobmFtZSwgZikge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXIobmFtZSk7XG4gICAgICAgIGxpc3RlbmVycy5vbmNlLmFkZChmKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGEgbmFtZWQgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gbGlzdGVuIHRvLlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiBUaGUgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uKG5hbWUsIGYpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2dldExpc3RlbmVyKG5hbWUpO1xuICAgICAgICBsaXN0ZW5lcnMub24uYWRkKGYpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBJbml0IHRoZSBzYXZlZCBzdGF0ZSBmb3IgYW4gZXZlbnQgbmFtZS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2luaXRTdGF0ZUxpc3RlbmVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdFN0YXRlTGlzdGVuZXIobmFtZSkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZUxpc3RlbmVyLmdldChuYW1lKTtcbiAgICAgICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdGF0ZSA9IHt9O1xuICAgICAgICAgIHN0YXRlLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fc3RhdGVMaXN0ZW5lci5zZXQobmFtZSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIGV2ZW50IG5hbWUgaXMgY2FsbGVkLlxuICAgICAgICogVGhlIFByb21pc2UgaXMgaW1tZWRpYXRlbHkgcmVzb2x2ZWQgd2hlbiB0aGUgZXZlbnQgbmFtZSB3YXMgY2FsbGVkIGluIHRoZVxuICAgICAgICogcGFzdC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnd2hlbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gd2hlbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0U3RhdGVMaXN0ZW5lcihuYW1lKS5wcm9taXNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciB0aGF0IHdhcyByZWdpc3RlcmVkIHdpdGggZWl0aGVyXG4gICAgICAgKiB7QGxpbmsgRXZlbnRIYW5kbGVyI29ufSBvciB7QGxpbmsgRXZlbnRIYW5kbGVyI29uY2V9LlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvZmYnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihuYW1lLCBmKSB7XG4gICAgICAgIGlmIChuYW1lID09IG51bGwgfHwgZiA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGV2ZW50IG5hbWUgYW5kIGZ1bmN0aW9uIScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuX2V2ZW50TGlzdGVuZXIuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAobGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpc3RlbmVyLm9uLmRlbGV0ZShmKTtcbiAgICAgICAgICBsaXN0ZW5lci5vbmNlLmRlbGV0ZShmKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVtaXQgYSBuYW1lZCBldmVudC4gQWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbGlzdGVuIHRvIHRoZVxuICAgICAgICogc3BlY2lmaWVkIG5hbWUgd2lsbCByZWNlaXZlIHRoZSBldmVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZW1pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5pdFN0YXRlTGlzdGVuZXIobmFtZSkucmVzb2x2ZSgpO1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9ldmVudExpc3RlbmVyLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5vbi5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsaXN0ZW5lci5vbmNlLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxpc3RlbmVyLm9uY2UgPSBuZXcgU2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZXN0cm95JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIE5hbWVkRXZlbnRIYW5kbGVyO1xuICB9KCk7XG5cbiAgLy8gVE9ETzogSW1wbGVtZW50IGZ1bmN0aW9uIHRvIGRlc2NyaWJlIHJhbmdlc1xuXG4gIC8qKlxuICAgKiBBIHJlbGF0aXZlIHBvc2l0aW9uIHRoYXQgaXMgYmFzZWQgb24gdGhlIFlqcyBtb2RlbC4gSW4gY29udHJhc3QgdG8gYW5cbiAgICogYWJzb2x1dGUgcG9zaXRpb24gKHBvc2l0aW9uIGJ5IGluZGV4KSwgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGNhbiBiZVxuICAgKiByZWNvbXB1dGVkIHdoZW4gcmVtb3RlIGNoYW5nZXMgYXJlIHJlY2VpdmVkLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogYGBgSW5zZXJ0KDAsICd4JykoJ2F8YmMnKSA9ICd4YXxiYydgYGAgV2hlcmUgfCBpcyB0aGUgY3Vyc29yIHBvc2l0aW9uLlxuICAgKlxuICAgKiBBIHJlbGF0aXZlIGN1cnNvciBwb3NpdGlvbiBjYW4gYmUgb2J0YWluZWQgd2l0aCB0aGUgZnVuY3Rpb25cbiAgICoge0BsaW5rIGdldFJlbGF0aXZlUG9zaXRpb259IGFuZCBpdCBjYW4gYmUgdHJhbnNmb3JtZWQgdG8gYW4gYWJzb2x1dGUgcG9zaXRpb25cbiAgICogd2l0aCB7QGxpbmsgZnJvbVJlbGF0aXZlUG9zaXRpb259LlxuICAgKlxuICAgKiBQcm8gdGlwOiBVc2UgdGhpcyB0byBpbXBsZW1lbnQgc2hhcmVkIGN1cnNvciBsb2NhdGlvbnMgaW4gWVRleHQgb3IgWVhtbCFcbiAgICogVGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIHtAbGluayBlbmNvZGFibGV9LCBzbyB5b3UgY2FuIHNlbmQgaXQgdG8gb3RoZXJcbiAgICogY2xpZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ3VycmVudCBjdXJzb3IgcG9zaXRpb24gaXMgYXQgcG9zaXRpb24gMTBcbiAgICogbGV0IHJlbGF0aXZlUG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKHlUZXh0LCAxMClcbiAgICogLy8gbW9kaWZ5IHlUZXh0XG4gICAqIHlUZXh0Lmluc2VydCgwLCAnYWJjJylcbiAgICogeVRleHQuZGVsZXRlKDMsIDEwKVxuICAgKiAvLyBDb21wdXRlIHRoZSBjdXJzb3IgcG9zaXRpb25cbiAgICogbGV0IGFic29sdXRlUG9zaXRpb24gPSBmcm9tUmVsYXRpdmVQb3NpdGlvbih5LCByZWxhdGl2ZVBvc2l0aW9uKVxuICAgKiBhYnNvbHV0ZVBvc2l0aW9uLnR5cGUgLy8gPT4geVRleHRcbiAgICogY29uc29sZS5sb2coJ2N1cnNvciBsb2NhdGlvbiBpcyAnICsgYWJzb2x1dGVQb3NpdGlvbi5vZmZzZXQpIC8vID0+IGN1cnNvciBsb2NhdGlvbiBpcyAzXG4gICAqXG4gICAqIEB0eXBlZGVmIHtlbmNvZGFibGV9IFJlbGF0aXZlUG9zaXRpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlbGF0aXZlUG9zaXRpb24gYmFzZWQgb24gYSBhYnNvbHV0ZSBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtZVHlwZX0gdHlwZSBUaGUgYmFzZSB0eXBlIChlLmcuIFlUZXh0IG9yIFlBcnJheSkuXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gb2Zmc2V0IFRoZSBhYnNvbHV0ZSBwb3NpdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24odHlwZSwgb2Zmc2V0KSB7XG4gICAgLy8gVE9ETzogcmVuYW1lIHRvIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25cbiAgICB2YXIgdCA9IHR5cGUuX3N0YXJ0O1xuICAgIHdoaWxlICh0ICE9PSBudWxsKSB7XG4gICAgICBpZiAodC5fZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHQuX2xlbmd0aCA+IG9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBbdC5faWQudXNlciwgdC5faWQuY2xvY2sgKyBvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCAtPSB0Ll9sZW5ndGg7XG4gICAgICB9XG4gICAgICB0ID0gdC5fcmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBbJ2VuZG9mJywgdHlwZS5faWQudXNlciwgdHlwZS5faWQuY2xvY2sgfHwgbnVsbCwgdHlwZS5faWQubmFtZSB8fCBudWxsLCB0eXBlLl9pZC50eXBlIHx8IG51bGxdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEFic29sdXRlUG9zaXRpb24gVGhlIHJlc3VsdCBvZiB7QGxpbmsgZnJvbVJlbGF0aXZlUG9zaXRpb259XG4gICAqIEBwcm9wZXJ0eSB7WVR5cGV9IHR5cGUgVGhlIHR5cGUgb24gd2hpY2ggdG8gYXBwbHkgdGhlIGFic29sdXRlIHBvc2l0aW9uLlxuICAgKiBAcHJvcGVydHkge0ludGVnZXJ9IG9mZnNldCBUaGUgYWJzb2x1dGUgb2Zmc2V0LnJcbiAgICovXG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYSByZWxhdGl2ZSBwb3NpdGlvbiBiYWNrIHRvIGEgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7WX0geSBUaGUgWWpzIGluc3RhbmNlIGluIHdoaWNoIHRvIHF1ZXJ5IGZvciB0aGUgYWJzb2x1dGUgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvcyBUaGUgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAqIEByZXR1cm4ge0Fic29sdXRlUG9zaXRpb259IFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBpbiB0aGUgWWpzIG1vZGVsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlICsgb2Zmc2V0KS5cbiAgICovXG4gIGZ1bmN0aW9uIGZyb21SZWxhdGl2ZVBvc2l0aW9uKHksIHJwb3MpIHtcbiAgICBpZiAocnBvc1swXSA9PT0gJ2VuZG9mJykge1xuICAgICAgdmFyIGlkID0gdm9pZCAwO1xuICAgICAgaWYgKHJwb3NbM10gPT09IG51bGwpIHtcbiAgICAgICAgaWQgPSBuZXcgSUQocnBvc1sxXSwgcnBvc1syXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZCA9IG5ldyBSb290SUQocnBvc1szXSwgcnBvc1s0XSk7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHkub3MuZ2V0KGlkKTtcbiAgICAgIHdoaWxlICh0eXBlLl9yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUuX3JlZG9uZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUuY29uc3RydWN0b3IgPT09IEdDKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgb2Zmc2V0OiB0eXBlLmxlbmd0aFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgc3RydWN0ID0geS5vcy5maW5kTm9kZVdpdGhVcHBlckJvdW5kKG5ldyBJRChycG9zWzBdLCBycG9zWzFdKSkudmFsO1xuICAgICAgdmFyIGRpZmYgPSBycG9zWzFdIC0gc3RydWN0Ll9pZC5jbG9jaztcbiAgICAgIHdoaWxlIChzdHJ1Y3QuX3JlZG9uZSAhPT0gbnVsbCkge1xuICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3QuX3JlZG9uZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnQgPSBzdHJ1Y3QuX3BhcmVudDtcbiAgICAgIGlmIChzdHJ1Y3QuY29uc3RydWN0b3IgPT09IEdDIHx8IHBhcmVudC5fZGVsZXRlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghc3RydWN0Ll9kZWxldGVkKSB7XG4gICAgICAgIG9mZnNldCA9IGRpZmY7XG4gICAgICB9XG4gICAgICBzdHJ1Y3QgPSBzdHJ1Y3QuX2xlZnQ7XG4gICAgICB3aGlsZSAoc3RydWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghc3RydWN0Ll9kZWxldGVkKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IHN0cnVjdC5fbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHN0cnVjdCA9IHN0cnVjdC5fbGVmdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHBhcmVudCxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogcmVuYW1lIG11dGV4XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtdXR1YWwgZXhjbHVkZSBmdW5jdGlvbiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG11dHVhbEV4Y2x1ZGUgPSBjcmVhdGVNdXR1YWxFeGNsdWRlKClcbiAgICogbXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAqICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBpbW1lZGlhdGVseSBleGVjdXRlZFxuICAgKiAgIG11dHVhbEV4Y2x1ZGUoZnVuY3Rpb24gKCkge1xuICAgKiAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBuZXZlciBleGVjdXRlZCwgYXMgaXQgaXMgY2FsbGVkIHdpdGggdGhlIHNhbWVcbiAgICogICAgIC8vIG11dHVhbEV4Y2x1ZGVcbiAgICogICB9KVxuICAgKiB9KVxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBtdXR1YWwgZXhjbHVkZSBmdW5jdGlvblxuICAgKiBAcHVibGljXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVNdXR1YWxFeGNsdWRlKCkge1xuICAgIHZhciB0b2tlbiA9IHRydWU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG11dHVhbEV4Y2x1ZGUoZikge1xuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIHRva2VuID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYnN0cmFjdCBjbGFzcyBmb3IgYmluZGluZ3MuXG4gICAqXG4gICAqIEEgYmluZGluZyBoYW5kbGVzIGRhdGEgYmluZGluZyBmcm9tIGEgWWpzIHR5cGUgdG8gYSBkYXRhIG9iamVjdC4gRm9yIGV4YW1wbGUsXG4gICAqIHlvdSBjYW4gYmluZCBhIFF1aWxsIGVkaXRvciBpbnN0YW5jZSB0byBhIFlUZXh0IGluc3RhbmNlIHdpdGggdGhlIGBRdWlsbEJpbmRpbmdgIGNsYXNzLlxuICAgKlxuICAgKiBJdCBpcyBleHBlY3RlZCB0aGF0IGEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gYWNjZXB0cyB0d28gcGFyYW1ldGVyc1xuICAgKiAodHlwZSBhbmQgYmluZGluZyB0YXJnZXQpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGNvbnN0IHF1aWxsID0gbmV3IFF1aWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgKiAgIGNvbnN0IHR5cGUgPSB5LmRlZmluZSgncXVpbGwnLCBZLlRleHQpXG4gICAqICAgY29uc3QgYmluZGluZyA9IG5ldyBZLlF1aWxsQmluZGluZyhxdWlsbCwgdHlwZSlcbiAgICpcbiAgICovXG5cbiAgdmFyIEJpbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtZVHlwZX0gdHlwZSBZanMgdHlwZS5cbiAgICAgKiBAcGFyYW0ge2FueX0gdGFyZ2V0IEJpbmRpbmcgVGFyZ2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpbmRpbmcodHlwZSwgdGFyZ2V0KSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCaW5kaW5nKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgWWpzIHR5cGUgdGhhdCBpcyBib3VuZCB0byBgdGFyZ2V0YFxuICAgICAgICogQHR5cGUge1lUeXBlfVxuICAgICAgICovXG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdGFyZ2V0IHRoYXQgYHR5cGVgIGlzIGJvdW5kIHRvLlxuICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICB0aGlzLl9tdXR1YWxFeGNsdWRlID0gY3JlYXRlTXV0dWFsRXhjbHVkZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGRhdGEgb2JzZXJ2ZXJzIChib3RoIGZyb20gdGhlIHR5cGUgYW5kIHRoZSB0YXJnZXQpLlxuICAgICAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhCaW5kaW5nLCBbe1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQmluZGluZztcbiAgfSgpO1xuXG4gIC8qIGdsb2JhbHMgZ2V0U2VsZWN0aW9uICovXG5cbiAgdmFyIHJlbGF0aXZlU2VsZWN0aW9uID0gbnVsbDtcblxuICBmdW5jdGlvbiBfZ2V0Q3VycmVudFJlbGF0aXZlU2VsZWN0aW9uKGRvbUJpbmRpbmcpIHtcbiAgICB2YXIgX2dldFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbigpLFxuICAgICAgICBiYXNlTm9kZSA9IF9nZXRTZWxlY3Rpb24uYmFzZU5vZGUsXG4gICAgICAgIGJhc2VPZmZzZXQgPSBfZ2V0U2VsZWN0aW9uLmJhc2VPZmZzZXQsXG4gICAgICAgIGV4dGVudE5vZGUgPSBfZ2V0U2VsZWN0aW9uLmV4dGVudE5vZGUsXG4gICAgICAgIGV4dGVudE9mZnNldCA9IF9nZXRTZWxlY3Rpb24uZXh0ZW50T2Zmc2V0O1xuXG4gICAgdmFyIGJhc2VOb2RlVHlwZSA9IGRvbUJpbmRpbmcuZG9tVG9UeXBlLmdldChiYXNlTm9kZSk7XG4gICAgdmFyIGV4dGVudE5vZGVUeXBlID0gZG9tQmluZGluZy5kb21Ub1R5cGUuZ2V0KGV4dGVudE5vZGUpO1xuICAgIGlmIChiYXNlTm9kZVR5cGUgIT09IHVuZGVmaW5lZCAmJiBleHRlbnROb2RlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGJhc2VOb2RlVHlwZSwgYmFzZU9mZnNldCksXG4gICAgICAgIHRvOiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV4dGVudE5vZGVUeXBlLCBleHRlbnRPZmZzZXQpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBnZXRDdXJyZW50UmVsYXRpdmVTZWxlY3Rpb24gPSB0eXBlb2YgZ2V0U2VsZWN0aW9uICE9PSAndW5kZWZpbmVkJyA/IF9nZXRDdXJyZW50UmVsYXRpdmVTZWxlY3Rpb24gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb25GaXhlcihkb21CaW5kaW5nLCByZW1vdGUpIHtcbiAgICBpZiAocmVtb3RlKSB7XG4gICAgICByZWxhdGl2ZVNlbGVjdGlvbiA9IGdldEN1cnJlbnRSZWxhdGl2ZVNlbGVjdGlvbihkb21CaW5kaW5nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGFmdGVyVHJhbnNhY3Rpb25TZWxlY3Rpb25GaXhlcihkb21CaW5kaW5nLCByZW1vdGUpIHtcbiAgICBpZiAocmVsYXRpdmVTZWxlY3Rpb24gIT09IG51bGwgJiYgcmVtb3RlKSB7XG4gICAgICBkb21CaW5kaW5nLnJlc3RvcmVTZWxlY3Rpb24ocmVsYXRpdmVTZWxlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qIGdsb2JhbCBnZXRTZWxlY3Rpb24gKi9cblxuICBmdW5jdGlvbiBmaW5kU2Nyb2xsUmVmZXJlbmNlKHNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICBpZiAoc2Nyb2xsaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGFuY2hvciA9IGdldFNlbGVjdGlvbigpLmFuY2hvck5vZGU7XG4gICAgICBpZiAoYW5jaG9yID09IG51bGwpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gc2Nyb2xsaW5nRWxlbWVudC5jaGlsZHJlbjsgLy8gb25seSBpdGVyYXRlIHRocm91Z2ggbm9uLXRleHQgbm9kZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGVtID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGlmIChyZWN0LnRvcCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbGVtOiBlbGVtLCB0b3A6IHJlY3QudG9wIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYW5jaG9yLm5vZGVUeXBlID09PSBkb2N1bWVudC5URVhUX05PREUpIHtcbiAgICAgICAgICBhbmNob3IgPSBhbmNob3IucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9wID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgcmV0dXJuIHsgZWxlbTogYW5jaG9yLCB0b3A6IHRvcCB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpeFNjcm9sbChzY3JvbGxpbmdFbGVtZW50LCByZWYpIHtcbiAgICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgICB2YXIgZWxlbSA9IHJlZi5lbGVtLFxuICAgICAgICAgIHRvcCA9IHJlZi50b3A7XG5cbiAgICAgIHZhciBjdXJyZW50VG9wID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICB2YXIgbmV3U2Nyb2xsID0gc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgKyBjdXJyZW50VG9wIC0gdG9wO1xuICAgICAgaWYgKG5ld1Njcm9sbCA+PSAwKSB7XG4gICAgICAgIHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wID0gbmV3U2Nyb2xsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gdHlwZU9ic2VydmVyKGV2ZW50cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9tdXR1YWxFeGNsdWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzY3JvbGxSZWYgPSBmaW5kU2Nyb2xsUmVmZXJlbmNlKF90aGlzLnNjcm9sbGluZ0VsZW1lbnQpO1xuICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB5eG1sID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB2YXIgZG9tID0gX3RoaXMudHlwZVRvRG9tLmdldCh5eG1sKTtcbiAgICAgICAgaWYgKGRvbSAhPT0gdW5kZWZpbmVkICYmIGRvbSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoeXhtbC5jb25zdHJ1Y3RvciA9PT0gWVhtbFRleHQpIHtcbiAgICAgICAgICAgIGRvbS5ub2RlVmFsdWUgPSB5eG1sLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5hdHRyaWJ1dGVzQ2hhbmdlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgZXZlbnQuYXR0cmlidXRlc0NoYW5nZWQuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB5eG1sLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUT0RPOiBpbnN0ZWFkIG9mIGhhcmQtY2hlY2tpbmcgdGhlIHR5cGVzLCBpdCB3b3VsZCBiZSBiZXN0IHRvXG4gICAgICAgICAgICAgKiAgICAgICBzcGVjaWZ5IHRoZSB0eXBlJ3MgZmVhdHVyZXMuIEUuZy5cbiAgICAgICAgICAgICAqICAgICAgICAgLSBfeXhtbEhhc0F0dHJpYnV0ZXNcbiAgICAgICAgICAgICAqICAgICAgICAgLSBfeXhtbEhhc0NoaWxkcmVuXG4gICAgICAgICAgICAgKiAgICAgICBGdXJ0aGVybW9yZSwgdGhlIGZlYXR1cmVzIHNob3VsZG4ndCBiZSBlbmNvZGVkIGluIHRoZSB0eXBlcyxcbiAgICAgICAgICAgICAqICAgICAgIG9ubHkgaW4gdGhlIGF0dHJpYnV0ZXMgKGFib3ZlKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZXZlbnQuY2hpbGRMaXN0Q2hhbmdlZCAmJiB5eG1sLmNvbnN0cnVjdG9yICE9PSBZWG1sSG9vaykge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudENoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIHl4bWwuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IF90aGlzLnR5cGVUb0RvbS5nZXQoY2hpbGRUeXBlKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvZXMgbm90IGV4aXN0LiBDcmVhdGUgaXQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY2hpbGRUeXBlLnRvRG9tKF90aGlzLm9wdHMuZG9jdW1lbnQsIF90aGlzLm9wdHMuaG9va3MsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tLmluc2VydEJlZm9yZShub2RlLCBjdXJyZW50Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vcFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIElzIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhlIGRvbS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBpdCBhbmQgcmVtb3ZlIGFsbCBkb20gbm9kZXMgaW4tYmV0d2Vlbi5cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tQ2hpbGRyZW5VbnRpbEVsZW1lbnRGb3VuZChkb20sIGN1cnJlbnRDaGlsZCwgY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoaWxkID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZW1vdmVEb21DaGlsZHJlblVudGlsRWxlbWVudEZvdW5kKGRvbSwgY3VycmVudENoaWxkLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZml4U2Nyb2xsKF90aGlzLnNjcm9sbGluZ0VsZW1lbnQsIHNjcm9sbFJlZik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBTaW1wbGVEaWZmIGRlc2NyaWJlcyBhIGNoYW5nZSBvbiBhIFN0cmluZy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc29sZS5sb2coYSkgLy8gdGhlIG9sZCB2YWx1ZVxuICAgKiBjb25zb2xlLmxvZyhiKSAvLyB0aGUgdXBkYXRlZCB2YWx1ZVxuICAgKiAvLyBBcHBseSBjaGFuZ2VzIG9mIGRpZmYgKHBzZXVkb2NvZGUpXG4gICAqIGEucmVtb3ZlKGRpZmYucG9zLCBkaWZmLnJlbW92ZSkgLy8gUmVtb3ZlIGBkaWZmLnJlbW92ZWAgY2hhcmFjdGVyc1xuICAgKiBhLmluc2VydChkaWZmLnBvcywgZGlmZi5pbnNlcnQpIC8vIEluc2VydCBgZGlmZi5pbnNlcnRgXG4gICAqIGEgPT09IGIgLy8gdmFsdWVzIG1hdGNoXG4gICAqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFNpbXBsZURpZmZcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHBvcyBUaGUgaW5kZXggd2hlcmUgY2hhbmdlcyB3ZXJlIGFwcGxpZWRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlbGV0ZSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gZGVsZXRlIHN0YXJ0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0IGBpbmRleGAuXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBpbnNlcnQgVGhlIG5ldyB0ZXh0IHRvIGluc2VydCBhdCBgaW5kZXhgIGFmdGVyIGFwcGx5aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgYGRlbGV0ZWBcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRpZmYgYmV0d2VlbiB0d28gc3RyaW5ncy4gVGhpcyBkaWZmIGltcGxlbWVudGF0aW9uIGlzIGhpZ2hseVxuICAgKiBlZmZpY2llbnQsIGJ1dCBub3QgdmVyeSBzb3BoaXN0aWNhdGVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhIFRoZSBvbGQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBiIFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtTaW1wbGVEaWZmfSBUaGUgZGlmZiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHNpbXBsZURpZmYoYSwgYikge1xuICAgIHZhciBsZWZ0ID0gMDsgLy8gbnVtYmVyIG9mIHNhbWUgY2hhcmFjdGVycyBjb3VudGluZyBmcm9tIGxlZnRcbiAgICB2YXIgcmlnaHQgPSAwOyAvLyBudW1iZXIgb2Ygc2FtZSBjaGFyYWN0ZXJzIGNvdW50aW5nIGZyb20gcmlnaHRcbiAgICB3aGlsZSAobGVmdCA8IGEubGVuZ3RoICYmIGxlZnQgPCBiLmxlbmd0aCAmJiBhW2xlZnRdID09PSBiW2xlZnRdKSB7XG4gICAgICBsZWZ0Kys7XG4gICAgfVxuICAgIGlmIChsZWZ0ICE9PSBhLmxlbmd0aCB8fCBsZWZ0ICE9PSBiLmxlbmd0aCkge1xuICAgICAgLy8gT25seSBjaGVjayByaWdodCBpZiBhICE9PSBiXG4gICAgICB3aGlsZSAocmlnaHQgKyBsZWZ0IDwgYS5sZW5ndGggJiYgcmlnaHQgKyBsZWZ0IDwgYi5sZW5ndGggJiYgYVthLmxlbmd0aCAtIHJpZ2h0IC0gMV0gPT09IGJbYi5sZW5ndGggLSByaWdodCAtIDFdKSB7XG4gICAgICAgIHJpZ2h0Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwb3M6IGxlZnQsIC8vIFRPRE86IHJlbmFtZSB0byBpbmRleCAoYWxzbyBpbiB0eXBlIGFib3ZlKVxuICAgICAgcmVtb3ZlOiBhLmxlbmd0aCAtIGxlZnQgLSByaWdodCxcbiAgICAgIGluc2VydDogYi5zbGljZShsZWZ0LCBiLmxlbmd0aCAtIHJpZ2h0KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogMS4gQ2hlY2sgaWYgYW55IG9mIHRoZSBub2RlcyB3YXMgZGVsZXRlZFxuICAgKiAyLiBJdGVyYXRlIG92ZXIgdGhlIGNoaWxkcmVuLlxuICAgKiAgICAyLjEgSWYgYSBub2RlIGV4aXN0cyB0aGF0IGlzIG5vdCB5ZXQgYm91bmQgdG8gYSB0eXBlLCBpbnNlcnQgYSBuZXcgbm9kZVxuICAgKiAgICAyLjIgSWYgX2NvbnRlbnRzLmxlbmd0aCA8IGRvbS5jaGlsZE5vZGVzLmxlbmd0aCwgZmlsbCB0aGVcbiAgICogICAgICAgIHJlc3Qgb2YgX2NvbnRlbnQgd2l0aCBjaGlsZE5vZGVzXG4gICAqICAgIDIuMyBJZiBhIG5vZGUgd2FzIG1vdmVkLCBkZWxldGUgaXQgYW5kXG4gICAqICAgICAgIHJlY3JlYXRlIGEgbmV3IHl4bWwgZWxlbWVudCB0aGF0IGlzIGJvdW5kIHRvIHRoYXQgbm9kZS5cbiAgICogICAgICAgWW91IGNhbiBkZXRlY3QgdGhhdCBhIG5vZGUgd2FzIG1vdmVkIGJlY2F1c2UgZXhwZWN0ZWRJZFxuICAgKiAgICAgICAhPT0gYWN0dWFsSWQgaW4gdGhlIGxpc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5Q2hhbmdlc0Zyb21Eb20oYmluZGluZywgZG9tLCB5eG1sLCBfZG9jdW1lbnQpIHtcbiAgICBpZiAoeXhtbCA9PSBudWxsIHx8IHl4bWwgPT09IGZhbHNlIHx8IHl4bWwuY29uc3RydWN0b3IgPT09IFlYbWxIb29rKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB5ID0geXhtbC5feTtcbiAgICB2YXIga25vd25DaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKHZhciBpID0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB0eXBlID0gYmluZGluZy5kb21Ub1R5cGUuZ2V0KGRvbS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZSAhPT0gZmFsc2UpIHtcbiAgICAgICAga25vd25DaGlsZHJlbi5hZGQodHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIDEuIENoZWNrIGlmIGFueSBvZiB0aGUgbm9kZXMgd2FzIGRlbGV0ZWRcbiAgICB5eG1sLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkVHlwZSkge1xuICAgICAgaWYgKGtub3duQ2hpbGRyZW4uaGFzKGNoaWxkVHlwZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoaWxkVHlwZS5fZGVsZXRlKHkpO1xuICAgICAgICByZW1vdmVBc3NvY2lhdGlvbihiaW5kaW5nLCBiaW5kaW5nLnR5cGVUb0RvbS5nZXQoY2hpbGRUeXBlKSwgY2hpbGRUeXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyAyLiBpdGVyYXRlXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBkb20uY2hpbGROb2RlcztcbiAgICB2YXIgbGVuID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgdmFyIHByZXZFeHBlY3RlZFR5cGUgPSBudWxsO1xuICAgIHZhciBleHBlY3RlZFR5cGUgPSBpdGVyYXRlVW50aWxVbmRlbGV0ZWQoeXhtbC5fc3RhcnQpO1xuICAgIGZvciAodmFyIGRvbUNudCA9IDA7IGRvbUNudCA8IGxlbjsgZG9tQ250KyspIHtcbiAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2RvbUNudF07XG4gICAgICB2YXIgY2hpbGRUeXBlID0gYmluZGluZy5kb21Ub1R5cGUuZ2V0KGNoaWxkTm9kZSk7XG4gICAgICBpZiAoY2hpbGRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBzaG91bGQgYmUgaWdub3JlZCBvciBpcyBnb2luZyB0byBiZSBkZWxldGVkXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGVjdGVkVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChleHBlY3RlZFR5cGUgIT09IGNoaWxkVHlwZSkge1xuICAgICAgICAgICAgLy8gMi4zIE5vdCBleHBlY3RlZCBub2RlXG4gICAgICAgICAgICBpZiAoY2hpbGRUeXBlLl9wYXJlbnQgIT09IHl4bWwpIHtcbiAgICAgICAgICAgICAgLy8gY2hpbGQgd2FzIG1vdmVkIGZyb20gYW5vdGhlciBwYXJlbnRcbiAgICAgICAgICAgICAgLy8gY2hpbGRUeXBlIGlzIGdvaW5nIHRvIGJlIGRlbGV0ZWQgYnkgaXRzIHByZXZpb3VzIHBhcmVudFxuICAgICAgICAgICAgICByZW1vdmVBc3NvY2lhdGlvbihiaW5kaW5nLCBjaGlsZE5vZGUsIGNoaWxkVHlwZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjaGlsZCB3YXMgbW92ZWQgdG8gYSBkaWZmZXJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgIHJlbW92ZUFzc29jaWF0aW9uKGJpbmRpbmcsIGNoaWxkTm9kZSwgY2hpbGRUeXBlKTtcbiAgICAgICAgICAgICAgY2hpbGRUeXBlLl9kZWxldGUoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RXhwZWN0ZWRUeXBlID0gaW5zZXJ0Tm9kZUhlbHBlcih5eG1sLCBwcmV2RXhwZWN0ZWRUeXBlLCBjaGlsZE5vZGUsIF9kb2N1bWVudCwgYmluZGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGV4cGVjdGVkIG5vZGUuIENvbnRpbnVlLlxuICAgICAgICAgICAgcHJldkV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZSA9IGl0ZXJhdGVVbnRpbFVuZGVsZXRlZChleHBlY3RlZFR5cGUuX3JpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gMi4yIEZpbGwgX2NvbnRlbnQgd2l0aCBjaGlsZCBub2Rlc1xuICAgICAgICAgIHByZXZFeHBlY3RlZFR5cGUgPSBpbnNlcnROb2RlSGVscGVyKHl4bWwsIHByZXZFeHBlY3RlZFR5cGUsIGNoaWxkTm9kZSwgX2RvY3VtZW50LCBiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMi4xIEEgbmV3IG5vZGUgd2FzIGZvdW5kXG4gICAgICAgIHByZXZFeHBlY3RlZFR5cGUgPSBpbnNlcnROb2RlSGVscGVyKHl4bWwsIHByZXZFeHBlY3RlZFR5cGUsIGNoaWxkTm9kZSwgX2RvY3VtZW50LCBiaW5kaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGRvbU9ic2VydmVyKG11dGF0aW9ucywgX2RvY3VtZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX211dHVhbEV4Y2x1ZGUoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMudHlwZS5feS50cmFuc2FjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaWZmQ2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICAgIHZhciBkb20gPSBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgICAgdmFyIHl4bWwgPSBfdGhpcy5kb21Ub1R5cGUuZ2V0KGRvbSk7XG4gICAgICAgICAgaWYgKHl4bWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSB5eG1sIGlzIHVuZGVmaW5lZCwgd2UgZG91YmxlIGNoZWNrIGlmIHdlIGZvcmdvdCB0byBiaW5kIHRoZSBkb21cbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBkb207XG4gICAgICAgICAgICB2YXIgeVBhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgIHlQYXJlbnQgPSBfdGhpcy5kb21Ub1R5cGUuZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICB9IHdoaWxlICh5UGFyZW50ID09PSB1bmRlZmluZWQgJiYgcGFyZW50ICE9PSBudWxsKTtcbiAgICAgICAgICAgIGlmICh5UGFyZW50ICE9PSBmYWxzZSAmJiB5UGFyZW50ICE9PSB1bmRlZmluZWQgJiYgeVBhcmVudC5jb25zdHJ1Y3RvciAhPT0gWVhtbEhvb2spIHtcbiAgICAgICAgICAgICAgZGlmZkNoaWxkcmVuLmFkZChwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAoeXhtbCA9PT0gZmFsc2UgfHwgeXhtbC5jb25zdHJ1Y3RvciA9PT0gWVhtbEhvb2spIHtcbiAgICAgICAgICAgIC8vIGRvbSBlbGVtZW50IGlzIGZpbHRlcmVkIC8gYSBkb20gaG9va1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKG11dGF0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NoYXJhY3RlckRhdGEnOlxuICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gc2ltcGxlRGlmZih5eG1sLnRvU3RyaW5nKCksIGRvbS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgICB5eG1sLmRlbGV0ZShjaGFuZ2UucG9zLCBjaGFuZ2UucmVtb3ZlKTtcbiAgICAgICAgICAgICAgeXhtbC5pbnNlcnQoY2hhbmdlLnBvcywgY2hhbmdlLmluc2VydCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgIGlmICh5eG1sLmNvbnN0cnVjdG9yID09PSBZWG1sRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmFtZSA9IG11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBkb20uZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgICAvLyBjaGVjayBpZiBmaWx0ZXIgYWNjZXB0cyBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc2V0KG5hbWUsIHZhbCk7XG4gICAgICAgICAgICAgIGlmICh5eG1sLmNvbnN0cnVjdG9yICE9PSBZWG1sRnJhZ21lbnQgJiYgX3RoaXMuZmlsdGVyKGRvbS5ub2RlTmFtZSwgYXR0cmlidXRlcykuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeXhtbC5nZXRBdHRyaWJ1dGUobmFtZSkgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHl4bWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeXhtbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjaGlsZExpc3QnOlxuICAgICAgICAgICAgICBkaWZmQ2hpbGRyZW4uYWRkKG11dGF0aW9uLnRhcmdldCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGRpZmZDaGlsZHJlbltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBkb20gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgdmFyIHl4bWwgPSBfdGhpcy5kb21Ub1R5cGUuZ2V0KGRvbSk7XG4gICAgICAgICAgICBhcHBseUNoYW5nZXNGcm9tRG9tKF90aGlzLCBkb20sIHl4bWwsIF9kb2N1bWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBnbG9iYWwgTXV0YXRpb25PYnNlcnZlciwgZ2V0U2VsZWN0aW9uICovXG5cbiAgLyoqXG4gICAqIEEgYmluZGluZyB0aGF0IGJpbmRzIHRoZSBjaGlsZHJlbiBvZiBhIFlYbWxGcmFnbWVudCB0byBhIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBUaGlzIGJpbmRpbmcgaXMgYXV0b21hdGljYWxseSBkZXN0cm95ZWQgd2hlbiBpdHMgcGFyZW50IGlzIGRlbGV0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAqIGNvbnN0IHR5cGUgPSB5LmRlZmluZSgneG1sJywgWS5YbWxGcmFnbWVudClcbiAgICogY29uc3QgYmluZGluZyA9IG5ldyBZLlF1aWxsQmluZGluZyh0eXBlLCBkaXYpXG4gICAqXG4gICAqL1xuXG4gIHZhciBEb21CaW5kaW5nID0gZnVuY3Rpb24gKF9CaW5kaW5nKSB7XG4gICAgaW5oZXJpdHMoRG9tQmluZGluZywgX0JpbmRpbmcpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtZWG1sRnJhZ21lbnR9IHR5cGUgVGhlIGJpbmQgc291cmNlLiBUaGlzIGlzIHRoZSB1bHRpbWF0ZSBzb3VyY2Ugb2ZcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnV0aC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCBUaGUgYmluZCB0YXJnZXQuIE1pcnJvcnMgdGhlIHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb25zXG4gICAgICAqIEBwYXJhbSB7RmlsdGVyRnVuY3Rpb259IFtvcHRzLmZpbHRlcj1kZWZhdWx0RmlsdGVyXSBUaGUgZmlsdGVyIGZ1bmN0aW9uIHRvIHVzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEb21CaW5kaW5nKHR5cGUsIHRhcmdldCkge1xuICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9tQmluZGluZyk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERvbUJpbmRpbmcuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEb21CaW5kaW5nKSkuY2FsbCh0aGlzLCB0eXBlLCB0YXJnZXQpKTtcbiAgICAgIC8vIEJpbmRpbmcgaGFuZGxlcyB0ZXh0VHlwZSBhcyB0aGlzLnR5cGUgYW5kIGRvbVRleHRhcmVhIGFzIHRoaXMudGFyZ2V0XG5cblxuICAgICAgX3RoaXMub3B0cyA9IG9wdHM7XG4gICAgICBvcHRzLmRvY3VtZW50ID0gb3B0cy5kb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgIG9wdHMuaG9va3MgPSBvcHRzLmhvb2tzIHx8IHt9O1xuICAgICAgX3RoaXMuc2Nyb2xsaW5nRWxlbWVudCA9IG9wdHMuc2Nyb2xsaW5nRWxlbWVudCB8fCBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBNYXBzIGVhY2ggRE9NIGVsZW1lbnQgdG8gdGhlIHR5cGUgdGhhdCBpdCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgICAgKiBAdHlwZSB7TWFwfVxuICAgICAgICovXG4gICAgICBfdGhpcy5kb21Ub1R5cGUgPSBuZXcgTWFwKCk7XG4gICAgICAvKipcbiAgICAgICAqIE1hcHMgZWFjaCBZWG1sIHR5cGUgdG8gdGhlIERPTSBlbGVtZW50IHRoYXQgaXQgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICAgICogQHR5cGUge01hcH1cbiAgICAgICAqL1xuICAgICAgX3RoaXMudHlwZVRvRG9tID0gbmV3IE1hcCgpO1xuICAgICAgLyoqXG4gICAgICAgKiBEZWZpbmVzIHdoaWNoIERPTSBhdHRyaWJ1dGVzIGFuZCBlbGVtZW50cyB0byBmaWx0ZXIgb3V0LlxuICAgICAgICogQWxzbyBmaWx0ZXJzIHJlbW90ZSBjaGFuZ2VzLlxuICAgICAgICogQHR5cGUge0ZpbHRlckZ1bmN0aW9ufVxuICAgICAgICovXG4gICAgICBfdGhpcy5maWx0ZXIgPSBvcHRzLmZpbHRlciB8fCBkZWZhdWx0RmlsdGVyO1xuICAgICAgLy8gc2V0IGluaXRpYWwgdmFsdWVcbiAgICAgIHRhcmdldC5pbm5lckhUTUwgPSAnJztcbiAgICAgIHR5cGUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShjaGlsZC50b0RvbShvcHRzLmRvY3VtZW50LCBvcHRzLmhvb2tzLCBfdGhpcyksIG51bGwpO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5fdHlwZU9ic2VydmVyID0gdHlwZU9ic2VydmVyLmJpbmQoX3RoaXMpO1xuICAgICAgX3RoaXMuX2RvbU9ic2VydmVyID0gZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgICBkb21PYnNlcnZlci5jYWxsKF90aGlzLCBtdXRhdGlvbnMsIG9wdHMuZG9jdW1lbnQpO1xuICAgICAgfTtcbiAgICAgIHR5cGUub2JzZXJ2ZURlZXAoX3RoaXMuX3R5cGVPYnNlcnZlcik7XG4gICAgICBfdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKF90aGlzLl9kb21PYnNlcnZlcik7XG4gICAgICBfdGhpcy5fbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgX3RoaXMuX2N1cnJlbnRTZWwgPSBudWxsO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fY3VycmVudFNlbCA9IGdldEN1cnJlbnRSZWxhdGl2ZVNlbGVjdGlvbihfdGhpcyk7XG4gICAgICB9KTtcbiAgICAgIHZhciB5ID0gdHlwZS5feTtcbiAgICAgIF90aGlzLnkgPSB5O1xuICAgICAgLy8gRm9yY2UgZmx1c2ggZG9tIGNoYW5nZXMgYmVmb3JlIFR5cGUgY2hhbmdlcyBhcmUgYXBwbGllZCAodGhleSBtaWdodFxuICAgICAgLy8gbW9kaWZ5IHRoZSBkb20pXG4gICAgICBfdGhpcy5fYmVmb3JlVHJhbnNhY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24gKHksIHRyYW5zYWN0aW9uLCByZW1vdGUpIHtcbiAgICAgICAgX3RoaXMuX2RvbU9ic2VydmVyKF90aGlzLl9tdXRhdGlvbk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgICBfdGhpcy5fbXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb25GaXhlcihfdGhpcywgcmVtb3RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgeS5vbignYmVmb3JlVHJhbnNhY3Rpb24nLCBfdGhpcy5fYmVmb3JlVHJhbnNhY3Rpb25IYW5kbGVyKTtcbiAgICAgIF90aGlzLl9hZnRlclRyYW5zYWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICh5LCB0cmFuc2FjdGlvbiwgcmVtb3RlKSB7XG4gICAgICAgIF90aGlzLl9tdXR1YWxFeGNsdWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhZnRlclRyYW5zYWN0aW9uU2VsZWN0aW9uRml4ZXIoX3RoaXMsIHJlbW90ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZW1vdmUgYXNzb2NpYXRpb25zXG4gICAgICAgIC8vIFRPRE86IHRoaXMgY291bGQgYmUgZG9uZSBtb3JlIGVmZmljaWVudGx5XG4gICAgICAgIC8vIGUuZy4gQWx3YXlzIGRlbGV0ZSB1c2luZyB0aGUgZm9sbG93aW5nIGFwcHJvYWNoLCBvciByZW1vdmVBc3NvY2lhdGlvblxuICAgICAgICAvLyBpbiBkb20vdHlwZS1vYnNlcnZlci4uXG4gICAgICAgIHRyYW5zYWN0aW9uLmRlbGV0ZWRTdHJ1Y3RzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICB2YXIgZG9tID0gX3RoaXMudHlwZVRvRG9tLmdldCh0eXBlKTtcbiAgICAgICAgICBpZiAoZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbW92ZUFzc29jaWF0aW9uKF90aGlzLCBkb20sIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgeS5vbignYWZ0ZXJUcmFuc2FjdGlvbicsIF90aGlzLl9hZnRlclRyYW5zYWN0aW9uSGFuZGxlcik7XG4gICAgICAvLyBCZWZvcmUgY2FsbGluZyBvYnNlcnZlcnMsIGFwcGx5IGRvbSBmaWx0ZXIgdG8gYWxsIGNoYW5nZWQgYW5kIG5ldyB0eXBlcy5cbiAgICAgIF90aGlzLl9iZWZvcmVPYnNlcnZlckNhbGxzSGFuZGxlciA9IGZ1bmN0aW9uICh5LCB0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBBcHBseSBkb20gZmlsdGVyIHRvIG5ldyBhbmQgY2hhbmdlZCB0eXBlc1xuICAgICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VicywgdHlwZSkge1xuICAgICAgICAgIC8vIE9ubHkgY2hlY2sgYXR0cmlidXRlcy4gTmV3IHR5cGVzIGFyZSBmaWx0ZXJlZCBiZWxvdy5cbiAgICAgICAgICBpZiAoc3Vicy5zaXplID4gMSB8fCBzdWJzLnNpemUgPT09IDEgJiYgc3Vicy5oYXMobnVsbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhcHBseUZpbHRlck9uVHlwZSh5LCBfdGhpcywgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubmV3VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIGFwcGx5RmlsdGVyT25UeXBlKHksIF90aGlzLCB0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgeS5vbignYmVmb3JlT2JzZXJ2ZXJDYWxscycsIF90aGlzLl9iZWZvcmVPYnNlcnZlckNhbGxzSGFuZGxlcik7XG4gICAgICBjcmVhdGVBc3NvY2lhdGlvbihfdGhpcywgdGFyZ2V0LCB0eXBlKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOT1RFOiBjdXJyZW50bHkgZG9lcyBub3QgYXBwbHkgZmlsdGVyIHRvIGV4aXN0aW5nIGVsZW1lbnRzIVxuICAgICAqIEBwYXJhbSB7RmlsdGVyRnVuY3Rpb259IGZpbHRlciBUaGUgZmlsdGVyIGZ1bmN0aW9uIHRvIHVzZSBmcm9tIG5vdyBvbi5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoRG9tQmluZGluZywgW3tcbiAgICAgIGtleTogJ3NldEZpbHRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmlsdGVyKGZpbHRlcikge1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgLy8gVE9ETzogYXBwbHkgZmlsdGVyIHRvIGFsbCBlbGVtZW50c1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRVbmRvU3RhY2tJbmZvJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VW5kb1N0YWNrSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3Jlc3RvcmVVbmRvU3RhY2tJbmZvJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZVVuZG9TdGFja0luZm8oaW5mbykge1xuICAgICAgICB0aGlzLnJlc3RvcmVTZWxlY3Rpb24oaW5mbyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0U2VsZWN0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U2VsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Jlc3RvcmVTZWxlY3Rpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgdG8gPSBzZWxlY3Rpb24udG8sXG4gICAgICAgICAgICAgIGZyb20gPSBzZWxlY3Rpb24uZnJvbTtcblxuICAgICAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGVyZSBpcyBsaXR0bGUgaW5mb3JtYXRpb24gb24gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhbmNob3IvZm9jdXMgYW5kIGJhc2UvZXh0ZW50LlxuICAgICAgICAgICAqIE1ETiBkb2Vzbid0IGV2ZW4gbWVudGlvbiBiYXNlL2V4dGVudCBhbnltb3JlLi4gdGhvdWdoIHlvdSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAgICAgICAgKiBzZXRCYXNlQW5kRXh0ZW50IHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uLi5cbiAgICAgICAgICAgKiBJIGNhbiBvYnNlcnZlIHRoYXQgYmFzZS9leHRlbmQgcmVmZXIgdG8gbm90ZXMgaGlnaGVyIHVwIGluIHRoZSB4bWwgaGllcmFjaHkuXG4gICAgICAgICAgICogRXNwZXNpYWxseSBmb3IgdW5kby9yZWRvIHRoaXMgaXMgcHJlZmVycmVkLiBJZiB0aGlzIGJlY29tZXMgYSBwcm9ibGVtIGluIHRoZSBmdXR1cmUsXG4gICAgICAgICAgICogd2Ugc2hvdWxkIHByb2JhYmx5IGdvIGJhY2sgdG8gYW5jaG9yL2ZvY3VzLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBicm93c2VyU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgdmFyIGJhc2VOb2RlID0gYnJvd3NlclNlbGVjdGlvbi5iYXNlTm9kZSxcbiAgICAgICAgICAgICAgYmFzZU9mZnNldCA9IGJyb3dzZXJTZWxlY3Rpb24uYmFzZU9mZnNldCxcbiAgICAgICAgICAgICAgZXh0ZW50Tm9kZSA9IGJyb3dzZXJTZWxlY3Rpb24uZXh0ZW50Tm9kZSxcbiAgICAgICAgICAgICAgZXh0ZW50T2Zmc2V0ID0gYnJvd3NlclNlbGVjdGlvbi5leHRlbnRPZmZzZXQ7XG5cbiAgICAgICAgICBpZiAoZnJvbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHNlbCA9IGZyb21SZWxhdGl2ZVBvc2l0aW9uKHRoaXMueSwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoc2VsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy50eXBlVG9Eb20uZ2V0KHNlbC50eXBlKTtcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHNlbC5vZmZzZXQ7XG4gICAgICAgICAgICAgIGlmIChub2RlICE9PSBiYXNlTm9kZSB8fCBvZmZzZXQgIT09IGJhc2VPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBiYXNlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgYmFzZU9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0byAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9zZWwgPSBmcm9tUmVsYXRpdmVQb3NpdGlvbih0aGlzLnksIHRvKTtcbiAgICAgICAgICAgIGlmIChfc2VsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBfbm9kZSA9IHRoaXMudHlwZVRvRG9tLmdldChfc2VsLnR5cGUpO1xuICAgICAgICAgICAgICB2YXIgX29mZnNldCA9IF9zZWwub2Zmc2V0O1xuICAgICAgICAgICAgICBpZiAoX25vZGUgIT09IGV4dGVudE5vZGUgfHwgX29mZnNldCAhPT0gZXh0ZW50T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50Tm9kZSA9IF9ub2RlO1xuICAgICAgICAgICAgICAgIGV4dGVudE9mZnNldCA9IF9vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICBicm93c2VyU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQoYmFzZU5vZGUsIGJhc2VPZmZzZXQsIGV4dGVudE5vZGUsIGV4dGVudE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGFsbCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGhhbmRsZWQgYnkgdGhpcyBjbGFzcy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kb21Ub1R5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLnR5cGVUb0RvbSA9IG51bGw7XG4gICAgICAgIHRoaXMudHlwZS51bm9ic2VydmVEZWVwKHRoaXMuX3R5cGVPYnNlcnZlcik7XG4gICAgICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB2YXIgeSA9IHRoaXMudHlwZS5feTtcbiAgICAgICAgeS5vZmYoJ2JlZm9yZVRyYW5zYWN0aW9uJywgdGhpcy5fYmVmb3JlVHJhbnNhY3Rpb25IYW5kbGVyKTtcbiAgICAgICAgeS5vZmYoJ2JlZm9yZU9ic2VydmVyQ2FsbHMnLCB0aGlzLl9iZWZvcmVPYnNlcnZlckNhbGxzSGFuZGxlcik7XG4gICAgICAgIHkub2ZmKCdhZnRlclRyYW5zYWN0aW9uJywgdGhpcy5fYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIpO1xuICAgICAgICBnZXQoRG9tQmluZGluZy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEb21CaW5kaW5nLnByb3RvdHlwZSksICdkZXN0cm95JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIERvbUJpbmRpbmc7XG4gIH0oQmluZGluZyk7XG5cbiAgLyoqXG4gICAqIEFueXRoaW5nIHRoYXQgY2FuIGJlIGVuY29kZWQgd2l0aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBjYW4gYmUgZGVjb2RlZCB3aXRoXG4gICAqIGBKU09OLnBhcnNlYC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0eSBzaG91bGQgaG9sZDpcbiAgICogYEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoa2V5KSk9PT1rZXlgXG4gICAqXG4gICAqIEF0IHRoZSBtb21lbnQgdGhlIG9ubHkgc2FmZSB2YWx1ZXMgYXJlIG51bWJlciBhbmQgc3RyaW5nLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7KG51bWJlcnxzdHJpbmcpfSBlbmNvZGFibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgWWpzIGluc3RhbmNlIGhhbmRsZXMgdGhlIHN0YXRlIG9mIHNoYXJlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vbSBVc2VycyBpbiB0aGUgc2FtZSByb29tIHNoYXJlIHRoZSBzYW1lIGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgQ29ubmVjdG9yIGRlZmluaXRpb25cbiAgICogQHBhcmFtIHtBYnN0cmFjdFBlcnNpc3RlbmNlfSBwZXJzaXN0ZW5jZSBQZXJzaXN0ZW5jZSBhZGFwdGVyIGluc3RhbmNlXG4gICAqL1xuXG4gIHZhciBZID0gZnVuY3Rpb24gKF9OYW1lZEV2ZW50SGFuZGxlcikge1xuICAgIGluaGVyaXRzKFksIF9OYW1lZEV2ZW50SGFuZGxlcik7XG5cbiAgICBmdW5jdGlvbiBZKHJvb20sIG9wdHMsIHBlcnNpc3RlbmNlKSB7XG4gICAgICB2YXIgY29uZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBZKTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoWS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFkpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgX3RoaXMuZ2NFbmFibGVkID0gY29uZi5nYyB8fCBmYWxzZTtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJvb20gbmFtZSB0aGF0IHRoaXMgWWpzIGluc3RhbmNlIGNvbm5lY3RzIHRvLlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgX3RoaXMucm9vbSA9IHJvb207XG4gICAgICBpZiAob3B0cyAhPSBudWxsKSB7XG4gICAgICAgIG9wdHMuY29ubmVjdG9yLnJvb20gPSByb29tO1xuICAgICAgfVxuICAgICAgX3RoaXMuX2NvbnRlbnRSZWFkeSA9IGZhbHNlO1xuICAgICAgX3RoaXMuX29wdHMgPSBvcHRzO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLnVzZXJJRCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgX3RoaXMudXNlcklEID0gZ2VuZXJhdGVSYW5kb21VaW50MzIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnVzZXJJRCA9IG9wdHMudXNlcklEO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgYSBNYXAgc28gd2UgY2FuIHVzZSBlbmNvZGFibGVzIGFzIGtleXNcbiAgICAgIF90aGlzLnNoYXJlID0ge307XG4gICAgICBfdGhpcy5kcyA9IG5ldyBEZWxldGVTdG9yZShfdGhpcyk7XG4gICAgICBfdGhpcy5vcyA9IG5ldyBPcGVyYXRpb25TdG9yZShfdGhpcyk7XG4gICAgICBfdGhpcy5zcyA9IG5ldyBTdGF0ZVN0b3JlKF90aGlzKTtcbiAgICAgIF90aGlzLl9taXNzaW5nU3RydWN0cyA9IG5ldyBNYXAoKTtcbiAgICAgIF90aGlzLl9yZWFkeVRvSW50ZWdyYXRlID0gW107XG4gICAgICBfdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUge0BsaW5rIEFic3RyYWN0Q29ubmVjdG9yfS50aGF0IGlzIHVzZWQgYnkgdGhpcyBZanMgaW5zdGFuY2UuXG4gICAgICAgKiBAdHlwZSB7QWJzdHJhY3RDb25uZWN0b3J9XG4gICAgICAgKi9cbiAgICAgIF90aGlzLmNvbm5lY3RvciA9IG51bGw7XG4gICAgICBfdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBpbml0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIGluaXRDb25uZWN0aW9uKCkge1xuICAgICAgICBpZiAob3B0cyAhPSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMuY29ubmVjdG9yID0gbmV3IFlbb3B0cy5jb25uZWN0b3IubmFtZV0oX3RoaXMsIG9wdHMuY29ubmVjdG9yKTtcbiAgICAgICAgICBfdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIF90aGlzLmVtaXQoJ2Nvbm5lY3RvclJlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB7QGxpbmsgQWJzdHJhY3RQZXJzaXN0ZW5jZX0gdGhhdCBpcyB1c2VkIGJ5IHRoaXMgWWpzIGluc3RhbmNlLlxuICAgICAgICogQHR5cGUge0Fic3RyYWN0UGVyc2lzdGVuY2V9XG4gICAgICAgKi9cbiAgICAgIF90aGlzLnBlcnNpc3RlbmNlID0gbnVsbDtcbiAgICAgIGlmIChwZXJzaXN0ZW5jZSAhPSBudWxsKSB7XG4gICAgICAgIF90aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XG4gICAgICAgIHBlcnNpc3RlbmNlLl9pbml0KF90aGlzKS50aGVuKGluaXRDb25uZWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRDb25uZWN0aW9uKCk7XG4gICAgICB9XG4gICAgICAvLyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGlzUGFyZW50T2ZcbiAgICAgIF90aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgX3RoaXMuX2hhc1VuZG9NYW5hZ2VyID0gZmFsc2U7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoWSwgW3tcbiAgICAgIGtleTogJ19zZXRDb250ZW50UmVhZHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDb250ZW50UmVhZHkoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29udGVudFJlYWR5KSB7XG4gICAgICAgICAgdGhpcy5fY29udGVudFJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NvbnRlbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3doZW5Db250ZW50UmVhZHknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdoZW5Db250ZW50UmVhZHkoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50UmVhZHkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBfdGhpczIub25jZSgnY29udGVudCcsIHJlc29sdmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2JlZm9yZUNoYW5nZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2JlZm9yZUNoYW5nZSgpIHt9XG4gICAgICAvKipcbiAgICAgICAqIENoYW5nZXMgdGhhdCBoYXBwZW4gaW5zaWRlIG9mIGEgdHJhbnNhY3Rpb24gYXJlIGJ1bmRsZWQuIFRoaXMgbWVhbnMgdGhhdFxuICAgICAgICogdGhlIG9ic2VydmVyIGZpcmVzIF9hZnRlcl8gdGhlIHRyYW5zYWN0aW9uIGlzIGZpbmlzaGVkIGFuZCB0aGF0IGFsbCBjaGFuZ2VzXG4gICAgICAgKiB0aGF0IGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgdHJhbnNhY3Rpb24gYXJlIHNlbnQgYXMgb25lIG1lc3NhZ2UgdG8gdGhlXG4gICAgICAgKiBvdGhlciBwZWVycy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIFRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCBhcyBhIHRyYW5zYWN0aW9uXG4gICAgICAgKiBAcGFyYW0gez9Cb29sZWFufSByZW1vdGUgT3B0aW9uYWwuIFdoZXRoZXIgdGhpcyB0cmFuc2FjdGlvbiBpcyBpbml0aWF0ZWQgYnlcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhIHJlbW90ZSBwZWVyLiBUaGlzIHNob3VsZCBub3QgYmUgc2V0IG1hbnVhbGx5IVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0cmFuc2FjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNhY3QoZikge1xuICAgICAgICB2YXIgcmVtb3RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgICB2YXIgaW5pdGlhbENhbGwgPSB0aGlzLl90cmFuc2FjdGlvbiA9PT0gbnVsbDtcbiAgICAgICAgaWYgKGluaXRpYWxDYWxsKSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24odGhpcyk7XG4gICAgICAgICAgdGhpcy5lbWl0KCdiZWZvcmVUcmFuc2FjdGlvbicsIHRoaXMsIHRoaXMuX3RyYW5zYWN0aW9uLCByZW1vdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZih0aGlzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxDYWxsKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdiZWZvcmVPYnNlcnZlckNhbGxzJywgdGhpcywgdGhpcy5fdHJhbnNhY3Rpb24sIHJlbW90ZSk7XG4gICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy5fdHJhbnNhY3Rpb247XG4gICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgIC8vIGVtaXQgY2hhbmdlIGV2ZW50cyBvbiBjaGFuZ2VkIHR5cGVzXG4gICAgICAgICAgdHJhbnNhY3Rpb24uY2hhbmdlZFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHN1YnMsIHR5cGUpIHtcbiAgICAgICAgICAgIGlmICghdHlwZS5fZGVsZXRlZCkge1xuICAgICAgICAgICAgICB0eXBlLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHN1YnMsIHJlbW90ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50cywgdHlwZSkge1xuICAgICAgICAgICAgaWYgKCF0eXBlLl9kZWxldGVkKSB7XG4gICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFldmVudC50YXJnZXQuX2RlbGV0ZWQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gdHlwZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gY2hlY2sgZm9yIGV2ZW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB3YXkgZXZlbnRzIGlzIGVtcHR5Li5cbiAgICAgICAgICAgICAgdHlwZS5fZGVlcEV2ZW50SGFuZGxlci5jYWxsRXZlbnRMaXN0ZW5lcnModHJhbnNhY3Rpb24sIGV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gd2hlbiBhbGwgY2hhbmdlcyAmIGV2ZW50cyBhcmUgcHJvY2Vzc2VkLCBlbWl0IGFmdGVyVHJhbnNhY3Rpb24gZXZlbnRcbiAgICAgICAgICB0aGlzLmVtaXQoJ2FmdGVyVHJhbnNhY3Rpb24nLCB0aGlzLCB0cmFuc2FjdGlvbiwgcmVtb3RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBGYWtlIF9zdGFydCBmb3Igcm9vdCBwcm9wZXJ0aWVzICh5LnNldCgnbmFtZScsIHR5cGUpKVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZWZpbmUnLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVmaW5lIGEgc2hhcmVkIGRhdGEgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBNdWx0aXBsZSBjYWxscyBvZiBgeS5kZWZpbmUobmFtZSwgVHlwZUNvbnN0cnVjdG9yKWAgeWllbGQgdGhlIHNhbWUgcmVzdWx0XG4gICAgICAgKiBhbmQgZG8gbm90IG92ZXJ3cml0ZSBlYWNoIG90aGVyLiBJLmUuXG4gICAgICAgKiBgeS5kZWZpbmUobmFtZSwgdHlwZSkgPT09IHkuZGVmaW5lKG5hbWUsIHR5cGUpYFxuICAgICAgICpcbiAgICAgICAqIEFmdGVyIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIHR5cGUgaXMgYWxzbyBhdmFpbGFibGUgb24gYHkuc2hhcmVbbmFtZV1gLlxuICAgICAgICpcbiAgICAgICAqICpCZXN0IFByYWN0aWNlczoqXG4gICAgICAgKiBFaXRoZXIgZGVmaW5lIGFsbCB0eXBlcyByaWdodCBhZnRlciB0aGUgWWpzIGluc3RhbmNlIGlzIGNyZWF0ZWQgb3IgYWx3YXlzXG4gICAgICAgKiB1c2UgYHkuZGVmaW5lKC4uKWAgd2hlbiBhY2Nlc3NpbmcgYSB0eXBlLlxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAgIC8vIE9wdGlvbiAxXG4gICAgICAgKiAgIGNvbnN0IHkgPSBuZXcgWSguLilcbiAgICAgICAqICAgeS5kZWZpbmUoJ215QXJyYXknLCBZQXJyYXkpXG4gICAgICAgKiAgIHkuZGVmaW5lKCdteU1hcCcsIFlNYXApXG4gICAgICAgKiAgIC8vIC4uIHdoZW4gYWNjZXNzaW5nIHRoZSB0eXBlIHVzZSB5LnNoYXJlW25hbWVdXG4gICAgICAgKiAgIHkuc2hhcmUubXlBcnJheS5pbnNlcnQoLi4pXG4gICAgICAgKiAgIHkuc2hhcmUubXlNYXAuc2V0KC4uKVxuICAgICAgICpcbiAgICAgICAqICAgLy8gT3B0aW9uMlxuICAgICAgICogICBjb25zdCB5ID0gbmV3IFkoLi4pXG4gICAgICAgKiAgIC8vIC4uIHdoZW4gYWNjZXNzaW5nIHRoZSB0eXBlIHVzZSBgeS5kZWZpbmUoLi4pYFxuICAgICAgICogICB5LmRlZmluZSgnbXlBcnJheScsIFlBcnJheSkuaW5zZXJ0KC4uKVxuICAgICAgICogICB5LmRlZmluZSgnbXlNYXAnLCBZTWFwKS5zZXQoLi4pXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7WVR5cGUgQ29uc3RydWN0b3J9IFR5cGVDb25zdHJ1Y3RvciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHR5cGUgZGVmaW5pdGlvblxuICAgICAgICogQHJldHVybnMge1lUeXBlfSBUaGUgY3JlYXRlZCB0eXBlXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZpbmUobmFtZSwgVHlwZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHZhciBpZCA9IG5ldyBSb290SUQobmFtZSwgVHlwZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLm9zLmdldChpZCk7XG4gICAgICAgIGlmICh0aGlzLnNoYXJlW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnNoYXJlW25hbWVdID0gdHlwZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNoYXJlW25hbWVdICE9PSB0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIGlzIGFscmVhZHkgZGVmaW5lZCB3aXRoIGEgZGlmZmVyZW50IGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IGEgZGVmaW5lZCB0eXBlLiBUaGUgdHlwZSBtdXN0IGJlIGRlZmluZWQgbG9jYWxseS4gRmlyc3QgZGVmaW5lIHRoZVxuICAgICAgICogdHlwZSB3aXRoIHtAbGluayBkZWZpbmV9LlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZSBhcyBgeS5zaGFyZVtuYW1lXWBcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgdHlwZW5hbWVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQkJDEobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZVtuYW1lXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEaXNjb25uZWN0IHRoaXMgWWpzIEluc3RhbmNlIGZyb20gdGhlIG5ldHdvcmsuIFRoZSBjb25uZWN0b3Igd2lsbFxuICAgICAgICogdW5zdWJzY3JpYmUgZnJvbSB0aGUgcm9vbSBhbmQgZG9jdW1lbnQgdXBkYXRlcyBhcmUgbm90IHNoYXJlZCBhbnltb3JlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXNjb25uZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgZGlzY29ubmVjdGVkLCB0ZWxsIHRoZSBjb25uZWN0b3IgdG8gcmVjb25uZWN0IHRvIHRoZSByb29tLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWNvbm5lY3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IucmVjb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGlzY29ubmVjdCBmcm9tIHRoZSByb29tLCBhbmQgZGVzdHJveSBhbGwgdHJhY2VzIG9mIHRoaXMgWWpzIGluc3RhbmNlLlxuICAgICAgICogUGVyc2lzdGVkIGRhdGEgd2lsbCByZW1haW4gdW50aWwgcmVtb3ZlZCBieSB0aGUgcGVyc2lzdGVuY2UgYWRhcHRlci5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgZ2V0KFkucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoWS5wcm90b3R5cGUpLCAnZGVzdHJveScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2hhcmUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rvci5kZXN0cm95ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucGVyc2lzdGVuY2UuZGVpbml0KHRoaXMpO1xuICAgICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3MgPSBudWxsO1xuICAgICAgICB0aGlzLmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zcyA9IG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3N0YXJ0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogRmFrZSBfc3RhcnQgZm9yIHJvb3QgcHJvcGVydGllcyAoeS5zZXQoJ25hbWUnLCB0eXBlKSlcbiAgICAgICAqL1xuICAgICAgLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBZO1xuICB9KE5hbWVkRXZlbnRIYW5kbGVyKTtcblxuXG4gIFkuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kWWpzKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmKFkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIGZ1bmN0aW9uIScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgUmV2ZXJzZU9wZXJhdGlvbiA9IGZ1bmN0aW9uIFJldmVyc2VPcGVyYXRpb24oeSwgdHJhbnNhY3Rpb24sIGJpbmRpbmdJbmZvcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSZXZlcnNlT3BlcmF0aW9uKTtcblxuICAgIHRoaXMuY3JlYXRlZCA9IG5ldyBEYXRlKCk7XG4gICAgdmFyIGJlZm9yZVN0YXRlID0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGU7XG4gICAgaWYgKGJlZm9yZVN0YXRlLmhhcyh5LnVzZXJJRCkpIHtcbiAgICAgIHRoaXMudG9TdGF0ZSA9IG5ldyBJRCh5LnVzZXJJRCwgeS5zcy5nZXRTdGF0ZSh5LnVzZXJJRCkgLSAxKTtcbiAgICAgIHRoaXMuZnJvbVN0YXRlID0gbmV3IElEKHkudXNlcklELCBiZWZvcmVTdGF0ZS5nZXQoeS51c2VySUQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b1N0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMuZnJvbVN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5kZWxldGVkU3RydWN0cyA9IG5ldyBTZXQoKTtcbiAgICB0cmFuc2FjdGlvbi5kZWxldGVkU3RydWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJ1Y3QpIHtcbiAgICAgIF90aGlzLmRlbGV0ZWRTdHJ1Y3RzLmFkZCh7XG4gICAgICAgIGZyb206IHN0cnVjdC5faWQsXG4gICAgICAgIGxlbjogc3RydWN0Ll9sZW5ndGhcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE1hcHMgZnJvbSBiaW5kaW5nIHRvIGJpbmRpbmcgaW5mb3JtYXRpb24gKGUuZy4gY3Vyc29yIGluZm9ybWF0aW9uKVxuICAgICAqL1xuICAgIHRoaXMuYmluZGluZ0luZm9zID0gYmluZGluZ0luZm9zO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFwcGx5UmV2ZXJzZU9wZXJhdGlvbih5LCBzY29wZSwgcmV2ZXJzZUJ1ZmZlcikge1xuICAgIHZhciBwZXJmb3JtZWRVbmRvID0gZmFsc2U7XG4gICAgdmFyIHVuZG9PcCA9IHZvaWQgMDtcbiAgICB5LnRyYW5zYWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB1bmRvT3AgPSByZXZlcnNlQnVmZmVyLnBvcCgpO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBpdGVyYXRlIHtmcm9tfS17dG99XG4gICAgICAgIGlmICh1bmRvT3AuZnJvbVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgeS5vcy5nZXRJdGVtQ2xlYW5TdGFydCh1bmRvT3AuZnJvbVN0YXRlKTtcbiAgICAgICAgICB5Lm9zLmdldEl0ZW1DbGVhbkVuZCh1bmRvT3AudG9TdGF0ZSk7XG4gICAgICAgICAgeS5vcy5pdGVyYXRlKHVuZG9PcC5mcm9tU3RhdGUsIHVuZG9PcC50b1N0YXRlLCBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHdoaWxlIChvcC5fZGVsZXRlZCAmJiBvcC5fcmVkb25lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG9wID0gb3AuX3JlZG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcC5fZGVsZXRlZCA9PT0gZmFsc2UgJiYgaXNQYXJlbnRPZihzY29wZSwgb3ApKSB7XG4gICAgICAgICAgICAgIHBlcmZvcm1lZFVuZG8gPSB0cnVlO1xuICAgICAgICAgICAgICBvcC5fZGVsZXRlKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWRvaXRlbXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHVuZG9PcC5kZWxldGVkU3RydWN0c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBkZWwgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgdmFyIGZyb21TdGF0ZSA9IGRlbC5mcm9tO1xuICAgICAgICAgICAgdmFyIHRvU3RhdGUgPSBuZXcgSUQoZnJvbVN0YXRlLnVzZXIsIGZyb21TdGF0ZS5jbG9jayArIGRlbC5sZW4gLSAxKTtcbiAgICAgICAgICAgIHkub3MuZ2V0SXRlbUNsZWFuU3RhcnQoZnJvbVN0YXRlKTtcbiAgICAgICAgICAgIHkub3MuZ2V0SXRlbUNsZWFuRW5kKHRvU3RhdGUpO1xuICAgICAgICAgICAgeS5vcy5pdGVyYXRlKGZyb21TdGF0ZSwgdG9TdGF0ZSwgZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICAgIGlmIChpc1BhcmVudE9mKHNjb3BlLCBvcCkgJiYgb3AuX3BhcmVudCAhPT0geSAmJiAob3AuX2lkLnVzZXIgIT09IHkudXNlcklEIHx8IHVuZG9PcC5mcm9tU3RhdGUgPT09IG51bGwgfHwgb3AuX2lkLmNsb2NrIDwgdW5kb09wLmZyb21TdGF0ZS5jbG9jayB8fCBvcC5faWQuY2xvY2sgPiB1bmRvT3AudG9TdGF0ZS5jbG9jaykpIHtcbiAgICAgICAgICAgICAgICByZWRvaXRlbXMuYWRkKG9wKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlZG9pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgIHZhciBvcFVuZG9uZSA9IG9wLl9yZWRvKHksIHJlZG9pdGVtcyk7XG4gICAgICAgICAgcGVyZm9ybWVkVW5kbyA9IHBlcmZvcm1lZFVuZG8gfHwgb3BVbmRvbmU7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgd2hpbGUgKCFwZXJmb3JtZWRVbmRvICYmIHJldmVyc2VCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChwZXJmb3JtZWRVbmRvKSB7XG4gICAgICAvLyBzaG91bGQgYmUgcGVyZm9ybWVkIGFmdGVyIHRoZSB1bmRvIHRyYW5zYWN0aW9uXG4gICAgICB1bmRvT3AuYmluZGluZ0luZm9zLmZvckVhY2goZnVuY3Rpb24gKGluZm8sIGJpbmRpbmcpIHtcbiAgICAgICAgYmluZGluZy5fcmVzdG9yZVVuZG9TdGFja0luZm8oaW5mbyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBlcmZvcm1lZFVuZG87XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgYSBoaXN0b3J5IG9mIGxvY2FsbHkgYXBwbGllZCBvcGVyYXRpb25zLiBUaGUgVW5kb01hbmFnZXIgaGFuZGxlcyB0aGVcbiAgICogdW5kb2luZyBhbmQgcmVkb2luZyBvZiBsb2NhbGx5IGNyZWF0ZWQgY2hhbmdlcy5cbiAgICovXG5cbiAgdmFyIFVuZG9NYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7WVR5cGV9IHNjb3BlIFRoZSBzY29wZSBvbiB3aGljaCB0byBsaXN0ZW4gZm9yIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWxseSBwcm92aWRlZCBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuZG9NYW5hZ2VyKHNjb3BlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVW5kb01hbmFnZXIpO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5fYmluZGluZ3MgPSBuZXcgU2V0KG9wdGlvbnMuYmluZGluZ3MpO1xuICAgICAgb3B0aW9ucy5jYXB0dXJlVGltZW91dCA9IG9wdGlvbnMuY2FwdHVyZVRpbWVvdXQgPT0gbnVsbCA/IDUwMCA6IG9wdGlvbnMuY2FwdHVyZVRpbWVvdXQ7XG4gICAgICB0aGlzLl91bmRvQnVmZmVyID0gW107XG4gICAgICB0aGlzLl9yZWRvQnVmZmVyID0gW107XG4gICAgICB0aGlzLl9zY29wZSA9IHNjb3BlO1xuICAgICAgdGhpcy5fdW5kb2luZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkb2luZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fbGFzdFRyYW5zYWN0aW9uV2FzVW5kbyA9IGZhbHNlO1xuICAgICAgdmFyIHkgPSBzY29wZS5feTtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB5Ll9oYXNVbmRvTWFuYWdlciA9IHRydWU7XG4gICAgICB2YXIgYmluZGluZ0luZm9zID0gdm9pZCAwO1xuICAgICAgeS5vbignYmVmb3JlVHJhbnNhY3Rpb24nLCBmdW5jdGlvbiAoeSwgdHJhbnNhY3Rpb24sIHJlbW90ZSkge1xuICAgICAgICBpZiAoIXJlbW90ZSkge1xuICAgICAgICAgIC8vIFN0b3JlIGJpbmRpbmcgaW5mb3JtYXRpb24gYmVmb3JlIHRyYW5zYWN0aW9uIGlzIGV4ZWN1dGVkXG4gICAgICAgICAgLy8gQnkgcmVzdG9yaW5nIHRoZSBiaW5kaW5nIGluZm9ybWF0aW9uLCB3ZSBjYW4gbWFrZSBzdXJlIHRoYXQgdGhlIHN0YXRlXG4gICAgICAgICAgLy8gYmVmb3JlIHRoZSB0cmFuc2FjdGlvbiBjYW4gYmUgcmVjb3ZlcmVkXG4gICAgICAgICAgYmluZGluZ0luZm9zID0gbmV3IE1hcCgpO1xuICAgICAgICAgIF90aGlzMi5fYmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICAgICAgYmluZGluZ0luZm9zLnNldChiaW5kaW5nLCBiaW5kaW5nLl9nZXRVbmRvU3RhY2tJbmZvKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHkub24oJ2FmdGVyVHJhbnNhY3Rpb24nLCBmdW5jdGlvbiAoeSwgdHJhbnNhY3Rpb24sIHJlbW90ZSkge1xuICAgICAgICBpZiAoIXJlbW90ZSAmJiB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuaGFzKHNjb3BlKSkge1xuICAgICAgICAgIHZhciByZXZlcnNlT3BlcmF0aW9uID0gbmV3IFJldmVyc2VPcGVyYXRpb24oeSwgdHJhbnNhY3Rpb24sIGJpbmRpbmdJbmZvcyk7XG4gICAgICAgICAgaWYgKCFfdGhpczIuX3VuZG9pbmcpIHtcbiAgICAgICAgICAgIHZhciBsYXN0VW5kb09wID0gX3RoaXMyLl91bmRvQnVmZmVyLmxlbmd0aCA+IDAgPyBfdGhpczIuX3VuZG9CdWZmZXJbX3RoaXMyLl91bmRvQnVmZmVyLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChfdGhpczIuX3JlZG9pbmcgPT09IGZhbHNlICYmIF90aGlzMi5fbGFzdFRyYW5zYWN0aW9uV2FzVW5kbyA9PT0gZmFsc2UgJiYgbGFzdFVuZG9PcCAhPT0gbnVsbCAmJiAob3B0aW9ucy5jYXB0dXJlVGltZW91dCA8IDAgfHwgcmV2ZXJzZU9wZXJhdGlvbi5jcmVhdGVkIC0gbGFzdFVuZG9PcC5jcmVhdGVkIDw9IG9wdGlvbnMuY2FwdHVyZVRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgIGxhc3RVbmRvT3AuY3JlYXRlZCA9IHJldmVyc2VPcGVyYXRpb24uY3JlYXRlZDtcbiAgICAgICAgICAgICAgaWYgKHJldmVyc2VPcGVyYXRpb24udG9TdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxhc3RVbmRvT3AudG9TdGF0ZSA9IHJldmVyc2VPcGVyYXRpb24udG9TdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFVuZG9PcC5mcm9tU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGxhc3RVbmRvT3AuZnJvbVN0YXRlID0gcmV2ZXJzZU9wZXJhdGlvbi5mcm9tU3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldmVyc2VPcGVyYXRpb24uZGVsZXRlZFN0cnVjdHMuZm9yRWFjaChsYXN0VW5kb09wLmRlbGV0ZWRTdHJ1Y3RzLmFkZCwgbGFzdFVuZG9PcC5kZWxldGVkU3RydWN0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczIuX2xhc3RUcmFuc2FjdGlvbldhc1VuZG8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgX3RoaXMyLl91bmRvQnVmZmVyLnB1c2gocmV2ZXJzZU9wZXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV90aGlzMi5fcmVkb2luZykge1xuICAgICAgICAgICAgICBfdGhpczIuX3JlZG9CdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMyLl9sYXN0VHJhbnNhY3Rpb25XYXNVbmRvID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzMi5fcmVkb0J1ZmZlci5wdXNoKHJldmVyc2VPcGVyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5mb3JjZSB0aGF0IHRoZSBuZXh0IGNoYW5nZSBpcyBjcmVhdGVkIGFzIGEgc2VwYXJhdGUgaXRlbSBpbiB0aGUgdW5kbyBzdGFja1xuICAgICAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhVbmRvTWFuYWdlciwgW3tcbiAgICAgIGtleTogJ2ZsdXNoQ2hhbmdlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2hDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLl9sYXN0VHJhbnNhY3Rpb25XYXNVbmRvID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVbmRvIHRoZSBsYXN0IGxvY2FsbHkgY3JlYXRlZCBjaGFuZ2UuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VuZG8nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgICAgIHRoaXMuX3VuZG9pbmcgPSB0cnVlO1xuICAgICAgICB2YXIgcGVyZm9ybWVkVW5kbyA9IGFwcGx5UmV2ZXJzZU9wZXJhdGlvbih0aGlzLnksIHRoaXMuX3Njb3BlLCB0aGlzLl91bmRvQnVmZmVyKTtcbiAgICAgICAgdGhpcy5fdW5kb2luZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcGVyZm9ybWVkVW5kbztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZWRvIHRoZSBsYXN0IGxvY2FsbHkgY3JlYXRlZCBjaGFuZ2UuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlZG8nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZG8oKSB7XG4gICAgICAgIHRoaXMuX3JlZG9pbmcgPSB0cnVlO1xuICAgICAgICB2YXIgcGVyZm9ybWVkUmVkbyA9IGFwcGx5UmV2ZXJzZU9wZXJhdGlvbih0aGlzLnksIHRoaXMuX3Njb3BlLCB0aGlzLl9yZWRvQnVmZmVyKTtcbiAgICAgICAgdGhpcy5fcmVkb2luZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcGVyZm9ybWVkUmVkbztcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFVuZG9NYW5hZ2VyO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuICBcdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXJzLlxuICAgKi9cblxuICB2YXIgcyA9IDEwMDA7XG4gIHZhciBtID0gcyAqIDYwO1xuICB2YXIgaCA9IG0gKiA2MDtcbiAgdmFyIGQgPSBoICogMjQ7XG4gIHZhciB5ID0gZCAqIDM2NS4yNTtcblxuICAvKipcbiAgICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAgICpcbiAgICogT3B0aW9uczpcbiAgICpcbiAgICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gICAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHZhciBpbmRleCA9IGZ1bmN0aW9uIGluZGV4KHZhbCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgY2FzZSAneWVhcic6XG4gICAgICBjYXNlICd5cnMnOlxuICAgICAgY2FzZSAneXInOlxuICAgICAgY2FzZSAneSc6XG4gICAgICAgIHJldHVybiBuICogeTtcbiAgICAgIGNhc2UgJ2RheXMnOlxuICAgICAgY2FzZSAnZGF5JzpcbiAgICAgIGNhc2UgJ2QnOlxuICAgICAgICByZXR1cm4gbiAqIGQ7XG4gICAgICBjYXNlICdob3Vycyc6XG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgIGNhc2UgJ2hycyc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICdoJzpcbiAgICAgICAgcmV0dXJuIG4gKiBoO1xuICAgICAgY2FzZSAnbWludXRlcyc6XG4gICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgY2FzZSAnbWlucyc6XG4gICAgICBjYXNlICdtaW4nOlxuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIHJldHVybiBuICogbTtcbiAgICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgIGNhc2UgJ3NlY3MnOlxuICAgICAgY2FzZSAnc2VjJzpcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICByZXR1cm4gbiAqIHM7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgY2FzZSAnbXNlY3MnOlxuICAgICAgY2FzZSAnbXNlYyc6XG4gICAgICBjYXNlICdtcyc6XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbXNcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgICBpZiAobXMgPj0gZCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgICB9XG4gICAgaWYgKG1zID49IGgpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gICAgfVxuICAgIGlmIChtcyA+PSBtKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICAgIH1cbiAgICBpZiAobXMgPj0gcykge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgICB9XG4gICAgcmV0dXJuIG1zICsgJ21zJztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8IG1zICsgJyBtcyc7XG4gIH1cblxuICAvKipcbiAgICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICAgIGlmIChtcyA8IG4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG4gIH1cblxuICB2YXIgZGVidWcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICAgICAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gICAgICpcbiAgICAgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gICAgICovXG5cbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbiAgICBleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbiAgICBleHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuICAgIGV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuICAgIGV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgZXhwb3J0cy5odW1hbml6ZSA9IGluZGV4O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gICAgICovXG5cbiAgICBleHBvcnRzLm5hbWVzID0gW107XG4gICAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICAgICAqL1xuXG4gICAgZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICAgICAqL1xuXG4gICAgdmFyIHByZXZUaW1lO1xuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgY29sb3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgICAgdmFyIGhhc2ggPSAwLFxuICAgICAgICAgIGk7XG5cbiAgICAgIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAgICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICAgIC8vIGRpc2FibGVkP1xuICAgICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgICAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgdmFyIGluZGV4JCQxID0gMDtcbiAgICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uIChtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGluZGV4JCQxKys7XG4gICAgICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleCQkMV07XG4gICAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4JCQxLCAxKTtcbiAgICAgICAgICAgIGluZGV4JCQxLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICAgICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICAgICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gICAgICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICAgICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAgICAgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICAgICAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICAgICAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gICAgICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICBleHBvcnRzLmVuYWJsZSgnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICAgIHZhciBpLCBsZW47XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29lcmNlIGB2YWxgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICAgICogQHJldHVybiB7TWl4ZWR9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHZhciBkZWJ1Z18xID0gZGVidWcuY29lcmNlO1xuICB2YXIgZGVidWdfMiA9IGRlYnVnLmRpc2FibGU7XG4gIHZhciBkZWJ1Z18zID0gZGVidWcuZW5hYmxlO1xuICB2YXIgZGVidWdfNCA9IGRlYnVnLmVuYWJsZWQ7XG4gIHZhciBkZWJ1Z181ID0gZGVidWcuaHVtYW5pemU7XG4gIHZhciBkZWJ1Z182ID0gZGVidWcubmFtZXM7XG4gIHZhciBkZWJ1Z183ID0gZGVidWcuc2tpcHM7XG4gIHZhciBkZWJ1Z184ID0gZGVidWcuZm9ybWF0dGVycztcblxuICB2YXIgYnJvd3NlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gICAgICpcbiAgICAgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gICAgICovXG5cbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbiAgICBleHBvcnRzLmxvZyA9IGxvZztcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG4gICAgZXhwb3J0cy5sb2FkID0gbG9hZDtcbiAgICBleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbiAgICBleHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZSA/IGNocm9tZS5zdG9yYWdlLmxvY2FsIDogbG9jYWxzdG9yYWdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBDb2xvcnMuXG4gICAgICovXG5cbiAgICBleHBvcnRzLmNvbG9ycyA9IFsnbGlnaHRzZWFncmVlbicsICdmb3Jlc3RncmVlbicsICdnb2xkZW5yb2QnLCAnZG9kZ2VyYmx1ZScsICdkYXJrb3JjaGlkJywgJ2NyaW1zb24nXTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gICAgICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gICAgICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgICAgIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgICAgIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gICAgICAvLyBleHBsaWNpdGx5XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgICAgIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gICAgICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8XG4gICAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8XG4gICAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fFxuICAgICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICAgICAqL1xuXG4gICAgZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICAgICAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gICAgICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgKyBhcmdzWzBdICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICAgICAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICAgICAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICAgICAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cbiAgICAgIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gICAgICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gICAgICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgbGFzdEMgPSAwO1xuICAgICAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgICAgICBsYXN0QyA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICAgICAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gbG9nKCkge1xuICAgICAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgICAgIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gICAgICByZXR1cm4gJ29iamVjdCcgPT09ICh0eXBlb2YgY29uc29sZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29uc29sZSkpICYmIGNvbnNvbGUubG9nICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgdmFyIHI7XG4gICAgICB0cnkge1xuICAgICAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICAgICAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAgICAgKi9cblxuICAgIGV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAgICAgKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICAgICAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9KTtcbiAgdmFyIGJyb3dzZXJfMSA9IGJyb3dzZXIubG9nO1xuICB2YXIgYnJvd3Nlcl8yID0gYnJvd3Nlci5mb3JtYXRBcmdzO1xuICB2YXIgYnJvd3Nlcl8zID0gYnJvd3Nlci5zYXZlO1xuICB2YXIgYnJvd3Nlcl80ID0gYnJvd3Nlci5sb2FkO1xuICB2YXIgYnJvd3Nlcl81ID0gYnJvd3Nlci51c2VDb2xvcnM7XG4gIHZhciBicm93c2VyXzYgPSBicm93c2VyLnN0b3JhZ2U7XG4gIHZhciBicm93c2VyXzcgPSBicm93c2VyLmNvbG9ycztcblxuICAvLyBUT0RPOiByZW5hbWUgQ29ubmVjdG9yXG5cbiAgdmFyIEFic3RyYWN0Q29ubmVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0Q29ubmVjdG9yKHksIG9wdHMpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEFic3RyYWN0Q29ubmVjdG9yKTtcblxuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICBpZiAob3B0cy5yb2xlID09IG51bGwgfHwgb3B0cy5yb2xlID09PSAnbWFzdGVyJykge1xuICAgICAgICB0aGlzLnJvbGUgPSAnbWFzdGVyJztcbiAgICAgIH0gZWxzZSBpZiAob3B0cy5yb2xlID09PSAnc2xhdmUnKSB7XG4gICAgICAgIHRoaXMucm9sZSA9ICdzbGF2ZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb2xlIG11c3QgYmUgZWl0aGVyICdtYXN0ZXInIG9yICdzbGF2ZSchXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cgPSBicm93c2VyKCd5OmNvbm5lY3RvcicpO1xuICAgICAgdGhpcy5sb2dNZXNzYWdlID0gYnJvd3NlcigneTpjb25uZWN0b3ItbWVzc2FnZScpO1xuICAgICAgdGhpcy5fZm9yd2FyZEFwcGxpZWRTdHJ1Y3RzID0gb3B0cy5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMgfHwgZmFsc2U7IC8vIFRPRE86IHJlbmFtZVxuICAgICAgdGhpcy5yb2xlID0gb3B0cy5yb2xlO1xuICAgICAgdGhpcy5jb25uZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaXNTeW5jZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudXNlckV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgICB0aGlzLndoZW5TeW5jZWRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudFN5bmNUYXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5kZWJ1ZyA9IG9wdHMuZGVidWcgPT09IHRydWU7XG4gICAgICB0aGlzLmJyb2FkY2FzdEJ1ZmZlciA9IG5ldyBCaW5hcnlFbmNvZGVyKCk7XG4gICAgICB0aGlzLmJyb2FkY2FzdEJ1ZmZlclNpemUgPSAwO1xuICAgICAgdGhpcy5wcm90b2NvbFZlcnNpb24gPSAxMTtcbiAgICAgIHRoaXMuYXV0aEluZm8gPSBvcHRzLmF1dGggfHwgbnVsbDtcbiAgICAgIHRoaXMuY2hlY2tBdXRoID0gb3B0cy5jaGVja0F1dGggfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCd3cml0ZScpO1xuICAgICAgfTsgLy8gZGVmYXVsdCBpcyBldmVyeW9uZSBoYXMgd3JpdGUgYWNjZXNzXG4gICAgICBpZiAob3B0cy5tYXhCdWZmZXJMZW5ndGggPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1heEJ1ZmZlckxlbmd0aCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXhCdWZmZXJMZW5ndGggPSBvcHRzLm1heEJ1ZmZlckxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhBYnN0cmFjdENvbm5lY3RvciwgW3tcbiAgICAgIGtleTogJ3JlY29ubmVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmxvZygncmVjb25uZWN0aW5nLi4nKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkaXNjb25uZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmxvZygnZGlzY3Jvbm5lY3RpbmcuLicpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmlzU3luY2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudFN5bmNUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLndoZW5TeW5jZWRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uVXNlckV2ZW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblVzZXJFdmVudChmKSB7XG4gICAgICAgIHRoaXMudXNlckV2ZW50TGlzdGVuZXJzLnB1c2goZik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlVXNlckV2ZW50TGlzdGVuZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVVzZXJFdmVudExpc3RlbmVyKGYpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnRMaXN0ZW5lcnMgPSB0aGlzLnVzZXJFdmVudExpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICByZXR1cm4gZiAhPT0gZztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXNlckxlZnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVzZXJMZWZ0KHVzZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbnMuaGFzKHVzZXIpKSB7XG4gICAgICAgICAgdGhpcy5sb2coJyVzOiBVc2VyIGxlZnQgJXMnLCB0aGlzLnkudXNlcklELCB1c2VyKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLmRlbGV0ZSh1c2VyKTtcbiAgICAgICAgICAvLyBjaGVjayBpZiBpc1N5bmNlZCBldmVudCBjYW4gYmUgc2VudCBub3dcbiAgICAgICAgICB0aGlzLl9zZXRTeW5jZWRXaXRoKG51bGwpO1xuICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy51c2VyRXZlbnRMaXN0ZW5lcnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciBmID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgZih7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAndXNlckxlZnQnLFxuICAgICAgICAgICAgICAgIHVzZXI6IHVzZXJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndXNlckpvaW5lZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXNlckpvaW5lZCh1c2VyLCByb2xlLCBhdXRoKSB7XG4gICAgICAgIGlmIChyb2xlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgdGhlIHJvbGUgb2YgdGhlIGpvaW5lZCB1c2VyIScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zLmhhcyh1c2VyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1c2VyIGFscmVhZHkgam9pbmVkIScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKCclczogVXNlciBqb2luZWQgJXMnLCB0aGlzLnkudXNlcklELCB1c2VyKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5zZXQodXNlciwge1xuICAgICAgICAgIHVpZDogdXNlcixcbiAgICAgICAgICBpc1N5bmNlZDogZmFsc2UsXG4gICAgICAgICAgcm9sZTogcm9sZSxcbiAgICAgICAgICBwcm9jZXNzQWZ0ZXJBdXRoOiBbXSxcbiAgICAgICAgICBwcm9jZXNzQWZ0ZXJTeW5jOiBbXSxcbiAgICAgICAgICBhdXRoOiBhdXRoIHx8IG51bGwsXG4gICAgICAgICAgcmVjZWl2ZWRTeW5jU3RlcDI6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGVmZXIgPSB7fTtcbiAgICAgICAgZGVmZXIucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgZGVmZXIucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLmdldCh1c2VyKS5zeW5jU3RlcDIgPSBkZWZlcjtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoaXMudXNlckV2ZW50TGlzdGVuZXJzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgICAgZih7XG4gICAgICAgICAgICAgIGFjdGlvbjogJ3VzZXJKb2luZWQnLFxuICAgICAgICAgICAgICB1c2VyOiB1c2VyLFxuICAgICAgICAgICAgICByb2xlOiByb2xlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N5bmNXaXRoVXNlcih1c2VyKTtcbiAgICAgIH1cblxuICAgICAgLy8gRXhlY3V0ZSBhIGZ1bmN0aW9uIF93aGVuXyB3ZSBhcmUgY29ubmVjdGVkLlxuICAgICAgLy8gSWYgbm90IGNvbm5lY3RlZCwgd2FpdCB1bnRpbCBjb25uZWN0ZWRcblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3doZW5TeW5jZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdoZW5TeW5jZWQoZikge1xuICAgICAgICBpZiAodGhpcy5pc1N5bmNlZCkge1xuICAgICAgICAgIGYoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndoZW5TeW5jZWRMaXN0ZW5lcnMucHVzaChmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zeW5jV2l0aFVzZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zeW5jV2l0aFVzZXIodXNlcklEKSB7XG4gICAgICAgIGlmICh0aGlzLnJvbGUgPT09ICdzbGF2ZScpIHtcbiAgICAgICAgICByZXR1cm47IC8vIFwiVGhlIGN1cnJlbnQgc3luYyBoYXMgbm90IGZpbmlzaGVkIG9yIHRoaXMgaXMgY29udHJvbGxlZCBieSBhIG1hc3RlciFcIlxuICAgICAgICB9XG4gICAgICAgIHNlbmRTeW5jU3RlcDEodGhpcywgdXNlcklEKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZmlyZUlzU3luY2VkTGlzdGVuZXJzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlyZUlzU3luY2VkTGlzdGVuZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTeW5jZWQpIHtcbiAgICAgICAgICB0aGlzLmlzU3luY2VkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBJdCBpcyBzYWZlciB0byByZW1vdmUgdGhpcyFcbiAgICAgICAgICAvLyBjYWxsIHdoZW5zeW5jZWQgbGlzdGVuZXJzXG4gICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gdGhpcy53aGVuU3luY2VkTGlzdGVuZXJzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciBmID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy53aGVuU3luY2VkTGlzdGVuZXJzID0gW107XG4gICAgICAgICAgdGhpcy55Ll9zZXRDb250ZW50UmVhZHkoKTtcbiAgICAgICAgICB0aGlzLnkuZW1pdCgnc3luY2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzZW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKHVpZCwgYnVmZmVyKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgTWVzc2FnZSB0byBiZSBhbiBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IC0gZG9uXFwndCB1c2UgdGhpcyBtZXRob2QgdG8gc2VuZCBjdXN0b20gbWVzc2FnZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZygnVXNlciVzIHRvIFVzZXIlczogU2VuZCBcXCcleVxcJycsIHkudXNlcklELCB1aWQsIGJ1ZmZlcik7XG4gICAgICAgIHRoaXMubG9nTWVzc2FnZSgnVXNlciVzIHRvIFVzZXIlczogU2VuZCAlWScsIHkudXNlcklELCB1aWQsIFt5LCBidWZmZXJdKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdicm9hZGNhc3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJyb2FkY2FzdChidWZmZXIpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBNZXNzYWdlIHRvIGJlIGFuIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgLSBkb25cXCd0IHVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGN1c3RvbSBtZXNzYWdlcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKCdVc2VyJXM6IEJyb2FkY2FzdCBcXCcleVxcJycsIHkudXNlcklELCBidWZmZXIpO1xuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UoJ1VzZXIlczogQnJvYWRjYXN0OiAlWScsIHkudXNlcklELCBbeSwgYnVmZmVyXSk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgIEJ1ZmZlciBvcGVyYXRpb25zLCBhbmQgYnJvYWRjYXN0IHRoZW0gd2hlbiByZWFkeS5cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdicm9hZGNhc3RTdHJ1Y3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJyb2FkY2FzdFN0cnVjdChzdHJ1Y3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgZmlyc3RDb250ZW50ID0gdGhpcy5icm9hZGNhc3RCdWZmZXIubGVuZ3RoID09PSAwO1xuICAgICAgICBpZiAoZmlyc3RDb250ZW50KSB7XG4gICAgICAgICAgdGhpcy5icm9hZGNhc3RCdWZmZXIud3JpdGVWYXJTdHJpbmcodGhpcy55LnJvb20pO1xuICAgICAgICAgIHRoaXMuYnJvYWRjYXN0QnVmZmVyLndyaXRlVmFyU3RyaW5nKCd1cGRhdGUnKTtcbiAgICAgICAgICB0aGlzLmJyb2FkY2FzdEJ1ZmZlclNpemUgPSAwO1xuICAgICAgICAgIHRoaXMuYnJvYWRjYXN0QnVmZmVyU2l6ZVBvcyA9IHRoaXMuYnJvYWRjYXN0QnVmZmVyLnBvcztcbiAgICAgICAgICB0aGlzLmJyb2FkY2FzdEJ1ZmZlci53cml0ZVVpbnQzMigwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJyb2FkY2FzdEJ1ZmZlclNpemUrKztcbiAgICAgICAgc3RydWN0Ll90b0JpbmFyeSh0aGlzLmJyb2FkY2FzdEJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLm1heEJ1ZmZlckxlbmd0aCA+IDAgJiYgdGhpcy5icm9hZGNhc3RCdWZmZXIubGVuZ3RoID4gdGhpcy5tYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAvLyBpdCBpcyBuZWNlc3NhcnkgdG8gc2VuZCB0aGUgYnVmZmVyIG5vd1xuICAgICAgICAgIC8vIGNhY2hlIHRoZSBidWZmZXIgYW5kIGNoZWNrIGlmIHNlcnZlciBpcyByZXNwb25zaXZlXG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnJvYWRjYXN0QnVmZmVyO1xuICAgICAgICAgIGJ1ZmZlci5zZXRVaW50MzIodGhpcy5icm9hZGNhc3RCdWZmZXJTaXplUG9zLCB0aGlzLmJyb2FkY2FzdEJ1ZmZlclNpemUpO1xuICAgICAgICAgIHRoaXMuYnJvYWRjYXN0QnVmZmVyID0gbmV3IEJpbmFyeUVuY29kZXIoKTtcbiAgICAgICAgICB0aGlzLndoZW5SZW1vdGVSZXNwb25zaXZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5icm9hZGNhc3QoYnVmZmVyLmNyZWF0ZUJ1ZmZlcigpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdENvbnRlbnQpIHtcbiAgICAgICAgICAvLyBzZW5kIHRoZSBidWZmZXIgd2hlbiBhbGwgdHJhbnNhY3Rpb25zIGFyZSBmaW5pc2hlZFxuICAgICAgICAgIC8vIChvciBidWZmZXIgZXhjZWVkcyBtYXhCdWZmZXJMZW5ndGgpXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuYnJvYWRjYXN0QnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIF9idWZmZXIgPSBfdGhpcy5icm9hZGNhc3RCdWZmZXI7XG4gICAgICAgICAgICAgIF9idWZmZXIuc2V0VWludDMyKF90aGlzLmJyb2FkY2FzdEJ1ZmZlclNpemVQb3MsIF90aGlzLmJyb2FkY2FzdEJ1ZmZlclNpemUpO1xuICAgICAgICAgICAgICBfdGhpcy5icm9hZGNhc3QoX2J1ZmZlci5jcmVhdGVCdWZmZXIoKSk7XG4gICAgICAgICAgICAgIF90aGlzLmJyb2FkY2FzdEJ1ZmZlciA9IG5ldyBCaW5hcnlFbmNvZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqIFNvbWVob3cgY2hlY2sgdGhlIHJlc3BvbnNpdmVuZXNzIG9mIHRoZSByZW1vdGUgY2xpZW50cy9zZXJ2ZXJcbiAgICAgICAqIERlZmF1bHQgYmVoYXZpb3I6XG4gICAgICAgKiAgIFdhaXQgMTAwbXMgYmVmb3JlIGJyb2FkY2FzdGluZyB0aGUgbmV4dCBiYXRjaCBvZiBvcGVyYXRpb25zXG4gICAgICAgKlxuICAgICAgICogT25seSB1c2VkIHdoZW4gbWF4QnVmZmVyTGVuZ3RoIGlzIHNldFxuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnd2hlblJlbW90ZVJlc3BvbnNpdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdoZW5SZW1vdGVSZXNwb25zaXZlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICBZb3UgcmVjZWl2ZWQgYSByYXcgbWVzc2FnZSwgYW5kIHlvdSBrbm93IHRoYXQgaXQgaXMgaW50ZW5kZWQgZm9yIFlqcy4gVGhlbiBjYWxsIHRoaXMgZnVuY3Rpb24uXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVjZWl2ZU1lc3NhZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2VpdmVNZXNzYWdlKHNlbmRlciwgYnVmZmVyLCBza2lwQXV0aCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgdmFyIHVzZXJJRCA9IHkudXNlcklEO1xuICAgICAgICBza2lwQXV0aCA9IHNraXBBdXRoIHx8IGZhbHNlO1xuICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0V4cGVjdGVkIE1lc3NhZ2UgdG8gYmUgYW4gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSEnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbmRlciA9PT0gdXNlcklEKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWNvZGVyID0gbmV3IEJpbmFyeURlY29kZXIoYnVmZmVyKTtcbiAgICAgICAgdmFyIGVuY29kZXIgPSBuZXcgQmluYXJ5RW5jb2RlcigpO1xuICAgICAgICB2YXIgcm9vbW5hbWUgPSBkZWNvZGVyLnJlYWRWYXJTdHJpbmcoKTsgLy8gcmVhZCByb29tIG5hbWVcbiAgICAgICAgZW5jb2Rlci53cml0ZVZhclN0cmluZyhyb29tbmFtZSk7XG4gICAgICAgIHZhciBtZXNzYWdlVHlwZSA9IGRlY29kZXIucmVhZFZhclN0cmluZygpO1xuICAgICAgICB2YXIgc2VuZGVyQ29ubiA9IHRoaXMuY29ubmVjdGlvbnMuZ2V0KHNlbmRlcik7XG4gICAgICAgIHRoaXMubG9nKCdVc2VyJXMgZnJvbSBVc2VyJXM6IFJlY2VpdmUgXFwnJXNcXCcnLCB1c2VySUQsIHNlbmRlciwgbWVzc2FnZVR5cGUpO1xuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UoJ1VzZXIlcyBmcm9tIFVzZXIlczogUmVjZWl2ZSAlWScsIHVzZXJJRCwgc2VuZGVyLCBbeSwgYnVmZmVyXSk7XG4gICAgICAgIGlmIChzZW5kZXJDb25uID09IG51bGwgJiYgIXNraXBBdXRoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gdW5rbm93biBwZWVyIScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlVHlwZSA9PT0gJ3N5bmMgc3RlcCAxJyB8fCBtZXNzYWdlVHlwZSA9PT0gJ3N5bmMgc3RlcCAyJykge1xuICAgICAgICAgIHZhciBhdXRoID0gZGVjb2Rlci5yZWFkVmFyVWludCgpO1xuICAgICAgICAgIGlmIChzZW5kZXJDb25uLmF1dGggPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VuZGVyQ29ubi5wcm9jZXNzQWZ0ZXJBdXRoLnB1c2goW21lc3NhZ2VUeXBlLCBzZW5kZXJDb25uLCBkZWNvZGVyLCBlbmNvZGVyLCBzZW5kZXJdKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGF1dGhcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrQXV0aChhdXRoLCB5LCBzZW5kZXIpLnRoZW4oZnVuY3Rpb24gKGF1dGhQZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgICBpZiAoc2VuZGVyQ29ubi5hdXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZW5kZXJDb25uLmF1dGggPSBhdXRoUGVybWlzc2lvbnM7XG4gICAgICAgICAgICAgICAgeS5lbWl0KCd1c2VyQXV0aGVudGljYXRlZCcsIHtcbiAgICAgICAgICAgICAgICAgIHVzZXI6IHNlbmRlckNvbm4udWlkLFxuICAgICAgICAgICAgICAgICAgYXV0aDogYXV0aFBlcm1pc3Npb25zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gc2VuZGVyQ29ubi5wcm9jZXNzQWZ0ZXJBdXRoO1xuICAgICAgICAgICAgICBzZW5kZXJDb25uLnByb2Nlc3NBZnRlckF1dGggPSBbXTtcblxuICAgICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5jb21wdXRlTWVzc2FnZShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChza2lwQXV0aCB8fCBzZW5kZXJDb25uLmF1dGggIT0gbnVsbCkgJiYgKG1lc3NhZ2VUeXBlICE9PSAndXBkYXRlJyB8fCBzZW5kZXJDb25uLmlzU3luY2VkKSkge1xuICAgICAgICAgIHRoaXMuY29tcHV0ZU1lc3NhZ2UobWVzc2FnZVR5cGUsIHNlbmRlckNvbm4sIGRlY29kZXIsIGVuY29kZXIsIHNlbmRlciwgc2tpcEF1dGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbmRlckNvbm4ucHJvY2Vzc0FmdGVyU3luYy5wdXNoKFttZXNzYWdlVHlwZSwgc2VuZGVyQ29ubiwgZGVjb2RlciwgZW5jb2Rlciwgc2VuZGVyLCBmYWxzZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY29tcHV0ZU1lc3NhZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVNZXNzYWdlKG1lc3NhZ2VUeXBlLCBzZW5kZXJDb25uLCBkZWNvZGVyLCBlbmNvZGVyLCBzZW5kZXIsIHNraXBBdXRoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlVHlwZSA9PT0gJ3N5bmMgc3RlcCAxJyAmJiAoc2VuZGVyQ29ubi5hdXRoID09PSAnd3JpdGUnIHx8IHNlbmRlckNvbm4uYXV0aCA9PT0gJ3JlYWQnKSkge1xuICAgICAgICAgIC8vIGNhbm5vdCB3YWl0IGZvciBzeW5jIHN0ZXAgMSB0byBmaW5pc2gsIGJlY2F1c2Ugd2UgbWF5IHdhaXQgZm9yIHN5bmMgc3RlcCAyIGluIHN5bmMgc3RlcCAxICgtPmxvY2spXG4gICAgICAgICAgcmVhZFN5bmNTdGVwMShkZWNvZGVyLCBlbmNvZGVyLCB0aGlzLnksIHNlbmRlckNvbm4sIHNlbmRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgICAgeS50cmFuc2FjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUgPT09ICdzeW5jIHN0ZXAgMicgJiYgc2VuZGVyQ29ubi5hdXRoID09PSAnd3JpdGUnKSB7XG4gICAgICAgICAgICAgIHJlYWRTeW5jU3RlcDIoZGVjb2RlciwgZW5jb2RlciwgeSwgc2VuZGVyQ29ubiwgc2VuZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZVR5cGUgPT09ICd1cGRhdGUnICYmIChza2lwQXV0aCB8fCBzZW5kZXJDb25uLmF1dGggPT09ICd3cml0ZScpKSB7XG4gICAgICAgICAgICAgIGludGVncmF0ZVJlbW90ZVN0cnVjdHMoeSwgZGVjb2Rlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZWNlaXZlIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRTeW5jZWRXaXRoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U3luY2VkV2l0aCh1c2VyKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh1c2VyICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgdXNlckNvbm4gPSB0aGlzLmNvbm5lY3Rpb25zLmdldCh1c2VyKTtcbiAgICAgICAgICB1c2VyQ29ubi5pc1N5bmNlZCA9IHRydWU7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VzID0gdXNlckNvbm4ucHJvY2Vzc0FmdGVyU3luYztcbiAgICAgICAgICB1c2VyQ29ubi5wcm9jZXNzQWZ0ZXJTeW5jID0gW107XG4gICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgX3RoaXMzLmNvbXB1dGVNZXNzYWdlKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25ucyA9IEFycmF5LmZyb20odGhpcy5jb25uZWN0aW9ucy52YWx1ZXMoKSk7XG4gICAgICAgIGlmIChjb25ucy5sZW5ndGggPiAwICYmIGNvbm5zLmV2ZXJ5KGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgcmV0dXJuIHUuaXNTeW5jZWQ7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgdGhpcy5fZmlyZUlzU3luY2VkTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEFic3RyYWN0Q29ubmVjdG9yO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIERlY29kZXIgYW5kIGZpbGwgdGhlIFlqcyBpbnN0YW5jZSB3aXRoIGRhdGEgaW4gdGhlIGRlY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7WX0geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7QmluYXJ5RGVjb2Rlcn0gZGVjb2RlciBUaGUgQmluYXJ5RGVjb2RlciB0byByZWFkIGZyb20uXG4gICAqL1xuICBmdW5jdGlvbiBmcm9tQmluYXJ5KHksIGRlY29kZXIpIHtcbiAgICB5LnRyYW5zYWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGludGVncmF0ZVJlbW90ZVN0cnVjdHMoeSwgZGVjb2Rlcik7XG4gICAgICByZWFkRGVsZXRlU2V0KHksIGRlY29kZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSB0aGUgWWpzIG1vZGVsIHRvIGJpbmFyeSBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7WX0geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0JpbmFyeUVuY29kZXJ9IFRoZSBlbmNvZGVyIGluc3RhbmNlIHRoYXQgY2FuIGJlIHRyYW5zZm9ybWVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHRvIEFycmF5QnVmZmVyIG9yIEJ1ZmZlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRvQmluYXJ5KHkpIHtcbiAgICB2YXIgZW5jb2RlciA9IG5ldyBCaW5hcnlFbmNvZGVyKCk7XG4gICAgd3JpdGVTdHJ1Y3RzKHksIGVuY29kZXIsIG5ldyBNYXAoKSk7XG4gICAgd3JpdGVEZWxldGVTZXQoeSwgZW5jb2Rlcik7XG4gICAgcmV0dXJuIGVuY29kZXI7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGcmVzaENuZigpIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEJpbmFyeUVuY29kZXIoKTtcbiAgICBidWZmZXIud3JpdGVVaW50MzIoMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbjogMCxcbiAgICAgIGJ1ZmZlcjogYnVmZmVyXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYnN0cmFjdCBwZXJzaXN0ZW5jZSBjbGFzcy5cbiAgICovXG5cbiAgdmFyIEFic3RyYWN0UGVyc2lzdGVuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RQZXJzaXN0ZW5jZShvcHRzKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdFBlcnNpc3RlbmNlKTtcblxuICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgIHRoaXMueXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoQWJzdHJhY3RQZXJzaXN0ZW5jZSwgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCh5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNuZiA9IHRoaXMueXMuZ2V0KHkpO1xuICAgICAgICBpZiAoY25mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbmYgPSBnZXRGcmVzaENuZigpO1xuICAgICAgICAgIGNuZi5tdXR1YWxFeGNsdWRlID0gY3JlYXRlTXV0dWFsRXhjbHVkZSgpO1xuICAgICAgICAgIHRoaXMueXMuc2V0KHksIGNuZik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCh5KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHkub24oJ2FmdGVyVHJhbnNhY3Rpb24nLCBmdW5jdGlvbiAoeSwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgdmFyIGNuZiA9IF90aGlzLnlzLmdldCh5KTtcbiAgICAgICAgICAgICAgaWYgKGNuZi5sZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgY25mLmJ1ZmZlci5zZXRVaW50MzIoMCwgY25mLmxlbik7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2F2ZVVwZGF0ZSh5LCBjbmYuYnVmZmVyLmNyZWF0ZUJ1ZmZlcigpLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgdmFyIF9jbmYgPSBnZXRGcmVzaENuZigpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBfY25mKSB7XG4gICAgICAgICAgICAgICAgICBjbmZba2V5XSA9IF9jbmZba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJldHJpZXZlKHkpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjbmYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY25mKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVpbml0KHkpIHtcbiAgICAgICAgdGhpcy55cy5kZWxldGUoeSk7XG4gICAgICAgIHkucGVyc2lzdGVuY2UgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMueXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgcGVyc2lzdGVkIGRhdGEgdGhhdCBiZWxvbmdzIHRvIGEgcm9vbS5cbiAgICAgICAqIEF1dG9tYXRpY2FsbHkgZGVzdHJveXMgYWxsIFlqcyBhbGwgWWpzIGluc3RhbmNlcyB0aGF0IHBlcnNpc3QgdG9cbiAgICAgICAqIHRoZSByb29tLiBJZiBgZGVzdHJveVlqc0luc3RhbmNlcyA9IGZhbHNlYCB0aGUgcGVyc2lzdGVuY2UgZnVuY3Rpb25hbGl0eVxuICAgICAgICogd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIFlqcyBpbnN0YW5jZXMuXG4gICAgICAgKlxuICAgICAgICogKiogTXVzdCBiZSBvdmVyd3JpdHRlbiEgKipcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlUGVyc2lzdGVkRGF0YScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlUGVyc2lzdGVkRGF0YShyb29tKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkZXN0cm95WWpzSW5zdGFuY2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgIHRoaXMueXMuZm9yRWFjaChmdW5jdGlvbiAoY25mLCB5KSB7XG4gICAgICAgICAgaWYgKHkucm9vbSA9PT0gcm9vbSkge1xuICAgICAgICAgICAgaWYgKGRlc3Ryb3lZanNJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgeS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczIuZGVpbml0KHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qIG92ZXJ3cml0ZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZVVwZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZVVwZGF0ZShidWZmZXIpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2F2ZSBzdHJ1Y3QgdG8gdXBkYXRlIGJ1ZmZlci5cbiAgICAgICAqIHNhdmVVcGRhdGUgaXMgY2FsbGVkIHdoZW4gdHJhbnNhY3Rpb24gZW5kc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzYXZlU3RydWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlU3RydWN0KHksIHN0cnVjdCkge1xuICAgICAgICB2YXIgY25mID0gdGhpcy55cy5nZXQoeSk7XG4gICAgICAgIGlmIChjbmYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNuZi5tdXR1YWxFeGNsdWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0cnVjdC5fdG9CaW5hcnkoY25mLmJ1ZmZlcik7XG4gICAgICAgICAgICBjbmYubGVuKys7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogb3ZlcndyaXRlICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZXRyaWV2ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmV0cmlldmUoeSwgbW9kZWwsIHVwZGF0ZXMpIHtcbiAgICAgICAgdmFyIGNuZiA9IHRoaXMueXMuZ2V0KHkpO1xuICAgICAgICBpZiAoY25mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbmYubXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB5LnRyYW5zYWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKG1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmcm9tQmluYXJ5KHksIG5ldyBCaW5hcnlEZWNvZGVyKG5ldyBVaW50OEFycmF5KG1vZGVsKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh1cGRhdGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGludGVncmF0ZVJlbW90ZVN0cnVjdHMoeSwgbmV3IEJpbmFyeURlY29kZXIobmV3IFVpbnQ4QXJyYXkodXBkYXRlc1tpXSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeS5lbWl0KCdwZXJzaXN0ZW5jZVJlYWR5Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogb3ZlcndyaXRlICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdwZXJzaXN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJzaXN0KHkpIHtcbiAgICAgICAgcmV0dXJuIHRvQmluYXJ5KHkpLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQWJzdHJhY3RQZXJzaXN0ZW5jZTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIHR5cGVPYnNlcnZlciQxKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9tdXR1YWxFeGNsdWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ZXh0YXJlYSA9IF90aGlzLnRhcmdldDtcbiAgICAgIHZhciB0ZXh0VHlwZSA9IF90aGlzLnR5cGU7XG4gICAgICB2YXIgcmVsYXRpdmVTdGFydCA9IGdldFJlbGF0aXZlUG9zaXRpb24odGV4dFR5cGUsIHRleHRhcmVhLnNlbGVjdGlvblN0YXJ0KTtcbiAgICAgIHZhciByZWxhdGl2ZUVuZCA9IGdldFJlbGF0aXZlUG9zaXRpb24odGV4dFR5cGUsIHRleHRhcmVhLnNlbGVjdGlvbkVuZCk7XG4gICAgICB0ZXh0YXJlYS52YWx1ZSA9IHRleHRUeXBlLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgc3RhcnQgPSBmcm9tUmVsYXRpdmVQb3NpdGlvbih0ZXh0VHlwZS5feSwgcmVsYXRpdmVTdGFydCk7XG4gICAgICB2YXIgZW5kID0gZnJvbVJlbGF0aXZlUG9zaXRpb24odGV4dFR5cGUuX3ksIHJlbGF0aXZlRW5kKTtcbiAgICAgIHRleHRhcmVhLnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9tT2JzZXJ2ZXIkMSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHRoaXMuX211dHVhbEV4Y2x1ZGUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRpZmYgPSBzaW1wbGVEaWZmKF90aGlzMi50eXBlLnRvU3RyaW5nKCksIF90aGlzMi50YXJnZXQudmFsdWUpO1xuICAgICAgX3RoaXMyLnR5cGUuZGVsZXRlKGRpZmYucG9zLCBkaWZmLnJlbW92ZSk7XG4gICAgICBfdGhpczIudHlwZS5pbnNlcnQoZGlmZi5wb3MsIGRpZmYuaW5zZXJ0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGJpbmRpbmcgdGhhdCBiaW5kcyBhIFlUZXh0IHRvIGEgZG9tIHRleHRhcmVhLlxuICAgKlxuICAgKiBUaGlzIGJpbmRpbmcgaXMgYXV0b21hdGljYWxseSBkZXN0cm95ZWQgd2hlbiBpdHMgcGFyZW50IGlzIGRlbGV0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgY29uc3QgdGV4dGFyZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbiAgICogICBjb25zdCB0eXBlID0geS5kZWZpbmUoJ3RleHRhcmVhJywgWS5UZXh0KVxuICAgKiAgIGNvbnN0IGJpbmRpbmcgPSBuZXcgWS5RdWlsbEJpbmRpbmcodHlwZSwgdGV4dGFyZWEpXG4gICAqXG4gICAqL1xuXG4gIHZhciBUZXh0YXJlYUJpbmRpbmcgPSBmdW5jdGlvbiAoX0JpbmRpbmcpIHtcbiAgICBpbmhlcml0cyhUZXh0YXJlYUJpbmRpbmcsIF9CaW5kaW5nKTtcblxuICAgIGZ1bmN0aW9uIFRleHRhcmVhQmluZGluZyh0ZXh0VHlwZSwgZG9tVGV4dGFyZWEpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRhcmVhQmluZGluZyk7XG5cbiAgICAgIC8vIHNldCBpbml0aWFsIHZhbHVlXG4gICAgICB2YXIgX3RoaXMzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGV4dGFyZWFCaW5kaW5nLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dGFyZWFCaW5kaW5nKSkuY2FsbCh0aGlzLCB0ZXh0VHlwZSwgZG9tVGV4dGFyZWEpKTtcbiAgICAgIC8vIEJpbmRpbmcgaGFuZGxlcyB0ZXh0VHlwZSBhcyB0aGlzLnR5cGUgYW5kIGRvbVRleHRhcmVhIGFzIHRoaXMudGFyZ2V0XG5cblxuICAgICAgZG9tVGV4dGFyZWEudmFsdWUgPSB0ZXh0VHlwZS50b1N0cmluZygpO1xuICAgICAgLy8gT2JzZXJ2ZXJzIGFyZSBoYW5kbGVkIGJ5IHRoaXMgY2xhc3NcbiAgICAgIF90aGlzMy5fdHlwZU9ic2VydmVyID0gdHlwZU9ic2VydmVyJDEuYmluZChfdGhpczMpO1xuICAgICAgX3RoaXMzLl9kb21PYnNlcnZlciA9IGRvbU9ic2VydmVyJDEuYmluZChfdGhpczMpO1xuICAgICAgdGV4dFR5cGUub2JzZXJ2ZShfdGhpczMuX3R5cGVPYnNlcnZlcik7XG4gICAgICBkb21UZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIF90aGlzMy5fZG9tT2JzZXJ2ZXIpO1xuICAgICAgcmV0dXJuIF90aGlzMztcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhUZXh0YXJlYUJpbmRpbmcsIFt7XG4gICAgICBrZXk6ICdkZXN0cm95JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAvLyBSZW1vdmUgZXZlcnl0aGluZyB0aGF0IGlzIGhhbmRsZWQgYnkgdGhpcyBjbGFzc1xuICAgICAgICB0aGlzLnR5cGUudW5vYnNlcnZlKHRoaXMuX3R5cGVPYnNlcnZlcik7XG4gICAgICAgIHRoaXMudGFyZ2V0LnVub2JzZXJ2ZSh0aGlzLl9kb21PYnNlcnZlcik7XG4gICAgICAgIGdldChUZXh0YXJlYUJpbmRpbmcucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dGFyZWFCaW5kaW5nLnByb3RvdHlwZSksICdkZXN0cm95JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFRleHRhcmVhQmluZGluZztcbiAgfShCaW5kaW5nKTtcblxuICBmdW5jdGlvbiB0eXBlT2JzZXJ2ZXIkMihldmVudCkge1xuICAgIHZhciBxdWlsbCA9IHRoaXMudGFyZ2V0O1xuICAgIC8vIEZvcmNlIGZsdXNoIFF1aWxsIGNoYW5nZXMuXG4gICAgcXVpbGwudXBkYXRlKCd5anMnKTtcbiAgICB0aGlzLl9tdXR1YWxFeGNsdWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEFwcGx5IGNvbXB1dGVkIGRlbHRhLlxuICAgICAgcXVpbGwudXBkYXRlQ29udGVudHMoZXZlbnQuZGVsdGEsICd5anMnKTtcbiAgICAgIC8vIEZvcmNlIGZsdXNoIFF1aWxsIGNoYW5nZXMuIElnbm9yZSBhcHBsaWVkIGNoYW5nZXMuXG4gICAgICBxdWlsbC51cGRhdGUoJ3lqcycpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVpbGxPYnNlcnZlcihkZWx0YSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9tdXR1YWxFeGNsdWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnR5cGUuYXBwbHlEZWx0YShkZWx0YS5vcHMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgQmluZGluZyB0aGF0IGJpbmRzIGEgWVRleHQgdHlwZSB0byBhIFF1aWxsIGVkaXRvci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcXVpbGwgPSBuZXcgUXVpbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAqIGNvbnN0IHR5cGUgPSB5LmRlZmluZSgncXVpbGwnLCBZLlRleHQpXG4gICAqIGNvbnN0IGJpbmRpbmcgPSBuZXcgWS5RdWlsbEJpbmRpbmcocXVpbGwsIHR5cGUpXG4gICAqIC8vIE5vdyBtb2RpZmljYXRpb25zIG9uIHRoZSBET00gd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlIFR5cGUsIGFuZCB0aGUgb3RoZXJcbiAgICogLy8gd2F5IGFyb3VuZCFcbiAgICovXG5cbiAgdmFyIFF1aWxsQmluZGluZyA9IGZ1bmN0aW9uIChfQmluZGluZykge1xuICAgIGluaGVyaXRzKFF1aWxsQmluZGluZywgX0JpbmRpbmcpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtZVGV4dH0gdGV4dFR5cGVcbiAgICAgKiBAcGFyYW0ge1F1aWxsfSBxdWlsbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFF1aWxsQmluZGluZyh0ZXh0VHlwZSwgcXVpbGwpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWxsQmluZGluZyk7XG5cbiAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlLlxuICAgICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFF1aWxsQmluZGluZy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFF1aWxsQmluZGluZykpLmNhbGwodGhpcywgdGV4dFR5cGUsIHF1aWxsKSk7XG4gICAgICAvLyBCaW5kaW5nIGhhbmRsZXMgdGV4dFR5cGUgYXMgdGhpcy50eXBlIGFuZCBxdWlsbCBhcyB0aGlzLnRhcmdldC5cblxuXG4gICAgICBxdWlsbC5zZXRDb250ZW50cyh0ZXh0VHlwZS50b0RlbHRhKCksICd5anMnKTtcbiAgICAgIC8vIE9ic2VydmVycyBhcmUgaGFuZGxlZCBieSB0aGlzIGNsYXNzLlxuICAgICAgX3RoaXMyLl90eXBlT2JzZXJ2ZXIgPSB0eXBlT2JzZXJ2ZXIkMi5iaW5kKF90aGlzMik7XG4gICAgICBfdGhpczIuX3F1aWxsT2JzZXJ2ZXIgPSBxdWlsbE9ic2VydmVyLmJpbmQoX3RoaXMyKTtcbiAgICAgIHRleHRUeXBlLm9ic2VydmUoX3RoaXMyLl90eXBlT2JzZXJ2ZXIpO1xuICAgICAgcXVpbGwub24oJ3RleHQtY2hhbmdlJywgX3RoaXMyLl9xdWlsbE9ic2VydmVyKTtcbiAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoUXVpbGxCaW5kaW5nLCBbe1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgdGhhdCBpcyBoYW5kbGVkIGJ5IHRoaXMgY2xhc3MuXG4gICAgICAgIHRoaXMudHlwZS51bm9ic2VydmUodGhpcy5fdHlwZU9ic2VydmVyKTtcbiAgICAgICAgdGhpcy50YXJnZXQub2ZmKCd0ZXh0LWNoYW5nZScsIHRoaXMuX3F1aWxsT2JzZXJ2ZXIpO1xuICAgICAgICBnZXQoUXVpbGxCaW5kaW5nLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFF1aWxsQmluZGluZy5wcm90b3R5cGUpLCAnZGVzdHJveScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBRdWlsbEJpbmRpbmc7XG4gIH0oQmluZGluZyk7XG5cbiAgZnVuY3Rpb24gdHlwZU9ic2VydmVyJDMoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fbXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29kZU1pcnJvciA9IF90aGlzLnRhcmdldDtcbiAgICAgIHZhciBkZWx0YXMgPSBldmVudC5kZWx0YTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgZnJvbSA9IGNvZGVNaXJyb3IucG9zRnJvbUluZGV4KGluZGV4KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IGRlbHRhc1tpXTtcbiAgICAgICAgaWYgKGRlbHRhLnJldGFpbikge1xuICAgICAgICAgIGluZGV4ID0gZGVsdGEucmV0YWluO1xuICAgICAgICAgIGZyb20gPSBjb2RlTWlycm9yLnBvc0Zyb21JbmRleChpbmRleCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGEuaW5zZXJ0KSB7XG4gICAgICAgICAgY29kZU1pcnJvci5yZXBsYWNlUmFuZ2UoZGVsdGEuaW5zZXJ0LCBmcm9tLCBmcm9tKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YS5kZWxldGUpIHtcbiAgICAgICAgICBjb2RlTWlycm9yLnJlcGxhY2VSYW5nZSgnJywgZnJvbSwgY29kZU1pcnJvci5wb3NGcm9tSW5kZXgoaW5kZXggKyBkZWx0YS5kZWxldGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY29kZU1pcnJvck9ic2VydmVyKGNvZGVNaXJyb3IsIGRlbHRhcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5fbXV0dWFsRXhjbHVkZShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07XG4gICAgICAgIHZhciBzdGFydCA9IGNvZGVNaXJyb3IuaW5kZXhGcm9tUG9zKGRlbHRhLmZyb20pO1xuICAgICAgICAvLyBhcHBseSB0aGUgZGVsZXRlIG9wZXJhdGlvbiBmaXJzdFxuICAgICAgICBpZiAoZGVsdGEucmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGRlbExlbmd0aCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkZWx0YS5yZW1vdmVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBkZWxMZW5ndGggKz0gZGVsdGEucmVtb3ZlZFtqXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFwiZW50ZXJcIiBpcyBhbHNvIGEgY2hhcmFjdGVyIGluIG91ciBjYXNlXG4gICAgICAgICAgZGVsTGVuZ3RoICs9IGRlbHRhLnJlbW92ZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgICBfdGhpczIudHlwZS5kZWxldGUoc3RhcnQsIGRlbExlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgaW5zZXJ0IG9wZXJhdGlvblxuICAgICAgICBfdGhpczIudHlwZS5pbnNlcnQoc3RhcnQsIGRlbHRhLnRleHQuam9pbignXFxuJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgYmluZGluZyB0aGF0IGJpbmRzIGEgWVRleHQgdG8gYSBjb2RlbWlycm9yLlxuICAgKlxuICAgKiBUaGlzIGJpbmRpbmcgaXMgYXV0b21hdGljYWxseSBkZXN0cm95ZWQgd2hlbiBpdHMgcGFyZW50IGlzIGRlbGV0ZWQuXG4gICAqXG4gICAqL1xuXG4gIHZhciBDb2RlTWlycm9yQmluZGluZyA9IGZ1bmN0aW9uIChfQmluZGluZykge1xuICAgIGluaGVyaXRzKENvZGVNaXJyb3JCaW5kaW5nLCBfQmluZGluZyk7XG5cbiAgICBmdW5jdGlvbiBDb2RlTWlycm9yQmluZGluZyh0ZXh0VHlwZSwgY29kZU1pcnJvcikge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29kZU1pcnJvckJpbmRpbmcpO1xuXG4gICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgdmFyIF90aGlzMyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvZGVNaXJyb3JCaW5kaW5nLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29kZU1pcnJvckJpbmRpbmcpKS5jYWxsKHRoaXMsIHRleHRUeXBlLCBjb2RlTWlycm9yKSk7XG5cbiAgICAgIGNvZGVNaXJyb3Iuc2V0VmFsdWUodGV4dFR5cGUudG9TdHJpbmcoKSk7XG4gICAgICAvLyBPYnNlcnZlcnMgYXJlIGhhbmRsZWQgYnkgdGhpcyBjbGFzc1xuICAgICAgX3RoaXMzLl90eXBlT2JzZXJ2ZXIgPSB0eXBlT2JzZXJ2ZXIkMy5iaW5kKF90aGlzMyk7XG4gICAgICBfdGhpczMuX2NvZGVNaXJyb3JPYnNlcnZlciA9IGNvZGVNaXJyb3JPYnNlcnZlci5iaW5kKF90aGlzMyk7XG4gICAgICB0ZXh0VHlwZS5vYnNlcnZlKF90aGlzMy5fdHlwZU9ic2VydmVyKTtcbiAgICAgIGNvZGVNaXJyb3Iub24oJ2NoYW5nZXMnLCBfdGhpczMuX2NvZGVNaXJyb3JPYnNlcnZlcik7XG4gICAgICByZXR1cm4gX3RoaXMzO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKENvZGVNaXJyb3JCaW5kaW5nLCBbe1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgdGhhdCBpcyBoYW5kbGVkIGJ5IHRoaXMgY2xhc3NcbiAgICAgICAgdGhpcy50eXBlLnVub2JzZXJ2ZSh0aGlzLl90eXBlT2JzZXJ2ZXIpO1xuICAgICAgICB0aGlzLnRhcmdldC51bm9ic2VydmUodGhpcy5fY29kZU1pcnJvck9ic2VydmVyKTtcbiAgICAgICAgZ2V0KENvZGVNaXJyb3JCaW5kaW5nLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGVNaXJyb3JCaW5kaW5nLnByb3RvdHlwZSksICdkZXN0cm95JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIENvZGVNaXJyb3JCaW5kaW5nO1xuICB9KEJpbmRpbmcpO1xuXG4gIC8vIFRPRE86IFRoZSBmb2xsb3dpbmcgYXNzaWdubWVudHMgc2hvdWxkIGJlIG1vdmVkIHRvIHlqcy1kaXN0XG4gIFkuQWJzdHJhY3RDb25uZWN0b3IgPSBBYnN0cmFjdENvbm5lY3RvcjtcbiAgWS5BYnN0cmFjdFBlcnNpc3RlbmNlID0gQWJzdHJhY3RQZXJzaXN0ZW5jZTtcbiAgWS5BcnJheSA9IFlBcnJheTtcbiAgWS5NYXAgPSBZTWFwO1xuICBZLlRleHQgPSBZVGV4dDtcbiAgWS5YbWxFbGVtZW50ID0gWVhtbEVsZW1lbnQ7XG4gIFkuWG1sRnJhZ21lbnQgPSBZWG1sRnJhZ21lbnQ7XG4gIFkuWG1sVGV4dCA9IFlYbWxUZXh0O1xuICBZLlhtbEhvb2sgPSBZWG1sSG9vaztcblxuICBZLlRleHRhcmVhQmluZGluZyA9IFRleHRhcmVhQmluZGluZztcbiAgWS5RdWlsbEJpbmRpbmcgPSBRdWlsbEJpbmRpbmc7XG4gIFkuRG9tQmluZGluZyA9IERvbUJpbmRpbmc7XG4gIFkuQ29kZU1pcnJvckJpbmRpbmcgPSBDb2RlTWlycm9yQmluZGluZztcblxuICBEb21CaW5kaW5nLmRvbVRvVHlwZSA9IGRvbVRvVHlwZTtcbiAgRG9tQmluZGluZy5kb21zVG9UeXBlcyA9IGRvbXNUb1R5cGVzO1xuICBEb21CaW5kaW5nLnN3aXRjaEFzc29jaWF0aW9uID0gc3dpdGNoQXNzb2NpYXRpb247XG5cbiAgWS51dGlscyA9IHtcbiAgICBCaW5hcnlEZWNvZGVyOiBCaW5hcnlEZWNvZGVyLFxuICAgIFVuZG9NYW5hZ2VyOiBVbmRvTWFuYWdlcixcbiAgICBnZXRSZWxhdGl2ZVBvc2l0aW9uOiBnZXRSZWxhdGl2ZVBvc2l0aW9uLFxuICAgIGZyb21SZWxhdGl2ZVBvc2l0aW9uOiBmcm9tUmVsYXRpdmVQb3NpdGlvbixcbiAgICByZWdpc3RlclN0cnVjdDogcmVnaXN0ZXJTdHJ1Y3QsXG4gICAgaW50ZWdyYXRlUmVtb3RlU3RydWN0czogaW50ZWdyYXRlUmVtb3RlU3RydWN0cyxcbiAgICB0b0JpbmFyeTogdG9CaW5hcnksXG4gICAgZnJvbUJpbmFyeTogZnJvbUJpbmFyeVxuICB9O1xuXG4gIFkuZGVidWcgPSBicm93c2VyO1xuICBicm93c2VyLmZvcm1hdHRlcnMuWSA9IG1lc3NhZ2VUb1N0cmluZztcbiAgYnJvd3Nlci5mb3JtYXR0ZXJzLnkgPSBtZXNzYWdlVG9Sb29tbmFtZTtcblxuICByZXR1cm4gWTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXkuanMubWFwXG4iLCJ2YXIgWSA9IHJlcXVpcmUoJ3lqcycpO1xud2luZG93LlkgPSBZO1xucmVxdWlyZSgneS13ZWJydGMzJykoWSk7XG5cbnZhciBZMiA9IHJlcXVpcmUoJ3lqczInKTtcbndpbmRvdy5ZMiA9IFkyO1xucmVxdWlyZSgneS13ZWJydGMzJykoWTIpO1xuXG5sZXQgeSA9IG5ldyBZKCd5bm90ZWJvb2snLCB7XG4gICAgY29ubmVjdG9yOiB7XG4gICAgICAgIG5hbWU6ICd3ZWJydGMnLFxuICAgICAgICByb29tOiAnZGluZXNoJyxcbiAgICAgICAgdXJsOiAnaHR0cDovL2Zpbndpbi5pbzoxMjU2J1xuICAgIH1cbn0pO1xud2luZG93LnkgPSB5O1xuXG5sZXQgeTIgPSBuZXcgWTIoJ3lub3RlYm9vazInLCB7XG4gICAgY29ubmVjdG9yOiB7XG4gICAgICAgIG5hbWU6ICd3ZWJydGMnLFxuICAgICAgICByb29tOiAnZGluZXNoMicsXG4gICAgICAgIHVybDogJ2h0dHA6Ly9maW53aW4uaW86MTI1NydcbiAgICB9XG59KTtcbndpbmRvdy55MiA9IHkyO1xuXG5mdW5jdGlvbiBsb2FkX3lub3RlYm9vayh5KSB7XG4gICAgZnVuY3Rpb24gbG9hZF95bm90ZWJvb2syKHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBKdXB5dGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBKdXB5dGVyLm5vdGVib29rICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxvYWRfeW5vdGVib29rMyh5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChsb2FkX3lub3RlYm9vazIsIDAsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChsb2FkX3lub3RlYm9vazIsIDAsIHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZF95bm90ZWJvb2szKHkpIHtcbiAgICAgICAgdmFyIHltYXAgPSB5LmRlZmluZSgneW1hcCcsIFkuTWFwKTtcbiAgICAgICAgSnVweXRlci5ub3RlYm9vay55ID0geTtcbiAgICAgICAgSnVweXRlci5ub3RlYm9vay55bWFwID0geW1hcDtcbiAgICAgICAgeW1hcC5vYnNlcnZlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4IG9mIGUua2V5c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHltYXAuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IEp1cHl0ZXIubm90ZWJvb2suaW5zZXJ0X2NlbGxfYXRfaW5kZXgoZGF0YS5jZWxsX2RhdGEuY2VsbF90eXBlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgbmV3IFkuQ29kZU1pcnJvckJpbmRpbmcoeS5kZWZpbmUoJ3ljb2RlbWlycm9yJytkYXRhLmlkLCBZLlRleHQpLCBjZWxsLmNvZGVfbWlycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAoeS5jb25uZWN0b3Iuc29ja2V0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLmZyb21KU09OKGRhdGEuY2VsbF9kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuY2VsbF9kYXRhLmNlbGxfdHlwZSAhPT0gJ21hcmtkb3duJykge1xuICAgICAgICAgICAgICAgICAgICBuZXcgWS5Eb21CaW5kaW5nKHkuZGVmaW5lKCd5eG1sJytkYXRhLmlkLCBZLlhtbEZyYWdtZW50KSwgY2VsbC5vdXRwdXRfYXJlYS5lbGVtZW50WzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoeS5jb25uZWN0b3Iuc29ja2V0cyA9PT0gMCkge1xuICAgICAgICAgICAgSnVweXRlci5ub3RlYm9vay5pc19maXJzdCA9IHRydWU7XG4gICAgICAgICAgICBKdXB5dGVyLm5vdGVib29rLmxvYWRfbm90ZWJvb2soSnVweXRlci5ub3RlYm9vay5ub3RlYm9va19wYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEp1cHl0ZXIubm90ZWJvb2suaXNfZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIEp1cHl0ZXIubm90ZWJvb2subG9hZF9ub3RlYm9vayhKdXB5dGVyLm5vdGVib29rLm5vdGVib29rX3BhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZF95bm90ZWJvb2syKHkpO1xufVxuXG5mdW5jdGlvbiBsb2FkX3lub3RlYm9vazQoeSkge1xuICAgIGlmICh5LmNvbm5lY3Rvci5zb2NrZXRzID49IDApIHtcbiAgICAgICAgbG9hZF95bm90ZWJvb2soeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChsb2FkX3lub3RlYm9vazQsIDAsIHkpO1xuICAgIH1cbn1cblxuLy9sb2FkX3lub3RlYm9vazQoeSk7XG4iXX0=
